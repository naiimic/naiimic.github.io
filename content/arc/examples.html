<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BARC Examples</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <link rel="shortcut icon" href="https://naiimic.github.io/favicons/videogame-favicon.ico">
	<link rel="apple-touch-icon" href="https://naiimic.github.io/favicons/videogame-apple-touch-icon.png">
	<link rel="icon" type="image/png" href="https://naiimic.github.io/favicons/videogame-favicon-16x16.png" sizes="16x16">
	<link rel="icon" type="image/png" href="https://naiimic.github.io/favicons/videogame-favicon-32x32.png" sizes="32x32">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    
    <style>
        /* Base Styles */
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            font-family: 'Space Grotesk', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Hide Scrollbar */
        ::-webkit-scrollbar { display: none; }
        * { -ms-overflow-style: none; scrollbar-width: none; }

        /* Navigation Styles */
        .nav-glass {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(99, 102, 241, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .nav-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        @media (max-width: 768px) {
            
            .nav-group {
                width: 100%;
                justify-content: center;
            }
            
            .nav-group:last-child {
                flex-direction: row;
                gap: 0.5rem;
            }
        }

        @media (max-width: 768px) {
            /* Hide desktop controls */
            .nav-group:last-child {
                display: none !important;
            }

            .nav-group .flex.items-center.gap-2 {
                display: none !important;
            }

            /* Keep the Model Performance link visible */
            .nav-group a[href="arc.html"] {
                display: flex !important;
            }
            
            /* Bottom navigation/controls */
            .mobile-model-select {
                position: fixed;
                bottom: 0;  /* Changed from 1rem to 0 */
                left: 0;
                right: 0;
                background: rgba(15, 23, 42, 0.98);
                backdrop-filter: blur(10px);
                padding: 0.75rem;
                z-index: 49;
                border-top: 1px solid rgba(99, 102, 241, 0.2);
            }

            .mobile-model-select select {
                width: 100%;
                padding: 0.75rem;
                background: rgba(30, 41, 59, 0.8);
                border: 1px solid rgba(99, 102, 241, 0.2);
                border-radius: 0.5rem;
                color: white;
                font-size: 0.875rem;
            }

            /* Floating action buttons - adjust position to be above model selector */
            .mobile-fab-container {
                position: fixed;
                bottom: 75px;
                right: 1rem;
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
                z-index: 51;
            }

            .mobile-fab {
                width: 48px;
                height: 48px;
                border-radius: 50%;
                background: rgba(99, 102, 241, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                border: none;
                color: white;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
                transition: all 0.3s ease;
            }

            .mobile-fab:active {
                transform: scale(0.95);
                background: rgba(99, 102, 241, 1);
            }
            
            .mobile-fab.hidden {
                display: none;
            }

            /* Add padding to main content to prevent content from being hidden */
            main {
                padding-bottom: calc(60px + 1rem) !important; /* Height of model selector + some padding */
            }
        }

        .logo-gradient {
            background: linear-gradient(45deg, #6366f1, #ec4899);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* Card Styles */
        .example-card {
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            overflow: hidden;
            min-height: 100%;
        }

        .example-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.15);
        }

        /* Grid Layout */
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 2rem;
            padding: 1rem;
        }

        /* Source Card Styles */
        .source-card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            transition: all 0.3s ease;
        }

        .source-card.active {
            border-color: #6366f1;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
        }

        /* Button Styles */
        .gradient-btn {
            height: 40px;
            min-width: 100px;
            padding: 0 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-weight: 500;
            letter-spacing: 0.025em;
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap;
        }

        .card-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            z-index: 1;
            background: rgba(24, 19, 60, 0.5);
            backdrop-filter: blur(0px);
            height: 70px;
        }

        .card-container {
            width: 100%;
            margin-bottom: 2rem;
            perspective: 1000px;
        }

        .card-flipper {
            width: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            position: relative;
        }

        .card-flipper.flipped {
            transform: rotateY(180deg);
        }

        /* Card Faces */
        .card-front {
            width: 100%;
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            backface-visibility: hidden;
        }

        .card-back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotateY(180deg);
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            backface-visibility: hidden;
            overflow: hidden; /* Contain the absolute positioned content */
        }

        .card-front {
            position: relative;
        }

        .card-back {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            transform: rotateY(180deg);
        }

        .code-content {
            position: absolute;
            top: 80px; /* Height of header */
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0 1.5rem 1.5rem;
            overflow: hidden; /* Hide container overflow */
        }

        .code-content pre code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.75rem !important;
            line-height: 1.4 !important;
        }

        .code-content code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.75rem !important;
            line-height: 1.4 !important;
        }

        .code-content pre {
            height: 100%;
            margin: 0;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.3) !important;
            border-radius: 0.5rem;
            overflow-y: auto; /* Only scroll the pre element */
            font-size: 0.75rem !important;
        }

        .button-base {
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            color: white;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            white-space: nowrap;
        }

        .button-base:hover {
            background: rgba(99, 102, 241, 0.3);
        }

        .copy-toast {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(34, 197, 94, 0.9);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: fade 1.5s forwards;
        }

        @keyframes fade {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            15% { opacity: 1; transform: translate(-50%, 0); }
            85% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        @keyframes toast {
            0% { 
                opacity: 0;
                transform: translate(-50%, -1rem);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -1rem);
            }
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .copy-tooltip {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            pointer-events: none;
            animation: fadeOut 1.5s forwards;
            white-space: nowrap;
        }

        /* Image Grid */
        .image-grid {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 0 1.5rem 1.5rem;
            margin-top: 80px; /* Match the space where code starts in back card */
        }

        .image-container {
            background: rgba(30, 41, 59, 0.3);
            padding: 1rem;
            border-radius: 0.75rem;
        }

        .image-pair {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .image-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            border-radius: 0.75rem;
            overflow: hidden; /* Ensure image respects container's border radius */
            padding: 0.25rem;
        }

        .image-wrapper img {
            width: 100%;
            height: auto;
            object-fit: contain;
            border-radius: 0.5rem;
            display: block; /* Remove any potential spacing */
        }

        .image-caption {
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
            text-align: center;
        }

        pre {
            margin: 0;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 0.5rem;
            overflow-x: auto;
        }

        .gradient-btn:focus {
            outline: none;
        }

        .gradient-btn:not(.active):hover {
            background: linear-gradient(45deg, rgba(236, 72, 153, 0.1), rgba(99, 102, 241, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .gradient-btn i,
        .gradient-btn span {
            color: inherit;
            position: relative;
        }

        .gradient-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Loading Animation */
        .loading-dots {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding: 2rem;
        }

        .loading-dot {
            width: 0.5rem;
            height: 0.5rem;
            background: linear-gradient(45deg, #6366f1, #ec4899);
            border-radius: 50%;
            animation: pulse 1s infinite ease-in-out;
        }

        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .examples-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .source-card {
                padding: 1rem;
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spin-animation {
            animation: spin 1s linear;
        }

        .gradient-btn.shuffle-active {
            background: linear-gradient(45deg, rgba(236, 72, 153, 0.2), rgba(99, 102, 241, 0.2));
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .custom-scrollbar {
            position: fixed;
            right: 8px;
            top: 120px; /* Positioned below the nav bar */
            height: calc(100vh - 120px); /* Adjust height to account for nav */
            width: 12px;
            z-index: 50; /* Ensure it's below the nav which has z-index: 50 */
            pointer-events: none;
        }

        .scrollbar-track {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 100%;
            height: 70vh;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            pointer-events: all;
        }

        .scrollbar-thumb {
            position: absolute;
            width: 100%;
            border-radius: 6px;
            min-height: 40px;
            max-height: 15vh; 
            background: rgba(99, 102, 241, 0.3);
            cursor: pointer;
            transition: background 0.2s;
        }

        .scrollbar-thumb:hover,
        .scrollbar-thumb:active {
            background: rgba(99, 102, 241, 0.5);
        }

        .scrollbar-thumb.dragging {
            background: rgba(99, 102, 241, 0.6);
            cursor: grabbing;
        }

        @media (max-width: 768px) {
            .custom-scrollbar {
                display: none;
            }
        }
    </style>
</head>
<body class="antialiased">
    <!-- Navigation -->
    <nav class="nav-glass sticky top-0 z-50">
        <div class="container mx-auto px-6">
            <div class="flex flex-col gap-4 py-3">
                <!-- Top Row - Title -->
                <div class="flex justify-center">
                    <h1 class="text-2xl md:text-3xl font-bold logo-gradient">BARC Synthetic Examples</h1>
                </div>
                
                <!-- Bottom Row - Controls -->
                <div class="flex justify-between items-center">
                    <div class="nav-group">
                        <a href="arc.html" class="gradient-btn px-4 py-2 rounded-lg">
                            <i class="fas fa-cube mr-2"></i>
                            <span>Model Performance</span>
                        </a>
                        <div class="flex items-center gap-2">
                            <button id="shuffleButton" class="gradient-btn px-4 py-2 rounded-lg">
                                <i class="fas fa-random mr-2"></i>
                                <span>Shuffle</span>
                            </button>
                            <button id="resetButton" class="gradient-btn px-3 py-2 rounded-lg hidden">
                                <i class="fas fa-rotate"></i>
                            </button>
                        </div>
                    </div>
                    <div class="nav-group">
                        <select id="sourceSelector" class="bg-slate-800/50 backdrop-blur-lg text-slate-200 rounded-lg border border-slate-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 px-4 py-2">
                            <option value="barc_gpt4_desc">GPT-4</option>
                            <option value="barc_gpt4o_mini_desc">GPT4o-mini</option>
                            <option value="barc_heavy">Heavy</option>
                            <option value="barc_heavy_suggest">Heavy with Suggestions</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-8">
        <!-- Source Overview -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div id="sourceStats" class="source-card p-6">
                <h2 class="text-xl font-bold text-slate-200 mb-4">Overview</h2>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <p class="text-slate-400">Total Examples</p>
                        <p class="text-2xl font-bold logo-gradient" id="totalCount">0</p>
                    </div>
                    <div>
                        <p class="text-slate-400">Current Source</p>
                        <p class="text-2xl font-bold logo-gradient" id="currentSource">All</p>
                    </div>
                </div>
            </div>
            <div id="sourceDescription" class="source-card p-6">
                <h2 class="text-xl font-bold text-slate-200 mb-4">Source Description</h2>
                <p class="text-slate-400" id="descriptionText">
                    Viewing all examples from different sources.
                </p>
            </div>
        </div>

        <!-- Examples Grid -->
        <div id="examplesGrid" class="examples-grid">
            <!-- Examples will be inserted here -->
        </div>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="loading-dots hidden">
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
        </div>
        
        <div class="mobile-fab-container md:hidden">
            <button class="mobile-fab" id="mobileShuffleButton" onclick="handleShuffle()">
                <i class="fas fa-random"></i>
            </button>
            <button class="mobile-fab hidden" id="mobileResetButton" onclick="handleReset()">
                <i class="fas fa-rotate"></i>
            </button>
        </div>
        
        <div class="mobile-model-select md:hidden">
            <select id="mobileSourceSelector" onchange="handleSourceChange({ target: this })">
                <option value="barc_gpt4_desc">GPT-4</option>
                <option value="barc_gpt4o_mini_desc">GPT4o-mini</option>
                <option value="barc_heavy">Heavy</option>
                <option value="barc_heavy_suggest">Heavy with Suggestions</option>
            </select>
        </div>
    </main>

    <div class="custom-scrollbar">
        <div class="scrollbar-track">
            <div class="scrollbar-thumb">
                <div class="scrollbar-thumb-inner"></div>
            </div>
        </div>
    </div>

    <script>
        // Data and State Management
        const examples = [{"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# circular pattern detection, color transformation\n\n# description:\n# In the input grid, there are several circular patterns of colored pixels, separated by black pixels.\n# To make the output grid, you should change the color of each detected circular pattern as follows:\n# Red circles become Yellow, Blue circles become Pink, and Green circles become Teal.\n\ndef main(input_grid):\n    # Detect circular patterns in the grid\n    circular_patterns = detect_objects(grid=input_grid, colors=[Color.RED, Color.BLUE, Color.GREEN], monochromatic=True, connectivity=8)\n    \n    # Initialize output grid\n    output_grid = input_grid.copy()\n    \n    # Create a mapping for color transformation\n    color_map = {\n        Color.RED: Color.YELLOW,\n        Color.BLUE: Color.PINK,\n        Color.GREEN: Color.TEAL\n    }\n    \n    # Transform the colors of detected circular patterns\n    for pattern in circular_patterns:\n        # Get the bounding box of the pattern\n        x, y, width, height = bounding_box(pattern, background=Color.BLACK)\n        if width == height and width \u003e 1:  # Ensure it\u0027s a circular shape (or square as an approximation)\n            # Change the color of the whole circular pattern\n            output_grid[x:x + width, y:y + height] = color_map.get(pattern[0, 0], pattern[0, 0])  # Change color based on the first pixel\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with black background\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place circular patterns in the grid\n    num_patterns = np.random.randint(3, 6)\n    \n    for _ in range(num_patterns):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        radius = np.random.randint(2, 4)  # Circular patterns should be at least 2x2\n        \n        # Choose a random color for the circle\n        color_choice = np.random.choice([Color.RED, Color.BLUE, Color.GREEN])\n        \n        # Draw the circle\n        for i in range(-radius, radius + 1):\n            for j in range(-radius, radius + 1):\n                if i**2 + j**2 \u003c= radius**2:  # This checks if the point is inside the circle\n                    if 0 \u003c= x + i \u003c n and 0 \u003c= y + j \u003c m:\n                        grid[x + i, y + j] = color_choice\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/0/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/0/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/0/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/0/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/0/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/0/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/0/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/0/images/train_output_2.png"}]}, "index": 0, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, pattern recognition\n\n# description:\n# In the input grid, you will see a pattern of colored pixels consisting of two different colors and a background color.\n# The goal is to transform the grid by following these rules:\n# 1. All occurrences of the first color in the pattern should be replaced with the second color.\n# 2. The second color should be replaced with the first color.\n# 3. The background color should remain unchanged.\n\ndef main(input_grid):\n    # Identify the colors in the input grid\n    unique_colors = set(input_grid.flatten())\n    if len(unique_colors) \u003c 3:\n        raise ValueError(\"Input grid must contain at least two colors and a background.\")\n\n    # Determine the first and second colors (ignoring the background)\n    color_list = list(unique_colors - {Color.BLACK})\n    first_color, second_color = color_list[0], color_list[1]\n\n    # Generate the output grid by swapping the colors\n    output_grid = np.copy(input_grid)\n    output_grid[output_grid == first_color] = Color.TEAL  # Temporary color to avoid overwriting\n    output_grid[output_grid == second_color] = first_color\n    output_grid[output_grid == Color.TEAL] = second_color\n\n    return output_grid\n\ndef generate_input():\n    # Define the size of the grid\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Randomly select two colors from the available colors (excluding black)\n    available_colors = [color for color in Color.NOT_BLACK if color != Color.BLACK]\n    first_color, second_color = np.random.choice(available_colors, size=2, replace=False)\n\n    # Fill the grid with the two colors in a random pattern\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice([first_color, second_color, Color.BLACK], p=[0.45, 0.45, 0.1])  # 10% for background\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/1/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/1/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/1/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/1/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/1/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/1/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/1/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/1/images/train_output_2.png"}]}, "index": 1, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, size-based color transformation\n\n# description:\n# In the input, you will see a grid with several colored objects. \n# To make the output, change the color of the smallest object to blue, \n# the color of the largest object to red, and all other objects to green.\n\ndef main(input_grid):\n    # Find all connected components (objects) in the grid\n    objects = find_connected_components(grid=input_grid, monochromatic=True, background=Color.BLACK)\n\n    # Initialize output grid as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Determine the sizes of each object and identify the smallest and largest\n    sizes = [np.sum(obj != Color.BLACK) for obj in objects]\n    if not sizes:\n        return output_grid  # No objects found, return original grid\n\n    min_size = min(sizes)\n    max_size = max(sizes)\n\n    for obj in objects:\n        size = np.sum(obj != Color.BLACK)\n        if size == min_size:\n            output_grid[obj != Color.BLACK] = Color.BLUE\n        elif size == max_size:\n            output_grid[obj != Color.BLACK] = Color.RED\n        else:\n            output_grid[obj != Color.BLACK] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a black background\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly scatter colored objects in the grid\n    num_objects = np.random.randint(3, 6)\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.TEAL, Color.YELLOW]\n    \n    for _ in range(num_objects):\n        # Generate a random sprite (object) of a random size\n        sprite_height = np.random.randint(1, 4)\n        sprite_width = np.random.randint(1, 4)\n        sprite = random_sprite(sprite_height, sprite_width, density=1.0, color_palette=[np.random.choice(colors)])\n        \n        # Find a random free location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If no space is found, continue to the next object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/2/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/2/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/2/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/2/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/2/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/2/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/2/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/2/images/train_output_2.png"}]}, "index": 2, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, color mapping, grid transformation\n\n# description:\n# In the input, you will see a grid of colored pixels on a black background. Each color represents a different type of shape: \n# - Blue for circles\n# - Green for squares\n# - Red for triangles\n# The output should count how many of each shape color appear in the input and create a new grid where each color square represents \n# the count of that shape color. The output grid should be in the order of Blue, Green, and Red.\n\ndef main(input_grid):\n    # Count the occurrences of each color in the input grid\n    blue_count = np.sum(input_grid == Color.BLUE)\n    green_count = np.sum(input_grid == Color.GREEN)\n    red_count = np.sum(input_grid == Color.RED)\n\n    # Create an output grid with a single row for the counts\n    output_grid = np.zeros((1, 3), dtype=int)\n\n    # Map counts to colors in the output grid\n    output_grid[0, 0] = Color.BLUE if blue_count \u003e 0 else Color.BLACK\n    output_grid[0, 1] = Color.GREEN if green_count \u003e 0 else Color.BLACK\n    output_grid[0, 2] = Color.RED if red_count \u003e 0 else Color.BLACK\n\n    return output_grid\n\ndef generate_input():\n    # Create an empty black grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place colored shapes (circles, squares, triangles) in the grid\n    shape_colors = [Color.BLUE, Color.GREEN, Color.RED]\n    num_shapes = np.random.randint(5, 15)  # Random number of shapes between 5 and 15\n\n    for _ in range(num_shapes):\n        shape_color = np.random.choice(shape_colors)\n        # Random sprite (2x2) for each shape\n        shape_sprite = random_sprite(n=2, m=2, color_palette=[shape_color], density=1.0)\n        \n        # Find a random free location in the grid for the shape\n        try:\n            x, y = random_free_location_for_sprite(grid, shape_sprite)\n            blit_sprite(grid, shape_sprite, x=x, y=y)\n        except:\n            continue  # If no space found, skip this shape\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/3/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/3/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/3/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/3/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/3/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/3/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/3/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/3/images/train_output_2.png"}]}, "index": 3, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, grid manipulation\n\n# description:\n# In the input, you will see a grid with several colored objects. Each object is a connected component of the same color.\n# If any object touches the border of the grid, change its color to green.\n# The output grid will reflect these color changes based on the border condition.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n\n    # Change the color of objects that touch the border to green\n    for obj in objects:\n        x_min, y_min, width, height = bounding_box(obj, background=Color.BLACK)\n        x_max, y_max = x_min + height - 1, y_min + width - 1\n        \n        # Check if the object touches the border\n        if x_min == 0 or y_min == 0 or x_max == input_grid.shape[0] - 1 or y_max == input_grid.shape[1] - 1:\n            # Change the color of the object to green\n            output_grid[obj != Color.BLACK] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored objects in the grid\n    num_objects = np.random.randint(1, 5)  # Number of distinct color objects\n    colors = random.sample(Color.NOT_BLACK, num_objects)\n\n    for color in colors:\n        # Randomly place each color object in the grid\n        obj_width, obj_height = np.random.randint(1, 3), np.random.randint(1, 3)  # Small objects\n        sprite = random_sprite(n=obj_height, m=obj_width, color_palette=[color], density=1.0)\n        \n        # Ensure at least one object touches the border\n        if np.random.rand() \u003c 0.5:  # 50% chance to touch the border\n            border_position = np.random.choice([\u0027top\u0027, \u0027bottom\u0027, \u0027left\u0027, \u0027right\u0027])\n            if border_position == \u0027top\u0027:\n                y = np.random.randint(0, m - obj_width)\n                grid[0:obj_height, y:y + obj_width] = sprite\n            elif border_position == \u0027bottom\u0027:\n                y = np.random.randint(0, m - obj_width)\n                grid[n - obj_height:n, y:y + obj_width] = sprite\n            elif border_position == \u0027left\u0027:\n                x = np.random.randint(0, n - obj_height)\n                grid[x:x + obj_height, 0:obj_width] = sprite\n            else:  # \u0027right\u0027\n                x = np.random.randint(0, n - obj_height)\n                grid[x:x + obj_height, m - obj_width:m] = sprite\n        else:\n            # Place an object not touching the border\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n            grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/4/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/4/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/4/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/4/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/4/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/4/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/4/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/4/images/train_output_2.png"}]}, "index": 4, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flipping, pattern replication\n\n# description:\n# In the input, you will see a pattern of colored pixels on a black background. \n# To make the output, flip the pattern vertically, and then replicate the flipped pattern to fill the output grid.\n\ndef main(input_grid):\n    # Find the connected components (the pattern) in the input grid\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    # Assuming there is only one main pattern, we take the first one\n    pattern = objects[0]\n\n    # Crop the pattern to remove black borders\n    cropped_pattern = crop(pattern)\n\n    # Flip the pattern vertically\n    flipped_pattern = cropped_pattern[::-1]\n\n    # Create the output grid with double the height of the flipped pattern and the same width\n    output_height = flipped_pattern.shape[0] * 2\n    output_width = flipped_pattern.shape[1]\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Blit the flipped pattern twice into the output grid\n    blit_sprite(output_grid, flipped_pattern, x=0, y=0, background=Color.BLACK)\n    blit_sprite(output_grid, flipped_pattern, x=0, y=flipped_pattern.shape[0], background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Make a random-sized grid with a black background\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random pattern within the grid\n    pattern_density = np.random.uniform(0.2, 0.8)\n    pattern = random_sprite(n, m, density=pattern_density, color_palette=[color], symmetry=\u0027not_symmetric\u0027)\n\n    # Place the pattern in the center of the grid with a black background\n    grid = blit_sprite(grid, pattern, x=0, y=0, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/5/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/5/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/5/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/5/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/5/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/5/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/5/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/5/images/train_output_2.png"}]}, "index": 5, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, diagonal lines, color propagation\n\n# description:\n# In the input, you will see a grid with a single colored pixel. \n# To make the output, draw a diagonal line of the same color as the pixel, from the top left corner to the bottom right corner. \n# Then, reflect this line along the x-axis to achieve vertical symmetry.\n\ndef main(input_grid):\n    # Make output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the index of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n    \n    # Get color from colored pixel\n    color = input_grid[x, y]\n\n    # Draw diagonal line from (0, 0) to (min(width, height), min(width, height))\n    draw_line(output_grid, 0, 0, length=min(width, height), color=color, direction=(1, 1))\n    \n    # Reflect the diagonal line along the x-axis\n    for i in range(min(width, height)):\n        output_grid[i, i] = color  # Original diagonal\n        if i \u003c output_grid.shape[0]:  # Check if within bounds for reflection\n            output_grid[output_grid.shape[0] - 1 - i, i] = color  # Reflected diagonal\n\n    return output_grid\n\ndef generate_input():\n    # Make a square black grid for the background first\n    n = m = np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Put a randomly colored pixel at a random point on the grid\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/6/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/6/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/6/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/6/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/6/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/6/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/6/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/6/images/train_output_2.png"}]}, "index": 6, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# duplication, color transformation\n\n# description:\n# In the input you will see a grid with a single colored pixel in the center of the grid. \n# To make the output, duplicate the center pixel in a cross pattern (up, down, left, right) and change each color to a different color based on predefined rules.\n# For example, if the original color is blue, the new colors will be red, green, yellow, and black for the four directions.\n\ndef main(input_grid):\n    # Find the position of the colored pixel (assumed to be the only colored pixel)\n    colored_pixel_positions = np.argwhere(input_grid != Color.BLACK)\n    \n    # Check if there is exactly one colored pixel in the grid\n    if colored_pixel_positions.shape[0] != 1:\n        raise ValueError(\"Input grid must contain exactly one colored pixel.\")\n\n    x, y = colored_pixel_positions[0]\n    original_color = input_grid[x, y]\n\n    # Create an output grid initialized with black\n    output_grid = np.zeros_like(input_grid)\n\n    # Define the color transformation rules\n    color_transform = {\n        Color.BLUE: [Color.RED, Color.GREEN, Color.YELLOW, Color.BLACK],\n        Color.RED: [Color.GREEN, Color.YELLOW, Color.BLACK, Color.BLUE],\n        Color.GREEN: [Color.YELLOW, Color.BLACK, Color.BLUE, Color.RED],\n        Color.YELLOW: [Color.BLACK, Color.BLUE, Color.RED, Color.GREEN],\n        Color.BLACK: [Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW]\n    }\n\n    # Get the colors for up, down, left, right based on the original pixel color\n    new_colors = color_transform.get(original_color, [Color.BLACK]*4)\n\n    # Place the original color and its duplicates in the output grid\n    output_grid[x, y] = original_color  # center\n    output_grid[x-1, y] = new_colors[0]  # up\n    output_grid[x+1, y] = new_colors[1]  # down\n    output_grid[x, y-1] = new_colors[2]  # left\n    output_grid[x, y+1] = new_colors[3]  # right\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size 5x5 with a black background\n    grid_size = 5\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly select a color for the single pixel in the center\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Set the center pixel\n    grid[grid_size // 2, grid_size // 2] = center_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/7/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/7/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/7/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/7/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/7/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/7/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/7/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/7/images/train_output_2.png"}]}, "index": 7, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color replacement\n\n# description:\n# In the input grid, you will see a pattern of colored pixels with a black background. \n# The pattern consists of a square of any color that is surrounded by black pixels. \n# To produce the output grid, you should find the square pattern and change its color to blue while keeping the surrounding pixels black.\n\ndef main(input_grid):\n    # Create an output grid starting from a blank canvas\n    output_grid = np.zeros_like(input_grid)\n    \n    # Detect the square pattern by identifying non-black pixels\n    square_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=4)\n    \n    # There should only be one square pattern\n    assert len(square_objects) == 1\n    square_object = square_objects[0]\n\n    # Color the detected square blue\n    output_grid[square_object != Color.BLACK] = Color.BLUE\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m, where n and m are between 5 and 20\n    n = random.randint(5, 20)\n    m = random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random square sprite with a random color\n    square_size = random.randint(2, min(n, m) // 2)  # Ensure the square fits within the grid\n    color = random.choice(Color.NOT_BLACK)\n    \n    # Create a square sprite\n    square_sprite = np.full((square_size, square_size), color)\n\n    # Find a random position to blit the square sprite onto the grid\n    x, y = random_free_location_for_sprite(grid, square_sprite, background=Color.BLACK)\n    blit_sprite(grid, square_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/8/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/8/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/8/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/8/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/8/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/8/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/8/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/8/images/train_output_2.png"}]}, "index": 8, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, intersection, circles\n\n# description:\n# In the input, you will see a black grid with a single colored pixel. The pixel represents the center of a circle. \n# To make the output, draw a vertical and a horizontal line that intersect at the location of the colored pixel, \n# and draw a circle with the same color as the pixel around it.\n\ndef main(input_grid):\n    # Make output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the index of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Get color from the colored pixel\n    color = input_grid[x, y]\n\n    # Draw the vertical line\n    draw_line(output_grid, x, y, length=None, color=color, direction=(0, 1))\n    # Draw the horizontal line\n    draw_line(output_grid, x, y, length=None, color=color, direction=(1, 0))\n\n    # Draw the circle with the same color as the pixel\n    radius = 2  # You can adjust the radius as needed\n    for dx in range(-radius, radius + 1):\n        for dy in range(-radius, radius + 1):\n            if dx**2 + dy**2 \u003c= radius**2:  # Equation of a circle\n                if 0 \u003c= x + dx \u003c output_grid.shape[0] and 0 \u003c= y + dy \u003c output_grid.shape[1]:\n                    output_grid[x + dx, y + dy] = color\n\n    return output_grid\n\ndef generate_input():\n    # Make a 10x10 black grid for the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Put a colored pixel at a random point on the grid\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/9/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/9/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/9/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/9/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/9/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/9/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/9/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/9/images/train_output_2.png"}]}, "index": 9, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, region filling\n\n# description:\n# In the input, you will see a grid filled with various colors. \n# To create the output, you need to transform the grid as follows:\n# 1. For each region of adjacent same-colored pixels, change the color to a new color based on their current color:\n#    - red -\u003e green\n#    - green -\u003e blue\n#    - blue -\u003e red\n# 2. If a region contains any yellow pixels, change the whole region to orange.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = input_grid.copy()\n\n    # Find connected components\n    regions = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    for region in regions:\n        # Check if the region contains any yellow pixels\n        if Color.YELLOW in region:\n            # Color the whole region orange\n            x, y = np.where(region == Color.YELLOW)\n            flood_fill(output_grid, x[0], y[0], Color.ORANGE)\n        else:\n            # Determine the color of the region (assuming monochromatic regions)\n            unique_colors = np.unique(region)\n            if len(unique_colors) == 1:\n                current_color = unique_colors[0]\n                if current_color == Color.RED:\n                    flood_fill(output_grid, region[0][0], region[0][1], Color.GREEN)\n                elif current_color == Color.GREEN:\n                    flood_fill(output_grid, region[0][0], region[0][1], Color.BLUE)\n                elif current_color == Color.BLUE:\n                    flood_fill(output_grid, region[0][0], region[0][1], Color.RED)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size filled with random colors\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n    # Randomly fill the grid with colors\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/10/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/10/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/10/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/10/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/10/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/10/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/10/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/10/images/train_output_2.png"}]}, "index": 10, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color coding, object transformation\n\n# description:\n# In the input, you will see various colored objects on a 10x10 grid.\n# To make the output grid, check if each object is symmetric about its vertical axis.\n# If it is symmetric, color it green. If it is not symmetric, color it yellow.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Check each object for vertical symmetry\n    for obj in objects:\n        # Crop the object to its bounding box\n        cropped_obj = crop(obj, background=Color.BLACK)\n        \n        # Check for vertical mirror symmetry\n        if detect_mirror_symmetry(cropped_obj, ignore_colors=[Color.BLACK]):\n            # If symmetric, color the object green\n            output_grid[obj != Color.BLACK] = Color.GREEN\n        else:\n            # If not symmetric, color the object yellow\n            output_grid[obj != Color.BLACK] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Create a random sprite with a random symmetry (or not)\n        sprite = random_sprite(np.random.randint(2, 6), np.random.randint(2, 6), \n                               symmetry=np.random.choice([\"horizontal\", \"vertical\", \"not_symmetric\"]), \n                               color_palette=list(Color.NOT_BLACK))\n\n        # Find a random free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If no space is available, skip this object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/11/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/11/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/11/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/11/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/11/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/11/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/11/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/11/images/train_output_2.png"}]}, "index": 11, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, bounding box extraction\n\n# description:\n# In the input you will see a colored object on a black background, and several black pixels scattered around.\n# To make the output, slide the colored object towards the center of the output grid (which is a fixed 10x10) until it is centered.\n# If the object is already centered, it remains unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the colored object in the input grid\n    # 2. Calculate the bounding box of the detected object\n    # 3. Determine the center of the output grid (5, 5) since it\u0027s 10x10\n    # 4. Calculate the translation needed to center the object\n    # 5. Slide the object to the new position\n\n    output_grid = np.copy(input_grid)\n\n    # Detect the colored object (non-black pixels)\n    colored_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=4)\n\n    # There should only be one colored object in the grid\n    assert len(colored_objects) == 1\n    colored_object = colored_objects[0]\n\n    # Get the bounding box of the colored object\n    x, y, width, height = bounding_box(colored_object)\n\n    # Calculate the center of the output grid\n    center_x, center_y = 5, 5  # Since the output is a 10x10 grid\n\n    # Calculate the offset to center the colored object\n    object_center_x = x + width // 2\n    object_center_y = y + height // 2\n    translate_x = center_x - object_center_x\n    translate_y = center_y - object_center_y\n\n    # Translate the colored object to the center\n    translated_object = translate(colored_object, translate_x, translate_y, background=Color.BLACK)\n\n    # Blit the translated object onto the output grid\n    blit_object(output_grid, translated_object)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid with a single colored object on a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the width and height of the colored object between 2 and 4\n    width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n    color = random.choice(Color.NOT_BLACK)  # Pick a random color that\u0027s not black\n\n    # Create the colored object\n    colored_object = np.full((width, height), color)\n\n    # Find a random free location for the colored object in the grid, ensuring it fits\n    x, y = np.random.randint(0, n - width + 1), np.random.randint(0, m - height + 1)\n    blit_sprite(grid, colored_object, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/12/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/12/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/12/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/12/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/12/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/12/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/12/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/12/images/train_output_2.png"}]}, "index": 12, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color mapping, reflection\n\n# description:\n# In the input, you will see a grid containing various colored objects. The colored objects can be of different shapes, but they will always have a central point of symmetry.\n# To produce the output grid, for each object, reflect it across its central point and replace the color of the reflected part with the color of the central point of symmetry.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n    \n    # Detect symmetrical objects\n    objects = detect_objects(input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n\n    for obj in objects:\n        # Find the central point of the object\n        center_x, center_y = np.argwhere(obj != Color.BLACK).mean(axis=0).astype(int)\n        \n        # Get the color of the central point\n        central_color = obj[center_x, center_y]\n        \n        # Reflect the object across its central point\n        for x in range(obj.shape[0]):\n            for y in range(obj.shape[1]):\n                if obj[x, y] != Color.BLACK:\n                    reflected_x = center_x * 2 - x\n                    reflected_y = center_y * 2 - y\n                    \n                    # Set the color of the reflected position to the central color\n                    if 0 \u003c= reflected_x \u003c output_grid.shape[0] and 0 \u003c= reflected_y \u003c output_grid.shape[1]:\n                        output_grid[reflected_x, reflected_y] = central_color\n\n    return output_grid\n\n\ndef generate_input():\n    grid_size = 5\n\n    # Create a black grid\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly generate objects\n    num_objects = np.random.randint(1, 5)\n    for _ in range(num_objects):\n        # Create a random colored object\n        color = np.random.choice(Color.NOT_BLACK)\n        shape = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(2, 4), color_palette=[color])\n\n        # Get a random position to place the object in the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n\n        # Place the object in the grid\n        grid = blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/13/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/13/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/13/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/13/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/13/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/13/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/13/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/13/images/train_output_2.png"}]}, "index": 13, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, concentric patterns\n\n# description:\n# In the input, you will see a grid with a single blue pixel. \n# To make the output, create a concentric pattern of colors that will radiate from the blue pixel; \n# the outer layer should be yellow, the next layer should be pink, and the innermost layer should be green. \n# Each layer should be 1 pixel thick and should fill in the area around the blue pixel, \n# ensuring that the pattern stays within the bounds of the grid.\n\ndef main(input_grid):\n    # Find the blue pixel\n    blue_pixel_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], allowed_dimensions=[(1, 1)], monochromatic=True, connectivity=4)\n    assert len(blue_pixel_objects) == 1\n    blue_pixel_object = blue_pixel_objects[0]\n\n    # Get the position of the blue pixel\n    blue_x, blue_y = object_position(blue_pixel_object, background=Color.BLACK, anchor=\"upper left\")\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Set the colors for each layer\n    layers = [Color.YELLOW, Color.PINK, Color.GREEN]\n\n    # Draw concentric layers around the blue pixel\n    for layer_color in layers:\n        # Draw surrounding layer\n        if blue_x \u003e 0:  # Top\n            output_grid[blue_x - 1, blue_y] = layer_color\n        if blue_x \u003c output_grid.shape[0] - 1:  # Bottom\n            output_grid[blue_x + 1, blue_y] = layer_color\n        if blue_y \u003e 0:  # Left\n            output_grid[blue_x, blue_y - 1] = layer_color\n        if blue_y \u003c output_grid.shape[1] - 1:  # Right\n            output_grid[blue_x, blue_y + 1] = layer_color\n        \n        # Move to the next inner layer for the next iteration\n        blue_x, blue_y = blue_x - 1, blue_y - 1  # Shift inward\n\n    # Place the blue pixel in the center\n    output_grid[blue_pixel_object[0][0], blue_pixel_object[0][1]] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a 5x5 black grid for the background\n    n, m = 5, 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select the position of the blue pixel\n    x, y = np.random.randint(1, n - 1), np.random.randint(1, m - 1)  # Ensure space for layers\n    grid[x, y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/14/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/14/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/14/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/14/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/14/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/14/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/14/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/14/images/train_output_2.png"}]}, "index": 14, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel transformation, color shifting\n\n# description:\n# In the input, you will see a grid with several colored pixels. Each pixel will be transformed based on its position:\n# 1. If a pixel is located in an even row, it will change to the next color in the color sequence (e.g., RED to GREEN).\n# 2. If a pixel is located in an odd row, it will change to the previous color in the color sequence (e.g., BLUE to RED).\n# The color sequence is: RED, GREEN, BLUE, YELLOW, ORANGE, TEAL, GREY, PINK, MAROON, BLACK.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Define the color sequence\n    color_sequence = [\n        Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, \n        Color.ORANGE, Color.TEAL, Color.GREY, Color.PINK, \n        Color.MAROON, Color.BLACK\n    ]\n    \n    # Create a mapping of color to its index for easy manipulation\n    color_index = {color: idx for idx, color in enumerate(color_sequence)}\n    \n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color in color_index:  # Only process known colors\n                if x % 2 == 0:\n                    # Even row: move to the next color\n                    next_index = (color_index[color] + 1) % len(color_sequence)\n                    output_grid[x, y] = color_sequence[next_index]\n                else:\n                    # Odd row: move to the previous color\n                    prev_index = (color_index[color] - 1) % len(color_sequence)\n                    output_grid[x, y] = color_sequence[prev_index]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)  # Grid size\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colors in the grid from the defined color sequence\n    for x in range(n):\n        for y in range(m):\n            if np.random.rand() \u003c 0.3:  # 30% chance to place a color\n                grid[x, y] = np.random.choice(Color.NOT_BLACK)  # Choose a random color that is not black\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/15/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/15/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/15/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/15/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/15/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/15/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/15/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/15/images/train_output_2.png"}]}, "index": 15, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape completion, grid transformation\n\n# description:\n# In the input grid, you will see several colored shapes that are incomplete. \n# The output grid should have all shapes completed by filling in the missing pixels with the same color as the rest of the shape.\n\ndef main(input_grid):\n    # Detect all connected components in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    output_grid = np.copy(input_grid)\n\n    for component in components:\n        # Get the color of the current shape\n        shape_color = component[component != Color.BLACK][0]\n\n        # Identify the bounding box of the shape\n        x, y, width, height = bounding_box(component, background=Color.BLACK)\n\n        # Fill in the missing pixels in the shape\n        for i in range(x, x + width):\n            for j in range(y, y + height):\n                if output_grid[i, j] == Color.BLACK:\n                    output_grid[i, j] = shape_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose the number of shapes\n    num_shapes = np.random.randint(2, 6)\n\n    for _ in range(num_shapes):\n        # Randomly determine the size of the shape\n        shape_height = np.random.randint(2, 5)\n        shape_width = np.random.randint(2, 5)\n        \n        # Randomly select a color for the shape\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a shape with random density (some parts left out)\n        shape = random_sprite(n=shape_height, m=shape_width, color_palette=[shape_color], density=0.5, connectivity=4)\n\n        # Find a random free location to draw the shape\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1, border_size=1)\n        blit_sprite(grid, shape, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/16/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/16/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/16/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/16/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/16/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/16/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/16/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/16/images/train_output_2.png"}]}, "index": 16, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, size-based color transformation\n\n# description:\n# In the input grid, you will see various colored objects. \n# The task is to change the color of all objects that are larger than 2x2 pixels to yellow. \n# Any object of size 2x2 or smaller, as well as the background, should remain unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid)\n\n    # Check the size of each object and change its color if larger than 2x2\n    for obj in objects:\n        height, width = obj.shape\n        if height \u003e 2 and width \u003e 2:\n            output_grid[obj == Color.BLACK] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid of size n x m with objects of various sizes\n    n = np.random.randint(5, 15)\n    m = np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define a density for how many objects to add\n    density = 0.3\n    num_objects = int(density * n * m / 9)  # Each object will be at least 3x3\n\n    for _ in range(num_objects):\n        # Randomly generate the size of the object (minimum size 3x3)\n        height = np.random.randint(3, 6)\n        width = np.random.randint(3, 6)\n        \n        # Create a random object colored with a color other than black\n        color = np.random.choice([Color.RED, Color.BLUE, Color.GREEN, Color.ORANGE, Color.PINK])\n        obj = np.full((height, width), color)\n\n        # Find a random position to place the object on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=0)\n            blit_sprite(grid, obj, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If we cannot place the object, skip it\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/17/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/17/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/17/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/17/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/17/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/17/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/17/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/17/images/train_output_2.png"}]}, "index": 17, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# intersecting lines, color extraction\n\n# description:\n# In the input, you will see a grid with multiple colored diagonal lines, intersecting at a central point. \n# To make the output grid, identify the color of the intersection pixel and draw a square around it, \n# filled with that same color. The square should be of size 3x3 centered on the intersection pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Make a copy of the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the coordinates of the intersection pixel (which is the only maroon pixel in the grid)\n    intersection_coords = np.argwhere(input_grid == Color.MAROON)\n    if intersection_coords.size == 0:\n        return output_grid  # If no intersection, return as is\n    \n    x, y = intersection_coords[0]\n\n    # Fill a 3x3 square around the intersection with its color\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if 0 \u003c= x + i \u003c output_grid.shape[0] and 0 \u003c= y + j \u003c output_grid.shape[1]:\n                output_grid[x + i, y + j] = input_grid[x, y]  # Fill with the intersection color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color for the diagonal lines\n    colors = list(Color.NOT_BLACK)\n    color = random.choice(colors)\n\n    # Draw two diagonal lines that intersect at a random point\n    x, y = np.random.randint(1, n - 1), np.random.randint(1, m - 1)\n    draw_line(grid, x, y, length=None, color=color, direction=(1, 1))  # Diagonal from top-left to bottom-right\n    draw_line(grid, x, y, length=None, color=color, direction=(1, -1))  # Diagonal from bottom-left to top-right\n\n    # Set the intersection point to maroon\n    grid[x, y] = Color.MAROON\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/18/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/18/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/18/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/18/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/18/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/18/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/18/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/18/images/train_output_2.png"}]}, "index": 18, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color transformation, grid manipulation\n\n# description:\n# In the input, you will see two distinct 5x5 patterns placed vertically with a black interval in between.\n# Each pattern consists of colored pixels (red, teal, yellow, or green). \n# The task is to identify each pattern and then create an output grid where the first pattern is transformed to a teal background,\n# and the second pattern is transformed to a yellow background, while preserving the original shapes of the patterns.\n\ndef main(input_grid):\n    # Define the colors\n    red, teal, yellow, green, black = Color.RED, Color.TEAL, Color.YELLOW, Color.GREEN, Color.BLACK\n\n    # Detect the two patterns in the input grid\n    patterns = detect_objects(grid=input_grid, colors=[red, teal, yellow, green], monochromatic=False, connectivity=8)\n\n    # Check if we found exactly two patterns\n    if len(patterns) != 2:\n        raise ValueError(\"There should be exactly two patterns in the input grid.\")\n\n    # Create an output grid with the same shape as the input grid, initially filled with black\n    output_grid = np.full(input_grid.shape, black)\n\n    # Transform the first pattern to teal background and second to yellow background\n    for i, pattern in enumerate(patterns):\n        # Crop the pattern to focus on the non-black pixels\n        sprite = crop(pattern, background=black)\n\n        # Determine the target color based on the pattern\u0027s index\n        target_color = teal if i == 0 else yellow\n        \n        # Draw the pattern with the new background color\n        for x, y in np.argwhere(sprite != black):\n            output_grid[x + object_position(pattern)[0], y + object_position(pattern)[1]] = target_color\n\n    return output_grid\n\ndef generate_input():\n    # Create an empty grid of size 12x7\n    n, m = 12, 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define colors to choose from\n    colors = [Color.RED, Color.TEAL, Color.YELLOW, Color.GREEN]\n    \n    # Randomly select two colors for the patterns\n    selected_colors = np.random.choice(colors, size=2, replace=False)\n\n    # Define the size of the patterns\n    pattern_size = 5\n\n    # Place the first pattern\n    x_offset = 1\n    y_offset = np.random.randint(0, m - pattern_size - 1)\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[x_offset + i, y_offset + j] = selected_colors[0] if np.random.random() \u003e 0.2 else Color.BLACK\n\n    # Place the second pattern\n    x_offset += pattern_size + 1  # Moving down for the second pattern\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[x_offset + i, y_offset + j] = selected_colors[1] if np.random.random() \u003e 0.2 else Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/19/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/19/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/19/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/19/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/19/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/19/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/19/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/19/images/train_output_2.png"}]}, "index": 19, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# arrow drawing, grid transformation\n\n# description:\n# In the input, you will see a grid with a single blue pixel. \n# To make the output, draw a blue arrow pointing to the right, with the arrowhead located at the blue pixel.\n# The arrow should consist of a straight blue line leading to the arrowhead, and the arrowhead should be made of two diagonal lines extending down and up from the end of the arrow line.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the blue pixel\n    blue_x, blue_y = np.where(input_grid == Color.BLUE)\n\n    if len(blue_x) == 0:\n        return output_grid  # If no blue pixel found, return original grid\n\n    # Get the position of the blue pixel (assume there is only one)\n    blue_x, blue_y = blue_x[0], blue_y[0]\n\n    # Draw the straight line to the right from the blue pixel\n    draw_line(output_grid, blue_x, blue_y, length=3, color=Color.BLUE, direction=(0, 1))\n\n    # Draw the arrowhead (two diagonal lines)\n    # Diagonal down-left\n    draw_line(output_grid, blue_x + 0, blue_y + 3, length=1, color=Color.BLUE, direction=(1, -1))\n    # Diagonal down-right\n    draw_line(output_grid, blue_x + 0, blue_y + 3, length=1, color=Color.BLUE, direction=(1, 1))\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid as the background\n    n = np.random.randint(5, 15)\n    m = np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a random position for the blue pixel\n    blue_x = np.random.randint(0, n)\n    blue_y = np.random.randint(0, m - 3)  # Ensure there is space for the arrow\n\n    grid[blue_x, blue_y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/20/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/20/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/20/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/20/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/20/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/20/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/20/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/20/images/train_output_2.png"}]}, "index": 20, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pixel manipulation\n\n# description:\n# In the input you will see a medium sized grid with individual colored pixels. \n# To make the output: \n# 1. For each red pixel, change it to blue \n# 2. For each blue pixel, change it to red \n# 3. For each green pixel, change it to yellow \n# 4. For each yellow pixel, change it to green\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize output grid\n    output_grid = np.copy(input_grid)\n\n    # Perform color transformations\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.RED:\n                output_grid[x, y] = Color.BLUE\n            elif color == Color.BLUE:\n                output_grid[x, y] = Color.RED\n            elif color == Color.GREEN:\n                output_grid[x, y] = Color.YELLOW\n            elif color == Color.YELLOW:\n                output_grid[x, y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly fill the grid with colors\n    num_pixels = np.random.randint(10, 50)\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color_choice = np.random.choice([Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW])\n        grid[x, y] = color_choice\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/21/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/21/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/21/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/21/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/21/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/21/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/21/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/21/images/train_output_2.png"}]}, "index": 21, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input, you will see a 3x3 grid pattern consisting of a single color (for example, green).\n# To create the output, rotate this pattern 90 degrees clockwise and change its color to blue.\n\ndef main(input_grid):\n    # Get the original pattern\n    pattern = input_grid\n\n    # Rotate the pattern 90 degrees clockwise\n    rotated_pattern = np.rot90(pattern, k=-1)\n\n    # Change the color to blue (assuming Color.BLUE is defined)\n    output_grid = np.full(rotated_pattern.shape, Color.BLUE)\n    \n    # Overlay the rotated pattern on the output grid\n    output_grid[rotated_pattern != Color.BLACK] = Color.BLUE  # Assuming we only want to fill the non-black areas\n\n    return output_grid\n\ndef generate_input():\n    # Create a 3x3 grid with a single color (excluding black)\n    grid_size = 3\n    color_choice = np.random.choice([Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON])\n    \n    grid = np.full((grid_size, grid_size), Color.BLACK)\n    # Fill the whole grid with the chosen color\n    grid[:, :] = color_choice\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/22/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/22/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/22/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/22/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/22/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/22/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/22/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/22/images/train_output_2.png"}]}, "index": 22, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, pattern detection, filling\n\n# description:\n# In the input, you will see a grid with a background of one color and a pattern of colored pixels scattered throughout.\n# Your task is to count the number of times a specific color appears in the input grid, \n# and then create an output grid that fills a square area with the same color based on the count. \n# The output area is a square of side length equal to the count. \n# If the count is zero, return a 1x1 grid filled with black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Determine the color to count (we\u0027ll use the first non-background color found)\n    unique_colors = set(input_grid.flatten()) - {Color.BLACK}\n    if not unique_colors:\n        # If there are no unique colors, return a small black grid\n        return np.full((1, 1), Color.BLACK)\n\n    target_color = next(iter(unique_colors))\n\n    # Count how many times the target color appears\n    count = np.count_nonzero(input_grid == target_color)\n\n    # Create an output grid of size count x count filled with the target_color\n    if count \u003e 0:\n        output_grid = np.full((count, count), target_color)\n    else:\n        output_grid = np.full((1, 1), Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random-sized grid with a black background\n    n, m = np.random.randint(5, 15, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a random color for the pattern (not black)\n    available_colors = list(Color.NOT_BLACK)\n    target_color = np.random.choice(available_colors)\n\n    # Randomly scatter this target color in the grid\n    color_density = np.random.uniform(0.1, 0.5)  # Density of the target color\n    total_cells = n * m\n    num_target_color = int(total_cells * color_density)\n\n    for _ in range(num_target_color):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = target_color\n\n    # Ensure the background remains black\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/23/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/23/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/23/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/23/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/23/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/23/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/23/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/23/images/train_output_2.png"}]}, "index": 23, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, pattern recognition\n\n# description:\n# In the input, you will see a grid filled with colored pixels in a checkerboard pattern. \n# The first row and first column will indicate the color mapping: \n# The first cell (0,0) represents background color (black), \n# the first row will represent colors for even indexed columns, \n# and the first column will represent colors for even indexed rows. \n# To make the output grid, you should fill in the colors based on the mapping:\n# - (row_color, col_color) will be used to fill the grid such that:\n#   - If both row and column colors are the same, use that color.\n#   - Otherwise, use the color from the first row for even indexed columns and first column for even indexed rows.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Retrieve row colors and column colors\n    row_colors = input_grid[:, 0]\n    col_colors = input_grid[0, :]\n\n    # Fill the output grid based on the color mapping rules\n    for i in range(1, input_grid.shape[0]):\n        for j in range(1, input_grid.shape[1]):\n            row_color = row_colors[i]\n            col_color = col_colors[j]\n\n            if row_color == col_color:\n                output_grid[i, j] = row_color\n            else:\n                output_grid[i, j] = col_colors[j] if j % 2 == 0 else row_colors[i]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a checkerboard color layout\n    n, m = 6, 6  # Grid size\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define colors to be used\n    possible_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.TEAL, Color.PINK]\n\n    # Fill the first row and first column with random colors from possible_colors\n    grid[0, 1:] = np.random.choice(possible_colors, size=m-1)\n    grid[1:, 0] = np.random.choice(possible_colors, size=n-1)\n\n    # Fill the rest of the grid in a checkerboard pattern\n    for i in range(1, n):\n        for j in range(1, m):\n            # Fill in the grid with the background color for now\n            if (i + j) % 2 == 0:\n                grid[i, j] = Color.BLACK  # Background color\n            else:\n                # Randomly assign one of the colors for the checkerboard\n                grid[i, j] = np.random.choice(possible_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/24/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/24/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/24/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/24/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/24/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/24/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/24/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/24/images/train_output_2.png"}]}, "index": 24, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color transformation, object size determination\n\n# description:\n# In the input, you will see several objects of different colors against a black background.\n# To make the output, extract all objects, count their size, and change their color to:\n# - green if they have an odd number of pixels,\n# - red if they have an even number of pixels but greater than zero,\n# - leave black if they have zero pixels.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the objects in the input grid\n    objects = find_connected_components(input_grid)\n\n    # Change colors based on the size of each object\n    for obj in objects:\n        num_pixels = np.sum(obj != Color.BLACK)  # Count non-black pixels\n        if num_pixels % 2 == 1 and num_pixels \u003e 0:  # Odd number of pixels\n            output_grid[obj != Color.BLACK] = Color.GREEN\n        elif num_pixels % 2 == 0 and num_pixels \u003e 0:  # Even number of pixels\n            output_grid[obj != Color.BLACK] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Make a black 10x10 grid as the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of sprites\n    num_sprites = np.random.randint(3, 7)\n    for _ in range(num_sprites):\n        # Create a random sprite with random size and ensure it has a valid number of pixels\n        sprite = random_sprite(np.random.randint(1, 5), np.random.randint(1, 5), symmetry=\"not_symmetric\", color_palette=[Color.BLUE])\n        \n        # Ensure the sprite is not completely black\n        while np.sum(sprite != Color.BLACK) == 0:\n            sprite = random_sprite(np.random.randint(1, 5), np.random.randint(1, 5), symmetry=\"not_symmetric\", color_palette=[Color.BLUE])\n        \n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # Skip if there\u0027s no free space\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/25/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/25/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/25/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/25/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/25/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/25/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/25/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/25/images/train_output_2.png"}]}, "index": 25, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change\n\n# description:\n# In the input, you will see several different colored objects on a black background.\n# If an object is completely surrounded by black pixels, change its color to blue in the output.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the connected components (objects) in the input grid\n    objects = find_connected_components(input_grid)\n\n    # Iterate over each object and check if it is completely surrounded by black pixels\n    for obj in objects:\n        # Check if the object is surrounded by black pixels by checking its bounding box\n        x_min, x_max = np.min(np.where(obj != Color.BLACK)[0]), np.max(np.where(obj != Color.BLACK)[0])\n        y_min, y_max = np.min(np.where(obj != Color.BLACK)[1]), np.max(np.where(obj != Color.BLACK)[1])\n\n        # Check the border around the bounding box\n        if np.all(output_grid[x_min-1:x_max+2, y_min-1:y_max+2] == Color.BLACK):\n            # Change the color of the object to blue in the output grid\n            output_grid[obj == output_grid[x_min, y_min]] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Make a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Make a random number of sprites\n    num_sprites = np.random.randint(3, 7)\n    for _ in range(num_sprites):\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n        \n        # Try to ensure the sprite has a size that allows it to be surrounded\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/26/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/26/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/26/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/26/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/26/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/26/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/26/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/26/images/train_output_2.png"}]}, "index": 26, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, color filling\n\n# description:\n# In the input, you will see a grid with various colors scattered across it. \n# To make the output grid, you should first detect any connected components of pixels that share the same color. \n# Then, for each connected component, fill in a mirrored counterpart on the opposite side of the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all connected components in the grid.\n    # 2. For each component, create its mirrored counterpart on the opposite side of the grid.\n    \n    # Detect all colored components\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    \n    # Initialize the output grid with a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get grid dimensions\n    height, width = input_grid.shape\n\n    for component in components:\n        # Get the color of the current component\n        color = component[0][0]  # Taking the color from the first pixel in the component\n        \n        # Get the bounding box of the component\n        x, y, w, h = bounding_box(component, background=Color.BLACK)\n\n        # Create the mirrored coordinates\n        mirrored_x = height - (x + h)\n        \n        # Check if the mirrored position is valid\n        if mirrored_x \u003e= 0:\n            # Fill the mirrored component\n            for i in range(h):\n                for j in range(w):\n                    if component[i, j] != Color.BLACK:\n                        output_grid[mirrored_x + i, y + j] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels on the grid.\n    colors = Color.NOT_BLACK\n    density = 0.5\n    grid = random_scatter_points(grid=grid, color=np.random.choice(colors), density=density)\n\n    # Scatter additional colors to ensure connected components\n    num_components = np.random.randint(1, 4)  # Random number of color components\n    for _ in range(num_components):\n        color = np.random.choice(colors)\n        size = np.random.randint(3, 6)  # Size of the component\n        x_start, y_start = np.random.randint(0, n - size), np.random.randint(0, m - size)\n\n        # Draw a square component\n        for i in range(size):\n            for j in range(size):\n                grid[x_start + i, y_start + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/27/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/27/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/27/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/27/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/27/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/27/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/27/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/27/images/train_output_2.png"}]}, "index": 27, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swapping, striped patterns, grid manipulation\n\n# description:\n# In the input you will see a grid with horizontal stripes of two colors. \n# Each stripe has a fixed height. The task is to swap the colors of all the stripes.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    \n    # Identify the unique colors in the input grid (excluding black)\n    unique_colors = set(input_grid.flatten()) - {Color.BLACK}\n    \n    # If there are not exactly two colors, return the original grid (no valid transformation)\n    if len(unique_colors) != 2:\n        return output_grid\n    \n    # Identify the two colors\n    color1, color2 = list(unique_colors)\n    \n    # Swap the colors in the output grid\n    output_grid[input_grid == color1] = color2\n    output_grid[input_grid == color2] = color1\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Set the height of each stripe\n    STRIPE_HEIGHT = np.random.randint(1, 4)\n\n    # Randomly choose two colors (excluding black)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=2, replace=False)\n    \n    # Draw horizontal stripes\n    for i in range(0, n, STRIPE_HEIGHT):\n        if (i // STRIPE_HEIGHT) % 2 == 0:\n            draw_line(grid=grid, x=0, y=i, length=m, direction=(1, 0), color=colors[0])\n        else:\n            draw_line(grid=grid, x=0, y=i, length=m, direction=(1, 0), color=colors[1])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/28/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/28/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/28/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/28/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/28/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/28/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/28/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/28/images/train_output_2.png"}]}, "index": 28, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, sliding objects, color transformation\n\n# description:\n# In the input you will see a grid with several colored objects. \n# To make the output, slide each object down by a number of pixels equal to the number of objects of the same color.\n# If an object cannot move down due to other objects, it should stay in place.\n\ndef main(input_grid):\n    # Find the connected components of different colors in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Count the number of objects of each color\n    color_counts = {}\n    for obj in objects:\n        color = obj[obj != Color.BLACK][0]  # Each object is monochromatic\n        if color not in color_counts:\n            color_counts[color] = 0\n        color_counts[color] += 1\n\n    # Slide each object down by the count of its color\n    for obj in objects:\n        color = obj[obj != Color.BLACK][0]\n        slide_distance = color_counts[color]\n\n        # Translate the object down by the slide distance\n        translated_obj = translate(obj, 0, slide_distance, background=Color.BLACK)\n\n        # Check for collision with the existing objects in the output grid\n        # If there\u0027s a collision, we need to adjust the position\n        x, y = np.argwhere(input_grid == color)[0]  # Get original position of the object\n        while not collision(object1=output_grid, object2=translated_obj):\n            # If no collision, blit the object\n            output_grid = blit_object(grid=output_grid, obj=translated_obj, background=Color.BLACK)\n            break\n        else:\n            # If there is a collision, we keep the object in place\n            output_grid = blit_object(grid=output_grid, obj=obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size between 5x5 and 10x10\n    grid_len = np.random.randint(5, 11)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Randomly place colored objects on the grid\n    num_objects = np.random.randint(5, 15)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=num_objects)\n\n    for color in colors:\n        # Create a random sprite of size 1x1\n        sprite = np.array([[color]])\n        \n        # Find a random location for the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        \n        # Blit the sprite onto the grid\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/29/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/29/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/29/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/29/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/29/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/29/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/29/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/29/images/train_output_2.png"}]}, "index": 29, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, color transformation\n\n# description:\n# In the input, you will see a grid filled with colored pixels. Each row of pixels represents a different color.\n# To make the output, count the number of pixels of each color in the grid. If a color appears exactly 2 times, color the output row green.\n# If it appears exactly 3 times, color the output row red. If it appears exactly 4 times, color the output row blue.\n# Each row in the output will represent the colors corresponding to the counts in the input grid.\n\ndef main(input_grid):\n    # Create an empty output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the number of rows in the input grid\n    num_rows = input_grid.shape[0]\n    \n    for i in range(num_rows):\n        # Count the pixel colors in the current row\n        unique_colors, counts = np.unique(input_grid[i], return_counts=True)\n        \n        # Map the counts to the output colors\n        for color, count in zip(unique_colors, counts):\n            if count == 2:\n                output_grid[i] = Color.GREEN\n            elif count == 3:\n                output_grid[i] = Color.RED\n            elif count == 4:\n                output_grid[i] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 5x10 filled with random colors\n    n = 5\n    m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill each row with 0 to 4 pixels of one of the available colors\n    for i in range(n):\n        num_pixels = np.random.randint(0, 5)  # Choose how many pixels to fill (0 to 4)\n        colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=True)  # Choose random colors\n        grid[i, :num_pixels] = colors  # Fill the current row with the selected colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/30/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/30/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/30/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/30/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/30/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/30/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/30/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/30/images/train_output_2.png"}]}, "index": 30, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, scaling, placement\n\n# description:\n# In the input, you will see a grid with a single blue pixel and a large surrounding black frame. \n# To make the output grid, you should scale the blue pixel into a 5x5 blue square and place it in the center of the grid.\n\ndef main(input_grid):\n    # Step 1: Detect the blue pixel in the input grid.\n    blue_pixels = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True)\n    \n    # Step 2: Scale the blue pixel into a 5x5 square.\n    blue_square = np.full((5, 5), Color.BLUE)\n\n    # Step 3: Calculate the center position of the output grid.\n    center_x = (input_grid.shape[0] - 5) // 2\n    center_y = (input_grid.shape[1] - 5) // 2\n    \n    # Step 4: Create an output grid and place the blue square in the center.\n    output_grid = np.copy(input_grid)\n    output_grid[center_x:center_x + 5, center_y:center_y + 5] = blue_square\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = 20, 20\n    grid = np.full((n, m), Color.BLACK)\n\n    # Place a single blue pixel in a random location within the grid.\n    while True:\n        x = np.random.randint(n)\n        y = np.random.randint(m)\n        if grid[x, y] == Color.BLACK:  # Ensure the pixel is placed on a black background\n            grid[x, y] = Color.BLUE\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/31/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/31/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/31/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/31/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/31/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/31/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/31/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/31/images/train_output_2.png"}]}, "index": 31, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color detection, object extraction\n\n# description:\n# In the input you will see a 2D grid with colored objects. Some objects are formed of multiple colors and are not connected but represent the same shape.\n# To make the output, you need to unify all sections of each object into one color, preserving the shape of the object. \n# If an object is composed of multiple colors, it will be converted to a single color (the first color encountered in the object).\n\ndef main(input_grid):\n    # Start by creating an output grid that will be filled in\n    output_grid = np.copy(input_grid)\n\n    # Detect all objects in the grid\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=8, background=Color.BLACK)\n\n    # Process each detected object\n    for obj in objects:\n        # Extract the color of the first pixel in the object\n        first_color = obj[obj != Color.BLACK][0]\n\n        # Get the coordinates of this object and fill it with the first color\n        coords = np.argwhere(obj != Color.BLACK)\n        for x, y in coords:\n            output_grid[x + obj.shape[0] - obj.shape[0], y + obj.shape[1] - obj.shape[1]] = first_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium-sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of objects\n    num_objects = np.random.randint(2, 5)\n    colors = random.sample(list(Color.NOT_BLACK), num_objects)  # Choose unique colors for each object\n\n    for color in colors:\n        # Create a random object\n        sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.5, color_palette=[color])\n        \n        # Place the sprite in a random free location on the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n        \n        # Randomly add disconnected parts of the object with different colors\n        for _ in range(np.random.randint(1, 4)):  # Add 1 to 3 disconnected parts\n            disconnected_sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), density=0.5, color_palette=[random.choice(Color.NOT_BLACK)])\n            dx, dy = random_free_location_for_sprite(grid, disconnected_sprite)\n            blit_sprite(grid, disconnected_sprite, dx, dy)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/32/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/32/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/32/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/32/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/32/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/32/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/32/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/32/images/train_output_2.png"}]}, "index": 32, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color blending\n\n# description:\n# In the input, you will see a grid containing a central colored object surrounded by a border of another color.\n# To create the output, remove the border and blend the central object with its surrounding color.\n\ndef main(input_grid):\n    # Find the shape of the grid\n    n, m = input_grid.shape\n    \n    # Identify the color of the border (which is assumed to be the same for pixels around the object)\n    border_color = input_grid[0, 0]  # Take the color from the top-left corner\n    \n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Remove the border pixels\n    output_grid[output_grid == border_color] = Color.BLACK\n\n    # Blend the central object with the border color\n    # Find the central object pixels which are not black\n    central_object_pixels = np.argwhere(output_grid != Color.BLACK)\n\n    # If there are central object pixels, blend them with the border color\n    if central_object_pixels.size \u003e 0:\n        for x, y in central_object_pixels:\n            output_grid[x, y] = (border_color if output_grid[x, y] == Color.BLACK else output_grid[x, y])\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 7x7 filled with black\n    n, m = 7, 7\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define colors for the object and the border\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    border_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Make sure the object color and border color are different\n    while object_color == border_color:\n        border_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a central object and place it in the middle of the grid\n    sprite = random_sprite(5, 5, density=0.5, symmetry=None, color_palette=[object_color])\n    blit_sprite(grid, sprite, x=1, y=1)\n\n    # Create a border around the object\n    for i in range(n):\n        for j in range(m):\n            if (i == 0 or i == n-1 or j == 0 or j == m-1) and grid[i, j] == Color.BLACK:\n                grid[i, j] = border_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/33/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/33/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/33/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/33/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/33/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/33/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/33/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/33/images/train_output_2.png"}]}, "index": 33, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object detection, scaling\n\n# description:\n# In the input, you will see a grid filled with colors and objects. The goal is to identify the largest object of each color in the grid,\n# and scale those objects (duplicate them) by a factor of 2, filling the empty spaces with black pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid filled with black\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect objects for each color present in the grid\n    unique_colors = np.unique(input_grid)\n    for color in unique_colors:\n        if color == Color.BLACK:\n            continue\n        \n        # Find all objects of this color\n        objects = detect_objects(grid=input_grid, colors=[color], monochromatic=True, connectivity=8)\n\n        # Find the largest object\n        largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n        # Get the bounding box of the largest object\n        x, y, width, height = bounding_box(largest_object)\n\n        # Scale the object (duplicate it) by a factor of 2\n        for i in range(width):\n            for j in range(height):\n                if largest_object[i, j] != Color.BLACK:\n                    output_grid[2*x + i, 2*y + j] = largest_object[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random colors with some objects\n    n, m = np.random.randint(6, 10), np.random.randint(6, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the number of objects and their colors\n    num_objects = np.random.randint(3, 6)\n    colors = random.sample(list(Color.NOT_BLACK), num_objects)\n\n    for color in colors:\n        # Randomly create a sprite for this color and place it in the grid\n        sprite = random_sprite(n=np.random.randint(2, 5), m=np.random.randint(2, 5), color_palette=[color], density=0.4)\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, background=Color.BLACK)\n        except:\n            continue\n        \n        # Place the object in the grid\n        grid = blit_sprite(grid=grid, sprite=sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/34/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/34/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/34/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/34/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/34/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/34/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/34/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/34/images/train_output_2.png"}]}, "index": 34, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape expansion, color swap\n\n# description:\n# In the input you will see a black grid with a colored shape in the center. \n# To make the output, expand the shape by one pixel in all directions and swap its color with the color of the background.\n\ndef main(input_grid):\n    # Find connected components (the colored shape)\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4)\n    assert len(components) == 1  # There should be exactly one colored shape\n    shape = components[0]\n    \n    # Get the color of the shape and the background color\n    shape_color = shape[shape != Color.BLACK][0]  # The color of the shape\n    background_color = Color.BLACK  # The background is black\n    \n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, background_color)\n    \n    # Get the bounding box of the shape\n    x, y, width, height = bounding_box(shape)\n    \n    # Draw the expanded shape on the output grid\n    for dx in range(-1, width + 1):\n        for dy in range(-1, height + 1):\n            target_x = x + dx\n            target_y = y + dy\n            if 0 \u003c= target_x \u003c output_grid.shape[0] and 0 \u003c= target_y \u003c output_grid.shape[1]:\n                output_grid[target_x, target_y] = shape_color\n    \n    # Swap the shape color with the background color\n    output_grid[output_grid == shape_color] = background_color\n    output_grid[output_grid == background_color] = shape_color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 12x12 black grid\n    grid_size = 12\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a random colored shape (sprite) with a size of 3x3 to 5x5\n    shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape = random_sprite(shape_height, shape_width, color_palette=[shape_color], density=1.0)\n\n    # Find a random position to place the shape in the center of the grid\n    start_x = (grid_size - shape_height) // 2\n    start_y = (grid_size - shape_width) // 2\n    blit_sprite(input_grid, shape, x=start_x, y=start_y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/35/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/35/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/35/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/35/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/35/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/35/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/35/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/35/images/train_output_2.png"}]}, "index": 35, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, rotation, color changing\n\n# description:\n# In the input, you will see a grid with a single yellow object. \n# To create the output, you should rotate the object 90 degrees clockwise and change its color to blue.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the yellow object (it\u0027s the only one)\n    # 2. Change its color to blue\n    # 3. Rotate it 90 degrees clockwise\n\n    # Get the single yellow object\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1\n    yellow_object = objects[0]\n\n    # Make a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change its color to blue\n    yellow_object[yellow_object != Color.BLACK] = Color.BLUE\n\n    # Rotate it 90 degrees clockwise\n    rotated_object = np.rot90(yellow_object, k=-1)  # k=-1 for clockwise rotation\n\n    # Blit the rotated object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=rotated_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_len = np.random.randint(4, 8)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Randomly generate the yellow object and place it on the grid.\n    sprite_width, sprite_height = np.random.randint(1, grid_len - 1), np.random.randint(1, grid_len - 1)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.YELLOW], density=0.5)\n    \n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/36/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/36/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/36/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/36/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/36/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/36/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/36/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/36/images/train_output_2.png"}]}, "index": 36, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, reversing pattern\n\n# description:\n# In the input, you will see a grid where the top row contains a sequence of colored pixels followed by a grey line.\n# To create the output, count the number of pixels of each color in the top row, and then fill the output grid\n# such that the colors are arranged in a single column in reverse order, starting from the bottom of the column.\n# The number of colored pixels in the output corresponds to the number of pixels of each color in the input.\n\ndef main(input_grid):\n    # Count the occurrences of each color in the top row\n    color_counts = {}\n    for color in input_grid[0]:\n        if color != Color.GREY:  # Skip the grey line\n            if color in color_counts:\n                color_counts[color] += 1\n            else:\n                color_counts[color] = 1\n\n    # Prepare the output grid initialized to background color\n    output_height = sum(color_counts.values())\n    output_grid = np.zeros((output_height, 1), dtype=int)\n\n    # Fill the output grid in reverse order\n    current_row = output_height - 1\n    for color, count in reversed(color_counts.items()):\n        output_grid[current_row - count + 1:current_row + 1, 0] = color\n        current_row -= count\n\n    return output_grid\n\ndef generate_input():\n    # Randomly decide how many colors to use in the top row\n    num_colors = np.random.randint(2, 6)\n\n    # Select unique colors for the sequence\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    # Create a grid that will fit the colors along the top row, a grey line below it, and at least one empty row below\n    n = 2  # Two rows\n    m = num_colors + 1  # One extra column for grey line\n    grid = np.zeros((n, m), dtype=int)\n\n    # Put the colors in the top row\n    grid[0, :num_colors] = colors\n\n    # Add a grey line in the second row\n    grid[1, :] = Color.GREY\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/37/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/37/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/37/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/37/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/37/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/37/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/37/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/37/images/train_output_2.png"}]}, "index": 37, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern mapping, color replication, grid transformation\n\n# description:\n# In the input you will see a grid containing a central pattern surrounded by a border of black pixels.\n# Each side of the border contains pixels of a specific color (top, right, bottom, left). \n# To make the output, replace the central pattern\u0027s color with the corresponding color from the border on each side, \n# while keeping the black border intact.\n\ndef main(input_grid):\n    # Create an output grid, initialized as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the colors of the border pixels\n    top_color = input_grid[0, 1]  # Top center\n    right_color = input_grid[1, -1]  # Right center\n    bottom_color = input_grid[-1, 1]  # Bottom center\n    left_color = input_grid[1, 0]  # Left center\n\n    # Define the bounding box of the central pattern (everything except the border)\n    central_pattern = input_grid[1:-1, 1:-1]\n\n    # Replace the color of the central pattern with the corresponding border colors\n    output_grid[1:-1, 1:-1][central_pattern != Color.BLACK] = top_color\n    output_grid[1:-1, 1:-1][central_pattern != Color.BLACK] = right_color\n    output_grid[1:-1, 1:-1][central_pattern != Color.BLACK] = bottom_color\n    output_grid[1:-1, 1:-1][central_pattern != Color.BLACK] = left_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid size of 7x7 with a black background\n    grid_size = 7\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Define colors for the border (ensuring they are not black)\n    available_colors = list(Color.NOT_BLACK)\n    top_color = np.random.choice(available_colors)\n    right_color = np.random.choice(available_colors)\n    bottom_color = np.random.choice(available_colors)\n    left_color = np.random.choice(available_colors)\n\n    # Set the border colors\n    grid[0, 1] = top_color  # Top center\n    grid[1, -1] = right_color  # Right center\n    grid[-1, 1] = bottom_color  # Bottom center\n    grid[1, 0] = left_color  # Left center\n\n    # Generate a random central pattern\n    central_pattern = random_sprite(5, 5, density=0.5)  # 5x5 central pattern\n    grid[1:-1, 1:-1] = blit_sprite(grid=np.zeros((5, 5), dtype=int), sprite=central_pattern, x=0, y=0)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/38/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/38/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/38/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/38/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/38/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/38/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/38/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/38/images/train_output_2.png"}]}, "index": 38, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color matching, grid transformation\n\n# description:\n# In the input, you will see a black background with several colored circles of different sizes and a single colored square in the top left corner.\n# To make the output, find the circle that matches the color of the square and resize it to fill the grid, placing it in the center.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the color of the square in the top left corner.\n    # 2. Extract all colored circles in the grid.\n    # 3. Find the circle that matches the color of the square.\n    # 4. Resize this circle to fill the entire grid and place it in the center.\n\n    # Step 1: Get the color of the square\n    square_color = input_grid[0, 0]\n\n    # Step 2: Extract objects (circles)\n    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n\n    # Step 3: Find the circle that matches the square\u0027s color\n    matching_circle = None\n    for obj in objects:\n        if np.sum(obj != Color.BLACK) \u003e 0 and np.unique(obj[obj != Color.BLACK]).size == 1:\n            if np.unique(obj[obj != Color.BLACK])[0] == square_color:\n                matching_circle = obj\n                break\n\n    if matching_circle is None:\n        raise ValueError(\"No matching colored circle found.\")\n\n    # Step 4: Resize the circle to fill the grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    circle_height, circle_width = output_grid.shape\n    resized_circle = np.full((circle_height, circle_width), square_color)\n    \n    # Place resized circle in the center\n    blit_sprite(output_grid, resized_circle, x=0, y=0, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a grid filled with black.\n    # 2. Randomly place a colored square in the top left corner.\n    # 3. Generate several colored circles in random locations.\n    # 4. Ensure there is at least one circle that matches the square\u0027s color.\n\n    width, height = np.random.randint(10, 20, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    square_color = np.random.choice(Color.NOT_BLACK)\n    input_grid[0, 0] = square_color  # Place the colored square in the top left corner\n\n    num_circles = np.random.randint(1, 5)\n    for _ in range(num_circles):\n        circle_color = np.random.choice(Color.NOT_BLACK)\n        circle_radius = np.random.randint(1, min(width, height) // 4)  # Random radius for the circles\n        \n        # Create a circle sprite\n        circle_sprite = np.full((circle_radius * 2, circle_radius * 2), Color.BLACK)\n        for x in range(circle_radius * 2):\n            for y in range(circle_radius * 2):\n                if (x - circle_radius) ** 2 + (y - circle_radius) ** 2 \u003c= circle_radius ** 2:\n                    circle_sprite[x, y] = circle_color\n\n        # Place the circle randomly in the grid\n        x_offset = np.random.randint(0, width - circle_radius * 2)\n        y_offset = np.random.randint(0, height - circle_radius * 2)\n        blit_sprite(input_grid, circle_sprite, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/39/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/39/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/39/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/39/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/39/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/39/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/39/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/39/images/train_output_2.png"}]}, "index": 39, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color transformation\n\n# description:\n# In the input, you will see a grid filled with colored pixels, where some pixels are orange or yellow.\n# To make the output:\n# 1. For each orange pixel, replace the pixel with a pink pixel and add blue pixels in its immediate diagonals (northeast, northwest, southeast, southwest).\n# 2. For each yellow pixel, replace the pixel with a pink pixel and add green pixels in its immediate neighbors (up, down, left, right).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.ORANGE:\n                output_grid[x, y] = Color.PINK\n                # Place blue pixels in the diagonals\n                for dx in [-1, 1]:\n                    for dy in [-1, 1]:\n                        if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                            output_grid[x + dx, y + dy] = Color.BLUE\n            elif color == Color.YELLOW:\n                output_grid[x, y] = Color.PINK\n                # Place green pixels in the neighbors\n                for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                    if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                        output_grid[x + dx, y + dy] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place some orange and yellow pixels\n    num_orange = np.random.randint(1, 5)\n    num_yellow = np.random.randint(1, 5)\n    num_other = np.random.randint(5, 20)  # Other colors to fill the grid\n\n    for _ in range(num_orange):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.ORANGE\n    \n    for _ in range(num_yellow):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.YELLOW\n\n    for _ in range(num_other):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color not in [Color.ORANGE, Color.YELLOW]])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/40/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/40/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/40/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/40/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/40/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/40/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/40/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/40/images/train_output_2.png"}]}, "index": 40, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, color replacement\n\n# description:\n# In the input grid, you will find a pattern of colored pixels surrounded by a border of black pixels. \n# The colors of the pixels in the pattern can be any of the available colors. \n# To create the output grid, replace the pixels of the pattern with a new color provided along with the input grid. \n# The new color will be the second parameter in the input grid\u0027s metadata.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Determine the new color from the metadata (the last entry of the grid)\n    new_color = input_grid[-1, -1]  # Assumes this is the color to replace the pattern\n\n    # Create an output grid which is a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Replace the colored pixels in the grid with the new color\n    # We assume the pattern is surrounded by black pixels\n    for x in range(input_grid.shape[0] - 1):  # Exclude last row for metadata\n        for y in range(input_grid.shape[1] - 1):  # Exclude last column for metadata\n            if input_grid[x, y] != Color.BLACK:  # Check if the pixel is part of the pattern\n                output_grid[x, y] = new_color  # Replace with the new color\n\n    return output_grid[:-1, :-1]  # Remove the metadata row and column\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid size randomly between 5x5 and 8x8\n    n = np.random.randint(5, 9)\n    m = np.random.randint(5, 9)\n    grid = np.zeros((n + 1, m + 1), dtype=int)  # +1 for the metadata row and column\n\n    # Randomly select a color for the pattern\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a pattern of random size in the grid\n    pattern_height = np.random.randint(1, n - 1)\n    pattern_width = np.random.randint(1, m - 1)\n\n    # Fill the pattern area with the selected pattern color\n    for i in range(pattern_height):\n        for j in range(pattern_width):\n            if np.random.rand() \u003c 0.5:  # Randomly decide to fill or leave black\n                grid[i, j] = pattern_color\n\n    # Set a black border around the pattern\n    for i in range(n + 1):\n        grid[i, 0] = Color.BLACK\n        grid[i, m] = Color.BLACK\n    for j in range(m + 1):\n        grid[0, j] = Color.BLACK\n        grid[n, j] = Color.BLACK\n\n    # Set the metadata at the bottom right corner with the new color\n    new_color = np.random.choice(list(Color.NOT_BLACK))\n    grid[n, m] = new_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/41/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/41/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/41/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/41/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/41/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/41/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/41/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/41/images/train_output_2.png"}]}, "index": 41, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color shifting\n\n# description:\n# In the input you will see a grid containing a pattern of colored squares with a border of black pixels.\n# To make the output, extract the colored pattern, shift its color values by one (e.g., RED -\u003e GREEN, GREEN -\u003e BLUE, etc.),\n# and place the shifted pattern on a black background.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Crop the input grid to extract the colored pattern (removing the black border)\n    pattern = crop(input_grid, background=Color.BLACK)\n\n    # Create an output grid with a black background\n    output_grid = np.zeros_like(input_grid)\n\n    # Define a color shift mapping (cyclic)\n    color_shift_map = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.GREY,\n        Color.GREY: Color.PINK,\n        Color.PINK: Color.ORANGE,\n        Color.ORANGE: Color.TEAL,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.RED,\n        Color.BLACK: Color.BLACK,  # Keep black unchanged\n    }\n\n    # Apply the color shift to the pattern\n    for x in range(pattern.shape[0]):\n        for y in range(pattern.shape[1]):\n            original_color = pattern[x, y]\n            shifted_color = color_shift_map[original_color] if original_color != Color.BLACK else Color.BLACK\n            output_grid[x, y] = shifted_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the pattern \n    n, m = random.randint(3, 8), random.randint(3, 8)\n\n    # Generate a random pattern with a black border\n    pattern = random_sprite(n, m, color_palette=Color.NOT_BLACK, density=0.6)\n    \n    # Create an enlarged grid with a black border\n    enlarged_pattern = np.zeros((n + 2, m + 2), dtype=int)\n    enlarged_pattern[1:n + 1, 1:m + 1] = pattern\n\n    return enlarged_pattern", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/42/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/42/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/42/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/42/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/42/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/42/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/42/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/42/images/train_output_2.png"}]}, "index": 42, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, boundary extraction\n\n# description:\n# In the input, you will see a colored circular region in the center, surrounded by a background of another color. \n# Scattered pixels of a specific color are present outside the circular region. \n# To make the output grid, extract and keep the circular region, and connect each scattered pixel to the nearest point on the border of the circular region with a line of the same color as the scattered pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n    \n    # Identify the background color\n    background = np.bincount(input_grid.flatten()).argmax()\n    \n    # Find the circular region by detecting the largest connected component not equal to the background\n    objects = find_connected_components(input_grid, background=background, monochromatic=False)\n    circular_region = max(objects, key=lambda obj: np.sum(obj != background))\n    \n    # Create a bounding box for the circular region\n    x_min, y_min, width, height = bounding_box(circular_region, background=background)\n    \n    # Extract the circular region\n    output_grid[x_min:x_min + height, y_min:y_min + width] = input_grid[x_min:x_min + height, y_min:y_min + width]\n    \n    # Identify scattered pixels outside the circular region\n    for x, y in np.argwhere(input_grid != background):\n        if not (x_min \u003c= x \u003c x_min + height and y_min \u003c= y \u003c y_min + width):\n            scattered_color = input_grid[x, y]\n            # Find the closest point on the circular boundary\n            center_x, center_y = (x_min + height) // 2, (y_min + width) // 2\n            radius = (height // 2)  # Assuming a circular area\n            \n            # Calculate the distance from the pixel to the center\n            distance = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)\n            if distance \u003c radius:\n                continue  # Inside the circular region, skip\n            \n            # Calculate the closest point on the boundary\n            if distance \u003e 0:\n                scale = radius / distance\n                closest_x = int(center_x + (x - center_x) * scale)\n                closest_y = int(center_y + (y - center_y) * scale)\n                # Draw a line from the scattered pixel to the closest point on the boundary\n                draw_line(output_grid, x, y, end_x=closest_x, end_y=closest_y, color=scattered_color)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a background color\n    background_color = np.random.choice(Color.NOT_BLACK)\n    grid.fill(background_color)\n\n    # Create a circular region in the middle with a specific color\n    circle_color = np.random.choice(Color.NOT_BLACK)\n    center_x, center_y = n // 2, m // 2\n    radius = np.random.randint(3, min(n, m) // 4)\n    \n    # Draw a filled circle\n    for x in range(n):\n        for y in range(m):\n            if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                grid[x, y] = circle_color\n    \n    # Randomly scatter pixels of a different color outside the circular region\n    scattered_color = np.random.choice(Color.NOT_BLACK)\n    density = 0.2  # 20% density of scattered points\n    grid = random_scatter_points(grid=grid, color=scattered_color, density=density, background=background_color)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/43/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/43/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/43/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/43/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/43/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/43/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/43/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/43/images/train_output_2.png"}]}, "index": 43, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, object detection\n\n# description:\n# In the input, you will see multiple 2x2 yellow squares and green squares on a black background. \n# To create the output, switch the color of every 2x2 yellow square to orange and every 2x2 green square to orange. \n# All other colors should remain the same.\n\ndef main(input_grid):\n    # Create the output grid initialized to the same shape and background\n    output_grid = np.copy(input_grid)\n\n    # Detect all 2x2 yellow squares\n    yellow_squares = detect_objects(input_grid, colors=[Color.YELLOW], monochromatic=True, allowed_dimensions=[(2, 2)])\n    \n    # Change yellow squares to orange\n    for square in yellow_squares:\n        x, y, _, _ = bounding_box(square)\n        output_grid[x:x+2, y:y+2] = Color.ORANGE\n\n    # Detect all 2x2 green squares\n    green_squares = detect_objects(input_grid, colors=[Color.GREEN], monochromatic=True, allowed_dimensions=[(2, 2)])\n\n    # Change green squares to orange\n    for square in green_squares:\n        x, y, _, _ = bounding_box(square)\n        output_grid[x:x+2, y:y+2] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid as the background\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of yellow and green 2x2 squares\n    for color, count in zip([Color.YELLOW, Color.GREEN], np.random.randint(2, 6, size=2)):\n        square = np.full((2, 2), color, dtype=int)\n        for _ in range(count):\n            try:\n                x, y = random_free_location_for_sprite(grid, square, background=Color.BLACK)\n                blit_sprite(grid, square, x, y)\n            except:\n                continue  # If no valid location, skip to the next\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/44/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/44/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/44/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/44/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/44/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/44/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/44/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/44/images/train_output_2.png"}]}, "index": 44, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid rotation, color mapping\n\n# description:\n# In the input, you will see a square grid containing various colors. Additionally, there is a color guide that specifies a mapping of colors to their new positions after a 90-degree clockwise rotation. The task is to rotate the grid by 90 degrees clockwise and apply the color mapping from the guide.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Define the size of the grid and the new output grid\n    n, m = input_grid.shape\n    output_grid = np.zeros((m, n), dtype=int)  # Create an output grid with swapped dimensions\n\n    # Step 2: Rotate the grid 90 degrees clockwise\n    for i in range(n):\n        for j in range(m):\n            output_grid[j, n - 1 - i] = input_grid[i, j]\n\n    # Step 3: Map the colors according to the color guide\n    color_mapping = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.RED,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.TEAL,\n        Color.PINK: Color.GREY,\n        Color.GREY: Color.PINK,\n        Color.ORANGE: Color.BLACK,\n        Color.BLACK: Color.ORANGE\n    }\n\n    for i in range(m):\n        for j in range(n):\n            original_color = output_grid[i, j]\n            output_grid[i, j] = color_mapping.get(original_color, original_color)  # Keep unchanged if not in mapping\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid of size n x n with various colors\n    n = np.random.randint(5, 10)  # Grid size between 5 and 10\n    grid = np.zeros((n, n), dtype=int)\n\n    # Define available colors excluding black\n    available_colors = [c for c in Color.NOT_BLACK]\n\n    # Fill the grid with random colors\n    for i in range(n):\n        for j in range(n):\n            grid[i, j] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/45/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/45/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/45/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/45/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/45/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/45/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/45/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/45/images/train_output_2.png"}]}, "index": 45, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color switching, object detection\n\n# description:\n# In the input you will see a grid filled with squares of various colors. \n# Select two colors (for example, Color.RED and Color.BLUE) and switch the colors of the squares \n# that are entirely filled with those colors. The output grid will have the selected colors swapped.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Detect objects for the two colors\n    color1 = Color.RED\n    color2 = Color.BLUE\n\n    # Detect all objects of color1\n    objects_color1 = detect_objects(grid=input_grid, colors=[color1], monochromatic=True, connectivity=4)\n    \n    # Detect all objects of color2\n    objects_color2 = detect_objects(grid=input_grid, colors=[color2], monochromatic=True, connectivity=4)\n\n    output_grid = input_grid.copy()\n\n    # Color switch: Change color1 to color2 and color2 to color1 in the output grid\n    for obj in objects_color1:\n        # Get the position of the object and fill with color2\n        x, y = np.argwhere(input_grid == color1)[0]  # Get the position of the first pixel\n        flood_fill(output_grid, x, y, color2)\n\n    for obj in objects_color2:\n        # Get the position of the object and fill with color1\n        x, y = np.argwhere(input_grid == color2)[0]  # Get the position of the first pixel\n        flood_fill(output_grid, x, y, color1)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with random colors\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose two colors to switch\n    color1 = Color.RED\n    color2 = Color.BLUE\n\n    # Fill the grid with random colors while ensuring color1 and color2 appear\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.1:  # 10% chance to place color1 or color2\n                grid[i, j] = color1 if np.random.rand() \u003c 0.5 else color2\n            else:\n                grid[i, j] = np.random.choice([c for c in Color.NOT_BLACK if c != color1 and c != color2])\n\n    # Randomly fill a few squares of color1 and color2 to ensure they are present\n    for _ in range(np.random.randint(2, 5)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color1\n        if x + 1 \u003c n and y + 1 \u003c m:  # Ensure we can place a 2x2 square\n            grid[x+1, y] = color1\n            grid[x, y+1] = color1\n            grid[x+1, y+1] = color1\n\n    for _ in range(np.random.randint(2, 5)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color2\n        if x + 1 \u003c n and y + 1 \u003c m:  # Ensure we can place a 2x2 square\n            grid[x+1, y] = color2\n            grid[x, y+1] = color2\n            grid[x+1, y+1] = color2\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/46/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/46/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/46/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/46/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/46/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/46/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/46/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/46/images/train_output_2.png"}]}, "index": 46, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input you will see a colored shape on a black background.\n# To make the output, rotate the shape 90 degrees clockwise and change its color to orange.\n\ndef main(input_grid):\n    # Get the bounding box of the input shape\n    x, y, width, height = bounding_box(grid=input_grid)\n    \n    # Extract the shape from the input grid\n    shape = input_grid[x:x + width, y:y + height]\n    \n    # Rotate the shape 90 degrees clockwise\n    rotated_shape = np.rot90(shape, k=-1)  # k=-1 for 90 degrees clockwise\n    \n    # Make an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Replace the area of the output grid with the rotated shape and change its color to orange\n    output_shape = np.where(rotated_shape != Color.BLACK, Color.ORANGE, rotated_shape)\n    \n    # Calculate the position to place the rotated shape back into the output grid\n    output_grid[x:x + rotated_shape.shape[0], y:y + rotated_shape.shape[1]] = output_shape\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium sized grid\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random colored shape with a specific color\n    shape_color = np.random.choice(list(Color.NOT_BLACK))\n    shape_sprite = random_sprite(np.random.randint(3, n-2), np.random.randint(3, m-2), density=0.5, color_palette=[shape_color])\n    \n    # Choose a random position to place the shape\n    x, y = random_free_location_for_sprite(grid, shape_sprite)\n    blit_sprite(grid, shape_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/47/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/47/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/47/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/47/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/47/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/47/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/47/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/47/images/train_output_2.png"}]}, "index": 47, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation\n\n# description:\n# In the input, you will see a grid with different colored shapes. Each shape is made up of colored pixels.\n# To create the output, rotate each shape 90 degrees clockwise and change their color according to this mapping:\n# red -\u003e blue, green -\u003e red, blue -\u003e green.\n\ndef main(input_grid):\n    # Initialize the output grid based on the input shape\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Define the color transformation mapping\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.RED,\n        Color.BLUE: Color.GREEN\n    }\n\n    # Get the shape of the input grid\n    rows, cols = input_grid.shape\n\n    # Rotate and transform colors\n    for x in range(rows):\n        for y in range(cols):\n            color = input_grid[x][y]\n            if color in color_map:\n                # Calculate new position after 90 degrees clockwise rotation\n                new_x = y\n                new_y = rows - 1 - x\n                output_grid[new_x, new_y] = color_map[color]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random colors with shapes\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a few distinct shapes of different colors\n    num_shapes = np.random.randint(1, 5)\n    for _ in range(num_shapes):\n        w = np.random.randint(1, 5)\n        h = np.random.randint(1, 5)\n        sprite = random_sprite(w, h, density=0.5, color_palette=[Color.RED, Color.GREEN, Color.BLUE])\n\n        # Find a random location to place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/48/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/48/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/48/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/48/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/48/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/48/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/48/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/48/images/train_output_2.png"}]}, "index": 48, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color matching, mirroring\n\n# description:\n# In the input you will see a central pattern surrounded by a border of differently-colored pixels (top and bottom rows, leftmost and rightmost columns).\n# To create the output grid, you should:\n# 1. Extract the central pattern, removing the surrounding border.\n# 2. Mirror the central pattern horizontally and vertically.\n# 3. Change the color of the mirrored pattern to match the original border colors (top to bottom, left to right).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central pattern, removing the border\n    central_pattern = crop(grid=input_grid[1:-1, 1:-1], background=Color.BLACK)\n\n    # Get the colors of the border pixels\n    top_color = input_grid[0, 1]\n    bottom_color = input_grid[-1, 1]\n    left_color = input_grid[1, 0]\n    right_color = input_grid[1, -1]\n\n    # Mirror the central pattern horizontally and vertically\n    mirrored_pattern = np.copy(central_pattern)\n    mirrored_pattern = np.flipud(mirrored_pattern)  # Vertical flip\n    mirrored_pattern = np.fliplr(mirrored_pattern)  # Horizontal flip\n\n    # Create an output grid with the same dimensions as the input grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Update the output grid with the mirrored pattern\n    output_grid[1:-1, 1:-1] = mirrored_pattern\n\n    # Update the border colors in the output grid\n    output_grid[0, 1] = top_color  # Top border\n    output_grid[-1, 1] = bottom_color  # Bottom border\n    output_grid[1, 0] = left_color  # Left border\n    output_grid[1, -1] = right_color  # Right border\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the central pattern\n    n, m = random.randint(3, 6), random.randint(3, 6)\n\n    # Get the color of the border and central pattern\n    border_colors = random.sample(Color.NOT_BLACK, 4)  # Four distinct colors for corners\n    central_color = random.choice(Color.NOT_BLACK)\n\n    # Generate a random central pattern\n    central_pattern = random_sprite(n, m, color_palette=[central_color], density=0.5)\n\n    # Create an enlarged grid with the border colors\n    enlarged_pattern = np.zeros((n + 2, m + 2), dtype=int)\n\n    # Set border colors\n    enlarged_pattern[0, 1] = border_colors[0]  # Top\n    enlarged_pattern[-1, 1] = border_colors[1]  # Bottom\n    enlarged_pattern[1, 0] = border_colors[2]  # Left\n    enlarged_pattern[1, -1] = border_colors[3]  # Right\n\n    # Place the central pattern in the grid\n    enlarged_pattern[1:-1, 1:-1] = central_pattern\n\n    return enlarged_pattern", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/49/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/49/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/49/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/49/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/49/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/49/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/49/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/49/images/train_output_2.png"}]}, "index": 49, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color transformation\n\n# description:\n# In the input, you will see a grid with a single color pixel in a symmetrical pattern. \n# To create the output grid, duplicate this pixel in all symmetrical positions to create a full symmetrical pattern.\n# The output should maintain the center of symmetry at the original pixel\u0027s position.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the coordinates of the original color pixel.\n    original_pixel_coords = np.argwhere(input_grid != Color.BLACK)\n    if len(original_pixel_coords) == 0:\n        return input_grid  # No colored pixels to process.\n\n    # Assume there is a single colored pixel; get its coordinates\n    center_x, center_y = original_pixel_coords[0]\n    \n    # Create output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Define symmetrical transformations relative to the center pixel\n    transformations = [\n        (0, 0),  # Original pixel\n        (0, -1), # Left \n        (0, 1),  # Right\n        (-1, 0), # Above\n        (1, 0),  # Below\n        (-1, -1), # Top-left\n        (-1, 1),  # Top-right\n        (1, -1),  # Bottom-left\n        (1, 1)    # Bottom-right\n    ]\n\n    # Set the color in all symmetrical positions\n    for dx, dy in transformations:\n        sym_x = center_x + dx\n        sym_y = center_y + dy\n        if 0 \u003c= sym_x \u003c input_grid.shape[0] and 0 \u003c= sym_y \u003c input_grid.shape[1]:\n            output_grid[sym_x, sym_y] = input_grid[center_x, center_y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of given size, randomly filled with black pixels\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a position in the grid to place the original colored pixel\n    center_x = np.random.randint(0, n)\n    center_y = np.random.randint(0, m)\n\n    # Randomly choose a color for the pixel (not black)\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Place the colored pixel in the center\n    grid[center_x, center_y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/50/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/50/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/50/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/50/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/50/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/50/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/50/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/50/images/train_output_2.png"}]}, "index": 50, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# pattern extraction, color transformation\n\n# description:\n# In the input, you will see a grid with a single colored pixel in the center surrounded by a pattern of pixels. \n# The output should consist of the surrounding pattern transformed to match the color of the central pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the dimensions of the input grid\n    n, m = input_grid.shape\n    \n    # Extract the central pixel color\n    center_color = input_grid[n // 2, m // 2]\n\n    # Create an output grid with the same size filled with black\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # Define the bounding box around the center pixel\n    # The pattern should cover the entire grid except for the center pixel\n    output_grid[:n // 2, :] = input_grid[:n // 2, :]  # top half\n    output_grid[n // 2 + 1:, :] = input_grid[n // 2 + 1:, :]  # bottom half\n    output_grid[:, :m // 2] = input_grid[:, :m // 2]  # left half\n    output_grid[:, m // 2 + 1:] = input_grid[:, m // 2 + 1:]  # right half\n\n    # Change the color of the output grid to match the center color\n    output_grid[output_grid != Color.BLACK] = center_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid size\n    n, m = 7, 7  # fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a color for the center pixel\n    center_color = random.choice(list(Color.NOT_BLACK))\n    grid[n // 2, m // 2] = center_color\n\n    # Fill the surrounding pattern with random colors\n    for i in range(n):\n        for j in range(m):\n            if (i != n // 2 or j != m // 2):  # Avoid the center pixel\n                grid[i, j] = random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/51/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/51/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/51/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/51/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/51/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/51/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/51/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/51/images/train_output_2.png"}]}, "index": 51, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swapping, object manipulation\n\n# description:\n# In the input, you will see two distinct objects: a green object and a yellow object. \n# The yellow object will be surrounded by black pixels, while the green object will be surrounded by white pixels.\n# To make the output, swap the colors of the two objects such that the green object becomes yellow and the yellow object becomes green.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components for monochromatic objects\n    components = find_connected_components(input_grid, monochromatic=True)\n\n    # Initialize variables to hold the positions of the objects\n    green_object = None\n    yellow_object = None\n\n    # Identify the green and yellow objects\n    for component in components:\n        if np.any(component == Color.GREEN):\n            green_object = component\n        elif np.any(component == Color.YELLOW):\n            yellow_object = component\n\n    if green_object is not None:\n        # Swap the color of the green object to yellow\n        output_grid[green_object == Color.GREEN] = Color.YELLOW\n\n    if yellow_object is not None:\n        # Swap the color of the yellow object to green\n        output_grid[yellow_object == Color.YELLOW] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a green object\n    green_object = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[Color.GREEN])\n    \n    # Create a yellow object\n    yellow_object = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[Color.YELLOW])\n\n    # Place the green object in a random location\n    green_x, green_y = random_free_location_for_sprite(grid, green_object)\n    blit_sprite(grid, green_object, x=green_x, y=green_y)\n\n    # Place the yellow object in a different random location\n    yellow_x, yellow_y = random_free_location_for_sprite(grid, yellow_object)\n    blit_sprite(grid, yellow_object, x=yellow_x, y=yellow_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/52/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/52/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/52/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/52/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/52/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/52/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/52/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/52/images/train_output_2.png"}]}, "index": 52, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity, color merging, background filling\n\n# description:\n# In the input, you will see a grid with a black background and several colored pixels scattered throughout. \n# The objective is to create a new output grid where each black pixel is filled with the color of the nearest colored pixel. \n# The colored pixels should remain unchanged in the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the input grid\n    height, width = input_grid.shape\n    \n    # Create an output grid initialized to the input grid\n    output_grid = np.copy(input_grid)\n    \n    # For each pixel in the grid, if it is black, find the nearest colored pixel\n    for x in range(height):\n        for y in range(width):\n            if input_grid[x, y] == Color.BLACK:\n                # Initialize the minimum distance and the nearest color\n                min_distance = float(\u0027inf\u0027)\n                nearest_color = Color.BLACK\n                \n                # Check all colored pixels to find the nearest one\n                for i in range(height):\n                    for j in range(width):\n                        if input_grid[i, j] != Color.BLACK:\n                            # Calculate the Manhattan distance\n                            distance = abs(x - i) + abs(y - j)\n                            if distance \u003c min_distance:\n                                min_distance = distance\n                                nearest_color = input_grid[i, j]\n                \n                # Set the output grid pixel to the nearest color\n                output_grid[x, y] = nearest_color\n    \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black background grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels in the grid\n    num_colored_pixels = np.random.randint(5, 15)\n    for _ in range(num_colored_pixels):\n        color = random.choice(Color.NOT_BLACK)\n        \n        # Choose random coordinates for the colored pixel\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        \n        # Ensure we are not overwriting existing colored pixels\n        while grid[x, y] != Color.BLACK:\n            x = np.random.randint(0, n)\n            y = np.random.randint(0, m)\n        \n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/53/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/53/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/53/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/53/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/53/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/53/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/53/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/53/images/train_output_2.png"}]}, "index": 53, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object rotation, color mapping\n\n# description:\n# In the input, you will see a 3x3 pattern square of colors except for black.\n# To make the output, you should rotate the pattern square 90 degrees clockwise and then \n# map the colors of the rotated pattern to a new set of colors according to a given mapping.\n\ndef main(input_grid):\n    # Detect the 3x3 pattern square (assuming there is exactly one)\n    pattern_objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n    \n    # Extract the 3x3 pattern square\n    pattern = crop(pattern_objects[0], background=Color.BLACK)\n\n    # Rotate the pattern square 90 degrees clockwise\n    rotated_pattern = np.rot90(pattern, k=-1)\n\n    # Define the color mapping\n    color_mapping = {\n        Color.BLUE: Color.GREEN,\n        Color.RED: Color.YELLOW,\n        Color.GREEN: Color.RED,\n        Color.YELLOW: Color.BLUE,\n        Color.ORANGE: Color.PINK,\n        Color.PINK: Color.ORANGE,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.TEAL,\n    }\n\n    # Create output grid by mapping colors from rotated pattern\n    output_grid = np.zeros_like(input_grid)\n    \n    for i in range(rotated_pattern.shape[0]):\n        for j in range(rotated_pattern.shape[1]):\n            original_color = rotated_pattern[i, j]\n            # Map color if it\u0027s in the mapping dictionary, otherwise keep it the same\n            new_color = color_mapping.get(original_color, original_color)\n            output_grid[i, j] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random pattern square of size 3x3\n    pattern = random_sprite(n=3, m=3, density=1.0, color_palette=Color.NOT_BLACK)\n\n    # Randomly place the 3x3 pattern in the grid\n    x, y = random_free_location_for_sprite(grid, pattern)\n    grid = blit_sprite(grid, pattern, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/54/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/54/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/54/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/54/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/54/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/54/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/54/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/54/images/train_output_2.png"}]}, "index": 54, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color transformation\n\n# description:\n# In the input, you will see a grid containing a central pattern surrounded by a frame of pixels that have the same color.\n# The inner pattern consists of pixels of various colors. \n# To make the output grid, you should:\n# 1. Extract the central pattern.\n# 2. Change all the colors in the central pattern to match the color of the surrounding frame.\n# 3. Return the modified central pattern as the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Crop the central pattern out by removing the surrounding border\n    output_grid = crop(input_grid, background=Color.BLACK)\n\n    # Get the border color from the original input grid\n    border_color = input_grid[0, 0]  # Assuming uniform border color\n\n    # Change the color of the central pattern to match the border color\n    output_grid[output_grid != Color.BLACK] = border_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the central pattern\n    n, m = random.randint(3, 10), random.randint(3, 10)\n\n    # Select a color for the border\n    border_color = random.choice(Color.NOT_BLACK)\n\n    # Generate a random central pattern with various colors\n    pattern_colors = random.sample(Color.NOT_BLACK, k=random.randint(1, 5))\n    pattern = random_sprite(n, m, color_palette=pattern_colors, density=0.5)\n\n    # Create a grid with a border of the border color around the central pattern\n    enlarged_pattern = np.zeros((n + 2, m + 2), dtype=int)\n\n    # Set the border pixels to the border color\n    enlarged_pattern[0, :] = border_color\n    enlarged_pattern[-1, :] = border_color\n    enlarged_pattern[:, 0] = border_color\n    enlarged_pattern[:, -1] = border_color\n\n    # Place the central pattern in the middle of the border\n    enlarged_pattern[1:-1, 1:-1] = pattern\n\n    return enlarged_pattern", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/55/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/55/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/55/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/55/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/55/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/55/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/55/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/55/images/train_output_2.png"}]}, "index": 55, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping and pixel shifting\n\n# description:\n# The input is a grid where each column is of the same color. \n# To make the output, each color will shift downwards by one cell, and if there is a black pixel below a color pixel, \n# that color pixel will wrap around to the top of the same column.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the number of rows and columns\n    rows, cols = input_grid.shape\n\n    # Shift colors downwards\n    for col in range(cols):\n        for row in range(rows):\n            current_color = input_grid[row, col]\n            if current_color != Color.BLACK:\n                new_row = (row + 1) % rows  # wrap around to the top if we go below the last row\n                output_grid[new_row, col] = current_color\n                output_grid[row, col] = Color.BLACK  # clear the original position\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random height and fixed width with black background\n    n = np.random.randint(5, 15)  # height\n    m = np.random.randint(3, 10)   # width\n    grid = np.full((n, m), Color.BLACK)  # fill the grid with black pixels\n\n    # Randomly fill each column with a single color from the palette (avoiding black)\n    for col in range(m):\n        color = np.random.choice(list(Color.NOT_BLACK))  # choose a random color excluding black\n        grid[:, col] = color  # fill the entire column with this color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/56/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/56/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/56/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/56/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/56/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/56/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/56/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/56/images/train_output_2.png"}]}, "index": 56, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, pattern drawing, spatial arrangement\n\n# description:\n# In the input, you will see two green circles. \n# To create the output grid, you should place a 1x3 yellow bar pattern vertically exactly halfway between the two green circles.\n\ndef main(input_grid):\n    # Detect the two green circles in the grid.\n    green_circles = detect_objects(grid=input_grid, colors=[Color.GREEN], monochromatic=True, connectivity=8)\n    \n    if len(green_circles) != 2:\n        raise ValueError(\"Expected exactly two green circles in the input grid.\")\n\n    # Find the midpoint between the two circles\n    first_circle_x, first_circle_y = object_position(green_circles[0], background=Color.BLACK, anchor=\"center\")\n    second_circle_x, second_circle_y = object_position(green_circles[1], background=Color.BLACK, anchor=\"center\")\n    \n    mid_x = int((first_circle_x + second_circle_x) / 2)\n    mid_y = int((first_circle_y + second_circle_y) / 2)\n\n    # Generate the 1x3 yellow bar pattern\n    yellow_bar_sprite = np.array([[Color.YELLOW],\n                                   [Color.YELLOW],\n                                   [Color.YELLOW]])\n\n    # Create an output grid copy\n    output_grid = input_grid.copy()\n\n    # Place the yellow bar centered at the midpoint\n    upper_left_x = mid_x - 1  # Center the 1x3 bar\n    upper_left_y = mid_y - 1  # Center the 1x3 bar\n    blit_sprite(output_grid, yellow_bar_sprite, x=upper_left_x, y=upper_left_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_len = np.random.randint(10, 15)\n    n, m = grid_len, grid_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose positions for two green circles\n    positions = random.sample(range(grid_len), 2)\n    x1, y1 = positions[0], np.random.randint(0, grid_len)\n    x2, y2 = positions[1], np.random.randint(0, grid_len)\n\n    # Ensure the two circles are not placed in the same position\n    while (x1, y1) == (x2, y2):\n        x2, y2 = random.choice(range(grid_len)), random.choice(range(grid_len))\n\n    # Draw the two green circles on the grid\n    grid[x1, y1] = Color.GREEN\n    grid[x2, y2] = Color.GREEN\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/57/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/57/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/57/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/57/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/57/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/57/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/57/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/57/images/train_output_2.png"}]}, "index": 57, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines, color mapping, grid transformation\n\n# description:\n# In the input you will see a grid with several colored pixels, where each colored pixel will dictate the direction of a diagonal line drawn from that pixel.\n# The colors map to diagonal directions as follows:\n# - Red pixels draw a diagonal line to the top-right corner (northeast)\n# - Blue pixels draw a diagonal line to the top-left corner (northwest)\n# - Green pixels draw a diagonal line to the bottom-left corner (southwest)\n# - Yellow pixels draw a diagonal line to the bottom-right corner (southeast)\n# The lines should extend until they either hit the edge of the grid or overlap with another color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.RED:\n                draw_line(output_grid, x, y, direction=(1, 1), color=Color.RED)  # top-right\n            elif color == Color.BLUE:\n                draw_line(output_grid, x, y, direction=(1, -1), color=Color.BLUE)  # top-left\n            elif color == Color.GREEN:\n                draw_line(output_grid, x, y, direction=(-1, -1), color=Color.GREEN)  # bottom-left\n            elif color == Color.YELLOW:\n                draw_line(output_grid, x, y, direction=(-1, 1), color=Color.YELLOW)  # bottom-right\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels\n    num_pixels = np.random.randint(5, 15)  # total number of colored pixels\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        # Randomly assign color (excluding black)\n        color = np.random.choice([Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW])\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/58/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/58/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/58/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/58/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/58/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/58/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/58/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/58/images/train_output_2.png"}]}, "index": 58, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation\n\n# description:\n# In the input, you will see several objects of different colors on a black background.\n# To create the output grid, flip the colors of each object: \n# - Change red to green\n# - Change green to blue\n# - Change blue to red\n# - Leave all other colors unchanged\n\ndef main(input_grid):\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the connected components in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Define the color mapping\n    color_map = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.RED\n    }\n\n    # Flip the colors based on the defined mapping\n    for obj in objects:\n        for color, new_color in color_map.items():\n            if np.any(obj == color):\n                output_grid[obj == color] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid of size 12x12\n    n, m = 12, 12\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the number of objects to create\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Randomly generate dimensions for the new object\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n        # Create a random color for the object, choosing from red, green, or blue\n        color_palette = [Color.RED, Color.GREEN, Color.BLUE]\n        color = np.random.choice(color_palette)\n        \n        # Create a sprite (object) with the chosen color\n        sprite = random_sprite(w, h, color_palette=[color])\n\n        # Find a random free location to place the sprite\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/59/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/59/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/59/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/59/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/59/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/59/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/59/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/59/images/train_output_2.png"}]}, "index": 59, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, object extraction, color transformation\n\n# description:\n# In the input you will see a grid containing various colored objects on a black background. \n# Each object is made up of 2 to 4 pixels. To create the output grid, count the number of colored objects \n# and color the output grid based on the number of objects: \n# - If there are 1 object, fill the grid with yellow.\n# - If there are 2 objects, fill the grid with blue.\n# - If there are 3 objects, fill the grid with red.\n# - If there are 4 or more objects, fill the grid with green.\n\ndef main(input_grid):\n    # Detect all colored objects in the input grid (excluding black)\n    objects = detect_objects(grid=input_grid, background=Color.BLACK, monochromatic=True)\n    \n    # Count the number of distinct objects\n    num_objects = len(objects)\n    \n    # Create an output grid based on the number of objects found\n    if num_objects == 1:\n        output_color = Color.YELLOW\n    elif num_objects == 2:\n        output_color = Color.BLUE\n    elif num_objects == 3:\n        output_color = Color.RED\n    else:  # num_objects \u003e= 4\n        output_color = Color.GREEN\n    \n    # Create an output grid filled with the determined color\n    output_grid = np.full(input_grid.shape, output_color, dtype=int)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size between 10x10 to 15x15\n    n = np.random.randint(10, 16)\n    m = np.random.randint(10, 16)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of objects between 1 and 5\n    num_objects = np.random.randint(1, 6)\n    \n    for _ in range(num_objects):\n        # Generate a random sprite with size between 1x1 and 2x2\n        sprite_size = np.random.randint(1, 3)  # either 1x1 or 2x2\n        sprite = random_sprite(n=sprite_size, m=sprite_size, density=1.0, color_palette=[Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK])\n        \n        # Place the sprite randomly in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, background=Color.BLACK)\n            grid = blit_sprite(grid=grid, sprite=sprite, x=x, y=y)\n        except:\n            pass  # If no space, skip placing this object\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/60/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/60/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/60/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/60/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/60/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/60/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/60/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/60/images/train_output_2.png"}]}, "index": 60, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, cropping, color matching\n\n# description:\n# In the input you will see a grid with a specific colored square surrounded by a border of another color. \n# The task is to extract the inner colored square and change its color to match the border color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid to produce the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the input grid\n    components = find_connected_components(output_grid, monochromatic=False, connectivity=4)\n\n    # We assume there is only one border and one inner square based on the description\n    border_color = None\n    inner_square = None\n\n    for component in components:\n        # Crop the component to analyze its contents\n        cropped_component = crop(component)\n\n        # If the component has a color that is not black, we assume it\u0027s the inner square\n        if np.any(cropped_component != Color.BLACK):\n            inner_square = cropped_component\n        elif border_color is None:  # Assume the first color found is the border color\n            border_color = component[0, 0]\n\n    # Ensure we have both parts\n    if inner_square is not None and border_color is not None:\n        # Change the color of the inner square to match the border color\n        inner_square[:] = border_color\n\n    # Return the modified inner square\n    return inner_square\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size n x m\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select colors for the border and inner square\n    border_color = np.random.choice(Color.NOT_BLACK)\n    inner_color = np.random.choice([c for c in Color.NOT_BLACK if c != border_color])\n\n    # Create the border (1 pixel thick)\n    grid[0, :] = border_color\n    grid[-1, :] = border_color\n    grid[:, 0] = border_color\n    grid[:, -1] = border_color\n\n    # Create the inner square in the center\n    inner_size = np.random.randint(1, min(n, m) - 2)  # Ensure there\u0027s a border\n    start_x, start_y = (n - inner_size) // 2, (m - inner_size) // 2\n    grid[start_x:start_x + inner_size, start_y:start_y + inner_size] = inner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/61/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/61/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/61/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/61/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/61/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/61/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/61/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/61/images/train_output_2.png"}]}, "index": 61, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# growing, objects, pixel manipulation\n\n# description:\n# In the input you will see a small multicolor object, and a few big circles. Each circle has a few colored pixels sprinkled inside it. The background is NOT black.\n# To make the output: \n# 1. Remove the small object from the input\n# 2. Place copies of the small object centered on top of the colored pixels sprinkled inside the circles\n# 3. The small object has pointy things sticking out of it. Extend each pointy thing outward until it hits the edge of the circle.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color and replace it with black for processing\n    # 2. Find the small object and delete it from the input\n    # 3. Crop the small object to get its sprite\n    # 4. Identify the pointy parts of the small object\n    # 5. For each circle, locate the colored pixels and place the small object centered on those pixels\n    # 6. Extend pointy parts outward until they hit the edge of the circle\n\n    # Identify the background color\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    input_grid[input_grid == background_color] = Color.BLACK\n\n    # Find the small object and remove it\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    smallest_object = min(objects, key=lambda x: np.count_nonzero(x))\n    input_grid[smallest_object != Color.BLACK] = Color.BLACK\n\n    # Crop the sprite and identify pointy positions\n    sprite = crop(smallest_object)\n    pointy_positions = get_pointy_positions(sprite)\n\n    # Prepare the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find circles and place the sprite centered on colored pixels\n    circles = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    for circle in circles:\n        colored_pixels = np.argwhere(circle != Color.BLACK)\n        for x, y in colored_pixels:\n            # Place a copy of the sprite centered on the colored pixel\n            blit_sprite(output_grid, sprite, x - sprite.shape[0] // 2, y - sprite.shape[1] // 2, background=Color.BLACK)\n\n            # Extend pointy parts outward\n            for point_x, point_y in pointy_positions:\n                dx, dy = np.sign([point_x - sprite.shape[0] // 2, point_y - sprite.shape[1] // 2])\n                draw_line(output_grid, x + dx, y + dy, length=None, direction=(dx, dy), color=sprite[point_x, point_y], stop_at_color=[Color.BLACK])\n\n    # Restore the background color\n    output_grid[output_grid == Color.BLACK] = background_color\n\n    return output_grid\n\ndef get_pointy_positions(sprite):\n    \"\"\"Returns the positions of the pointy things sticking out of the sprite.\"\"\"\n    edge_indices = get_edge_indices(sprite)\n    next_neighbor, previous_neighbor = edge_indices[1:] + edge_indices[:1], edge_indices[-1:] + edge_indices[:-1]\n    pointy_positions = [\n        (x, y) for (x, y), (next_x, next_y), (prev_x, prev_y) in zip(edge_indices, next_neighbor, previous_neighbor)\n        if sprite[x, y] != Color.BLACK and sprite[next_x, next_y] == Color.BLACK and sprite[prev_x, prev_y] == Color.BLACK\n    ]\n    return pointy_positions\n\ndef get_edge_indices(sprite):\n    \"\"\"Returns a list of all the (i,j) locations of the edge pixels.\"\"\"\n    edge_indices = [(x, 0) for x in range(sprite.shape[0])]\n    edge_indices.extend([(sprite.shape[0]-1, y) for y in range(1, sprite.shape[1])])\n    edge_indices.extend([(x, sprite.shape[1]-1) for x in range(sprite.shape[0]-2, -1, -1)])\n    edge_indices.extend([(0, y) for y in range(sprite.shape[1]-2, 0, -1)])\n    return edge_indices\n\ndef generate_input():\n    # Generate a random input grid with a small object and circles with colored pixels\n    background_color = random.choice(Color.NOT_BLACK)\n    circle_color = random.choice([color for color in Color.NOT_BLACK if color != background_color])\n    marker_color = random.choice([color for color in Color.NOT_BLACK if color != background_color and color != circle_color])\n    \n    # Create a small object with pointy features\n    sprite = random_sprite(3, 3, symmetry=\"not_symmetric\",\n                           color_palette=[color for color in Color.NOT_BLACK if color not in [background_color, circle_color, marker_color]])\n    sprite = np.pad(sprite, 1, constant_values=Color.BLACK)  # Add a border of black\n    sprite = crop(sprite)  # Crop to ensure it\u0027s a valid sprite\n    \n    # Create the grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Create circles and sprinkle colored pixels\n    n_circles = random.choice([1, 2])\n    for _ in range(n_circles):\n        r = np.random.randint(5, 10)  # Random radius\n        x_center, y_center = np.random.randint(r, n-r), np.random.randint(r, m-r)\n        for i in range(-r, r+1):\n            for j in range(-r, r+1):\n                if i**2 + j**2 \u003c= r**2:  # Within the circle\n                    grid[x_center + i, y_center + j] = circle_color\n                    if np.random.rand() \u003c 0.3:  # 30% chance to place a marker\n                        grid[x_center + i, y_center + j] = marker_color\n        \n    # Place the small object somewhere in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n    blit_sprite(grid, sprite, x, y)\n\n    # Change the background color\n    grid[grid == Color.BLACK] = background_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/62/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/62/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/62/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/62/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/62/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/62/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/62/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/62/images/train_output_2.png"}]}, "index": 62, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion\n\n# description:\n# In the input, you will see a grid with several colored blocks against a grey background.\n# In the output, invert the colors of the blocks, changing each color to its \"inverse\" from a predefined mapping.\n\ndef main(input_grid):\n    # Define the color inversion mapping\n    color_inversion = {\n        Color.RED: Color.ORANGE,\n        Color.GREEN: Color.PINK,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE,\n        Color.ORANGE: Color.RED,\n        Color.PINK: Color.GREEN,\n        Color.PINK: Color.TEAL,\n        Color.TEAL: Color.PINK,\n        Color.ORANGE: Color.MAROON,\n        Color.MAROON: Color.ORANGE,\n    }\n    \n    # Create an output grid initialized with the background color\n    output_grid = np.full(input_grid.shape, Color.GREY)\n\n    # Perform color inversion\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            original_color = input_grid[x, y]\n            if original_color in color_inversion:\n                output_grid[x, y] = color_inversion[original_color]\n            else:\n                output_grid[x, y] = original_color  # Preserve grey background\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid of colors with grey background\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.GREY)\n\n    # Set a random density of colored blocks\n    density = np.random.rand() * 0.5  # Up to 50% of the grid can be colored\n\n    # Fill the grid with random colors\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c density:\n                # Randomly choose a color that\u0027s not grey\n                color = np.random.choice(Color.NOT_BLACK)\n                grid[i, j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/63/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/63/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/63/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/63/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/63/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/63/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/63/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/63/images/train_output_2.png"}]}, "index": 63, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, filling, color mapping\n\n# description:\n# In the input, you will see a grid with a row of colored blocks on the left and a column of colored blocks at the bottom. \n# There is also a square in the top right corner that is not touching the other colors. \n# To make the output:\n# 1. Count the number of different colors that aren\u0027t black.\n# 2. Fill the square with the color that corresponds to the number of different colors counted, cycling through a predefined color palette if necessary.\n\ndef main(input_grid):\n    # Count the number of different colors that aren\u0027t black\n    num_colors = len(set(input_grid.flatten())) - 1  # Subtract one for black\n\n    # Define a color palette to cycle through\n    color_palette = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.ORANGE, Color.GREY, Color.TEAL, Color.MAROON]\n\n    # Determine the color for the square based on the number of distinct colors\n    square_color = color_palette[(num_colors - 1) % len(color_palette)]  # Use modulo to cycle through the palette\n    \n    # Fill the square in the input grid with the determined color\n    # Find the square in the top right corner\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n    for obj in objects:\n        if obj[0, -1] == Color.BLACK:  # Assuming the square is in the top right corner\n            square = obj\n            break\n\n    # Get dimensions of the square\n    x, y, w, h = bounding_box(square)\n    \n    # Fill the square with the determined color\n    input_grid[x:x+w, y:y+h] = square_color\n\n    return input_grid\n\ndef generate_input():\n    # Create a 7x7 black grid for the background\n    n = m = 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Pick colors for the left and bottom of the grid from non-black colors\n    colors = list(Color.NOT_BLACK)\n\n    # Create a random sequence of colors for the left column\n    left_colors = np.random.choice(colors, size=n-1, replace=False)\n    grid[:-1, 0] = left_colors\n\n    # Create a random sequence of colors for the bottom row\n    bottom_colors = np.random.choice(colors, size=m-1, replace=False)\n    grid[-1, :-1] = bottom_colors\n\n    # Create a square sprite of a random color\n    square_color = np.random.choice(colors)\n    square_sprite = random_sprite(2, 2, density=1, color_palette=[square_color])\n\n    # Place the square in the top right corner of the grid\n    x, y = 0, m - 2  # Top right corner\n    blit_sprite(grid, square_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/64/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/64/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/64/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/64/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/64/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/64/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/64/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/64/images/train_output_2.png"}]}, "index": 64, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern repetition, vertical line extension\n\n# description:\n# In the input, you will see a pattern made up of vertical lines of colors. \n# The output should repeat this pattern across the entire grid, stacking the vertical lines next to each other.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the height and width of the input grid\n    height, width = input_grid.shape\n    \n    # Create the output grid which will have the same height but repeated pattern width\n    output_width = width * 3  # Repeat the pattern three times\n    output_grid = np.full((height, output_width), Color.BLACK)\n\n    # For each vertical line in the input grid, copy it to the output grid at the new location\n    for col in range(width):\n        for row in range(height):\n            color = input_grid[row, col]\n            if color != Color.BLACK:  # Only copy non-black colors\n                # Copy this color to the corresponding columns in the output grid\n                output_grid[row, col] = color\n                output_grid[row, col + width] = color\n                output_grid[row, col + 2 * width] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid with black background\n    height = np.random.randint(5, 10)\n    width = np.random.randint(3, 6)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly choose some vertical lines of colors\n    for col in range(width):\n        # Randomly decide if this column should have a vertical line\n        if np.random.rand() \u003e 0.5:  # 50% chance to have a vertical line\n            line_color = np.random.choice(list(Color.NOT_BLACK))\n            for row in range(height):\n                grid[row, col] = line_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/65/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/65/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/65/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/65/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/65/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/65/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/65/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/65/images/train_output_2.png"}]}, "index": 65, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, counting, spreading\n\n# description:\n# In the input, you will see a grid with a black background and colored pixels. To make the output, you should find the colored pixels\n# that have at least one adjacent (up, down, left, right) pixel of the same color. These pixels should then be spread to their adjacent \n# cells (up, down, left, right) if those cells are black. If adjacent cells are already colored, they will remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    rows, cols = input_grid.shape\n\n    # Iterate through every cell in the grid\n    for x in range(rows):\n        for y in range(cols):\n            # Only consider non-black pixels\n            if input_grid[x, y] != Color.BLACK:\n                # Check for adjacent pixels of the same color\n                if (\n                    (x \u003e 0 and input_grid[x - 1, y] == input_grid[x, y]) or\n                    (x \u003c rows - 1 and input_grid[x + 1, y] == input_grid[x, y]) or\n                    (y \u003e 0 and input_grid[x, y - 1] == input_grid[x, y]) or\n                    (y \u003c cols - 1 and input_grid[x, y + 1] == input_grid[x, y])\n                ):\n                    # Spread the color to adjacent cells if they are black\n                    if x \u003e 0 and output_grid[x - 1, y] == Color.BLACK:\n                        output_grid[x - 1, y] = input_grid[x, y]\n                    if x \u003c rows - 1 and output_grid[x + 1, y] == Color.BLACK:\n                        output_grid[x + 1, y] = input_grid[x, y]\n                    if y \u003e 0 and output_grid[x, y - 1] == Color.BLACK:\n                        output_grid[x, y - 1] = input_grid[x, y]\n                    if y \u003c cols - 1 and output_grid[x, y + 1] == Color.BLACK:\n                        output_grid[x, y + 1] = input_grid[x, y]\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black background grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a number of colored pixels to place on the grid\n    num_colored_pixels = np.random.randint(5, 15)\n\n    for _ in range(num_colored_pixels):\n        # Randomly choose a color from the available colors, excluding black\n        color = np.random.choice(list(Color.NOT_BLACK))\n\n        # Randomly select a position for the colored pixel that is currently black\n        empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.BLACK]\n        if empty_cells:\n            x, y = random.choice(empty_cells)\n            grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/66/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/66/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/66/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/66/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/66/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/66/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/66/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/66/images/train_output_2.png"}]}, "index": 66, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, objects, separation\n\n# description:\n# In the input, you will see several colored objects on a black background. \n# To make the output, you should blend the colors of each object with a specified color (blue) \n# and replace the original color with the blended color. \n# The blending rule is that if an object\u0027s color is red, it becomes green; \n# if it is yellow, it becomes green; and if it is blue, it remains blue. \n# All other colors should be turned to black.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Get the objects in the input grid\n    objects = find_connected_components(input_grid)\n    \n    # Define color blending rules\n    color_blend_map = {\n        Color.RED: Color.GREEN,   # Blend red with blue to get green\n        Color.YELLOW: Color.GREEN,  # Blend yellow with blue to get green\n        Color.BLUE: Color.BLUE      # Blue remains blue\n    }\n    \n    # Apply blending rules to each object\n    for obj in objects:\n        # Get the unique color of the object\n        unique_colors = np.unique(obj[obj != Color.BLACK])\n        if len(unique_colors) == 1:  # Only process if the object is monochromatic\n            original_color = unique_colors[0]\n            # Blend the color according to the rules\n            new_color = color_blend_map.get(original_color, Color.BLACK)  # Default to black for unrecognized colors\n            output_grid[obj == original_color] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Make a random number of colored objects\n    num_objects = np.random.randint(3, 7)\n    \n    for _ in range(num_objects):\n        # Randomly generate the dimensions of the object\n        width, height = np.random.randint(1, 4), np.random.randint(1, 4)\n        # Select a color for the object from the blending rules\n        color_palette = [Color.RED, Color.YELLOW, Color.BLUE]\n        sprite_color = np.random.choice(color_palette)\n        sprite = random_sprite(width, height, symmetry=\"not_symmetric\", color_palette=[sprite_color])\n        \n        # Find a random free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If it doesn\u0027t fit, try another object\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/67/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/67/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/67/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/67/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/67/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/67/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/67/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/67/images/train_output_2.png"}]}, "index": 67, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, color, symmetry\n\n# description:\n# In the input, you will see a blue pixel and a red pixel. \n# To create the output, draw a diagonal yellow line from the blue pixel to the red pixel, \n# and then draw a green line that is symmetric to the yellow line about the vertical line that passes through the midpoint of the blue and red pixels.\n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # find the blue and red pixels\n    blue_pixel = np.where(input_grid == Color.BLUE)\n    red_pixel = np.where(input_grid == Color.RED)\n\n    # extract coordinates of blue and red pixels\n    blue_x, blue_y = blue_pixel[0][0], blue_pixel[1][0]\n    red_x, red_y = red_pixel[0][0], red_pixel[1][0]\n\n    # draw yellow diagonal line from blue to red\n    draw_line(output_grid, blue_x, blue_y, end_x=red_x, end_y=red_y, color=Color.YELLOW)\n\n    # calculate the midpoint for symmetry\n    mid_x = (blue_x + red_x) // 2\n    mid_y = (blue_y + red_y) // 2\n\n    # calculate the direction for the green line (symmetric)\n    # The slope of the yellow line is (red_y - blue_y) / (red_x - blue_x)\n    # The symmetric line will have the same vertical distance but in the opposite horizontal direction\n    if blue_x != red_x:  # prevent division by zero\n        slope = (red_y - blue_y) / (red_x - blue_x)\n        # Calculate the new endpoints by mirroring across the midpoint\n        new_red_y = mid_y + (mid_y - blue_y)\n        new_blue_y = mid_y - (red_y - mid_y)\n        \n        # Draw the green symmetric line\n        draw_line(output_grid, mid_x, new_red_y, end_x=mid_x, end_y=new_blue_y, color=Color.GREEN)\n\n    return output_grid\n\ndef generate_input():\n    # create a black grid for the background\n    n = np.random.randint(6, 15)\n    m = np.random.randint(6, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # select a random position for the blue pixel\n    blue_x = np.random.randint(0, n)\n    blue_y = np.random.randint(0, m)\n    grid[blue_x, blue_y] = Color.BLUE\n\n    # select a random position for the red pixel\n    red_x = np.random.randint(0, n)\n    red_y = np.random.randint(0, m)\n    grid[red_x, red_y] = Color.RED\n\n    # ensure blue and red are not in the same row or column\n    while blue_x == red_x or blue_y == red_y:\n        red_x = np.random.randint(0, n)\n        red_y = np.random.randint(0, m)\n        grid[red_x, red_y] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/68/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/68/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/68/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/68/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/68/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/68/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/68/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/68/images/train_output_2.png"}]}, "index": 68, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, rotation, grid manipulation\n\n# description:\n# In the input you will see a grid with a repeated pattern. For each repetition of the pattern,\n# rotate it 90 degrees clockwise in the output grid. The output grid will maintain the size of the input grid.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n    \n    # Calculate the number of pattern repetitions (assuming square patterns)\n    pattern_size = 3  # Size of the repeated pattern (3x3)\n    output_grid = np.full((n, m), Color.BLACK)  # Initialize output grid with black\n\n    # Process the input grid in blocks of pattern_size x pattern_size\n    for i in range(0, n, pattern_size):\n        for j in range(0, m, pattern_size):\n            # Extract the pattern block\n            pattern_block = input_grid[i:i + pattern_size, j:j + pattern_size]\n            \n            # Rotate the pattern block 90 degrees clockwise\n            rotated_block = np.rot90(pattern_block, k=-1)  # k=-1 for clockwise rotation\n            \n            # Place the rotated block in the output grid\n            output_grid[i:i + pattern_size, j:j + pattern_size] = rotated_block\n\n    return output_grid\n\ndef generate_input():\n    # Make a random grid size\n    n = np.random.randint(6, 12)  # Total rows\n    m = np.random.randint(6, 12)  # Total columns\n    \n    # Ensure that the dimensions are multiples of the pattern size\n    n = (n // 3) * 3\n    m = (m // 3) * 3\n    \n    # Create a grid to fill with patterns\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate a repeated pattern\n    pattern = random_sprite(n=3, m=3, density=0.5, color_palette=Color.NOT_BLACK)\n    \n    # Fill the grid with the repeated pattern\n    for i in range(0, n, 3):\n        for j in range(0, m, 3):\n            blit_sprite(grid, pattern, x=i, y=j)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/69/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/69/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/69/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/69/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/69/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/69/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/69/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/69/images/train_output_2.png"}]}, "index": 69, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# vertical reflection, concatenation\n\n# description:\n# In the input you will see a square pattern of random colors. \n# To make the output, reflect the pattern horizontally, and put the reflected pattern to the right of the input pattern.\n\ndef main(input_grid):\n    # take the input pattern\n    pattern = input_grid\n\n    # reflect the pattern horizontally\n    reflected_pattern = pattern[::-1, :]\n\n    # make the output grid by concatenating the original and reflected patterns\n    output_grid = np.concatenate((pattern, reflected_pattern), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # make a random square pattern of random size and colors\n    n = m = np.random.randint(3, 6)\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/70/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/70/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/70/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/70/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/70/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/70/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/70/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/70/images/train_output_2.png"}]}, "index": 70, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, counting, color transformation\n\n# description:\n# In the input, you will see multiple colored objects on a black background. Each object consists of connected pixels of a single color.\n# To make the output, count the number of pixels in each object and color the object yellow if it has five pixels, yellow if it has six pixels, and orange if it has seven pixels.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the objects in the input grid\n    objects = find_connected_components(input_grid)\n\n    # Count the number of pixels in each object and color them accordingly\n    for obj in objects:\n        num_pixels = np.sum(obj != Color.BLACK)  # Count non-black pixels\n        if num_pixels == 5:\n            color = Color.YELLOW\n        elif num_pixels == 6:\n            color = Color.YELLOW\n        elif num_pixels == 7:\n            color = Color.ORANGE\n        else:\n            continue  # Ignore objects with a different number of pixels\n        output_grid[obj != Color.BLACK] = color  # Color the object\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of colored objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Create a random object size between 5 and 7 pixels\n        size = np.random.randint(5, 8)\n        shape = random_sprite(np.random.randint(3, 5), np.random.randint(3, 5), color_palette=[Color.RED, Color.GREEN, Color.BLUE])\n        \n        # Make sure the object has the correct number of colored pixels\n        while np.sum(shape != Color.BLACK) != size:\n            shape = random_sprite(np.random.randint(3, 5), np.random.randint(3, 5), color_palette=[Color.RED, Color.GREEN, Color.BLUE])\n        \n        # Find a random position to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, padding=1, padding_connectivity=8)\n            blit_sprite(grid, shape, x=x, y=y)\n        except:\n            pass  # If no space is available, skip this object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/71/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/71/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/71/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/71/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/71/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/71/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/71/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/71/images/train_output_2.png"}]}, "index": 71, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, color assignment\n\n# description:\n# In the input, you will see a colored pattern on the left half of the grid, with a color pixel in the top right corner. \n# To create the output, mirror the left half of the grid to the right half and color it with the color of the pixel in the top right corner.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the width and height of the input grid\n    height, width = input_grid.shape\n    \n    # Create an output grid with the same size\n    output_grid = np.copy(input_grid)\n\n    # Get the color from the top right corner pixel\n    color_to_use = input_grid[0, width - 1]\n\n    # Mirror the left half to the right half\n    for y in range(height):\n        for x in range(width // 2):\n            output_grid[y, width - 1 - x] = input_grid[y, x]\n\n    # Color the mirrored pixels with the color from the top right corner\n    for y in range(height):\n        for x in range(width // 2, width):\n            output_grid[y, x] = color_to_use\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly define the size of the grid\n    height = np.random.randint(3, 6)\n    width = np.random.randint(6, 10)\n\n    # Create a grid\n    grid = np.zeros((height, width), dtype=int)\n\n    # Randomly select a color for the left half patterns\n    left_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the left half of the grid with the selected color, leaving the right half initially blank\n    for y in range(height):\n        for x in range(width // 2):\n            grid[y, x] = np.random.choice([left_color, Color.BLACK])\n\n    # Select a color for the top right corner pixel\n    color_for_corner = np.random.choice(list(Color.NOT_BLACK))\n    grid[0, width - 1] = color_for_corner\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/72/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/72/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/72/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/72/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/72/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/72/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/72/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/72/images/train_output_2.png"}]}, "index": 72, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color tracing, symmetry\n\n# description:\n# In the input, you will see a grid containing a pattern of colored pixels with a symmetric arrangement.\n# The pattern must be traced and mirrored across both the vertical and horizontal axes. \n# To make the output, create a grid that includes the original pattern and its mirrored counterpart at the \n# corresponding positions, maintaining symmetry.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Create the output grid, initially filled with black\n    output_grid = np.full((n * 2, m * 2), Color.BLACK)\n\n    # Fill the output grid with the original pattern\n    output_grid[0:n, 0:m] = input_grid\n\n    # Mirror the pattern across the vertical axis\n    output_grid[0:n, m:m * 2] = np.flip(input_grid, axis=1)\n\n    # Mirror the pattern across the horizontal axis\n    output_grid[n:n * 2, 0:m] = np.flip(input_grid, axis=0)\n\n    # Mirror the pattern across both the vertical and horizontal axes\n    output_grid[n:n * 2, m:m * 2] = np.flip(np.flip(input_grid, axis=0), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random sized grid with a black background\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random pattern density\n    density = np.random.uniform(0.3, 0.7)\n\n    # Generate a random pattern\n    colors = np.random.choice(list(Color.NOT_BLACK), size=int(n * m * density), replace=True)\n    for color in colors:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/73/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/73/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/73/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/73/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/73/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/73/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/73/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/73/images/train_output_2.png"}]}, "index": 73, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reflection, color inversion\n\n# description:\n# In the input you will see a grid with a pattern of random colors except black. \n# To make the output, reflect the pattern horizontally, invert the colors of the reflected pattern, \n# and place it on the right side of the input pattern.\n\ndef main(input_grid):\n    # Get the pattern from the input grid\n    pattern = input_grid\n\n    # Reflect the pattern horizontally\n    reflected_pattern = pattern[:, ::-1]\n\n    # Invert the colors of the reflected pattern\n    inverted_pattern = np.where(reflected_pattern != Color.BLACK, Color.BLACK, reflected_pattern)\n\n    # Make the output grid by concatenating the original pattern and the inverted reflected pattern\n    output_grid = np.concatenate((pattern, inverted_pattern), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the grid\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n\n    # Create a random sprite with colors except black\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/74/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/74/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/74/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/74/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/74/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/74/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/74/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/74/images/train_output_2.png"}]}, "index": 74, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color averaging\n\n# description:\n# In the input, you will see a grid consisting of various 2x2 colored squares. \n# To create the output grid, replace each 2x2 colored square with a single pixel of the \n# average color of the square. The average color is computed by averaging the RGB values \n# of the colors in the square, but since we\u0027re limited to the defined colors, round \n# the average to the nearest defined color.\n\ndef color_average(colors):\n    # Function to compute the average color and round to the nearest defined color\n    color_map = {\n        Color.RED: [255, 0, 0],\n        Color.GREEN: [0, 255, 0],\n        Color.BLUE: [0, 0, 255],\n        Color.YELLOW: [255, 255, 0],\n        Color.PINK: [255, 192, 203],\n        Color.ORANGE: [255, 165, 0],\n        Color.TEAL: [0, 128, 128],\n        Color.GRAY: [128, 128, 128],\n        Color.MAROON: [128, 0, 0],\n        Color.BLACK: [0, 0, 0]\n    }\n    \n    r, g, b = 0, 0, 0\n    for color in colors:\n        r += color_map[color][0]\n        g += color_map[color][1]\n        b += color_map[color][2]\n    \n    avg_color = [r // len(colors), g // len(colors), b // len(colors)]\n    \n    # Find the closest defined color\n    closest_color = min(color_map.keys(), key=lambda c: (color_map[c][0] - avg_color[0])**2 + \n                                                              (color_map[c][1] - avg_color[1])**2 + \n                                                              (color_map[c][2] - avg_color[2])**2)\n    \n    return closest_color\n\ndef main(input_grid):\n    # Get input grid shape\n    n, m = input_grid.shape\n\n    # Prepare output grid\n    output_grid = np.zeros((n // 2, m // 2), dtype=int)\n\n    # Loop through the input grid in steps of 2\n    for x in range(0, n, 2):\n        for y in range(0, m, 2):\n            # Extract the 2x2 block\n            block = input_grid[x:x + 2, y:y + 2]\n            # Compute the average color of the block\n            avg_color = color_average(block.flatten())\n            # Place the average color in the output grid\n            output_grid[x // 2, y // 2] = avg_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random 2x2 squares of colors\n    n, m = 20, 20\n    grid = np.zeros((n, m), dtype=int)\n\n    # The number of 2x2 squares to place\n    square_count = 10\n\n    # Place 2x2 squares randomly\n    for _ in range(square_count):\n        color = np.random.choice(Color.NOT_BLACK)\n        x = np.random.randint(0, n - 1, dtype=int) // 2 * 2\n        y = np.random.randint(0, m - 1, dtype=int) // 2 * 2\n        \n        # Blit the 2x2 square\n        square = np.full((2, 2), color)\n        grid = blit_sprite(grid=grid, sprite=square, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/75/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/75/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/75/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/75/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/75/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/75/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/75/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/75/images/train_output_2.png"}]}, "index": 75, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, mirroring, color replacement\n\n# description:\n# In the input, you will see a grid filled with colored pixels, including a row of blue pixels at the top and a row of green pixels at the bottom.\n# To make the output:\n# 1. Count the number of unique colors in the grid excluding blue and green.\n# 2. Create a mirrored version of the grid vertically (flipping it upside down).\n# 3. Replace all unique colors with yellow in the mirrored grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Count unique colors excluding blue and green\n    unique_colors = set(input_grid.flatten())\n    unique_colors.discard(Color.BLUE)\n    unique_colors.discard(Color.GREEN)\n    num_unique_colors = len(unique_colors)\n\n    # Step 2: Create a mirrored version of the grid\n    mirrored_grid = np.flipud(input_grid)\n\n    # Step 3: Replace all unique colors with yellow in the mirrored grid\n    for color in unique_colors:\n        mirrored_grid[mirrored_grid == color] = Color.YELLOW\n\n    return mirrored_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 black grid first as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the top row with blue pixels\n    grid[0, :] = Color.BLUE\n\n    # Fill the bottom row with green pixels\n    grid[-1, :] = Color.GREEN\n\n    # Randomly fill the remaining cells with colors excluding blue and green\n    colors_to_use = list(Color.NOT_BLACK)\n    colors_to_use.remove(Color.BLUE)\n    colors_to_use.remove(Color.GREEN)\n\n    for i in range(1, n-1):\n        for j in range(m):\n            if np.random.rand() \u003c 0.3:  # 30% chance to fill with a color\n                grid[i, j] = np.random.choice(colors_to_use)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/76/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/76/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/76/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/76/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/76/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/76/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/76/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/76/images/train_output_2.png"}]}, "index": 76, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color blending\n\n# description:\n# In the input, you will see a grid with several colored objects. Each object is a single connected component of color. \n# To create the output grid, you should find all objects and blend their colors together to create a new color. \n# If the blended color is unique in the grid, change the object color to that blended color; otherwise, change it to black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find all connected components (objects) in the grid.\n    # 2. For each object, blend its color and determine if it\u0027s unique.\n    # 3. Update the color of the object based on the blending.\n\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Find all objects\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # 2. For each object, blend its color\n    for obj in objects:\n        # Get the unique color of the object (assuming monochromatic)\n        unique_colors = np.unique(obj)\n        unique_colors = unique_colors[unique_colors != Color.BLACK]  # Exclude background\n\n        # Blend the colors - simple average for this example\n        if len(unique_colors) \u003e 0:\n            blended_color = np.mean(unique_colors)\n            blended_color = blended_color.astype(int)\n\n            # Check if this blended color is unique in the input grid\n            if np.count_nonzero(input_grid == blended_color) == 1:\n                # If unique, assign the blended color to the object in the output grid\n                output_grid[obj != Color.BLACK] = blended_color\n            else:\n                # If not unique, turn the object black\n                output_grid[obj != Color.BLACK] = Color.BLACK\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black background grid of size n x m\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate various colored objects\n    colors = list(Color.NOT_BLACK)  # All possible colors except black\n    num_objects = np.random.randint(3, 6)  # Number of objects to create\n\n    for _ in range(num_objects):\n        # Generate a random object and place it on the grid\n        sprite_width, sprite_height = np.random.randint(1, 4), np.random.randint(1, 4)\n        sprite_color = np.random.choice(colors)\n\n        # Create the random sprite\n        sprite = random_sprite(n=sprite_height, m=sprite_width, color_palette=[sprite_color], density=1.0)\n\n        # Find a random free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If no space is available, skip this object creation\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/77/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/77/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/77/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/77/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/77/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/77/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/77/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/77/images/train_output_2.png"}]}, "index": 77, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color mapping, object size\n\n# description:\n# In the input grid, there are shapes of different colors. Each shape can be a square, circle, or triangle and is made of a color. \n# The output will map each shape to a color according to its size: \n# - small shapes (1-2 pixels) -\u003e yellow, \n# - medium shapes (3-4 pixels) -\u003e orange, \n# - large shapes (5 or more pixels) -\u003e orange. \n# The shapes will retain their original colors in the output but will change according to the size mapping.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.copy(input_grid)\n\n    # Detect objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Color mapping based on size\n    size_color_map = {\n        \u0027small\u0027: Color.YELLOW,\n        \u0027medium\u0027: Color.ORANGE,\n        \u0027large\u0027: Color.ORANGE\n    }\n    \n    # Process each object\n    for obj in objects:\n        num_pixels = np.sum(obj != Color.BLACK)\n        if num_pixels \u003c= 2:\n            new_color = size_color_map[\u0027small\u0027]\n        elif num_pixels \u003c= 4:\n            new_color = size_color_map[\u0027medium\u0027]\n        else:\n            new_color = size_color_map[\u0027large\u0027]\n\n        # Update the output grid with the new color\n        output_grid[obj != Color.BLACK] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    grid = np.full((10, 10), Color.BLACK)\n    \n    # Randomly generate a number of shapes (between 3 to 5)\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        # Generate a random shape\n        shape_type = np.random.choice([\u0027square\u0027, \u0027circle\u0027, \u0027triangle\u0027])\n        if shape_type == \u0027square\u0027:\n            size = np.random.randint(1, 5)\n            sprite = random_sprite(size, size, color_palette=[Color.RED])\n        elif shape_type == \u0027circle\u0027:\n            size = np.random.randint(1, 5)\n            sprite = random_sprite(size, size, symmetry=\u0027radial\u0027, color_palette=[Color.BLUE])\n        elif shape_type == \u0027triangle\u0027:\n            size = np.random.randint(1, 5)\n            sprite = random_sprite(size, size, symmetry=\u0027not_symmetric\u0027, color_palette=[Color.GREEN])\n        \n        # Place the sprite randomly in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except:\n            continue  # If it fails to place the sprite, skip to the next shape\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/78/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/78/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/78/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/78/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/78/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/78/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/78/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/78/images/train_output_2.png"}]}, "index": 78, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color mapping\n\n# description:\n# In the input, you will see a grid with a single blue pixel and a colored square of a different color (either red, green, yellow, or orange).\n# To make the output, rotate the colored square around the blue pixel 90 degrees clockwise. The color of the square should correspond to the following mappings:\n# red -\u003e green, green -\u003e yellow, yellow -\u003e orange, orange -\u003e red.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = np.copy(input_grid)\n\n    # Locate the blue pixel\n    blue_pixel = np.argwhere(input_grid == Color.BLUE)\n    if len(blue_pixel) == 0:\n        return output_grid  # No blue pixel found, return the original grid\n\n    blue_x, blue_y = blue_pixel[0]\n\n    # Find the colored square surrounding the blue pixel\n    square_color = None\n    square_positions = []\n\n    # Check the surrounding pixels for the colored square (assuming a 3x3 square)\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if input_grid[blue_x + dx, blue_y + dy] != Color.BLUE:\n                square_color = input_grid[blue_x + dx, blue_y + dy]\n                square_positions.append((blue_x + dx, blue_y + dy))\n\n    if square_color is None:\n        return output_grid  # No colored square found, return the original grid\n\n    # Define the color mapping\n    color_mapping = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.YELLOW,\n        Color.YELLOW: Color.ORANGE,\n        Color.ORANGE: Color.RED\n    }\n\n    # Rotate positions 90 degrees clockwise around the blue pixel\n    for (x, y) in square_positions:\n        # Calculate new positions for rotation\n        new_x = blue_x - (y - blue_y)\n        new_y = blue_y + (x - blue_x)\n\n        # Check if the new position is within bounds\n        if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n            output_grid[new_x, new_y] = color_mapping.get(square_color, square_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid for the background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a blue pixel at a random position\n    blue_x = np.random.randint(1, n-1)\n    blue_y = np.random.randint(1, m-1)\n    grid[blue_x, blue_y] = Color.BLUE\n\n    # Choose a random color for the square and place it around the blue pixel\n    square_color = np.random.choice([Color.RED, Color.GREEN, Color.YELLOW, Color.ORANGE])\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx, dy) != (0, 0):  # Don\u0027t place on the blue pixel\n                grid[blue_x + dx, blue_y + dy] = square_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/79/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/79/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/79/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/79/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/79/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/79/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/79/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/79/images/train_output_2.png"}]}, "index": 79, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, pattern duplication\n\n# description:\n# In the input you will see a grid with a colored object that forms a pattern (e.g., a shape made of colored pixels).\n# To make the output grid, you should rotate the entire grid by 180 degrees, effectively flipping it upside down and reversing its left and right sides.\n\ndef main(input_grid):\n    # Rotate the grid by 180 degrees\n    output_grid = np.flipud(np.fliplr(input_grid))\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n = np.random.randint(4, 8)\n    m = np.random.randint(4, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random pattern in the grid\n    density = 0.3  # Percentage of the grid that will be filled with colors\n    sprite = random_sprite(n=n, m=m, density=density, color_palette=Color.NOT_BLACK)\n    \n    # Blit the randomly generated sprite onto the grid at a random position\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/80/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/80/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/80/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/80/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/80/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/80/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/80/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/80/images/train_output_2.png"}]}, "index": 80, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color blending, overlapping areas\n\n# description:\n# In the input, you will see a grid with several overlapping colored circles. \n# To make the output, change the color of each pixel that is inside multiple circles to be a blend of the colors of all circles that overlap at that pixel.\n# The blending is done by averaging the colors based on the number of overlaps.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Iterate over each pixel in the grid\n    for x in range(height):\n        for y in range(width):\n            if input_grid[x, y] != Color.BLACK:\n                # Count overlapping colors\n                count = 0\n                color_sum = np.zeros(3)  # Assuming RGB format for blending\n\n                # Check all pixels around (x, y) to see if they belong to a circle\n                for dx in range(-1, 2):\n                    for dy in range(-1, 2):\n                        if 0 \u003c= x + dx \u003c height and 0 \u003c= y + dy \u003c width:\n                            color = input_grid[x + dx, y + dy]\n                            if color != Color.BLACK:\n                                count += 1\n                                # Convert color to RGB-like values (example mapping)\n                                if color == Color.RED:\n                                    color_sum += np.array([255, 0, 0])\n                                elif color == Color.GREEN:\n                                    color_sum += np.array([0, 255, 0])\n                                elif color == Color.BLUE:\n                                    color_sum += np.array([0, 0, 255])\n                                # Add other colors as needed...\n\n                # If there are overlaps, average the colors\n                if count \u003e 0:\n                    avg_color = (color_sum / count).astype(int)\n                    # Here we need to convert back to a color representation; this is a simplified case\n                    # Convert average RGB value back to Color (for simplicity, we can just round to known colors)\n                    output_grid[x, y] = get_closest_color(avg_color)\n\n    return output_grid\n\ndef get_closest_color(avg_color):\n    # This function would convert the average RGB value back to the nearest color\n    # Here, we would need a predefined mapping for simplicity\n    # For demonstration purposes, let\u0027s just return a known color\n    if np.array_equal(avg_color, [255, 0, 0]):\n        return Color.RED\n    elif np.array_equal(avg_color, [0, 255, 0]):\n        return Color.GREEN\n    elif np.array_equal(avg_color, [0, 0, 255]):\n        return Color.BLUE\n    else:\n        return Color.BLACK  # Default case\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = 10, 10  # Grid size\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly draw circles of different colors\n    num_circles = random.randint(1, 5)\n    colors = random.sample(list(Color.NOT_BLACK), num_circles)\n\n    for color in colors:\n        # Random position and size for the circle\n        center_x = random.randint(1, n - 2)\n        center_y = random.randint(1, m - 2)\n        radius = random.randint(1, 3)\n\n        for x in range(max(0, center_x - radius), min(n, center_x + radius + 1)):\n            for y in range(max(0, center_y - radius), min(m, center_y + radius + 1)):\n                if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/81/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/81/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/81/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/81/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/81/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/81/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/81/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/81/images/train_output_2.png"}]}, "index": 81, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, grid manipulation\n\n# description:\n# In the input you will see a grid containing a 4x4 blue square on a colored background.\n# To make the output, you should invert the colors of the pixels within the 4x4 blue square (i.e., change blue to black, red to yellow, green to grey, blue to yellow, and vice versa).\n# The background color should remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the top-left corner of the 4x4 blue square\n    blue_square_loc = np.argwhere(input_grid == Color.BLUE)\n\n    if len(blue_square_loc) == 0:\n        raise ValueError(\"No blue square found in the input grid.\")\n\n    # We assume the first blue pixel found is the top-left corner of the blue square\n    top_left_x, top_left_y = blue_square_loc[0]\n\n    # Check if we have a valid 4x4 square\n    if (top_left_x + 3 \u003e= input_grid.shape[0] or top_left_y + 3 \u003e= input_grid.shape[1]):\n        raise ValueError(\"Blue square is not fully contained in the grid.\")\n\n    # Create the output grid as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Invert the colors within the 4x4 square\n    for i in range(4):\n        for j in range(4):\n            pixel_color = input_grid[top_left_x + i, top_left_y + j]\n            # Invert the color\n            if pixel_color == Color.BLUE:\n                output_grid[top_left_x + i, top_left_y + j] = Color.BLACK\n            elif pixel_color == Color.BLACK:\n                output_grid[top_left_x + i, top_left_y + j] = Color.BLUE\n            elif pixel_color == Color.RED:\n                output_grid[top_left_x + i, top_left_y + j] = Color.YELLOW\n            elif pixel_color == Color.YELLOW:\n                output_grid[top_left_x + i, top_left_y + j] = Color.RED\n            elif pixel_color == Color.GREEN:\n                output_grid[top_left_x + i, top_left_y + j] = Color.GREY\n            elif pixel_color == Color.GREY:\n                output_grid[top_left_x + i, top_left_y + j] = Color.GREEN\n            elif pixel_color == Color.BLUE:\n                output_grid[top_left_x + i, top_left_y + j] = Color.YELLOW\n            elif pixel_color == Color.YELLOW:\n                output_grid[top_left_x + i, top_left_y + j] = Color.BLUE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid size\n    n, m = np.random.randint(8, 20), np.random.randint(8, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors except for blue\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.2:\n                grid[i, j] = Color.BLUE  # Add blue pixels randomly\n\n            else:\n                grid[i, j] = np.random.choice([color for color in Color.NOT_BLACK if color != Color.BLUE])\n\n    # Ensure there is a valid 4x4 blue square somewhere in the grid\n    top_left_x = np.random.randint(0, n - 4)\n    top_left_y = np.random.randint(0, m - 4)\n\n    # Place a 4x4 blue square\n    for i in range(4):\n        for j in range(4):\n            grid[top_left_x + i, top_left_y + j] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/82/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/82/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/82/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/82/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/82/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/82/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/82/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/82/images/train_output_2.png"}]}, "index": 82, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color matching\n\n# description:\n# In the input, you will see a 10x10 grid filled with colored pixels. Within this grid, there are 4 distinct colored objects (each 2x2 pixels) arranged in various positions. The goal is to rotate each object 90 degrees clockwise and then place them back into the grid such that their colors match the original positions of the pixels they occupied in the input grid.\n\ndef main(input_grid):\n    # Step 1: Detect and extract the 2x2 colored objects from the input grid\n    objects = detect_objects(input_grid, background=Color.BLACK, allowed_dimensions=[(2, 2)], monochromatic=False)\n\n    # Step 2: Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK, dtype=int)\n\n    # Step 3: For each object, rotate it 90 degrees clockwise and place it back in the output grid\n    for obj in objects:\n        # Rotate the object 90 degrees clockwise\n        rotated_obj = np.rot90(obj, k=-1)  # k=-1 for clockwise rotation\n\n        # Find the position of the original object in the input grid\n        original_x, original_y = np.argwhere(input_grid == obj[0, 0])[0]  # Assuming the top-left pixel is representative\n\n        # Calculate the new position based on the original position\n        output_x = original_x\n        output_y = original_y\n\n        # Place the rotated object into the output grid\n        blit_sprite(output_grid, rotated_obj, x=output_x, y=output_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create an empty 10x10 grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Randomly place 4 distinct 2x2 objects in the grid\n    colors = np.random.choice([Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW], size=4, replace=False)\n    \n    for color in colors:\n        # Create a 2x2 object of the current color\n        obj = np.full((2, 2), color)\n\n        # Find a random free location for the object\n        x, y = random_free_location_for_sprite(grid, obj, padding=0, background=Color.BLACK)\n\n        # Place the object into the grid\n        blit_sprite(grid, obj, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/83/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/83/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/83/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/83/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/83/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/83/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/83/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/83/images/train_output_2.png"}]}, "index": 83, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reflection, symmetry detection\n\n# description:\n# In the input you will see a grid with a symmetrical pattern on the left half.\n# To make the output, reflect the left half of the pattern across the vertical axis to the right half of the output grid.\n\ndef main(input_grid):\n    # Determine the width of the input grid\n    width = input_grid.shape[1]\n    \n    # Get the left half of the pattern\n    left_half = input_grid[:, :width // 2]\n    \n    # Reflect the left half to the right\n    reflected_half = left_half[:, ::-1]\n    \n    # Create the output grid by concatenating the left half and the reflected right half\n    output_grid = np.concatenate((left_half, reflected_half), axis=1)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random height for the grid\n    height = np.random.randint(3, 6)\n    # Create a random width for the grid (must be even for symmetry)\n    width = np.random.randint(4, 8) * 2  # Ensuring width is even\n\n    # Generate a random sprite for the left half with non-black colors\n    left_half = random_sprite(height, width // 2, density=1, color_palette=Color.NOT_BLACK)\n    \n    # Create the input grid by concatenating the left half with a black background\n    input_grid = np.zeros((height, width), dtype=int)\n    input_grid[:, :width // 2] = left_half\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/84/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/84/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/84/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/84/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/84/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/84/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/84/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/84/images/train_output_2.png"}]}, "index": 84, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# surrounding, pixel replacement\n\n# description:\n# Given an input grid of colored pixels, surround every green pixel with yellow pixels.\n# The output grid should retain the original green pixels while replacing the surrounding pixels \n# (up to one pixel in each direction) with yellow.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x][y] == Color.GREEN:\n                # Surround the green pixel with yellow pixels\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if (dx != 0 or dy != 0) and 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                            output_grid[x + dx, y + dy] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide how many green pixels will be placed\n    num_green = np.random.randint(1, 6)\n    \n    for _ in range(num_green):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.GREEN\n\n    # Optionally, fill the grid with some other colors\n    available_colors = list(Color.NOT_BLACK)\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.GREEN:\n                continue  # Skip green pixels\n            # Randomly assign other colors to the grid, ensuring not to overwrite green\n            grid[i, j] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/85/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/85/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/85/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/85/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/85/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/85/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/85/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/85/images/train_output_2.png"}]}, "index": 85, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern transformation, pixel shifting\n\n# description:\n# In the input you will see a central square pattern of pixels in the grid surrounded by a black background.\n# To make the output, you should:\n# 1. Shift the entire pattern one pixel to the right and one pixel down.\n# 2. Fill the new positions with black pixels, effectively moving the pattern diagonally down-right within the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to start with\n    output_grid = np.copy(input_grid)\n\n    # Find the bounding box of the central pattern within the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n\n    # Since we expect a single pattern, we can safely access the first object\n    if len(objects) != 1:\n        raise ValueError(\"Expected exactly one connected component in the input grid.\")\n\n    central_pattern = objects[0]\n    \n    # Get the bounding box of the central pattern\n    x, y, width, height = bounding_box(central_pattern, background=Color.BLACK)\n    \n    # Shift the pattern to the right and down\n    for dx in range(width):\n        for dy in range(height):\n            # Calculate new position\n            new_x, new_y = x + dx + 1, y + dy + 1\n            \n            # Make sure we don\u0027t go out of bounds\n            if new_x \u003c output_grid.shape[0] and new_y \u003c output_grid.shape[1]:\n                # Set the new position to the color of the original pixel\n                output_grid[new_x, new_y] = input_grid[x + dx, y + dy]\n\n            # Clear the original position\n            output_grid[x + dx, y + dy] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random size for the grid, ensuring there\u0027s space for the pattern and the shift\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n\n    # Generate a random square pattern size\n    pattern_size = np.random.randint(2, min(n, m) - 1)\n    \n    # Select a random color for the pattern\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Place the pattern in the center of the grid\n    start_x = (n - pattern_size) // 2\n    start_y = (m - pattern_size) // 2\n    \n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[start_x + i, start_y + j] = pattern_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/86/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/86/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/86/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/86/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/86/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/86/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/86/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/86/images/train_output_2.png"}]}, "index": 86, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, object flipping\n\n# description:\n# In the input you will see a 3x3 pattern square. Flip the square horizontally to form the output.\n\ndef main(input_grid):\n    # Detect the 3x3 pattern square\n    pattern_square = input_grid\n    \n    # Flip the pattern square horizontally\n    flipped_pattern = np.flip(pattern_square, axis=1)\n\n    return flipped_pattern\n\ndef generate_input():\n    # Initialize the grid\n    n, m = 5, 5  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)    \n\n    # Generate a random 3x3 pattern square\n    pattern_size = 3\n    random_color = np.random.choice(Color.NOT_BLACK)\n    pattern_square = random_sprite(n=pattern_size, m=pattern_size, color_palette=[random_color], density=0.5)\n\n    # Place the pattern square in the center of the grid\n    x_pos, y_pos = (n - pattern_size) // 2, (m - pattern_size) // 2\n    grid = blit_sprite(x=x_pos, y=y_pos, grid=grid, sprite=pattern_square, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/87/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/87/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/87/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/87/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/87/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/87/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/87/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/87/images/train_output_2.png"}]}, "index": 87, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color manipulation, pixel shifting, connected components\n\n# description:\n# In the input, you will see several interconnected objects formed by horizontal and vertical edges, colored in different colors. \n# Each object is separated by black pixels, which serve as the background. \n# To produce the output grid, for each colored pixel in an object, shift it left unless there are no other colored pixels to the left and below it.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the connected components (objects) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    output_grid = np.zeros_like(input_grid)\n\n    for obj in objects:\n        transformed_object = np.zeros_like(obj)\n\n        for x in range(obj.shape[0]):\n            for y in range(obj.shape[1]):\n                if obj[x, y] != Color.BLACK:\n                    # Check if there are other colored pixels to the left and down\n                    left_and_below = obj[x, :y].copy().reshape(-1, 1)  # All pixels to the left\n                    down_and_below = obj[x+1:, y] if x + 1 \u003c obj.shape[0] else np.array([])  # All pixels below\n\n                    if np.any(left_and_below != Color.BLACK) or np.any(down_and_below != Color.BLACK):\n                        # Shift left\n                        if y \u003e 0:\n                            transformed_object[x, y - 1] = obj[x, y]  # Shift left\n                    else:\n                        transformed_object[x, y] = obj[x, y]  # Keep the pixel in place\n\n        blit_object(output_grid, transformed_object, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    n, m = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    n_objects = np.random.randint(1, 4)\n\n    for _ in range(n_objects):\n        color = random.choice(Color.NOT_BLACK)\n        \n        # Randomly generate the object shape\n        # Create a simple rectangular shape\n        width = np.random.randint(2, n // 4)\n        height = np.random.randint(2, m // 4)\n        obj = np.zeros((height, width), dtype=int)\n\n        # Fill the object with the random color\n        obj[:, :] = color\n\n        # Place the object randomly on the grid, ensuring it fits\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK, padding=1)\n        except:\n            continue\n\n        blit_sprite(grid, obj, x=x, y=y, background=Color.BLACK)\n\n    # Ensure something was generated\n    if np.all(grid == Color.BLACK):\n        return generate_input()\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/88/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/88/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/88/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/88/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/88/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/88/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/88/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/88/images/train_output_2.png"}]}, "index": 88, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color transformation\n\n# description:\n# In the input, you will see a grid with colored shapes on a black background. Each shape has a unique color. \n# To create the output grid, you should extract each unique colored shape and convert it into a corresponding color from a defined palette. \n# If the shape\u0027s color is not in the palette, it should be turned into a specific color (e.g., yellow). \n# The output grid should retain the original positions of the shapes.\n\ndef main(input_grid):\n    # Step 1: Find all connected components (shapes) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    \n    # Step 2: Prepare the output grid which is initially a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Define a color transformation palette\n    color_palette = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.ORANGE,\n        Color.TEAL: Color.PINK,\n        Color.YELLOW: Color.MAROON,\n        Color.GREY: Color.YELLOW,  # Default color for any color not in the palette\n    }\n    \n    # Step 3: Transform the colors of each shape in the output grid\n    for obj in objects:\n        # Get the color of the current object (assumed to be monochromatic)\n        color = obj[0, 0]\n        # Determine the new color based on the palette or default to yellow\n        new_color = color_palette.get(color, Color.YELLOW)\n        # Fill the output grid with the new color where the object is located\n        output_grid[output_grid == color] = new_color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a large enough grid, ensuring diversity of color and shape\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Randomly determine the number of objects and their colors\n    n_objects = np.random.randint(3, 6)\n    unique_colors = list(Color.NOT_BLACK)\n    np.random.shuffle(unique_colors)\n\n    for i in range(n_objects):\n        color = unique_colors[i % len(unique_colors)]  # Ensure unique colors for the objects\n        # Generate a random sprite (shape) for the object\n        sprite_width = np.random.randint(2, 5)\n        sprite_height = np.random.randint(2, 5)\n        sprite = random_sprite(sprite_height, sprite_width, color_palette=[color])\n        \n        # Find a random location for the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/89/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/89/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/89/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/89/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/89/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/89/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/89/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/89/images/train_output_2.png"}]}, "index": 89, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object growing, color filling\n\n# description:\n# In the input, you will see a grid with a single colored pixel. To make the output grid, you should grow the colored pixel into a square that fills the entire grid. The color of the square should match the color of the pixel in the input.\n\ndef main(input_grid):\n    # Identify the color of the single pixel in the input grid\n    unique_colors = np.unique(input_grid)\n    color = unique_colors[unique_colors != Color.BLACK][0]  # Exclude background (black)\n\n    # Create an output grid filled with the identified color\n    output_grid = np.full(input_grid.shape, color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m with black background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a color from the available colors\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Place a single colored pixel in a random position in the grid\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/90/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/90/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/90/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/90/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/90/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/90/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/90/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/90/images/train_output_2.png"}]}, "index": 90, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern repetition, color transformation\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels scattered throughout. \n# To make the output, repeat the pattern to fill the entire grid and change the color of the entire pattern to green.\n\ndef main(input_grid):\n    # Step 1: Identify the unique colors in the input grid\n    unique_colors = set(np.unique(input_grid))\n\n    # Step 2: Create a mask for the original pattern (i.e., not the background)\n    pattern_mask = (input_grid != Color.BLACK)\n\n    # Step 3: Create the output grid filled with black (background)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 4: Fill the output grid with the green color where the pattern exists\n    output_grid[pattern_mask] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Define dimensions for the grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Step 2: Randomly scatter a pattern of colored pixels in the grid\n    density = 0.3  # adjust the density of colored pixels\n    colors = list(Color.NOT_BLACK)  # available colors excluding black\n    \n    # Fill the grid based on density\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c density:\n                grid[i, j] = np.random.choice(colors)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/91/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/91/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/91/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/91/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/91/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/91/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/91/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/91/images/train_output_2.png"}]}, "index": 91, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color transformation, grid manipulation\n\n# description:\n# In the input, you will see a grid with a pattern consisting of one color in the center and a mirror image of that color \n# in a diagonal pattern towards the corners. The output should reflect this symmetry by transforming the input grid such that \n# all pixels in the grid are turned into the color found at the center, with the exception of the corners which should be \n# filled with the colors of the pixels at the corners of the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the center color\n    center_color = input_grid[input_grid.shape[0] // 2, input_grid.shape[1] // 2]\n\n    # Create the output grid filled with the center color\n    output_grid = np.full(input_grid.shape, center_color)\n\n    # Get the corner colors\n    top_left_color = input_grid[0, 0]\n    top_right_color = input_grid[0, -1]\n    bottom_left_color = input_grid[-1, 0]\n    bottom_right_color = input_grid[-1, -1]\n\n    # Set the corners in the output grid\n    output_grid[0, 0] = top_left_color\n    output_grid[0, -1] = top_right_color\n    output_grid[-1, 0] = bottom_left_color\n    output_grid[-1, -1] = bottom_right_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of size n x m where n and m are odd to ensure a center pixel\n    n, m = np.random.randint(5, 11, size=2)  # size from 5x5 to 10x10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a color for the center\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n    grid[n // 2, m // 2] = center_color\n\n    # Fill the grid diagonally with the center color\n    for i in range(min(n, m)):\n        grid[i, i] = center_color\n        grid[i, m - 1 - i] = center_color\n\n    # Set the corner colors\n    grid[0, 0] = np.random.choice(list(Color.NOT_BLACK))\n    grid[0, -1] = np.random.choice(list(Color.NOT_BLACK))\n    grid[-1, 0] = np.random.choice(list(Color.NOT_BLACK))\n    grid[-1, -1] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/92/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/92/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/92/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/92/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/92/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/92/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/92/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/92/images/train_output_2.png"}]}, "index": 92, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation\n\n# description:\n# In the input, you will see a grid with a central 3x3 pattern of pixels with four differently-colored pixels at its corners. \n# To create the output, you should:\n# 1. Rotate the central 3x3 pattern by 90 degrees clockwise.\n# 2. Change the color of the central pattern to match the color of the pixel in the top right corner.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create output grid initialized with black background\n    output_grid = np.zeros(input_grid.shape, dtype=int)\n\n    # Extract the central 3x3 pattern\n    central_pattern = input_grid[1:4, 1:4]\n\n    # Rotate the central pattern by 90 degrees clockwise\n    rotated_pattern = np.rot90(central_pattern, -1)\n\n    # Get the color from the top right corner to apply to the rotated pattern\n    color_to_match = input_grid[0, 3]\n\n    # Set the color of the rotated pattern\n    rotated_pattern[rotated_pattern != Color.BLACK] = color_to_match\n\n    # Place the modified rotated pattern in the output grid\n    output_grid[1:4, 1:4] = rotated_pattern\n\n    # Add the corner colors back to the output grid\n    output_grid[0, 0] = input_grid[0, 0]  # top left corner\n    output_grid[0, 3] = input_grid[0, 3]  # top right corner\n    output_grid[3, 0] = input_grid[3, 0]  # bottom left corner\n    output_grid[3, 3] = input_grid[3, 3]  # bottom right corner\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 5x5 grid to ensure there\u0027s space for the corners and central pattern\n    grid = np.zeros((5, 5), dtype=int)\n\n    # Randomly select colors for the corners\n    corner_colors = random.sample(Color.NOT_BLACK, 4)\n\n    # Assign the corner colors\n    grid[0, 0] = corner_colors[0]  # top left\n    grid[0, 3] = corner_colors[1]  # top right\n    grid[3, 0] = corner_colors[2]  # bottom left\n    grid[3, 3] = corner_colors[3]  # bottom right\n\n    # Create a random central 3x3 pattern\n    pattern_colors = random.sample(Color.NOT_BLACK, 1)  # Using the same color for the pattern\n    central_pattern = random_sprite(3, 3, density=0.5, color_palette=pattern_colors)\n\n    # Place the central pattern in the grid\n    grid[1:4, 1:4] = central_pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/93/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/93/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/93/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/93/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/93/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/93/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/93/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/93/images/train_output_2.png"}]}, "index": 93, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, merging\n\n# description:\n# In the input, you will see a grid with multiple colored objects. \n# To create the output grid, any two adjacent objects (horizontally or vertically) that are the same color should be merged into a single object. \n# The merged object should take on a new color, which is a mix of the two original colors. \n# If the two original colors are the same, the color remains unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Detect connected components (objects) in the grid\n    objects = find_connected_components(input_grid)\n\n    # Create a mapping for merging colors\n    for obj in objects:\n        # Get the bounding box of the current object\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n        \n        # If the object\u0027s size is larger than 1, check for adjacency with other objects\n        if width \u003e 1 or height \u003e 1:\n            # Check adjacent positions for merging\n            for dx in [-1, 1]:\n                for dy in [-1, 1]:\n                    adjacent_coord = (x + dx, y + dy)\n                    if 0 \u003c= adjacent_coord[0] \u003c output_grid.shape[0] and 0 \u003c= adjacent_coord[1] \u003c output_grid.shape[1]:\n                        adjacent_color = output_grid[adjacent_coord]\n                        if adjacent_color != Color.BLACK and adjacent_color == output_grid[x, y]:\n                            # If colors are the same, use that color\n                            output_grid[x, y] = adjacent_color\n                        elif adjacent_color != Color.BLACK:\n                            # Mix the colors if they are different\n                            mixed_color = mix_colors(output_grid[x, y], adjacent_color)\n                            output_grid[x, y] = mixed_color\n\n    return output_grid\n\ndef mix_colors(color1, color2):\n    # A simple function to mix two colors. This can be adjusted for better color mixing.\n    # For simplicity, we will return a \u0027blended\u0027 color based on some arbitrary mixing rules.\n    if color1 == color2:\n        return color1\n    else:\n        return Color.PINK  # Just an arbitrary blended color for this example\n\ndef generate_input():\n    # Initialize a black background grid of size n x m.\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define colors to be used (excluding black)\n    colors = [Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.ORANGE]\n\n    # Randomly generate colored objects on the grid\n    for _ in range(np.random.randint(5, 15)):\n        sprite_width, sprite_height = np.random.randint(1, 3), np.random.randint(1, 3)\n        color = np.random.choice(colors)\n        sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[color])\n        \n        # Attempt to place the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If the location is not free, skip placing this sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/94/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/94/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/94/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/94/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/94/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/94/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/94/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/94/images/train_output_2.png"}]}, "index": 94, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, filling\n\n# description:\n# In the input you will see a grid with circular red objects on a black background. \n# To create the output grid, detect the circular red objects and fill them with yellow.\n\ndef main(input_grid):\n    # Create an output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Detect the red circular objects in the input grid\n    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n\n    # Fill the detected red objects with yellow\n    for obj in red_objects:\n        output_grid[obj == Color.RED] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of red circular objects\n    num_objects = np.random.randint(1, 4)  # Randomly choose between 1 to 3 objects\n    for _ in range(num_objects):\n        # Generate a random radius for the circular object\n        radius = np.random.randint(1, 4)  # Radius between 1 and 3\n        # Create a circular object in a 2D array\n        y, x = np.ogrid[-radius:radius+1, -radius:radius+1]\n        mask = x**2 + y**2 \u003c= radius**2  # Create a circular mask\n        red_object = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n        red_object[mask] = Color.RED  # Fill the circle with red\n\n        # Try to place the circular object in a free location\n        try:\n            x_pos, y_pos = random_free_location_for_sprite(grid, red_object, background=Color.BLACK)\n            blit_sprite(grid, red_object, x=x_pos, y=y_pos, background=Color.BLACK)\n        except:\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/95/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/95/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/95/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/95/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/95/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/95/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/95/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/95/images/train_output_2.png"}]}, "index": 95, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, color matching, proximity\n\n# description:\n# In the input, you will see a grid with various colored pixels and several 2x2 empty squares marked with black pixels.\n# To create the output grid, fill each 2x2 square with the color of the pixel nearest to its center.\n# If multiple nearest pixels exist, use the color of the first one found.\n\ndef main(input_grid):\n    # Get the shape of the input grid\n    rows, cols = input_grid.shape\n    \n    # Prepare an output grid initialized with the background\n    output_grid = np.zeros_like(input_grid)\n    \n    # Loop through the grid to find 2x2 squares\n    for x in range(rows - 1):\n        for y in range(cols - 1):\n            # Check if the current position is the top-left corner of a 2x2 black square\n            if (input_grid[x, y] == Color.BLACK and\n                input_grid[x+1, y] == Color.BLACK and\n                input_grid[x, y+1] == Color.BLACK and\n                input_grid[x+1, y+1] == Color.BLACK):\n                \n                # Calculate the center of the 2x2 square\n                center_x, center_y = x + 0.5, y + 0.5\n                \n                # Find the nearest colored pixel to the center\n                closest_color = None\n                closest_distance = float(\u0027inf\u0027)\n                \n                for i in range(rows):\n                    for j in range(cols):\n                        if input_grid[i, j] != Color.BLACK:\n                            distance = np.sqrt((center_x - i) ** 2 + (center_y - j) ** 2)\n                            if distance \u003c closest_distance:\n                                closest_distance = distance\n                                closest_color = input_grid[i, j]\n                \n                # Fill the 2x2 square with the closest color found\n                output_grid[x:x+2, y:y+2] = closest_color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10 with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels (not black) in the grid\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(1, n-1), np.random.randint(1, m-1) # Avoid edges for the colored pixels\n        grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place several 2x2 black squares\n    num_squares = np.random.randint(2, 5)\n    for _ in range(num_squares):\n        while True:\n            x, y = np.random.randint(0, n-2), np.random.randint(0, m-2) # Ensure there\u0027s space for a 2x2 square\n            \n            # Check if the square can be placed\n            if (grid[x, y] == Color.BLACK and\n                grid[x+1, y] == Color.BLACK and\n                grid[x, y+1] == Color.BLACK and\n                grid[x+1, y+1] == Color.BLACK):\n                # Place the black square\n                grid[x, y] = Color.BLACK\n                grid[x+1, y] = Color.BLACK\n                grid[x, y+1] = Color.BLACK\n                grid[x+1, y+1] = Color.BLACK\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/96/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/96/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/96/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/96/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/96/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/96/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/96/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/96/images/train_output_2.png"}]}, "index": 96, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object translation, closest object selection\n\n# description:\n# In the input you will see a grid with various objects represented by their colors. \n# Each object can be of any color, but only one object is the closest to the top of the grid. \n# To make the output, detect the object that is closest to the top of the grid and translate it to the bottom of the grid.\n\ndef main(input_grid):\n    # Find the connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Find the object that is closest to the top of the grid\n    closest_object = None\n    closest_object_y = float(\u0027inf\u0027)\n    \n    for obj in objects:\n        # Get the coordinates of the topmost pixel of the object\n        y_coords, x_coords = np.argwhere(obj != Color.BLACK).T\n        topmost_y = np.min(y_coords)\n        \n        # Update the closest object if this one is closer to the top\n        if topmost_y \u003c closest_object_y:\n            closest_object_y = topmost_y\n            closest_object = obj\n\n    # Prepare the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Translate the closest object to the bottom of the grid\n    translated_object = translate(closest_object, x=0, y=input_grid.shape[0] - closest_object.shape[0] - closest_object_y, background=Color.BLACK)\n\n    # Blit the translated object onto the output grid\n    output_grid = blit_object(output_grid, translated_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random objects\n    grid_len = np.random.randint(8, 12)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Randomly create a number of objects in the grid\n    num_objects = np.random.randint(3, 6)\n    \n    for _ in range(num_objects):\n        # Create a random object\n        sprite_width, sprite_height = np.random.randint(2, 4), np.random.randint(2, 4)\n        sprite_color = np.random.choice([Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON])\n        sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[sprite_color], density=0.6)\n        \n        # Find a random free location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n        except:\n            continue\n        \n        # Blit the sprite onto the grid\n        grid = blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/97/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/97/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/97/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/97/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/97/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/97/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/97/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/97/images/train_output_2.png"}]}, "index": 97, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mixing, blending, grid transformation\n\n# description:\n# In the input, you will see overlapping colored circles. Each circle is represented by a different color.\n# To make the output, you should blend the colors of overlapping circles according to a specific rule:\n# - If two colors overlap, the output color will be a mixture of those colors.\n# - For example, if Red and Blue overlap, the output will be Grey.\n# The blending rules are predefined for the pairs of colors.\n\ndef blend_colors(color1, color2):\n    # Define the blending rules for color pairs\n    if (color1, color2) in [(Color.RED, Color.BLUE), (Color.BLUE, Color.RED)]:\n        return Color.GREY\n    elif (color1, color2) in [(Color.RED, Color.YELLOW), (Color.YELLOW, Color.RED)]:\n        return Color.ORANGE\n    elif (color1, Color.BLUE) in [(Color.BLUE, Color.YELLOW), (Color.YELLOW, Color.BLUE)]:\n        return Color.GREEN\n    else:\n        return color1  # return color1 if no mixing occurs\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Iterate over each pixel in the grid\n    for x in range(n):\n        for y in range(m):\n            # If the current pixel is not black, check for overlapping colors\n            if input_grid[x, y] != Color.BLACK:\n                # Blend the current color with neighboring pixels\n                current_color = input_grid[x, y]\n                blended_color = current_color\n                \n                # Check the four neighbors (up, down, left, right)\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 \u003c= nx \u003c n and 0 \u003c= ny \u003c m and input_grid[nx, ny] != Color.BLACK:\n                        blended_color = blend_colors(blended_color, input_grid[nx, ny])\n                \n                # Set the blended color in the output grid\n                output_grid[x, y] = blended_color\n            else:\n                output_grid[x, y] = Color.BLACK  # Keep the background black\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Define colors to use\n    available_colors = [Color.RED, Color.BLUE, Color.YELLOW, Color.GREEN, Color.ORANGE, Color.GREY]\n\n    # Randomly generate circles of colors in the grid\n    for _ in range(np.random.randint(5, 15)):  # Randomly place 5 to 15 circles\n        # Random position and size\n        size = np.random.randint(2, 5)\n        x_center = np.random.randint(0, n)\n        y_center = np.random.randint(0, m)\n        color = np.random.choice(available_colors)\n\n        # Draw the circle\n        for x in range(max(0, x_center - size), min(n, x_center + size + 1)):\n            for y in range(max(0, y_center - size), min(m, y_center + size + 1)):\n                if (x - x_center) ** 2 + (y - y_center) ** 2 \u003c= size ** 2:\n                    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/98/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/98/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/98/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/98/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/98/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/98/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/98/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/98/images/train_output_2.png"}]}, "index": 98, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, object positioning\n\n# description:\n# In the input grid, you will see colored objects represented by blocks of two rows of pixels (each block is 2 rows high).\n# Each color corresponds to a different color in the output grid according to the following mapping:\n# red -\u003e orange, green -\u003e grey, blue -\u003e teal, yellow -\u003e pink.\n# The blocks are positioned at random rows in the grid, and the output should maintain their positions while applying the color mapping.\n\ndef main(input_grid):\n    # Initialize the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Perform color mapping\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n\n# Constructing the color map\ncolor_map = {\n    Color.RED: Color.ORANGE,\n    Color.GREEN: Color.GREY,\n    Color.BLUE: Color.TEAL,\n    Color.YELLOW: Color.PINK\n}\n\ndef generate_input():\n    grid_height = np.random.randint(6, 16)  # Height of the grid\n    grid_width = np.random.randint(5, 15)    # Width of the grid\n    grid = np.full((grid_height, grid_width), Color.BLACK)  # Initialize the grid with BLACK\n    \n    # Randomly place blocks of colors\n    num_blocks = np.random.randint(1, 5)  # Number of colored blocks to place\n    \n    for _ in range(num_blocks):\n        # Choose a random color for the block\n        color = np.random.choice(list(color_map.keys()))\n        \n        # Choose a random starting position for the block\n        start_x = np.random.randint(0, grid_width)\n        start_y = np.random.randint(0, grid_height - 2)  # Ensure there\u0027s space for a block of 2 rows\n        \n        # Create a 2-row block of the chosen color\n        block = np.full((2, 1), color)  # 2 rows, 1 column\n        for dx in range(2):  # Fill the block into the grid\n            if start_x \u003c grid_width:  # Ensure we don\u0027t go out of bounds\n                grid[start_y + dx, start_x] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/99/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/99/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/99/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/99/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/99/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/99/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/99/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/99/images/train_output_2.png"}]}, "index": 99, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern merging, color blending\n\n# description:\n# In the input, you will see several 3x3 colored squares, and a larger green square outline.\n# To make the output, blend the colors of the small squares that fall within the bounds of the green square and fill the larger square with the resulting blended color.\n\ndef main(input_grid):\n    # Detect the green frame square and its position\n    green_square = detect_objects(grid=input_grid, colors=[Color.GREEN], monochromatic=True, connectivity=4)[0]\n    green_x, green_y, green_w, green_h = bounding_box(grid=green_square)\n\n    # Create an empty color count grid for blending\n    color_count = {}\n    total_count = 0\n\n    # Check for small colored squares within the boundaries of the green square\n    objects = detect_objects(grid=input_grid, monochromatic=True, connectivity=8)\n    for obj in objects:\n        obj_x, obj_y, obj_w, obj_h = bounding_box(grid=obj)\n        if obj_w == 3 and obj_h == 3:  # Check for 3x3 squares\n            # Check if it falls within the green square\n            if (obj_x \u003e= green_x and obj_x + obj_w \u003c= green_x + green_w and\n                obj_y \u003e= green_y and obj_y + obj_h \u003c= green_y + green_h):\n                # Get the color of the 3x3 square\n                color = obj[obj_x, obj_y]\n                if color != Color.GREEN:  # Avoid counting the green square itself\n                    if color not in color_count:\n                        color_count[color] = 0\n                    color_count[color] += 1\n                    total_count += 1\n\n    # Determine the blended color\n    if total_count == 0:\n        blended_color = Color.GREEN  # Default to green if no colors found\n    else:\n        # Simple averaging of colors for blending (this is a simplified approach)\n        blended_color = np.array([0, 0, 0])  # RGB placeholder\n        for color, count in color_count.items():\n            # Convert color string to RGB equivalent (mock representation)\n            rgb_value = {\n                Color.RED: [255, 0, 0],\n                Color.BLUE: [0, 0, 255],\n                Color.GREEN: [0, 255, 0],\n                Color.YELLOW: [255, 255, 0],\n                Color.PINK: [255, 192, 203],\n                Color.GREY: [128, 128, 128],\n                Color.ORANGE: [255, 165, 0],\n                Color.TEAL: [0, 128, 128],\n                Color.MAROON: [128, 0, 0],\n                Color.BLACK: [0, 0, 0]\n            }[color]\n            blended_color += np.array(rgb_value) * count\n\n        blended_color = (blended_color // total_count).astype(int)\n        blended_color = tuple(np.clip(blended_color, 0, 255))  # ensure valid color values\n\n        # Convert RGB back to Color enum for this example\n        blended_color = Color.BLACK  # Placeholder, real conversion logic needed\n\n    # Fill the green square with the blended color\n    output_grid = np.full((green_h, green_w), blended_color)\n    return output_grid\n\ndef generate_input():\n    # Initialize a grid of size 20x20\n    grid = np.zeros((20, 20), dtype=int)\n\n    # Define a function to create 3x3 colored squares\n    def create_square(color):\n        square = np.full((3, 3), color, dtype=int)\n        return square\n\n    # Place a larger green square outline\n    green_square_size = 8\n    green_square = np.full((green_square_size + 2, green_square_size + 2), Color.GREEN)\n    green_square[1:-1, 1:-1] = Color.BLACK\n    x_green, y_green = random_free_location_for_sprite(grid, green_square)\n    grid = blit_sprite(grid, green_square, x_green, y_green)\n\n    # Randomly generate several 3x3 color squares\n    colors = random.sample(list(Color.NOT_BLACK), 5)  # Pick 5 distinct colors\n    for color in colors:\n        square = create_square(color)\n        x_square, y_square = random_free_location_for_sprite(grid, square)\n        grid = blit_sprite(grid, square, x_square, y_square)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/100/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/100/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/100/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/100/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/100/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/100/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/100/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/100/images/train_output_2.png"}]}, "index": 100, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color transformation\n\n# description:\n# In the input, you will see a grid with various colored shapes. \n# The output will change the color of all shapes that have the same color as the largest shape to grey.\n\ndef main(input_grid):\n    # Find all connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n    \n    # Determine the largest shape based on area (number of pixels)\n    largest_shape = max(shapes, key=lambda shape: np.sum(shape != Color.BLACK))\n    \n    # Get the color of the largest shape\n    largest_color = largest_shape[0][0]  # since the shape is monochromatic, we can just take a pixel\n    \n    # Create an output grid based on the input\n    output_grid = input_grid.copy()\n    \n    # Change the color of all shapes that have the same color as the largest shape to grey\n    for shape in shapes:\n        if shape[0][0] == largest_color:\n            output_grid[shape != Color.BLACK] = Color.GREY\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of shapes\n    num_shapes = np.random.randint(3, 8)\n\n    for _ in range(num_shapes):\n        # Generate random dimensions for the shape\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape_color = np.random.choice([Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.ORANGE, Color.PINK])\n        \n        # Create a shape\n        shape = random_sprite(w, h, density=1.0, color_palette=[shape_color])\n\n        # Find a random free location to place the shape\n        try:\n            x, y = random_free_location_for_sprite(input_grid, shape)\n            blit_sprite(input_grid, shape, x=x, y=y)\n        except ValueError:\n            continue  # If there\u0027s no space, we skip placing this shape\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/101/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/101/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/101/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/101/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/101/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/101/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/101/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/101/images/train_output_2.png"}]}, "index": 101, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, scaling, color replacement\n\n# description:\n# In the input you will see a grid with various colored pixels. \n# To make the output, you should find the largest circular area (of continuous colors) \n# and replace it with a yellow circle of the same size.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect circular regions of colors in the grid\n    # 2. Find the largest circle based on pixel count\n    # 3. Replace the detected circle with a yellow circle of the same size\n\n    # 1. Detect circular regions of colors\n    color_objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n\n    # 2. Find the largest circle\n    largest_circle = max(color_objects, key=lambda obj: np.count_nonzero(obj != Color.BLACK))\n    \n    # Crop the largest circle\n    cropped_circle = crop(largest_circle, background=Color.BLACK)\n    \n    # 3. Create a yellow circle of the same size\n    yellow_circle = np.full(cropped_circle.shape, Color.YELLOW)\n\n    # Find the position of the largest circle in the original grid\n    x, y = object_position(largest_circle, background=Color.BLACK, anchor=\"upper left\")\n\n    # Prepare the output grid by copying the input grid\n    output_grid = np.copy(input_grid)\n\n    # Replace the largest circle area with the yellow circle\n    output_grid[x:x+cropped_circle.shape[0], y:y+cropped_circle.shape[1]] = yellow_circle\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels on the grid\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.PINK, Color.ORANGE]\n    for _ in range(np.random.randint(10, 100)):  # Random number of colored pixels\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        grid[x, y] = np.random.choice(colors)\n\n    # Create a random circular area of black pixels\n    circle_radius = np.random.randint(3, 6)\n    circle_center_x = np.random.randint(circle_radius, n - circle_radius)\n    circle_center_y = np.random.randint(circle_radius, m - circle_radius)\n\n    for x in range(circle_center_x - circle_radius, circle_center_x + circle_radius):\n        for y in range(circle_center_y - circle_radius, circle_center_y + circle_radius):\n            if (x - circle_center_x) ** 2 + (y - circle_center_y) ** 2 \u003c= circle_radius ** 2:\n                grid[x, y] = Color.BLACK  # Fill the circle with black pixels\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/102/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/102/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/102/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/102/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/102/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/102/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/102/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/102/images/train_output_2.png"}]}, "index": 102, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion\n\n# description:\n# In the input, you will see a grid filled with colors. \n# To make the output, invert the colors according to the following mapping:\n# blue becomes yellow, yellow becomes blue, red becomes green, green becomes red, \n# gray becomes teal, teal becomes gray, pink becomes maroon, maroon becomes pink.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Performs color inversion\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n    \n# Constructing the color map\ncolor_map = {Color.BLUE: Color.YELLOW, \n             Color.YELLOW: Color.BLUE, \n             Color.RED: Color.GREEN, \n             Color.GREEN: Color.RED, \n             Color.GRAY: Color.TEAL, \n             Color.TEAL: Color.GRAY, \n             Color.PINK: Color.MAROON, \n             Color.MAROON: Color.PINK}\n\ndef generate_input():\n    # Generate a grid of random colors\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # List of colors to populate in the grid\n    colors = list(color_map.keys())\n    \n    # Fill the grid with random colors\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = random.choice(colors)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/103/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/103/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/103/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/103/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/103/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/103/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/103/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/103/images/train_output_2.png"}]}, "index": 103, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, color transition, grid transformation\n\n# description:\n# In the input, you will see a grid with several colored objects on a black background. Each object has a distinct pixel color at its top-left corner. To make the output, extract each object and transition its top-left pixel color to blue, while ensuring the rest of the object remains unchanged on a black background.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract objects from the input grid\n    # 2. Modify the top-left pixel of each object to be blue\n    # 3. Create an output grid and blit the modified objects onto it\n\n    # Step 1: Extract the objects from the input\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Step 2: Create an output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 3: Process each object\n    for obj in objects:\n        # Crop the object to focus on the relevant area\n        cropped_obj = crop(obj, background=Color.BLACK)\n        \n        # Change the top-left pixel color to blue if it\u0027s not black\n        if cropped_obj[0, 0] != Color.BLACK:\n            cropped_obj[0, 0] = Color.BLUE\n            \n        # Blit the modified object onto the output grid\n        blit_object(output_grid, cropped_obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10 with a black background\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a number of objects\n    n_objects = np.random.randint(2, 5)\n    \n    for _ in range(n_objects):\n        # Create a random object with a distinct top-left pixel color\n        object_height, object_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        sprite = random_sprite(object_height, object_width, density=0.5, symmetry=None)\n\n        # Randomly place this object in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/104/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/104/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/104/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/104/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/104/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/104/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/104/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/104/images/train_output_2.png"}]}, "index": 104, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object alignment, size categorization, color filling\n\n# description:\n# In the input, you will see a grid with various colored squares of different sizes. Each square can be of a random color and is separated by a black background.\n# To create the output, align all the squares horizontally at the top of the grid, in the order of their area from smallest to largest. The area is calculated as width * height. The remaining space below should be filled with black.\n\ndef main(input_grid):\n    # Find all colored squares in the grid\n    colored_objects = detect_objects(grid=input_grid, monochromatic=False, background=Color.BLACK, connectivity=4)\n    \n    # Calculate the area of each square and store it with its color and position\n    squares = []\n    for obj in colored_objects:\n        x, y, w, h = bounding_box(grid=obj, background=Color.BLACK)\n        area = w * h\n        color = obj[x, y]\n        squares.append({\u0027color\u0027: color, \u0027area\u0027: area, \u0027bounding_box\u0027: (x, y, w, h)})\n    \n    # Sort squares by area\n    squares.sort(key=lambda square: square[\u0027area\u0027])\n    \n    # Create output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Place colors in the output grid in sorted order\n    current_x = 0\n    for square in squares:\n        color = square[\u0027color\u0027]\n        w, h = square[\u0027bounding_box\u0027][2], square[\u0027bounding_box\u0027][3]\n        if current_x + w \u003e output_grid.shape[1]:  # Check if it fits in the row\n            break\n        # Draw the square in the output grid\n        draw_line(output_grid, current_x, 0, length=w, direction=(1, 0), color=color)  # Top edge\n        draw_line(output_grid, current_x, h - 1, length=w, direction=(1, 0), color=color)  # Bottom edge\n        draw_line(output_grid, current_x, 0, length=h, direction=(0, 1), color=color)  # Left edge\n        draw_line(output_grid, current_x + w - 1, 0, length=h, direction=(0, 1), color=color)  # Right edge\n        current_x += w  # Move x position for next square\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of squares\n    num_squares = np.random.randint(3, 8)\n\n    for _ in range(num_squares):\n        # Randomly determine the square\u0027s size and position\n        size = np.random.randint(1, 5)  # Size of square (1 to 4)\n        x = np.random.randint(0, n - size)\n        y = np.random.randint(0, m - size)\n\n        # Choose a random color\n        color = np.random.choice(Color.NOT_BLACK)\n        \n        # Draw the square\n        for i in range(size):\n            for j in range(size):\n                grid[x + i, y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/105/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/105/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/105/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/105/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/105/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/105/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/105/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/105/images/train_output_2.png"}]}, "index": 105, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern replication, pixel manipulation\n\n# description:\n# In the input you will see a grid containing a single central colored square surrounded by a border of black pixels.\n# The central square has a size of 3x3 pixels. \n# To create the output grid, replicate the central square pattern in all four quadrants of the grid, \n# while maintaining the black border around the entire grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Crop the central square (3x3) from the input grid\n    central_square = input_grid[1:4, 1:4]\n\n    # Create the output grid filled with black pixels\n    output_grid = np.zeros_like(input_grid)\n\n    # Place the central square in all four quadrants\n    output_grid[1:4, 1:4] = central_square  # Top-left\n    output_grid[1:4, -4:-1] = central_square  # Top-right\n    output_grid[-4:-1, 1:4] = central_square  # Bottom-left\n    output_grid[-4:-1, -4:-1] = central_square  # Bottom-right\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create an empty grid with a black background\n    grid_size = 7  # Size of the grid\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly select a color for the central square\n    central_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the central 3x3 area with the selected color\n    grid[1:4, 1:4] = central_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/106/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/106/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/106/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/106/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/106/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/106/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/106/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/106/images/train_output_2.png"}]}, "index": 106, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean logical operations, grid partition, overlay\n\n# description:\n# Compute the AND operation of where the two grids are green, turning the output red in those locations. \n# In the input, you should see two 8x7 green patterns on top and bottom separated by a horizontal yellow line in the middle of the grid. \n# To make the output, you have to overlap the two patterns. If the overlapping cells are the same color, then the corresponding cell is colored red; \n# otherwise, if the overlapping cells are not the same color, then the corresponding cell is colored black.\n\ndef main(input_grid):\n    height, width = input_grid.shape\n    \n    # Find the horizontal yellow separator\n    for y_bar in range(height):\n        if np.all(input_grid[y_bar, :] == Color.YELLOW):\n            break\n\n    # Extract the top and bottom patterns\n    top_pattern = input_grid[:y_bar, :]\n    bottom_pattern = input_grid[y_bar + 1:, :]\n\n    # Initialize output grid\n    output_grid = np.zeros_like(top_pattern)\n\n    # Apply the AND operation\n    output_grid[(top_pattern == Color.GREEN) \u0026 (bottom_pattern == Color.GREEN)] = Color.RED\n    output_grid[(top_pattern != bottom_pattern)] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    # Define grid size\n    width = 8  \n    height = 15  # 7 top + 1 yellow line + 7 bottom\n\n    # Initialize an empty grid\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Randomly assign green or black to the top and bottom patterns\n    for x in range(width):\n        for y in range(7):\n            input_grid[y, x] = np.random.choice([Color.BLACK, Color.GREEN])\n            input_grid[y + 8, x] = np.random.choice([Color.BLACK, Color.GREEN])\n\n    # Set the yellow horizontal line\n    input_grid[7, :] = Color.YELLOW\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/107/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/107/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/107/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/107/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/107/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/107/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/107/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/107/images/train_output_2.png"}]}, "index": 107, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color guide, layering, grid transformation\n\n# description:\n# In the input, you will see a colored object in the center and a colored border around it, with a black background.\n# To make the output, change the color of the border to match the color of the object in the center.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the object in the center\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    center_color = output_grid[center_x, center_y]\n\n    # Change the color of the border (the outermost layer) to the center color\n    # Define the border area\n    border_color_change = [\n        (0, slice(0, -1)),  # Top border\n        (-1, slice(0, -1)),  # Bottom border\n        (slice(1, -1), 0),  # Left border\n        (slice(1, -1), -1)  # Right border\n    ]\n    \n    for idx in border_color_change:\n        if isinstance(idx[0], int):  # Row-based border\n            output_grid[idx[0], idx[1]] = center_color\n        else:  # Column-based border\n            output_grid[idx[0], idx[1]] = center_color\n\n    return output_grid\n\ndef generate_input():\n    # Make a black grid for the background\n    n, m = 7, 7  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the center object\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Create the center object in the grid\n    grid[n//2, m//2] = center_color\n    \n    # Set the border color (should be different than center)\n    border_color = np.random.choice([color for color in Color.NOT_BLACK if color != center_color])\n    \n    # Set the border pixels around the center\n    # Top border\n    grid[0, 1:-1] = border_color\n    # Bottom border\n    grid[-1, 1:-1] = border_color\n    # Left border\n    grid[1:-1, 0] = border_color\n    # Right border\n    grid[1:-1, -1] = border_color\n\n    # Return the generated grid\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/108/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/108/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/108/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/108/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/108/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/108/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/108/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/108/images/train_output_2.png"}]}, "index": 108, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern repetition, color transformation\n\n# description:\n# In the input grid, you\u0027ll see a small pattern in the center of the grid, surrounded by a border of one pixel width.\n# The border will be filled with a single color. \n# To create the output grid, repeat the central pattern to fill the entire grid, \n# changing the color of the pattern to match the color of the border.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Identify the central pattern by cropping the border\n    central_pattern = crop(input_grid, background=Color.BLACK)\n\n    # Get the color of the border\n    border_color = input_grid[0, 0]  # Assuming the border color is uniform\n\n    # Determine the output size\n    output_height = input_grid.shape[0] - 2\n    output_width = input_grid.shape[1] - 2\n\n    # Create an output grid filled with the border color\n    output_grid = np.full((output_height, output_width), border_color)\n\n    # Fill the output grid with the repeated central pattern\n    for i in range(output_height):\n        for j in range(output_width):\n            # Calculate the position in the central pattern\n            pattern_x = i % central_pattern.shape[0]\n            pattern_y = j % central_pattern.shape[1]\n            output_grid[i, j] = central_pattern[pattern_x, pattern_y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the central pattern\n    n, m = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    # Choose a border color\n    border_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Generate a random central pattern\n    central_pattern = random_sprite(n, m, density=0.5)\n\n    # Create the output grid with a border\n    output_grid = np.zeros((n + 2, m + 2), dtype=int)\n\n    # Fill the border with the selected border color\n    output_grid[0, :] = border_color\n    output_grid[-1, :] = border_color\n    output_grid[:, 0] = border_color\n    output_grid[:, -1] = border_color\n\n    # Place the central pattern in the middle of the grid\n    output_grid[1:-1, 1:-1] = central_pattern\n\n    return output_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/109/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/109/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/109/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/109/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/109/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/109/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/109/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/109/images/train_output_2.png"}]}, "index": 109, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern replacement, color mapping\n\n# description:\n# In the input, you will see a pattern of alternating red and blue pixels forming a checkered pattern on a black background.\n# To create the output grid, you should replace all red pixels with yellow and all blue pixels with orange while keeping the checkered structure intact.\n\ndef main(input_grid):\n    # Create a copy of the input grid to store the output\n    output_grid = input_grid.copy()\n\n    # Change the colors according to the transformation rules\n    output_grid[output_grid == Color.RED] = Color.YELLOW\n    output_grid[output_grid == Color.BLUE] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Define the size of the grid\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with a checkered pattern of red and blue pixels\n    for i in range(n):\n        for j in range(m):\n            # Alternate colors based on the sum of the indices\n            if (i + j) % 2 == 0:\n                grid[i, j] = Color.RED\n            else:\n                grid[i, j] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/110/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/110/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/110/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/110/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/110/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/110/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/110/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/110/images/train_output_2.png"}]}, "index": 110, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid mirroring, color propagation\n\n# description:\n# In the input, you will see a grid where the left half contains a certain pattern of colored squares and the right half is filled with black squares. \n# Your task is to mirror the pattern from the left half onto the right half, maintaining the original colors and their positions.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n    \n    # Get the width of the grid\n    height, width = input_grid.shape\n    \n    # Iterate through the left half of the grid\n    for y in range(height):\n        for x in range(width // 2):\n            # Copy the color from the left half to the mirrored position in the right half\n            output_grid[y, width - 1 - x] = input_grid[y, x]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the size of the grid\n    n = np.random.randint(5, 10)\n    m = n * 2  # Ensure the grid has an even width for mirroring\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a pattern color from the available colors\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the left half of the grid with a random pattern\n    for y in range(n):\n        for x in range(m // 2):\n            # Randomly decide to fill with the pattern color or leave it black\n            if np.random.rand() \u003e 0.5:\n                grid[y, x] = pattern_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/111/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/111/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/111/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/111/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/111/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/111/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/111/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/111/images/train_output_2.png"}]}, "index": 111, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, mirroring, grid transformation\n\n# description:\n# In the input, you will see a 5x5 grid containing a colored pattern in a 3x3 square located in the center. The rest of the grid is black.\n# The output should be a 5x5 grid where the center 3x3 pattern is mirrored horizontally, replacing the original pattern.\n\ndef main(input_grid):\n    # Crop the 3x3 central pattern\n    center_x, center_y = 1, 1  # center position of the 5x5 grid\n    pattern = input_grid[center_x:center_x + 3, center_y:center_y + 3]\n    \n    # Mirror the pattern horizontally\n    mirrored_pattern = np.flip(pattern, axis=1)  # flip along the vertical axis\n\n    # Create the output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Place the mirrored pattern back into the center of the output grid\n    output_grid[center_x:center_x + 3, center_y:center_y + 3] = mirrored_pattern\n\n    return output_grid\n\ndef generate_input():\n    # Create a 5x5 grid with a black background\n    grid = np.full((5, 5), Color.BLACK)\n\n    # Define the 3x3 pattern size\n    pattern_size = 3\n    start_x = start_y = 1  # Center of the 5x5 grid\n\n    # Generate a random pattern in the center\n    random_color = np.random.choice(list(Color.NOT_BLACK))\n    pattern = random_sprite(n=pattern_size, m=pattern_size, density=0.5, color_palette=[random_color])\n\n    # Place the pattern in the center of the grid\n    grid[start_x:start_x + pattern_size, start_y:start_y + pattern_size] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/112/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/112/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/112/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/112/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/112/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/112/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/112/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/112/images/train_output_2.png"}]}, "index": 112, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color filling\n\n# description:\n# In the input, you will see a grid with colored shapes on a black background. \n# To create the output grid, you should fill each detected shape with a specific color depending on its size:\n# - Shapes with an area of 1 pixel should be filled with blue\n# - Shapes with an area of 2 pixels should be filled with green\n# - Shapes with an area of 3 pixels should be filled with yellow\n# - Shapes with an area greater than 3 pixels should be filled with red\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a blank output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect all colored shapes in the input grid\n    shapes = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=False, connectivity=8)\n\n    # Color mapping based on area\n    color_mapping = {\n        1: Color.BLUE,\n        2: Color.GREEN,\n        3: Color.YELLOW\n    }\n\n    # Fill the shapes in the output grid based on their sizes\n    for shape in shapes:\n        area = np.sum(shape != Color.BLACK)  # Count the number of pixels in the shape\n        fill_color = color_mapping.get(area, Color.RED)  # Default to red for shapes larger than 3 pixels\n\n        # Fill the shape in the output grid\n        for x, y in np.argwhere(shape != Color.BLACK):\n            output_grid[x, y] = fill_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize a 10x10 black grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create shapes with varying sizes\n    for _ in range(np.random.randint(3, 6)):  # Create 3 to 5 shapes\n        # Randomly determine the size of the shape (1 to 5 pixels)\n        shape_size = np.random.randint(1, 6)\n        \n        # Randomly select a position for the shape\n        x_start = np.random.randint(0, n)\n        y_start = np.random.randint(0, m)\n\n        # Draw the shape in a random way\n        for _ in range(shape_size):\n            x_offset = np.random.choice([-1, 0, 1])\n            y_offset = np.random.choice([-1, 0, 1])\n            x, y = x_start + x_offset, y_start + y_offset\n            \n            if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m and grid[x, y] == Color.BLACK:\n                grid[x, y] = Color.RED  # Fill the shape with red color (can be any color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/113/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/113/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/113/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/113/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/113/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/113/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/113/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/113/images/train_output_2.png"}]}, "index": 113, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color filling, connectivity\n\n# description:\n# In the input, you will see a grid filled with colored pixels. The task is to find a color that forms a continuous \"L\" shape on the grid.\n# To make the output, if the \"L\" shape is found, fill the entire grid with that color; otherwise, fill the grid with black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    height, width = input_grid.shape\n    output_grid = np.zeros_like(input_grid)\n\n    # Function to check for \"L\" shape\n    def is_L_shape(x, y, color):\n        # Check if there is a vertical and horizontal line forming an \"L\"\n        # Vertical part\n        if (x + 2 \u003c height and input_grid[x, y] == color and \n            input_grid[x + 1, y] == color and input_grid[x + 2, y] == color):\n            # Check horizontal part\n            if y + 1 \u003c width and input_grid[x + 2, y] == color and input_grid[x + 2, y + 1] == color:\n                return True\n            if y - 1 \u003e= 0 and input_grid[x + 2, y] == color and input_grid[x + 2, y - 1] == color:\n                return True\n        # Horizontal part\n        if (y + 2 \u003c width and input_grid[x, y] == color and \n            input_grid[x, y + 1] == color and input_grid[x, y + 2] == color):\n            # Check vertical part\n            if x + 1 \u003c height and input_grid[x, y + 2] == color and input_grid[x + 1, y + 2] == color:\n                return True\n            if x - 1 \u003e= 0 and input_grid[x, y + 2] == color and input_grid[x - 1, y + 2] == color:\n                return True\n        return False\n\n    found_color = None\n\n    # Check all pixels for L shape\n    for x in range(height):\n        for y in range(width):\n            color = input_grid[x, y]\n            if color != Color.BLACK and (found_color is None or found_color != color):\n                if is_L_shape(x, y, color):\n                    found_color = color\n                    break\n        if found_color:\n            break\n\n    # Fill the output grid\n    if found_color:\n        output_grid.fill(found_color)\n    else:\n        output_grid.fill(Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color from the palette to form an \"L\" shape\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly decide where to place the \"L\" shape\n    start_x = np.random.randint(0, n - 2)\n    start_y = np.random.randint(0, m - 2)\n\n    # Create a vertical line of length 3\n    grid[start_x, start_y] = color\n    grid[start_x + 1, start_y] = color\n    grid[start_x + 2, start_y] = color\n\n    # Create a horizontal line forming the \"L\"\n    grid[start_x + 2, start_y] = color\n    grid[start_x + 2, start_y + 1] = color\n\n    # Fill the rest of the grid with random colors\n    colors = list(Color.NOT_BLACK)\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.BLACK:\n                grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/114/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/114/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/114/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/114/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/114/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/114/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/114/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/114/images/train_output_2.png"}]}, "index": 114, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, pixel manipulation\n\n# description:\n# In the input, you will see a grid with colored pixels. The output will consist of the original pattern and its reflection along the vertical axis, side by side. \n# The output grid should have the same height as the input grid and width equal to twice the input grid\u0027s width.\n\ndef main(input_grid):\n    # take the input pattern\n    pattern = input_grid\n\n    # reflect the pattern vertically\n    reflected_pattern = pattern[:, ::-1]\n\n    # combine the original and reflected patterns side by side\n    output_grid = np.concatenate((pattern, reflected_pattern), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # make a random-sized grid with black background\n    n = np.random.randint(3, 7)  # height between 3 and 6\n    m = np.random.randint(3, 7)  # width between 3 and 6\n    grid = np.full((n, m), Color.BLACK)\n\n    # fill the grid with random colors except black\n    colors = np.random.choice(list(Color.NOT_BLACK), size=(n, m), replace=True)\n\n    # randomly determine how many pixels to fill\n    num_fill_pixels = np.random.randint(1, n * m // 2)\n\n    # randomly select pixels to fill with color\n    for _ in range(num_fill_pixels):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        grid[x, y] = colors[x, y]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/115/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/115/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/115/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/115/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/115/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/115/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/115/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/115/images/train_output_2.png"}]}, "index": 115, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, shape formation, grid manipulation\n\n# description:\n# In the input, you will see a 3x3 blue square and a 3x3 red square.\n# To create the output grid, you should form a new shape by placing a yellow triangle \n# that occupies the same space as the intersection of the blue and red squares.\n\ndef main(input_grid):\n    # Detect the blue and red squares.\n    blue_square = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    red_square = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n\n    # Initialize the output grid as a copy of the input grid.\n    output_grid = np.copy(input_grid)\n\n    # Assuming there\u0027s exactly one blue and one red square, we can find their positions.\n    blue_x, blue_y = object_position(blue_square[0], background=Color.BLACK, anchor=\u0027upper left\u0027)\n    red_x, red_y = object_position(red_square[0], background=Color.BLACK, anchor=\u0027upper left\u0027)\n\n    # Calculate the intersection area of the two squares.\n    intersection_x1 = max(blue_x, red_x)\n    intersection_y1 = max(blue_y, red_y)\n    intersection_x2 = min(blue_x + 3, red_x + 3)  # Both are 3x3 squares\n    intersection_y2 = min(blue_y + 3, red_y + 3)\n\n    # Create a yellow triangle pattern to fill the intersection\n    yellow_triangle = np.zeros((3, 3), dtype=int)\n    yellow_triangle[0, :] = Color.YELLOW  # Fill the top row\n    yellow_triangle[1, :2] = Color.YELLOW  # Fill the left two of the second row\n    yellow_triangle[2, :1] = Color.YELLOW  # Fill the leftmost of the last row\n\n    # Calculate position to place the triangle in the output grid\n    triangle_x = intersection_x1\n    triangle_y = intersection_y1\n\n    # Blit the yellow triangle onto the output grid in the intersection\n    blit_sprite(output_grid, yellow_triangle, x=triangle_x, y=triangle_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of size 10x10.\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a 3x3 blue square and place it randomly on the grid\n    blue_square = np.full((3, 3), Color.BLUE)\n    blue_x, blue_y = random_free_location_for_sprite(grid, blue_square, background=Color.BLACK)\n    blit_sprite(grid, blue_square, blue_x, blue_y)\n\n    # Create a 3x3 red square and place it ensuring it touches the blue square\n    red_square = np.full((3, 3), Color.RED)\n\n    # Ensure it is placed such that it intersects with the blue square\n    # Randomly determine the overlap position\n    overlap_x = np.random.randint(blue_x, blue_x + 3)\n    overlap_y = np.random.randint(blue_y, blue_y + 3)\n\n    # Calculate new position for the red square to ensure it overlaps\n    red_x = overlap_x if overlap_x + 3 \u003c= n else overlap_x - 3\n    red_y = overlap_y if overlap_y + 3 \u003c= m else overlap_y - 3\n\n    # Blit the red square onto the grid\n    blit_sprite(grid, red_square, red_x, red_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/116/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/116/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/116/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/116/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/116/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/116/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/116/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/116/images/train_output_2.png"}]}, "index": 116, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, symmetry, reflection\n\n# description:\n# In the input, you will see a symmetric pattern with colored and black pixels.\n# To make the output, invert the colors of the pixels (black becomes colored, colored becomes black) \n# and then reflect the pattern across the vertical axis.\n\ndef main(input_grid):\n    # Step 1: Invert the colors of the input grid\n    inverted_grid = np.copy(input_grid)\n    inverted_grid[inverted_grid == Color.BLACK] = Color.RED  # Change black to a color (Red used as an example)\n    inverted_grid[inverted_grid != Color.RED] = Color.BLACK  # Change all colored pixels to black\n\n    # Step 2: Reflect the inverted grid across the vertical axis\n    output_grid = inverted_grid[:, ::-1]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random symmetric pattern with colors and black pixels\n    n = m = np.random.randint(3, 6)  # Randomly chosen size for the grid\n    grid = random_sprite(n, m, density=0.5, symmetry=\"vertical\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/117/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/117/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/117/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/117/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/117/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/117/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/117/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/117/images/train_output_2.png"}]}, "index": 117, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, filling, vertical alignment\n\n# description:\n# In the input, you will see a row with colored pixels followed by a pink line.\n# To create the output grid, copy the first two rows of the input. \n# Then, starting just below the pink line, fill in the grid by drawing vertical columns of colors corresponding to each pixel in the top row.\n# Each column should alternate between the colors in the top row until the grid is filled.\n# Repeat this pattern down to the bottom of the grid.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the colors from the top row\n    colors = input_grid[0, :]\n    num_colors = len(colors)\n\n    # Get the y-coordinate of the pink line\n    pink_line_y = np.where(input_grid[1] == Color.PINK)[0][0]\n\n    # Fill the output grid below the pink line\n    for col in range(num_colors):\n        for row in range(pink_line_y + 1, output_grid.shape[0]):\n            output_grid[row, col] = colors[col]\n\n    return output_grid\n\ndef generate_input():\n    # Decide how many colors to use (between 3 and 6)\n    num_colors = np.random.randint(3, 7)\n\n    # Select colors for the sequence\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    # Create a grid with 2 rows for the colors and a pink line\n    # The height of the grid will be 2 + a random height for the colored area\n    height = np.random.randint(5, 10)\n    grid = np.zeros((height + 2, num_colors), dtype=int)\n\n    # Fill the top row with selected colors\n    grid[0, :] = colors\n\n    # Fill the second row with a pink line\n    grid[1, :] = Color.PINK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/118/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/118/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/118/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/118/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/118/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/118/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/118/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/118/images/train_output_2.png"}]}, "index": 118, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, grid masking, pixel filtering\n\n# description:\n# In the input grid, there are random colored pixels and a specific border color that creates a frame.\n# To produce the output, extract all pixels that are the same color as the border and replace the rest with black pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)  # Start with a black grid\n\n    # Identify the border color\n    border_color = None\n    # Check the first row and first column for the border color\n    for color in input_grid[0, :]:\n        if color != Color.BLACK:\n            border_color = color\n            break\n        \n    if border_color is None:\n        for color in input_grid[:, 0]:\n            if color != Color.BLACK:\n                border_color = color\n                break\n    \n    # Extract pixels that match the border color\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] == border_color:\n                output_grid[x, y] = border_color  # Keep the border color\n            else:\n                output_grid[x, y] = Color.BLACK  # Replace with black\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    grid_size = 20\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly choose a border color\n    border_color = np.random.choice(Color.NOT_BLACK)\n\n    # Draw the border color around the grid\n    grid[0, :] = border_color  # Top border\n    grid[-1, :] = border_color  # Bottom border\n    grid[:, 0] = border_color  # Left border\n    grid[:, -1] = border_color  # Right border\n\n    # Fill the inner area with random colors\n    for x in range(1, grid_size - 1):\n        for y in range(1, grid_size - 1):\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/119/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/119/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/119/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/119/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/119/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/119/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/119/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/119/images/train_output_2.png"}]}, "index": 119, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, cropping, scaling\n\n# description:\n# In the input you will see a grid comprised of colored rectangles on a black background. Each rectangle is either yellow or maroon.\n# To create the output grid, transform the colors of the rectangles as follows:\n# 1. Yellow rectangles should be transformed to green.\n# 2. Maroon rectangles should be transformed to orange.\n# Additionally, the output grid should be scaled by a factor of 2 while maintaining the positions of the transformed rectangles.\n\ndef main(input_grid):\n    # Step 1: Detect all colored rectangles in the input grid\n    detected_objects = detect_objects(grid=input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    for obj in detected_objects:\n        # Step 2: Crop the detected rectangle\n        cropped_sprite = crop(obj, background=Color.BLACK)\n\n        # Step 3: Color transformation based on the original color\n        if np.any(cropped_sprite == Color.YELLOW):\n            cropped_sprite[cropped_sprite == Color.YELLOW] = Color.GREEN\n        elif np.any(cropped_sprite == Color.MAROON):\n            cropped_sprite[cropped_sprite == Color.MAROON] = Color.ORANGE\n        \n        # Step 4: Get the position of the original rectangle\n        x, y = object_position(obj, background=Color.BLACK, anchor=\u0027upper left\u0027)\n\n        # Step 5: Blit the transformed rectangle back to the output grid, maintaining the original sizes\n        output_grid = blit_sprite(grid=output_grid, sprite=cropped_sprite, x=x, y=y, background=Color.BLACK)\n\n    # Step 6: Scale the entire output grid by a factor of 2\n    output_grid = scale_pattern(pattern=output_grid, scale_factor=2)\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Create a black background grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Step 2: Define the dimensions and colors for rectangles\n    rectangles = [(2, 1), (1, 2), (3, 1), (1, 3)]  # possible rectangle sizes\n    colors = [Color.YELLOW, Color.MAROON]\n\n    # Step 3: Randomly generate and place colored rectangles on the grid\n    for _ in range(np.random.randint(4, 8)):  # Random number of rectangles\n        w, h = random.choice(rectangles)\n        color = random.choice(colors)\n        rectangle_sprite = np.full((h, w), color)\n\n        # Step 4: Place the rectangle randomly in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, rectangle_sprite, background=Color.BLACK)\n            blit_sprite(grid, rectangle_sprite, x, y, background=Color.BLACK)\n        except:\n            continue  # If no space is found, skip this rectangle\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/120/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/120/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/120/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/120/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/120/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/120/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/120/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/120/images/train_output_2.png"}]}, "index": 120, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# concentric squares, color propagation\n\n# description:\n# In the input, you will see a single colored pixel on a black background. \n# To make the output, create concentric squares of the same color as the colored pixel, \n# with the outermost square surrounding the location of the colored pixel.\n\ndef main(input_grid):\n    # Create output grid\n    output_grid = np.copy(input_grid)\n    \n    # Get the index of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Get color from colored pixel\n    color = input_grid[x, y]\n\n    # Draw concentric squares around the colored pixel\n    size = 1\n    while True:\n        # Define the bounds of the square\n        top_left_x = x - size\n        top_left_y = y - size\n        bottom_right_x = x + size\n        bottom_right_y = y + size\n\n        # Check if the bounds are within the grid\n        if top_left_x \u003c 0 or top_left_y \u003c 0 or bottom_right_x \u003e= output_grid.shape[0] or bottom_right_y \u003e= output_grid.shape[1]:\n            break  # Stop if we go out of bounds\n\n        # Draw the square outline\n        draw_line(output_grid, top_left_x, top_left_y, end_x=bottom_right_x, end_y=top_left_y, color=color)  # Top edge\n        draw_line(output_grid, top_left_x, top_left_y, end_x=top_left_x, end_y=bottom_right_y, color=color)  # Left edge\n        draw_line(output_grid, bottom_right_x, top_left_y, end_x=bottom_right_x, end_y=bottom_right_y, color=color)  # Right edge\n        draw_line(output_grid, top_left_x, bottom_right_y, end_x=bottom_right_x, end_y=bottom_right_y, color=color)  # Bottom edge\n\n        size += 1  # Increase the size for the next square\n\n    return output_grid\n\n\ndef generate_input():\n    # Make a square black grid for the background\n    n = m = np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Put a randomly colored pixel at a random point on the grid\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/121/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/121/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/121/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/121/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/121/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/121/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/121/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/121/images/train_output_2.png"}]}, "index": 121, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# growth, radial lines\n\n# description:\n# In the input, you will see a number of colored pixels scattered on a black background.\n# Each pixel will either be yellow, orange, or blue. From each yellow pixel, draw outward radial lines in all four cardinal directions.\n# From each orange pixel, draw outward diagonal lines in both diagonal directions (top-left to bottom-right and top-right to bottom-left).\n# From each blue pixel, draw outward radial lines in all eight directions.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    yellow_pixels = np.argwhere(input_grid == Color.YELLOW)\n    orange_pixels = np.argwhere(input_grid == Color.ORANGE)\n    blue_pixels = np.argwhere(input_grid == Color.BLUE)\n\n    # Process yellow pixels for radial lines (N, E, S, W)\n    for x, y in yellow_pixels:\n        draw_line(output_grid, x, y, length=None, direction=(0, 1), color=Color.YELLOW)  # South\n        draw_line(output_grid, x, y, length=None, direction=(0, -1), color=Color.YELLOW)  # North\n        draw_line(output_grid, x, y, length=None, direction=(1, 0), color=Color.YELLOW)  # East\n        draw_line(output_grid, x, y, length=None, direction=(-1, 0), color=Color.YELLOW)  # West\n\n    # Process orange pixels for diagonal lines (/ and \\)\n    for x, y in orange_pixels:\n        draw_line(output_grid, x, y, length=None, direction=(1, 1), color=Color.ORANGE)  # Down-Right\n        draw_line(output_grid, x, y, length=None, direction=(-1, -1), color=Color.ORANGE)  # Up-Left\n        draw_line(output_grid, x, y, length=None, direction=(1, -1), color=Color.ORANGE)  # Down-Left\n        draw_line(output_grid, x, y, length=None, direction=(-1, 1), color=Color.ORANGE)  # Up-Right\n\n    # Process blue pixels for radial lines (all 8 directions)\n    for x, y in blue_pixels:\n        draw_line(output_grid, x, y, length=None, direction=(0, 1), color=Color.BLUE)  # South\n        draw_line(output_grid, x, y, length=None, direction=(0, -1), color=Color.BLUE)  # North\n        draw_line(output_grid, x, y, length=None, direction=(1, 0), color=Color.BLUE)  # East\n        draw_line(output_grid, x, y, length=None, direction=(-1, 0), color=Color.BLUE)  # West\n        draw_line(output_grid, x, y, length=None, direction=(1, 1), color=Color.BLUE)  # Down-Right\n        draw_line(output_grid, x, y, length=None, direction=(-1, -1), color=Color.BLUE)  # Up-Left\n        draw_line(output_grid, x, y, length=None, direction=(1, -1), color=Color.BLUE)  # Down-Left\n        draw_line(output_grid, x, y, length=None, direction=(-1, 1), color=Color.BLUE)  # Up-Right\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a black grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly sprinkle some yellow, orange, and blue pixels\n    num_yellow = np.random.randint(1, 5)\n    num_orange = np.random.randint(1, 5)\n    num_blue = np.random.randint(1, 5)\n\n    for _ in range(num_yellow):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.YELLOW\n\n    for _ in range(num_orange):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.ORANGE\n\n    for _ in range(num_blue):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/122/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/122/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/122/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/122/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/122/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/122/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/122/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/122/images/train_output_2.png"}]}, "index": 122, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# adjacency, color transformation, pixel manipulation\n\n# description:\n# In the input, you will see a grid filled with 2x2 colored squares and some mixed-color noise pixels. \n# The goal is to transform the grid such that all colored squares are turned green, \n# noise pixels adjacent to any square turn into a lighter shade of their color, \n# and noise pixels not adjacent to any squares are removed (turned black).\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all colored squares (2x2 blocks).\n    # 2. Change the color of each square to green.\n    # 3. For each noise pixel, check if it is adjacent to any colored square.\n    # 4. If adjacent, change the noise pixel to a lighter shade of the adjacent square\u0027s color.\n    # 5. If not adjacent to any square, turn the noise pixel black.\n\n    output_grid = np.copy(input_grid)\n\n    # Step 1: Identify colored squares\n    squares = []\n    rows, cols = input_grid.shape\n\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            if (input_grid[r, c] != Color.BLACK and \n                input_grid[r, c] == input_grid[r + 1, c] == input_grid[r, c + 1] == input_grid[r + 1, c + 1]):\n                # Found a colored square\n                squares.append((r, c, input_grid[r, c]))  # (row, col, color)\n                # Change square color to green\n                output_grid[r:r + 2, c:c + 2] = Color.GREEN\n\n    # Step 3: Check noise pixels\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r, c] == Color.BLACK and input_grid[r, c] != Color.BLACK:\n                # It\u0027s a noise pixel\n                adjacent_to_square = False\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if (0 \u003c= r + dr \u003c rows and 0 \u003c= c + dc \u003c cols and \n                            input_grid[r + dr, c + dc] != Color.BLACK and\n                            input_grid[r + dr, c + dc] != Color.GREEN):\n                            adjacent_to_square = True\n                            # Change noise pixel to lighter color\n                            output_grid[r, c] = lighten_color(input_grid[r + dr, c + dc])\n                            break\n                    if adjacent_to_square:\n                        break\n                if not adjacent_to_square:\n                    # Not adjacent to any square, so remains black\n                    output_grid[r, c] = Color.BLACK\n\n    return output_grid\n\n\ndef lighten_color(color):\n    # Lighter shade of a color can be achieved by mixing it with white\n    if color == Color.RED:\n        return Color.PINK\n    elif color == Color.GREEN:\n        return Color.BLUE  # Assuming there\u0027s a light green color in the Color class\n    elif color == Color.BLUE:\n        return Color.YELLOW\n    elif color == Color.YELLOW:\n        return Color.TEAL  # Assuming there\u0027s a light yellow color in the Color class\n    elif color == Color.ORANGE:\n        return Color.GRAY  # Assuming there\u0027s a light orange color in the Color class\n    elif color == Color.MAROON:\n        return Color.ORANGE  # Assuming there\u0027s a orange color in the Color class\n    return color  # Default fallback\n\ndef generate_input():\n    # Plan:\n    # 1. Create a grid with a black background.\n    # 2. Randomly place a few colored squares (2x2 blocks).\n    # 3. Randomly sprinkle some noise pixels around.\n\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create colored squares\n    colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(3, 6), replace=False)\n    for color in colors:\n        for _ in range(np.random.randint(1, 4)):\n            x, y = np.random.randint(0, width - 1), np.random.randint(0, height - 1)\n            if grid[x, y] == Color.BLACK and grid[x + 1, y] == Color.BLACK and grid[x, y + 1] == Color.BLACK and grid[x + 1, y + 1] == Color.BLACK:\n                grid[x:x + 2, y:y + 2] = color\n\n    # Add noise pixels\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(width), np.random.randint(height)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/123/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/123/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/123/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/123/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/123/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/123/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/123/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/123/images/train_output_2.png"}]}, "index": 123, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, pattern filling, grid transformation\n\n# description:\n# In the input, you will see a grid containing several 2x2 squares of different colors (including black).\n# To make the output, count the number of 2x2 squares of each color and fill a new grid with 2x2 blocks of each color,\n# where the number of blocks in the output grid corresponds to the count from the input grid. \n# The output grid should be filled in a row-first manner, starting from the top-left corner.\n\ndef main(input_grid):\n    # Detect 2x2 colored squares in the input grid\n    square_objects = detect_objects(input_grid, colors=Color.NOT_BLACK, allowed_dimensions=[(2, 2)], monochromatic=True)\n\n    # Count occurrences of each colored square\n    color_count = {}\n    for square in square_objects:\n        color = square[0, 0]  # Assuming the square is monochromatic\n        if color not in color_count:\n            color_count[color] = 0\n        color_count[color] += 1\n\n    # Create the output grid dimensions\n    total_squares = sum(color_count.values())\n    output_grid_size = int(np.ceil(np.sqrt(total_squares)))  # Calculate size for a square output grid\n    output_grid = np.full((output_grid_size * 2, output_grid_size * 2), Color.BLACK)\n\n    # Fill the output grid with 2x2 squares based on the counts\n    pos_x, pos_y = 0, 0\n    for color, count in color_count.items():\n        for _ in range(count):\n            output_grid[pos_x:pos_x + 2, pos_y:pos_y + 2] = color\n            pos_y += 2  # Move to the next position in the row\n            if pos_y \u003e= output_grid.shape[1]:  # If we reach the end of the row, go to the next row\n                pos_y = 0\n                pos_x += 2\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with 2x2 colored squares\n    n = np.random.randint(6, 12)  # Random grid size\n    m = np.random.randint(6, 12)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Randomly choose the number of 2x2 squares\n    square_count = np.random.randint(1, 10)  # Number of colored squares\n    used_positions = set()\n    \n    for _ in range(square_count):\n        square_color = np.random.choice(list(Color.NOT_BLACK))  # Choose a random color (not black)\n        square_sprite = np.full((2, 2), square_color, dtype=int)\n\n        # Find a random free location for the 2x2 square\n        while True:\n            x = np.random.randint(0, n - 1)\n            y = np.random.randint(0, m - 1)\n\n            # Check if the position is free (ensuring it does not overlap with existing squares)\n            if (x, y) not in used_positions and (x + 1, y) not in used_positions and (x, y + 1) not in used_positions and (x + 1, y + 1) not in used_positions:\n                blit_sprite(grid, square_sprite, x=x, y=y)\n                used_positions.add((x, y))\n                used_positions.add((x + 1, y))\n                used_positions.add((x, y + 1))\n                used_positions.add((x + 1, y + 1))\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/124/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/124/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/124/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/124/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/124/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/124/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/124/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/124/images/train_output_2.png"}]}, "index": 124, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filling, connected components\n\n# description:\n# In the input, you will see a complex shape filled with various colors on a black background. \n# To create the output, fill the empty spaces within the shape with the color that is most common among the filled-in parts, \n# leaving the already colored parts untouched.\n\ndef main(input_grid):\n    # Find the background color\n    background = Color.BLACK\n    \n    # Extract connected components\n    components = find_connected_components(input_grid, background=background, monochromatic=False, connectivity=4)\n    \n    # Count colors in the filled components\n    color_counts = {}\n    for component in components:\n        colors, counts = np.unique(component[component != background], return_counts=True)\n        for color, count in zip(colors, counts):\n            if color != background:\n                if color in color_counts:\n                    color_counts[color] += count\n                else:\n                    color_counts[color] = count\n\n    # Determine the most common color\n    most_common_color = max(color_counts, key=color_counts.get)\n\n    # Create output grid\n    output_grid = np.copy(input_grid)\n\n    # Fill empty spaces with the most common color\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if output_grid[x, y] == background:\n                output_grid[x, y] = most_common_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a grid with random dimensions.\n    # 2. Randomly draw shapes in various colors and leave gaps (background).\n    # 3. Ensure that the filled colors have a variety of colors with some connected components.\n\n    grid_dimensions = np.random.randint(10, 30, size=(2))\n    grid = np.full(grid_dimensions, Color.BLACK)\n\n    # Randomly create filled shapes\n    num_shapes = np.random.randint(5, 15)\n    for _ in range(num_shapes):\n        # Random dimensions for the shape\n        shape_width, shape_height = np.random.randint(2, 6), np.random.randint(2, 6)\n        # Random color\n        color = np.random.choice(Color.NOT_BLACK)\n        # Random position\n        x = np.random.randint(0, grid_dimensions[0] - shape_width)\n        y = np.random.randint(0, grid_dimensions[1] - shape_height)\n        \n        # Create a sprite for the shape\n        sprite = random_sprite(shape_width, shape_height, density=1, color_palette=[color])\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/125/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/125/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/125/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/125/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/125/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/125/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/125/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/125/images/train_output_2.png"}]}, "index": 125, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, color transformation\n\n# description:\n# In the input grid, you will see several circles of the same color centered at different points. The goal is to transform the grid by looking at each circle and filling in its surrounding area with a new color based on its distance from the center. If the distance from the center is less than or equal to 2, fill it with a new color (e.g., yellow); if the distance is greater than 2 but less than or equal to 4, fill it with another color (e.g., orange). Areas further than 4 units from the center remain unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the grid (the circles)\n    circles = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    for circle in circles:\n        # Find the bounding box of the circle\n        x, y, w, h = bounding_box(circle)\n\n        # Get the center of the circle\n        center_x = x + w // 2\n        center_y = y + h // 2\n\n        # Iterate through the area surrounding the center point\n        for i in range(max(0, center_x - 5), min(output_grid.shape[0], center_x + 5)):\n            for j in range(max(0, center_y - 5), min(output_grid.shape[1], center_y + 5)):\n                # Calculate the distance from the center\n                distance = np.sqrt((i - center_x) ** 2 + (j - center_y) ** 2)\n\n                # Fill the output grid based on the distance\n                if distance \u003c= 2:\n                    output_grid[i, j] = Color.YELLOW\n                elif distance \u003c= 4:\n                    output_grid[i, j] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    grid = np.full((20, 20), Color.BLACK)\n\n    # Choose a color for the circles\n    circle_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly generate a number of circles\n    for _ in range(np.random.randint(3, 6)):\n        # Define a random radius for the circle\n        radius = np.random.randint(1, 3)\n\n        # Choose a random center point ensuring circles fit within the grid\n        center_x = np.random.randint(radius, 20 - radius)\n        center_y = np.random.randint(radius, 20 - radius)\n\n        # Draw the circle on the grid\n        for x in range(center_x - radius, center_x + radius + 1):\n            for y in range(center_y - radius, center_y + radius + 1):\n                if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                    grid[x, y] = circle_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/126/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/126/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/126/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/126/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/126/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/126/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/126/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/126/images/train_output_2.png"}]}, "index": 126, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid expansion, color mapping\n\n# description:\n# The input is a grid where each square is of the same color. \n# To make the output, double the size of the grid and change each color according to the following mapping:\n# red -\u003e blue, green -\u003e yellow, blue -\u003e red, yellow -\u003e green.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.full((input_grid.shape[0] * 2, input_grid.shape[1] * 2), Color.BLACK)\n\n    # Create color mapping\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN\n    }\n\n    # Fill the output grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x, y]\n            mapped_color = color_map.get(color, color)\n            output_grid[x*2:(x*2)+2, y*2:(y*2)+2] = mapped_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random colors\n    n = np.random.randint(1, 6)  # Random height\n    m = np.random.randint(1, 6)  # Random width\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors from the allowable set\n    color_choices = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(color_choices)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/127/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/127/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/127/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/127/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/127/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/127/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/127/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/127/images/train_output_2.png"}]}, "index": 127, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, extraction, color manipulation\n\n# description:\n# In the input, you will see a grid containing a colorful shape that has both horizontal and vertical symmetry,\n# surrounded by a black background. The task is to extract the symmetric shape and create a new grid with \n# the extracted shape in the center of a new grid filled with a different color (e.g., yellow).\n\ndef main(input_grid):\n    # Step 1: Detect the shape with mirror symmetries\n    mirrors = detect_mirror_symmetry(input_grid, ignore_colors=[Color.BLACK])\n    \n    # Step 2: We assume there is at least one symmetric shape based on the puzzle description\n    # Extract the colored shape from the input grid\n    object_mask = np.where(input_grid != Color.BLACK, 1, 0)\n    shape = crop(input_grid)\n\n    # Step 3: Create a new grid filled with Color.YELLOW\n    output_size = shape.shape\n    output_grid = np.full((output_size[0] + 2, output_size[1] + 2), Color.YELLOW, dtype=int)\n\n    # Step 4: Place the extracted shape in the center of the new grid\n    center_x = 1  # offset by 1 to center it\n    center_y = 1  # offset by 1 to center it\n    output_grid[center_x:center_x + shape.shape[0], center_y:center_y + shape.shape[1]] = shape\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size (between 5x5 to 10x10)\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a symmetric sprite\n    sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), symmetry=\u0027horizontal\u0027, color_palette=Color.NOT_BLACK)\n\n    # Place the sprite in the grid at a random location\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/128/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/128/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/128/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/128/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/128/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/128/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/128/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/128/images/train_output_2.png"}]}, "index": 128, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# circles, counting, color frequency\n\n# description:\n# In the input, you will see a grid filled with colored circles of various sizes and a non-black background.\n# To create the output, count the frequency of each color of the circles. The output should be a vertical array of circles\n# filled with the colors of the circles sorted from most common to least common, skipping the least common color.\n\ndef main(input_grid):\n    # Step 1: Find the background color\n    background = np.bincount(input_grid.flatten()).argmax()\n\n    # Step 2: Detect circles in the input grid\n    circles = detect_objects(grid=input_grid, monochromatic=False, connectivity=8, colors=Color.NOT_BLACK)\n    \n    # Step 3: Count the colors of the circles\n    circle_colors = [circle[circle != background][0] for circle in circles]\n    color_counts = {color: circle_colors.count(color) for color in set(circle_colors)}\n    \n    # Step 4: Sort colors by frequency and skip the least common color\n    sorted_colors = sorted(color_counts, key=color_counts.get, reverse=True)\n    if len(sorted_colors) \u003e 1:\n        sorted_colors = sorted_colors[1:]  # Skip least common\n    \n    # Step 5: Create the output grid and draw the circles\n    output_height = len(sorted_colors)\n    output_grid = np.full((output_height * 3, 3), background)  # Each circle has a height of 3\n    \n    for i, color in enumerate(sorted_colors):\n        # Create a sprite for the circle\n        circle_sprite = np.zeros((3, 3), dtype=int)\n        circle_sprite[1, 1] = color  # Center pixel is the color\n        \n        # Draw the circle in the output grid\n        blit_sprite(output_grid, circle_sprite, x=1, y=i * 3, background=background)\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Randomly choose a background color and generate a grid\n    background_color = np.random.choice(Color.NOT_BLACK)\n    grid_size = np.random.randint(15, 30)\n    grid = np.full((grid_size, grid_size), background_color)\n\n    # Step 2: Randomly determine the number of circles and their properties\n    num_circles = np.random.randint(5, 15)\n    colors_used = set()\n\n    for _ in range(num_circles):\n        color = np.random.choice(Color.NOT_BLACK)\n        while color == background_color or color in colors_used:\n            color = np.random.choice(Color.NOT_BLACK)\n        colors_used.add(color)\n\n        # Step 3: Randomly place circles on the grid\n        circle_radius = np.random.randint(1, 3)\n        center_x = np.random.randint(circle_radius, grid_size - circle_radius)\n        center_y = np.random.randint(circle_radius, grid_size - circle_radius)\n\n        # Draw the circle\n        for dx in range(-circle_radius, circle_radius + 1):\n            for dy in range(-circle_radius, circle_radius + 1):\n                if dx**2 + dy**2 \u003c= circle_radius**2:  # Check if within circle\n                    x = center_x + dx\n                    y = center_y + dy\n                    if 0 \u003c= x \u003c grid_size and 0 \u003c= y \u003c grid_size:\n                        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/129/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/129/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/129/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/129/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/129/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/129/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/129/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/129/images/train_output_2.png"}]}, "index": 129, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color filling, boundary tracing\n\n# description:\n# In the input, you will see a grid containing a single colored object surrounded by a black background.\n# The object can have a complex shape, and its color will be unique. The task is to trace the boundary of the object \n# and fill the interior with a different specified color (e.g., green). The output grid will show the original object \n# color only on its boundary and the new fill color inside.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Detect the colored object (non-black)\n    colored_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=4)\n\n    # There should only be one object detected\n    assert len(colored_objects) == 1\n    object_pixels = colored_objects[0]\n\n    # Get the bounding box of the detected object\n    x, y, w, h = bounding_box(object_pixels, background=Color.BLACK)\n\n    # Fill the interior of the object with green\n    for i in range(x, x + w):\n        for j in range(y, y + h):\n            # Check if the pixel is inside the object and not the boundary\n            if output_grid[i, j] == input_grid[x, y]:  # Check if it matches the original object\u0027s color\n                output_grid[i, j] = Color.GREEN  # Fill with green\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m with a black background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color for the object (not black)\n    object_color = np.random.choice(Color.NOT_BLACK)\n\n    # Define a random shape for the object\n    shape_width = np.random.randint(3, 8)\n    shape_height = np.random.randint(3, 8)\n\n    # Random position to place the object\n    start_x = np.random.randint(1, n - shape_height - 1)\n    start_y = np.random.randint(1, m - shape_width - 1)\n\n    # Draw the object in the grid\n    for i in range(shape_height):\n        for j in range(shape_width):\n            if np.random.rand() \u003c 0.5:  # Randomly fill half the area\n                grid[start_x + i, start_y + j] = object_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/130/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/130/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/130/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/130/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/130/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/130/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/130/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/130/images/train_output_2.png"}]}, "index": 130, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color replacement, object detection, flood fill\n\n# description:\n# In the input, you will see a colored object surrounded by a black background. There is also a small pixel of a different color at the top right corner.\n# To make the output, replace the color of the object with the color of the pixel from the top right corner.\n\ndef main(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # get the color of the pixel in the top right corner\n    corner_color = output_grid[0, -1]\n\n    # find the object in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4)\n    \n    # assuming there is only one object, replace its color with the corner color\n    for obj in objects:\n        output_grid[obj != Color.BLACK] = corner_color\n\n    return output_grid\n\ndef generate_input():\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # select a color for the sprite\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # select a color for the corner pixel\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # ensure the colors are different\n    while object_color == corner_color:\n        corner_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # create a sprite\n    sprite = random_sprite(5, 5, symmetry=\"not_symmetric\", color_palette=[object_color])\n    \n    # place the sprite in the center of the grid\n    x, y = (n - sprite.shape[0]) // 2, (m - sprite.shape[1]) // 2\n    blit_sprite(grid, sprite, x=x, y=y)\n\n    # place a single pixel of the corner color in the top right corner\n    grid[0, -1] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/131/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/131/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/131/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/131/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/131/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/131/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/131/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/131/images/train_output_2.png"}]}, "index": 131, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, color mapping\n\n# description:\n# In the input grid, you will see a central colored pixel surrounded by other colored pixels. \n# Your task is to create an output grid where the colors are mapped radially outward from the center pixel, \n# forming concentric rings of different colors. The outermost ring should be colored based on the colors of the pixels \n# adjacent to the center pixel, the next ring should be based on the pixels adjacent to those, and so on.\n\ndef main(input_grid):\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n    center_x, center_y = n // 2, m // 2  # Assuming the center is the middle pixel\n\n    output_grid = np.zeros_like(input_grid)\n\n    # Collect colors based on rings\n    colors_by_ring = {}\n\n    # Check for each pixel and group them into rings based on their distance from the center\n    for x in range(n):\n        for y in range(m):\n            # Calculate the distance from the center\n            distance = int(np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2))\n            color = input_grid[x, y]\n\n            if distance not in colors_by_ring:\n                colors_by_ring[distance] = []\n            if color not in colors_by_ring[distance]:\n                colors_by_ring[distance].append(color)\n\n    # Fill the output grid based on the collected colors by rings\n    for distance, colors in colors_by_ring.items():\n        # Determine the color for this ring (the first unique color)\n        if len(colors) \u003e 0:\n            ring_color = colors[0]\n            # Draw the ring\n            for x in range(n):\n                for y in range(m):\n                    if int(np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)) == distance:\n                        output_grid[x, y] = ring_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid size\n    n, m = 7, 7  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a central colored pixel\n    center_color = np.random.choice(Color.NOT_BLACK)\n    grid[n // 2, m // 2] = center_color\n\n    # Randomly scatter other colors around the center\n    for x in range(n):\n        for y in range(m):\n            if (x, y) != (n // 2, m // 2):  # Don\u0027t overwrite the center\n                if np.random.rand() \u003c 0.5:  # 50% chance to fill a pixel\n                    grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/132/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/132/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/132/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/132/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/132/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/132/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/132/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/132/images/train_output_2.png"}]}, "index": 132, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, pixel manipulation, connectivity\n\n# description:\n# In the input, you will see a grid with colored pixels. Some of the pixels are either green or yellow (those are special).\n# To create the output:\n# 1. For each green pixel, turn the pixel below it (if it exists) into red.\n# 2. For each yellow pixel, turn the pixel to the right of it (if it exists) into blue.\n# 3. All other pixels remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize output grid\n    output_grid = np.copy(input_grid)\n\n    # Iterate through the grid to apply transformations based on the special colors\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.GREEN:\n                # Change the pixel below to red if it exists\n                if x + 1 \u003c input_grid.shape[0]:\n                    output_grid[x + 1, y] = Color.RED\n            elif color == Color.YELLOW:\n                # Change the pixel to the right to blue if it exists\n                if y + 1 \u003c input_grid.shape[1]:\n                    output_grid[x, y + 1] = Color.BLUE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with random colors\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter some green and yellow pixels\n    num_green = np.random.randint(1, 6)\n    num_yellow = np.random.randint(1, 6)\n\n    for _ in range(num_green):\n        while True:\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            if grid[x, y] == Color.BLACK:  # Ensure the cell is empty\n                grid[x, y] = Color.GREEN\n                break\n\n    for _ in range(num_yellow):\n        while True:\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            if grid[x, y] == Color.BLACK:  # Ensure the cell is empty\n                grid[x, y] = Color.YELLOW\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/133/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/133/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/133/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/133/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/133/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/133/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/133/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/133/images/train_output_2.png"}]}, "index": 133, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color fill, bounding box extraction\n\n# description:\n# In the input you will see a grid with several colored objects. Each object is a closed shape of one color.\n# To make the output grid, detect all objects and fill them with a predetermined color (e.g., yellow).\n# The output should show each detected object filled in with the new color while maintaining their positions.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all the connected components (objects) in the grid.\n    # 2. For each object, fill it with the color yellow.\n    # 3. Return the modified grid with filled objects.\n\n    # 1. Detect all connected components (objects)\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Create a copy of the input grid to modify\n    output_grid = input_grid.copy()\n\n    # 2. For each object, fill it with the color yellow\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n        # Fill the bounding box area with yellow\n        output_grid[x:x + width, y:y + height] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter colored objects on the grid, avoiding black\n    for _ in range(np.random.randint(1, 5)):  # Create 1 to 4 random objects\n        color = np.random.choice([c for c in Color.NOT_BLACK])\n        # Create a small random object shape (2x2 to 3x3)\n        obj_width = np.random.randint(2, 4)\n        obj_height = np.random.randint(2, 4)\n        obj = np.full((obj_width, obj_height), color)\n\n        # Randomly find a free location to place the object\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK, padding=0, border_size=0)\n            blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except:\n            continue  # If placement fails, skip that object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/134/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/134/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/134/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/134/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/134/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/134/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/134/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/134/images/train_output_2.png"}]}, "index": 134, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color transformation\n\n# description:\n# In the input you will see a grid with a pattern of green rectangles and scattered yellow pixels.\n# To make the output, you should detect all the green rectangles and change their color to red, \n# while leaving the yellow pixels unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to store output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components that are green rectangles\n    green_rectangles = detect_objects(grid=input_grid, colors=[Color.GREEN], monochromatic=True, connectivity=4)\n\n    # Change the color of detected green rectangles to red\n    for rectangle in green_rectangles:\n        # Crop the rectangle to get its current color\n        output_grid[np.where(rectangle == Color.GREEN)] = Color.RED\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a background grid with size of n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter yellow pixels on the grid\n    grid = random_scatter_points(grid=grid, color=Color.YELLOW, density=0.3)\n\n    # Randomly generate the number of green rectangles\n    num_rectangles = np.random.randint(1, 5)\n\n    for _ in range(num_rectangles):\n        # Randomly define the dimensions of the rectangle\n        height, width = np.random.randint(2, 6), np.random.randint(2, 6)\n\n        # Randomly find a position for the rectangle\n        x, y = np.random.randint(0, n - height + 1), np.random.randint(0, m - width + 1)\n\n        # Draw the rectangle in green on the grid\n        grid[x:x + height, y:y + width] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/135/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/135/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/135/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/135/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/135/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/135/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/135/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/135/images/train_output_2.png"}]}, "index": 135, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color alignment, grid transformation\n\n# description:\n# In the input, you will see a grid with various colored objects (2x2 squares) scattered across it. \n# Each object has a specific color, and the goal is to rearrange the objects such that all objects of the same color are aligned together in the output grid.\n# The arrangement in the output grid should be in a compact manner, filling from the top-left corner downwards and left to right.\n\ndef main(input_grid):\n    # Step 1: Identify and extract objects from the input grid\n    objects = detect_objects(input_grid, background=Color.BLACK, allowed_dimensions=[(2, 2)])\n    \n    # Step 2: Create a color map to group objects by color\n    color_map = {}\n    for obj in objects:\n        color = obj[0, 0]  # Assume the color is defined by the top-left pixel\n        if color not in color_map:\n            color_map[color] = []\n        color_map[color].append(obj)\n    \n    # Step 3: Create the output grid and initialize its dimensions\n    output_height = len(objects) // 5 + (len(objects) % 5 \u003e 0)  # Max 5 objects per row\n    output_grid = np.full((output_height * 2, 10), Color.BLACK)  # Each object is 2x2\n\n    # Step 4: Place objects into the output grid\n    current_row = 0\n    current_column = 0\n    for color, objs in color_map.items():\n        for obj in objs:\n            # Place object in the output grid\n            blit_sprite(output_grid, obj, x=current_row * 2, y=current_column * 2, background=Color.BLACK)\n            current_column += 1\n            if current_column \u003e= 5:  # Move to the next row after 5 objects\n                current_column = 0\n                current_row += 1\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10x10 filled with black\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a random number of colored objects (2x2 squares)\n    num_objects = np.random.randint(3, 11)  # Choose between 3 and 10 objects\n    colors = np.random.choice(list(Color.NOT_BLACK), size=num_objects, replace=True)\n\n    for color in colors:\n        # Generate a 2x2 object with a specific color\n        obj = np.full((2, 2), color)\n\n        # Find a random free location for the object\n        x, y = random_free_location_for_sprite(grid, obj, border_size=1)\n        \n        # Place the object in the grid\n        blit_sprite(grid, obj, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/136/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/136/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/136/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/136/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/136/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/136/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/136/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/136/images/train_output_2.png"}]}, "index": 136, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# size detection, color transformation, object isolation\n\n# description:\n# In the input, you will see several colored objects of varying sizes. The largest object will be colored in a unique color (e.g., yellow).\n# To make the output, remove all objects except for the largest object and change its color to match the color of the smallest object.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (objects)\n    objects = find_connected_components(input_grid, monochromatic=False)\n\n    # Identify the largest and smallest objects based on pixel count\n    largest_object = max(objects, key=lambda x: np.count_nonzero(x))\n    smallest_object = min(objects, key=lambda x: np.count_nonzero(x))\n\n    # Get the color of the smallest object\n    smallest_color = smallest_object[smallest_object != Color.BLACK][0]\n\n    # Remove all objects from the output grid\n    output_grid[output_grid != Color.BLACK] = Color.BLACK\n\n    # Blit the largest object back to the output grid\n    blit_object(output_grid, largest_object, background=Color.BLACK)\n\n    # Change the color of the largest object to match the smallest object\u0027s color\n    output_grid[output_grid == Color.YELLOW] = smallest_color  # Assuming the largest starts as yellow\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the number of objects to create\n    num_objects = np.random.randint(5, 10)\n\n    # Create objects of varying sizes and colors\n    for _ in range(num_objects):\n        size = np.random.randint(1, 4)  # Object size\n        color = np.random.choice(list(Color.NOT_BLACK))  # Random color\n        sprite = random_sprite(size, size, color_palette=[color])  # Create sprite of the defined color\n\n        # Randomly position the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except:\n            pass  # Ignore if placement fails\n\n    # Ensure that one of the objects is colored yellow to be the largest\n    yellow_sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[Color.YELLOW])\n    try:\n        x, y = random_free_location_for_sprite(grid, yellow_sprite, padding=1)\n        blit_sprite(grid, yellow_sprite, x, y)\n    except:\n        pass  # Ignore if placement fails\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/137/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/137/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/137/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/137/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/137/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/137/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/137/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/137/images/train_output_2.png"}]}, "index": 137, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, pattern transformation\n\n# description:\n# In the input you will see a grid with a specific 2x2 color pattern (a square of red pixels).\n# To make the output grid, you should detect the 2x2 red square and replace it with a 2x2 yellow square.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all 2x2 red squares in the grid\n    # 2. Replace each detected red square with a yellow square\n\n    # 1. Detect all 2x2 red squares\n    output_grid = input_grid.copy()\n    red_squares = [(x, y) for x in range(input_grid.shape[0] - 1)\n                   for y in range(input_grid.shape[1] - 1)\n                   if np.all(input_grid[x:x+2, y:y+2] == Color.RED)]\n\n    # 2. Replace the detected red squares with yellow squares\n    for x, y in red_squares:\n        output_grid[x:x+2, y:y+2] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid with size of n x m.\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter color pixels in the grid, ensuring some 2x2 red squares exist.\n    available_colors = [Color.BLUE, Color.GREEN, Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON]\n    density = 0.5  # density of colored pixels\n    colored = 0\n\n    while colored \u003c density * n * m:\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = np.random.choice(available_colors)\n            colored += 1\n\n    # Ensure there is at least one 2x2 red square in the grid.\n    if np.random.rand() \u003c 0.5:  # 50% chance to place a red square\n        red_square = np.full((2, 2), Color.RED)\n        x, y = np.random.randint(0, n - 1), np.random.randint(0, m - 1)\n        grid[x:x+2, y:y+2] = red_square\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/138/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/138/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/138/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/138/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/138/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/138/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/138/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/138/images/train_output_2.png"}]}, "index": 138, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel removal, grid transformation, pattern extraction\n\n# description:\n# In the input you will see a grid with a colored pattern. \n# To make the output, remove every third pixel in the pattern starting from the top-left corner.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of input grid\n    n, m = input_grid.shape\n    output_grid = np.copy(input_grid)\n\n    # Iterate over each pixel in the grid\n    for x in range(n):\n        for y in range(m):\n            # Remove every third pixel\n            if (x * m + y) % 3 == 0:\n                output_grid[x, y] = Color.BLACK  # Set to background color (black)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the grid\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n\n    # Generate a random color pattern\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define a palette of colors\n    colors = random.sample(Color.NOT_BLACK, 5)  # Select 5 random colors from non-black colors\n\n    # Fill the grid with random colors\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/139/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/139/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/139/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/139/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/139/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/139/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/139/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/139/images/train_output_2.png"}]}, "index": 139, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color replacement\n\n# description:\n# In the input you will see a grid with a distinct pattern of two colors arranged in a checkerboard style.\n# To make the output, you should detect the checkerboard pattern and replace it with a new color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n    \n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n    \n    # Define the colors that we want to detect in a checkerboard pattern\n    colors_to_check = [Color.RED, Color.BLUE]\n    \n    # Check for a checkerboard pattern\n    for x in range(n - 1):\n        for y in range(m - 1):\n            # Get the current 2x2 block\n            block = input_grid[x:x+2, y:y+2]\n            \n            # Check if the block forms a checkerboard pattern with the defined colors\n            if (np.all(block[0, 0] == colors_to_check[0]) and \n                np.all(block[0, 1] == colors_to_check[1]) and \n                np.all(block[1, 0] == colors_to_check[1]) and \n                np.all(block[1, 1] == colors_to_check[0])):\n                # Replace the 2x2 checkerboard pattern with a new color (Color.GREEN)\n                output_grid[x:x+2, y:y+2] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n, m = np.random.randint(4, 10), np.random.randint(4, 10)\n    \n    # Create an empty grid\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly scatter colors in a checkerboard pattern\n    colors = [Color.RED, Color.BLUE]\n    \n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = colors[(x + y) % 2]  # Create a checkerboard pattern\n    \n    # Randomly place additional pixels to disrupt the pattern\n    density = 0.3  # density of additional colors\n    num_additional = int(density * n * m)\n    \n    for _ in range(num_additional):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:  # Don\u0027t overwrite existing colors\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)  # Add a random non-black color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/140/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/140/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/140/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/140/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/140/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/140/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/140/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/140/images/train_output_2.png"}]}, "index": 140, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection\n\n# description:\n# In the input, you will see a grid with a colored pattern of pixels. The pattern consists of red, blue, and green pixels.\n# To create the output grid, you need to create a symmetric reflection of the colored pattern across the vertical axis of the grid,\n# while keeping the original colored pixels on the left side unchanged. Any pixel on the right side that corresponds to a location\n# on the left side should be colored to match the left side\u0027s color. If the pixel on the left is black, the corresponding pixel on the right should also be black.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n    n, m = output_grid.shape\n\n    # Reflect the left half of the grid to the right half\n    for i in range(n):\n        for j in range(m // 2):\n            output_grid[i, m - j - 1] = output_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 black grid for the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter red, blue, and green pixels on the left half of the grid\n    for i in range(n):\n        for j in range(m // 2):\n            if np.random.rand() \u003c 0.3:  # 30% chance to place a color\n                grid[i, j] = np.random.choice([Color.RED, Color.BLUE, Color.GREEN])\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/141/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/141/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/141/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/141/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/141/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/141/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/141/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/141/images/train_output_2.png"}]}, "index": 141, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pattern completion\n\n# description:\n# In the input you will see a pattern that is partially symmetrical about a central horizontal line.\n# The output should be the completed pattern to make it fully symmetrical about that central line.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Determine the center line along which we will enforce symmetry\n    center_line = output_grid.shape[0] // 2\n    \n    # Complete the symmetry by reflecting the top half over the center line into the bottom half\n    for i in range(center_line):\n        for j in range(output_grid.shape[1]):\n            if output_grid[center_line - 1 - i, j] != Color.BLACK:\n                output_grid[center_line + i, j] = output_grid[center_line - 1 - i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid with a central horizontal line of symmetry\n    height, width = np.random.randint(6, 12), np.random.randint(6, 12)\n    grid = np.zeros((height, width), dtype=int)\n\n    # Generate a random pattern for the top half of the grid\n    pattern = random_sprite(n=height // 2, m=width, density=0.5, symmetry=None, color_palette=Color.NOT_BLACK)\n\n    # Place the pattern in the top half of the grid\n    grid[:height // 2, :] = pattern\n    \n    # Optionally occlude some areas in the bottom half to introduce asymmetry\n    for i in range(height // 2, height):\n        for j in range(width):\n            if np.random.rand() \u003c 0.3:  # 30% chance to fill with black\n                grid[i, j] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/142/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/142/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/142/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/142/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/142/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/142/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/142/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/142/images/train_output_2.png"}]}, "index": 142, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reflection, color transformation\n\n# description:\n# In the input, you will see a grid containing a pattern of colored pixels on the left side. \n# To create the output, you should reflect the pattern horizontally across the vertical center line of the grid \n# and change its color as follows: \n# red -\u003e blue, blue -\u003e green, green -\u003e red. The reflected pattern should be placed on the right side of the grid.\n\ndef main(input_grid):\n    # Get the height and width of the input grid\n    height, width = input_grid.shape\n\n    # Calculate the vertical center line for reflection\n    center_x = width // 2\n\n    # Prepare the output grid with the same dimensions\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Loop through each pixel in the left half of the grid\n    for y in range(height):\n        for x in range(center_x):\n            color = input_grid[y, x]\n\n            # Determine the new color based on the transformation rules\n            if color == Color.RED:\n                new_color = Color.BLUE\n            elif color == Color.BLUE:\n                new_color = Color.GREEN\n            elif color == Color.GREEN:\n                new_color = Color.RED\n            else:\n                continue  # If the color is not one of the specified colors, skip it\n\n            # Calculate the reflected position in the output grid\n            output_grid[y, width - x - 1] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random sized grid with black background\n    n = np.random.randint(5, 10)  # height of the grid\n    m = np.random.randint(5, 10)  # width of the grid\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the colors available for the pattern\n    available_colors = [Color.RED, Color.BLUE, Color.GREEN]\n\n    # Create a pattern on the left side of the grid\n    for y in range(n):\n        for x in range(m // 2):  # Only fill the left half\n            # Randomly assign a color to each pixel\n            grid[y, x] = np.random.choice(available_colors + [Color.BLACK])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/143/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/143/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/143/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/143/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/143/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/143/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/143/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/143/images/train_output_2.png"}]}, "index": 143, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color pattern recognition, vertical alignment\n\n# description:\n# In the input, you will see a grid with colored columns representing different patterns. \n# To make the output grid, you should find the columns that have the same pattern (the same color sequence from top to bottom) \n# and align them vertically, stacking them on top of each other, filling empty spaces with black.\n\ndef main(input_grid):\n    # Identify the unique patterns in each column\n    patterns = {}\n    num_rows, num_cols = input_grid.shape\n\n    for col in range(num_cols):\n        # Extract the column as a tuple of colors\n        column_pattern = tuple(input_grid[:, col])\n        if column_pattern in patterns:\n            patterns[column_pattern].append(col)\n        else:\n            patterns[column_pattern] = [col]\n\n    # Create an output grid filled with black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # For each unique pattern, stack the corresponding columns vertically\n    start_row = 0\n    for pattern, cols in patterns.items():\n        for col in cols:\n            # Get the non-black pixels from the column\n            non_black_pixels = input_grid[:, col][input_grid[:, col] != Color.BLACK]\n            num_non_black = non_black_pixels.shape[0]\n            # Place the non-black pixels in the output grid\n            output_grid[start_row:start_row + num_non_black, col] = non_black_pixels\n            start_row += num_non_black\n\n        # Reset start_row for the next unique pattern\n        start_row = 0\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(4, 8), np.random.randint(4, 8)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create patterns in the columns\n    for col in range(m):\n        # Decide a random height for the column (not more than n)\n        height = np.random.randint(1, n + 1)\n        # Generate a random pattern for the column\n        pattern = np.random.choice(list(Color.NOT_BLACK), size=height)\n        # Place the pattern in the column\n        grid[n - height:n, col] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/144/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/144/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/144/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/144/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/144/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/144/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/144/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/144/images/train_output_2.png"}]}, "index": 144, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation, complement\n\n# description:\n# In the input you will see a grid with a pattern of colored pixels. \n# To make the output, rotate the pattern 180 degrees and change the color of the pattern to its complement.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Rotate the input grid 180 degrees\n    rotated_grid = np.rot90(input_grid, k=2)\n\n    # Step 2: Find the complement of the colors in the rotated grid\n    # Create a mapping of colors to their complements\n    color_complement = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.RED,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.TEAL,\n        Color.PINK: Color.GREY,\n        Color.GREY: Color.PINK,\n        Color.ORANGE: Color.BLACK,\n        Color.BLACK: Color.ORANGE\n    }\n\n    # Create the output grid by replacing each color with its complement\n    output_grid = np.copy(rotated_grid)\n    for color in color_complement:\n        output_grid[output_grid == color] = color_complement[color]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid with a pattern of colors\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n\n    # Create a grid filled with a random color pattern\n    grid = random_sprite(n, m, density=0.5, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/145/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/145/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/145/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/145/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/145/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/145/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/145/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/145/images/train_output_2.png"}]}, "index": 145, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, grid transformation\n\n# description:\n# In the input grid, each cell contains a color from the set of colors. \n# To make the output grid, follow the mapping:\n# red -\u003e blue, blue -\u003e yellow, yellow -\u003e green, green -\u003e red\n# If a cell is black, it remains black. The grid should be transformed according to this mapping.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Perform color mapping\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n\n# Constructing the color map\ncolor_map = {\n    Color.RED: Color.BLUE,\n    Color.BLUE: Color.YELLOW,\n    Color.YELLOW: Color.GREEN,\n    Color.GREEN: Color.RED\n}\n\ndef generate_input():\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)  # Random grid size\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n    \n    # Randomly fill the grid with colors\n    colors = list(color_map.keys())\n    for x in range(n):\n        for y in range(m):\n            if np.random.random() \u003e 0.5:  # 50% chance to fill a cell with a color\n                grid[x, y] = np.random.choice(colors)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/146/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/146/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/146/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/146/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/146/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/146/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/146/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/146/images/train_output_2.png"}]}, "index": 146, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern, rotation\n\n# description:\n# In the input, you will see a grid containing a 3x3 colored pattern. The output should be the same grid size but with the 3x3 pattern rotated 90 degrees clockwise and repeated to fill the entire output grid.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid of the same size\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # Extract the 3x3 pattern from the input grid\n    pattern = input_grid[0:3, 0:3]\n\n    # Rotate the pattern 90 degrees clockwise\n    rotated_pattern = np.rot90(pattern, k=-1)\n\n    # Fill the output grid with the rotated pattern\n    for i in range(0, n, 3):\n        for j in range(0, m, 3):\n            output_grid[i:i+3, j:j+3] = rotated_pattern\n\n    return output_grid\n\ndef generate_input():\n    # Create a 3x3 array of randomly chosen, non-black, colors\n    grid = np.random.choice(Color.NOT_BLACK, size=(3, 3))\n\n    # Create a larger grid to fill with the 3x3 pattern\n    size = np.random.randint(6, 12)  # Size of the output grid should be larger\n    output_grid = np.zeros((size, size), dtype=int)\n\n    # Place the 3x3 pattern in the top-left corner of the output grid\n    output_grid[0:3, 0:3] = grid\n\n    return output_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/147/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/147/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/147/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/147/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/147/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/147/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/147/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/147/images/train_output_2.png"}]}, "index": 147, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, rotation, color correspondence, pattern expansion\n\n# description:\n# In the input, you will see a 3x3 sprite that acts as a tile pattern and a larger square of the same color.\n# To create the output, you should fill the larger square with copies of the 3x3 pattern. If the larger square \n# is blue, the pattern should be rotated 90 degrees clockwise before filling.\n\ndef main(input_grid):\n    # Find the 3x3 pattern tile and the larger square\n    objects = detect_objects(grid=input_grid, monochromatic=True, connectivity=8)\n    tile_pattern = None\n    larger_square = None\n\n    for obj in objects:\n        cropped_obj = crop(grid=obj, background=Color.BLACK)\n        if cropped_obj.shape == (3, 3):\n            tile_pattern = cropped_obj\n        elif cropped_obj.shape[0] \u003e 3 and cropped_obj.shape[1] \u003e 3:\n            larger_square = cropped_obj\n\n    assert tile_pattern is not None, \"Tile pattern not found.\"\n    assert larger_square is not None, \"Larger square not found.\"\n\n    # Check the color of the larger square\n    if np.any(larger_square == Color.BLUE):\n        tile_pattern = np.rot90(tile_pattern, k=-1)  # Rotate 90 degrees clockwise\n\n    # Fill the larger square with the tile pattern\n    output_grid = input_grid.copy()\n    tile_height, tile_width = tile_pattern.shape\n    large_height, large_width = larger_square.shape\n\n    for i in range(0, large_height, tile_height):\n        for j in range(0, large_width, tile_width):\n            output_grid[i:i + tile_height, j:j + tile_width] = tile_pattern\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = np.random.randint(12, 16), np.random.randint(12, 16)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a 3x3 tile pattern\n    tile_pattern = random_sprite(n=3, m=3, density=0.5)\n\n    # Create a larger square that is a multiple of the tile size\n    scale = np.random.randint(2, 5)  # Scale factor\n    larger_square = np.full((scale * 3, scale * 3), Color.BLUE if np.random.rand() \u003e 0.5 else Color.RED)\n\n    # Place the larger square in a random location\n    x_pos, y_pos = random_free_location_for_sprite(grid, larger_square)\n    grid = blit_sprite(x=x_pos, y=y_pos, grid=grid, sprite=larger_square, background=Color.BLACK)\n\n    # Place the tile pattern in a random location\n    tile_x_pos, tile_y_pos = random_free_location_for_sprite(grid, tile_pattern)\n    grid = blit_sprite(x=tile_x_pos, y=tile_y_pos, grid=grid, sprite=tile_pattern, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/148/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/148/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/148/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/148/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/148/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/148/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/148/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/148/images/train_output_2.png"}]}, "index": 148, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color uniqueness, transformation\n\n# description:\n# In the input, you will see a grid with several colored objects on a black background.\n# Each colored object consists of connected pixels of the same color. To make the output,\n# find the object with the maximum number of unique colors and output it. All other pixels should be black.\n\ndef main(input_grid):\n    # Find all connected components (objects)\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Initialize variables to track the object with the maximum number of unique colors\n    max_unique_colors = 0\n    target_object = None\n\n    # Analyze each object\n    for obj in objects:\n        unique_colors = set(obj.flatten()) - {Color.BLACK}  # Exclude background color\n        num_unique_colors = len(unique_colors)\n\n        # Update if this object has more unique colors\n        if num_unique_colors \u003e max_unique_colors:\n            max_unique_colors = num_unique_colors\n            target_object = obj\n\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    if target_object is not None:\n        # Color the target object in the output grid\n        output_grid[target_object != Color.BLACK] = target_object[target_object != Color.BLACK]\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid of size (10, 10)\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of objects (between 1 and 5)\n    num_objects = np.random.randint(1, 6)\n\n    for _ in range(num_objects):\n        # Create a random sprite with connected color pixels\n        sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), symmetry=None, color_palette=None)\n        # Choose a random free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except Exception:\n            continue  # If we cannot place the sprite, continue to try another one\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/149/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/149/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/149/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/149/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/149/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/149/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/149/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/149/images/train_output_2.png"}]}, "index": 149, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, mirroring, positioning\n\n# description:\n# In the input you will see a grid with a smaller pattern at the center encased in a specific color.\n# The output should mirror the pattern horizontally and vertically, placing the mirrored pattern back into the grid \n# while keeping the original color of the encasing.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Crop the pattern out from the input grid\n    cropped_pattern = crop(input_grid, background=Color.BLACK)\n    \n    # Get the bounding box coordinates of the pattern\n    x, y, width, height = bounding_box(cropped_pattern)\n    \n    # Mirror the pattern both horizontally and vertically\n    mirrored_pattern = np.flipud(np.fliplr(cropped_pattern))\n    \n    # Create a new output grid of the same size as the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Blit the original pattern back to the center of the output grid\n    output_grid = blit_sprite(output_grid, cropped_pattern, x=x, y=y, background=Color.BLACK)\n    \n    # Blit the mirrored pattern into the output grid\n    output_grid = blit_sprite(output_grid, mirrored_pattern, x=x + width, y=y + height, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the pattern\n    n, m = random.randint(3, 6), random.randint(3, 6)\n\n    # Choose a color for the encasing\n    encasing_color = random.choice(Color.NOT_BLACK)\n    \n    # Generate a random pattern\n    pattern_color = random.choice(Color.NOT_BLACK)\n    pattern = random_sprite(n, m, color_palette=[pattern_color], density=0.4)\n\n    # Create a grid large enough to contain the pattern encased in the encasing color\n    grid_size = max(n, m) * 2\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Place the pattern at the center of the grid\n    start_x = (grid_size - n) // 2\n    start_y = (grid_size - m) // 2\n    grid = blit_sprite(grid, pattern, x=start_x, y=start_y, background=Color.BLACK)\n\n    # Encasing the pattern with the encasing color\n    grid[start_x - 1, start_y - 1] = encasing_color\n    grid[start_x - 1, start_y + m] = encasing_color\n    grid[start_x + n, start_y - 1] = encasing_color\n    grid[start_x + n, start_y + m] = encasing_color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/150/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/150/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/150/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/150/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/150/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/150/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/150/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/150/images/train_output_2.png"}]}, "index": 150, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color replacement, pattern detection\n\n# description:\n# In the input, you will see a grid filled with colored pixels. Among these colors, one color appears exactly two times in the grid.\n# To create the output grid, find the cells that contain this unique color and replace them with two adjacent cells of a different color (e.g., red) while keeping all other colors intact.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Identify the color that appears exactly twice in the grid.\n    # 2. Replace those two occurrences with red pixels.\n\n    output_grid = np.copy(input_grid)\n\n    # 1. Find the color that appears exactly twice\n    color_count = {}\n    for color in Color.NOT_BLACK:\n        count = np.count_nonzero(input_grid == color)\n        if count == 2:\n            special_color = color\n            break\n\n    # 2. Get the positions of the special color\n    positions = np.argwhere(input_grid == special_color)\n\n    # Replace the two occurrences with red pixels\n    for pos in positions:\n        output_grid[tuple(pos)] = Color.RED\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random colors ensuring one color occurs exactly twice\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose colors ensuring one color appears twice\n    all_colors = list(Color.NOT_BLACK)\n    special_color = np.random.choice(all_colors)\n    \n    # Set the special color exactly twice\n    positions = [(np.random.randint(n), np.random.randint(m)) for _ in range(2)]\n    for pos in positions:\n        grid[tuple(pos)] = special_color\n\n    # Remove the special color from the options\n    remaining_colors = [color for color in all_colors if color != special_color]\n\n    # Fill the rest of the grid with random colors ensuring they don\u0027t interfere with the special color count\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.BLACK: # Only fill empty cells\n                grid[i, j] = np.random.choice(remaining_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/151/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/151/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/151/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/151/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/151/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/151/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/151/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/151/images/train_output_2.png"}]}, "index": 151, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line detection, shape transformation\n\n# description:\n# In the input you will see a grid with a diagonal line of a single color.\n# To make the output grid, you should detect the diagonal line and transform it into a triangle of the same color.\n\ndef main(input_grid):\n    # Detect diagonal line color and its coordinates\n    line_color = None\n    line_coords = []\n\n    for x in range(len(input_grid)):\n        for y in range(len(input_grid[0])):\n            if input_grid[x, y] != Color.BLACK:\n                # Check if the pixel is part of a diagonal line\n                if x == y:  # Check for diagonal from top-left to bottom-right\n                    line_coords.append((x, y))\n                    line_color = input_grid[x, y]\n    \n    # Create an output grid and set it to the background color (black)\n    output_grid = np.zeros_like(input_grid)\n\n    # Determine the size of the triangle based on the length of the detected line\n    triangle_height = len(line_coords)\n\n    # Draw a triangle of the same color in the output grid\n    for i in range(triangle_height):\n        for j in range(i + 1):  # Each row increases in width\n            output_grid[i, j] = line_color\n    \n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random color for the diagonal line\n    diagonal_color = np.random.choice(Color.NOT_BLACK)\n\n    # Draw a diagonal line of the chosen color\n    for i in range(min(n, m)):\n        grid[i, i] = diagonal_color\n\n    # Randomly scatter other colors to fill the background\n    available_colors = [c for c in Color.NOT_BLACK if c != diagonal_color]\n    for _ in range(int(n * m * 0.3)):  # Fill approximately 30% of the grid\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:  # Ensure we don\u0027t overwrite the diagonal line\n            grid[x, y] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/152/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/152/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/152/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/152/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/152/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/152/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/152/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/152/images/train_output_2.png"}]}, "index": 152, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection, color transformation\n\n# description:\n# In the input, you will see a grid with two colors: one color representing a line of symmetry and another color representing points to be reflected across that line.\n# The output should be a grid where the points of the second color are reflected across the line of symmetry defined by the first color.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n    n, m = input_grid.shape\n\n    # Find the line of symmetry (which is represented by the first color found)\n    symmetry_color = None\n    symmetry_line = -1\n    \n    # Identify the symmetry color and its position\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] != Color.BLACK:  # Ignore black as background\n                symmetry_color = input_grid[i, j]\n                symmetry_line = i  # We will assume horizontal symmetry for simplicity\n                break\n        if symmetry_line != -1:\n            break\n\n    # Reflect points across the symmetry line\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] != Color.BLACK and input_grid[i, j] != symmetry_color:\n                # Reflect across the symmetry line\n                reflected_row = 2 * symmetry_line - i\n                \n                if 0 \u003c= reflected_row \u003c n:\n                    output_grid[reflected_row, j] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 black grid for the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a line of symmetry (horizontal) at a random row in the grid\n    symmetry_row = np.random.randint(1, n-1)\n    grid[symmetry_row, :] = Color.GREEN  # Color.GREEN is the symmetry line color\n\n    # Randomly scatter points of another color (not on the symmetry line) for reflection\n    num_points = np.random.randint(5, 15)\n    for _ in range(num_points):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        while x == symmetry_row:  # Ensure we don\u0027t place a point on the symmetry line\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.RED  # Color.RED is the point color to reflect\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/153/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/153/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/153/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/153/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/153/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/153/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/153/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/153/images/train_output_2.png"}]}, "index": 153, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color merging\n\n# description:\n# In the input, you will see a grid with colored objects. \n# To create the output grid, you should merge the colors of all objects into one color (yellow)\n# and if two objects of different colors overlap, the resulting color should be red.\n\ndef main(input_grid):\n    # Find all connected components (objects) in the grid\n    objects = find_connected_components(grid=input_grid, monochromatic=False, background=Color.BLACK, connectivity=4)\n\n    output_grid = np.full(input_grid.shape, Color.BLACK)  # Start with a black background for the output grid\n\n    # Create a mapping of colors to their merged colors\n    color_mapping = {Color.YELLOW: Color.YELLOW, Color.BLUE: Color.YELLOW, Color.GREEN: Color.YELLOW, Color.RED: Color.YELLOW}\n\n    # Create a mask to keep track of where colors have been placed\n    for obj in objects:\n        # Determine the unique colors in the object\n        unique_colors = np.unique(obj)\n        unique_colors = unique_colors[unique_colors != Color.BLACK]  # Exclude the background color\n\n        # If there is only one color, merge it into the output grid\n        if len(unique_colors) == 1:\n            color = unique_colors[0]\n            output_grid[obj != Color.BLACK] = color_mapping.get(color, color)  # Merge according to mapping\n        else:\n            # If there are multiple colors, set the area to red\n            output_grid[obj != Color.BLACK] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random objects of different colors\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Randomly create colored objects\n    colors = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]\n    for _ in range(np.random.randint(3, 6)):  # Generate 3 to 5 objects\n        obj_width, obj_height = np.random.randint(1, 4), np.random.randint(1, 4)  # Random size for objects\n        color = np.random.choice(colors)  # Randomly choose an object color\n        sprite = random_sprite(n=obj_width, m=obj_height, color_palette=[color], density=1.0)  # Create a solid color object\n\n        # Find a random location to blit the object\n        x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n        grid = blit_sprite(grid=grid, sprite=sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/154/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/154/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/154/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/154/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/154/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/154/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/154/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/154/images/train_output_2.png"}]}, "index": 154, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape extraction, alignment by specific color\n\n# description:\n# In the input, you will see several colored shapes on a black background. Each shape has a single orange pixel that denotes its \u201canchor\u201d point.\n# To create the output grid, move each shape so that its orange pixel aligns with the center of the grid.\n# The output grid should be the smallest possible size that contains all the shapes after aligning them.\n\ndef main(input_grid):\n    # Extract the shapes from the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Output grid that will hold all shapes after moving them\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Center coordinates for the output grid\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n\n    for shape in shapes:\n        # Check if the shape contains the orange anchor point\n        if Color.ORANGE in shape:\n            # Crop the shape to isolate it\n            cropped_shape = crop(shape, background=Color.BLACK)\n\n            # Find the coordinates of the orange pixel\n            orange_pixel_coords = np.argwhere(cropped_shape == Color.ORANGE)[0]\n            orange_pixel_x, orange_pixel_y = orange_pixel_coords\n\n            # Calculate the offsets to center the orange pixel in the output grid\n            x_offset = center_x - orange_pixel_x\n            y_offset = center_y - orange_pixel_y\n\n            # Blit the cropped shape into the output grid at the new position\n            blit_sprite(output_grid, cropped_shape, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    # Ensure the output is as small as possible to contain all shapes\n    output_grid = crop(output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random size grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a list to hold the number of shapes and their properties\n    num_shapes = np.random.randint(2, 5)\n\n    for _ in range(num_shapes):\n        # Randomly generate the dimensions of the shape\n        shape_height, shape_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        \n        # Create a shape with a random color but ensure one pixel is orange\n        shape = random_sprite(shape_height, shape_width, density=0.5, color_palette=[Color.ORANGE] + random.sample(Color.NOT_BLACK, 4))\n\n        # Find a free location to place the shape on the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n        blit_sprite(grid, shape, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/155/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/155/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/155/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/155/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/155/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/155/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/155/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/155/images/train_output_2.png"}]}, "index": 155, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color shifting, objects, background\n\n# description:\n# In the input, you will see a colored object on a black background. \n# To make the output, shift the color of the object to the next color in a predefined sequence, while keeping the background unchanged.\n\ndef main(input_grid):\n    # Define the color sequence\n    color_sequence = [\n        Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, \n        Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE, \n        Color.TEAL, Color.MAROON\n    ]\n    \n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Find the bounding box of the colored object\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Loop through the bounding box to find the color of the object\n    for i in range(x, x + width):\n        for j in range(y, y + height):\n            if output_grid[i, j] in Color.NOT_BLACK:\n                current_color = output_grid[i, j]\n                # Find the next color in the sequence\n                next_color_index = (color_sequence.index(current_color) + 1) % len(color_sequence)\n                next_color = color_sequence[next_color_index]\n                output_grid[i, j] = next_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid as the background\n    n = np.random.randint(5, 20)\n    m = np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random color for the object\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random sprite (the colored object)\n    sprite_width, sprite_height = np.random.randint(2, n//2), np.random.randint(2, m//2)\n    sprite = random_sprite(sprite_width, sprite_height, color_palette=[object_color], density=1)\n\n    # Find a random free location for the sprite on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/156/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/156/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/156/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/156/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/156/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/156/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/156/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/156/images/train_output_2.png"}]}, "index": 156, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color replacement, wrapping\n\n# description:\n# In the input, you will see a grid where each cell may contain different colors. \n# To create the output, change the color of each cell to match the color of the cell directly above it. \n# Cells in the first row should inherit their color from the last row to simulate a wrapping effect.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Get the number of rows\n    rows, cols = input_grid.shape\n\n    for r in range(rows):\n        for c in range(cols):\n            if r == 0:\n                # For the first row, take color from the last row (wrapping effect)\n                output_grid[r, c] = input_grid[rows - 1, c]\n            else:\n                # For other rows, take color from the cell directly above\n                output_grid[r, c] = input_grid[r - 1, c]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)  # Grid dimensions between 5x5 and 15x15\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors excluding black\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/157/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/157/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/157/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/157/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/157/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/157/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/157/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/157/images/train_output_2.png"}]}, "index": 157, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# occlusion, symmetry, color inference\n\n# description:\n# In the input you will see a pattern that is vertically symmetric with random colors, but part of it has been occluded by a colored rectangle.\n# The output should recreate the pattern as if the rectangle was removed, ensuring that the resulting grid is perfectly vertically symmetric.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the occluded rectangle\n    # 2. Detect the vertical symmetry of the grid\n    # 3. Reconstruct the occluded part using the symmetry\n\n    occlusion_color = Color.BLACK\n    # Create a mask for the occluded area\n    occluded_mask = (input_grid == occlusion_color)\n    \n    # Detect vertical symmetry\n    symmetries = detect_mirror_symmetry(input_grid, ignore_colors=[occlusion_color])\n\n    # Create a copy of the input grid to modify\n    output_grid = input_grid.copy()\n    \n    # Fill in the occluded area based on symmetry\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if occluded_mask[x, y]:  # If it\u0027s part of the occluded area\n                # Find the corresponding point on the other side of the vertical symmetry\n                for symmetry in symmetries:\n                    symmetric_x, symmetric_y = symmetry.apply(x, y)\n                    if 0 \u003c= symmetric_x \u003c output_grid.shape[0] and 0 \u003c= symmetric_y \u003c output_grid.shape[1]:\n                        # Fill in the color from the symmetric position\n                        if output_grid[symmetric_x, symmetric_y] != occlusion_color:\n                            output_grid[x, y] = output_grid[symmetric_x, symmetric_y]\n                            break\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random sprite\n    # 2. Tile it to create a vertically symmetric pattern\n    # 3. Occlude it with a colored rectangle\n\n    # Create a random sprite\n    w, h = np.random.randint(3, 6, size=(2))\n    sprite = random_sprite(w, h, color_palette=Color.NOT_BLACK, density=0.7)\n\n    # Tile it to create a vertically symmetric pattern\n    horizontal_repetitions = np.random.randint(2, 5)\n    pattern = np.tile(sprite, (1, horizontal_repetitions))\n\n    # Occlude it with a randomly placed colored rectangle\n    w_occluder, h_occluder = np.random.randint(1, 4, size=(2))\n    x_occluder = np.random.randint(0, pattern.shape[0] - 1)\n    y_occluder = np.random.randint(0, pattern.shape[1] - h_occluder)\n    occluder_color = np.random.choice(Color.NOT_BLACK)\n    occluder_sprite = np.full((w_occluder, h_occluder), occluder_color)\n    blit_sprite(pattern, occluder_sprite, x=x_occluder, y=y_occluder, background=None)\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/158/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/158/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/158/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/158/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/158/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/158/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/158/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/158/images/train_output_2.png"}]}, "index": 158, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color propagation\n\n# description:\n# In the input you will see a grid of colored pixels with some yellow and orange pixels present.\n# To create the output:\n# 1. For each yellow pixel, add blue pixels in its immediate horizontal neighbors (left and right).\n# 2. For each orange pixel, add pink pixels in its immediate vertical neighbors (up and down).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.YELLOW:\n                # put blue pixels in the horizontal neighbors\n                if y \u003e 0:  # left neighbor\n                    output_grid[x, y - 1] = Color.BLUE\n                if y \u003c input_grid.shape[1] - 1:  # right neighbor\n                    output_grid[x, y + 1] = Color.BLUE\n            elif color == Color.ORANGE:\n                # put pink pixels in the vertical neighbors\n                if x \u003e 0:  # upper neighbor\n                    output_grid[x - 1, y] = Color.PINK\n                if x \u003c input_grid.shape[0] - 1:  # lower neighbor\n                    output_grid[x + 1, y] = Color.PINK\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    num_yellow, num_orange, num_other = np.random.randint(1, 5), np.random.randint(1, 5), np.random.randint(1, 5)\n\n    for _ in range(num_yellow):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.YELLOW\n    \n    for _ in range(num_orange):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.ORANGE\n    \n    for _ in range(num_other):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color not in [Color.YELLOW, Color.ORANGE]])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/159/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/159/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/159/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/159/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/159/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/159/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/159/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/159/images/train_output_2.png"}]}, "index": 159, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, growing, grid expansion\n\n# description:\n# In the input, you will see a grid with several colored pixels. For each colored pixel, you will create a square of the same color, but this time the squares will be of a fixed size of 3x3, centered around each pixel. The output grid should be large enough to accommodate all these squares without overlapping or going out of bounds.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the size of the input grid\n    n, m = input_grid.shape\n    \n    # Output grid size will be increased by a margin to accommodate 3x3 squares\n    output_grid = np.zeros((n + 2, m + 2), dtype=int)  # Expand size by 2 in each direction\n\n    # For each pixel in the input grid, draw a 3x3 square in the output grid\n    for x in range(n):\n        for y in range(m):\n            color = input_grid[x, y]\n            if color != Color.BLACK:  # Only process non-black pixels\n                # Define the top-left corner of the 3x3 square\n                top_left_x = x + 1  # Offset by 1\n                top_left_y = y + 1  # Offset by 1\n                \n                # Fill the 3x3 area with the same color\n                for dx in range(3):\n                    for dy in range(3):\n                        output_grid[top_left_x + dx, top_left_y + dy] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter some colored pixels (not black) throughout the grid\n    num_pixels = np.random.randint(1, 10)  # Random number of colored pixels\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(list(Color.NOT_BLACK))  # Choose a random color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/160/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/160/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/160/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/160/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/160/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/160/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/160/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/160/images/train_output_2.png"}]}, "index": 160, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, object manipulation\n\n# description:\n# In the input you will see a grid with several colored objects.\n# To make the output grid, you should rotate each object 180 degrees around its center.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find all connected components (colored objects) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    \n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    for obj in objects:\n        # Get the bounding box of the current object\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        \n        # Crop the object\n        cropped_object = crop(obj, background=Color.BLACK)\n        \n        # Rotate the cropped object by 180 degrees\n        rotated_object = np.rot90(cropped_object, k=2)\n        \n        # Calculate the new position to place the rotated object in the output grid\n        new_x = x\n        new_y = y  # Maintain the same top-left corner for simplicity\n        \n        # Blit the rotated object onto the output grid\n        output_grid = blit_sprite(output_grid, rotated_object, new_x, new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a square grid of random colors and shapes\n    grid_len = np.random.randint(6, 12)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    num_objects = np.random.randint(1, 5)  # Random number of objects to place\n\n    for _ in range(num_objects):\n        sprite_width = np.random.randint(2, 5)\n        sprite_height = np.random.randint(2, 5)\n        sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=Color.NOT_BLACK, density=0.5)\n        # Place the sprite in a random free location on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n        grid = blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/161/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/161/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/161/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/161/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/161/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/161/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/161/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/161/images/train_output_2.png"}]}, "index": 161, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color transformation\n\n# description:\n# In the input, you will see a grid with a central pattern surrounded by a border of pixels. \n# The four corners of the input grid will have outer border pixels of different colors. \n# To make the output, you should extract the central pattern and change the color of each pixel to the color of the corresponding outer corner of the input.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central pattern by cropping the input grid\n    output_grid = crop(grid=input_grid)\n\n    # Determine the colors of the corner pixels\n    top_left_color = input_grid[0, 0]\n    top_right_color = input_grid[0, -1]\n    bottom_left_color = input_grid[-1, 0]\n    bottom_right_color = input_grid[-1, -1]\n\n    # Create a grid to hold the transformed output based on corner colors\n    transformed_output = np.empty_like(output_grid)\n\n    # Assign corner colors to the corresponding pixels in the central pattern\n    transformed_output[0, :] = top_left_color  # Top row\n    transformed_output[-1, :] = bottom_left_color  # Bottom row\n    transformed_output[:, 0] = top_left_color  # Left column\n    transformed_output[:, -1] = bottom_right_color  # Right column\n\n    # Fill the inner area with the corresponding corner colors\n    for i in range(1, output_grid.shape[0] - 1):\n        for j in range(1, output_grid.shape[1] - 1):\n            transformed_output[i, j] = (top_left_color if i \u003c output_grid.shape[0] // 2 and j \u003c output_grid.shape[1] // 2 else\n                                         bottom_right_color if i \u003e= output_grid.shape[0] // 2 and j \u003e= output_grid.shape[1] // 2 else\n                                         top_right_color if i \u003c output_grid.shape[0] // 2 else\n                                         bottom_left_color)\n\n    return transformed_output\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the pattern \n    n, m = random.randint(5, 10), random.randint(5, 10)\n\n    # Generate colors for the corners and inner pattern\n    corner_colors = random.sample(Color.NOT_BLACK, 4)\n\n    # Create a grid with a border of corner colors\n    grid = np.zeros((n, m), dtype=int)\n\n    # Set the corner colors\n    grid[0, 0] = corner_colors[0]  # Top left\n    grid[0, -1] = corner_colors[1]  # Top right\n    grid[-1, 0] = corner_colors[2]  # Bottom left\n    grid[-1, -1] = corner_colors[3]  # Bottom right\n\n    # Create a central pattern of random colors\n    central_pattern = random_sprite(n - 2, m - 2, density=0.5, color_palette=random.sample(Color.NOT_BLACK, 1))\n\n    # Place the central pattern into the grid\n    grid[1:-1, 1:-1] = central_pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/162/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/162/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/162/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/162/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/162/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/162/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/162/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/162/images/train_output_2.png"}]}, "index": 162, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, sliding objects\n\n# description:\n# In the input you will see a pattern of colored dots in the top left corner of the grid, and a larger pattern of colored dots elsewhere in the grid. \n# To make the output, slide the smaller pattern so that it overlaps with the larger pattern, matching colors where possible.\n\ndef main(input_grid):\n    # Detect the smaller pattern in the top left corner\n    small_pattern = input_grid[:3, :3]  # Assuming the small pattern is a 3x3 area\n    large_pattern = input_grid[3:, 3:]   # The large pattern is assumed to start from (3, 3)\n    \n    # Create an output grid that is the same size as input\n    output_grid = np.copy(input_grid)\n\n    # Find the position of the large pattern\n    large_x, large_y, large_w, large_h = bounding_box(large_pattern)\n\n    # Slide small pattern over the large pattern\n    for dx in range(0, large_w - 2):  # Slide horizontally\n        for dy in range(0, large_h - 2):  # Slide vertically\n            # Check for color matches\n            match = True\n            for i in range(3):\n                for j in range(3):\n                    if large_pattern[dy + i, dx + j] != Color.BLACK and small_pattern[i, j] != large_pattern[dy + i, dx + j]:\n                        match = False\n                        break\n                if not match:\n                    break\n            \n            # If a match is found, blit the small pattern to the output grid\n            if match:\n                blit_sprite(output_grid, small_pattern, dx + large_x, dy + large_y, background=Color.BLACK)\n                return output_grid  # Return on first match\n\n    return output_grid  # Return original if no match is found\n\ndef generate_input():\n    # Create a grid of random size with black background\n    n = np.random.randint(6, 12)\n    m = np.random.randint(6, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a small random pattern (3x3)\n    small_pattern = random_sprite(3, 3, density=0.5)\n    \n    # Create a larger random pattern (4x4 or larger)\n    large_pattern = random_sprite(np.random.randint(4, 8), np.random.randint(4, 8), density=0.5)\n\n    # Place the small pattern in the top left corner\n    grid[:3, :3] = small_pattern\n\n    # Place the large pattern randomly in the grid without overlapping with the small pattern\n    x_pos, y_pos = random_free_location_for_sprite(grid, large_pattern)\n    blit_sprite(grid, large_pattern, x=x_pos, y=y_pos, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/163/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/163/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/163/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/163/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/163/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/163/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/163/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/163/images/train_output_2.png"}]}, "index": 163, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color transformation\n\n# description:\n# In the input grid, you will see a colored triangle shape on a black grid. \n# To produce the output grid, change the color of the triangle to green, \n# while leaving the rest of the grid unchanged.\n\ndef main(input_grid):\n    # 1. Find the connected component that forms the triangle.\n    # 2. Get the color of the triangle.\n    # 3. Replace the triangle\u0027s color with green.\n\n    # get the connected components\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # Assume there\u0027s only one triangle in the grid\n    triangle = objects[0]\n\n    # Change the triangle\u0027s color to green\n    output_grid = input_grid.copy()\n    output_grid[triangle != Color.BLACK] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Create a blank 20x20 black grid\n    grid = np.full((20, 20), Color.BLACK)\n\n    # Create a triangle shape\n    triangle_height = np.random.randint(3, 8)\n    triangle_base = triangle_height * 2 - 1  # base is double the height minus one to form a triangle\n    triangle_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create triangle in a numpy array\n    triangle = np.full((triangle_height, triangle_base), Color.BLACK)\n    for i in range(triangle_height):\n        triangle[i, triangle_height - 1 - i:triangle_height - 1 - i + (i * 2 + 1)] = triangle_color\n\n    # Find a random location to place the triangle on the grid\n    x = np.random.randint(0, 20 - triangle_height)\n    y = np.random.randint(0, 20 - triangle_base)\n\n    # Blit the triangle onto the grid\n    grid = blit_sprite(grid, triangle, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/164/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/164/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/164/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/164/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/164/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/164/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/164/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/164/images/train_output_2.png"}]}, "index": 164, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object detection, spatial alignment\n\n# description:\n# In the input, you will see a grid with several colored objects, each represented as a 3x3 pixel square. \n# Each square contains a central pixel that is a different color, and the rest of the pixels in the square \n# are a single color. \n# To create the output grid, for each square, replace the color of the outer pixels with the color of the \n# central pixel, effectively changing the square to a solid color that matches the center.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect all 3x3 squares in the grid.\n    # 2. For each square, identify the color of the central pixel.\n    # 3. Replace the colors of the outer pixels with the central color.\n    \n    output_grid = np.copy(input_grid)\n\n    # Step 1: Detect 3x3 squares\n    n, m = input_grid.shape\n    for x in range(n - 2):\n        for y in range(m - 2):\n            square = input_grid[x:x + 3, y:y + 3]\n            if np.all(square[1, 1] != Color.BLACK):  # Central pixel should not be background\n                central_color = square[1, 1]\n                # Step 3: Replace outer pixels with central color\n                output_grid[x:x + 3, y:y + 3] = central_color\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid with random colored squares\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create several 3x3 squares with a different central color\n    number_of_squares = np.random.randint(5, 10)\n\n    for _ in range(number_of_squares):\n        # Choose a random color for the central pixel\n        central_color = np.random.choice(Color.NOT_BLACK)\n        \n        # Create a 3x3 square\n        square = np.full((3, 3), Color.BLACK)\n        square[1, 1] = central_color  # Center pixel is the unique color\n        \n        # Fill the outer pixels with another color\n        outer_color = np.random.choice([c for c in Color.NOT_BLACK if c != central_color])\n        square[0, :] = outer_color\n        square[2, :] = outer_color\n        square[:, 0] = outer_color\n        square[:, 2] = outer_color\n\n        # Try to place the square randomly in the grid\n        while True:\n            x, y = np.random.randint(0, n - 2), np.random.randint(0, m - 2)\n            if np.all(grid[x:x + 3, y:y + 3] == Color.BLACK):  # Check for free space\n                blit_sprite(grid, square, x, y, background=Color.BLACK)\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/165/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/165/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/165/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/165/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/165/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/165/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/165/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/165/images/train_output_2.png"}]}, "index": 165, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, rotation\n\n# description:\n# In the input you will see an image with a random pattern of colored pixels. If the image is symmetric about its center,\n# rotate the image by 90 degrees clockwise for the output. If the image is not symmetric, leave it as it is.\n\ndef main(input_grid):\n    # Check for rotational symmetry about the center of the input grid.\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n    \n    # If a symmetry was found, rotate the grid 90 degrees clockwise.\n    if sym is not None:\n        output_grid = np.rot90(input_grid, k=-1)  # k=-1 for 90 degrees clockwise\n    else:\n        output_grid = np.copy(input_grid)  # No change if not symmetric\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid of specified size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n\n    # Create a random sprite with some colors\n    sprite_size = np.random.randint(3, 5)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=sprite_size * sprite_size)\n    sprite = colors.reshape((sprite_size, sprite_size))\n\n    # Determine a random position to place the sprite\n    x, y = random_free_location_for_sprite(grid, sprite)\n\n    # Place the sprite in the grid\n    blit_sprite(grid, sprite, x, y)\n\n    # Introduce some randomness to make it asymmetric if desired\n    if np.random.rand() \u003c 0.5:  # 50% chance to make it asymmetric\n        # Randomly change one pixel to black within the sprite area\n        random_x = np.random.randint(x, x + sprite_size)\n        random_y = np.random.randint(y, y + sprite_size)\n        grid[random_x, random_y] = Color.BLACK  # Make one pixel black\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/166/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/166/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/166/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/166/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/166/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/166/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/166/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/166/images/train_output_2.png"}]}, "index": 166, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, alignment\n\n# description:\n# In the input, you will see a grid with a single colored square shape (which can be of any size), \n# aligned either horizontally or vertically. To make the output, rotate the shape 90 degrees clockwise.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the connected component which is a monochromatic object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    obj = objects[0]\n\n    # Rotate the object 90 degrees clockwise\n    rotated_object = np.rot90(obj, k=-1)  # k=-1 for clockwise rotation\n\n    # Create an output grid with the same shape as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Determine the position to center the rotated object in the output grid\n    obj_height, obj_width = obj.shape\n    rotated_height, rotated_width = rotated_object.shape\n    start_x = (input_grid.shape[0] - rotated_height) // 2\n    start_y = (input_grid.shape[1] - rotated_width) // 2\n\n    # Blit the rotated object onto the output grid\n    blit_sprite(output_grid, rotated_object, start_x, start_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate a colored square shape\n    n = np.random.randint(2, 6)  # height of the shape\n    m = np.random.randint(2, 6)  # width of the shape\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random sprite that fills the grid with a single color\n    color = random.choice(Color.NOT_BLACK)  # avoid black for visual clarity\n    sprite = np.full((n, m), color, dtype=int)\n\n    # Place the sprite in a random location within a larger grid\n    larger_grid = np.zeros((10, 10), dtype=int)  # larger grid for placement\n    x = np.random.randint(0, larger_grid.shape[0] - n)\n    y = np.random.randint(0, larger_grid.shape[1] - m)\n    blit_sprite(larger_grid, sprite, x, y, background=Color.BLACK)\n\n    return larger_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/167/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/167/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/167/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/167/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/167/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/167/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/167/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/167/images/train_output_2.png"}]}, "index": 167, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input, you will see a colored square object on a black background. \n# To create the output grid, rotate the object 90 degrees clockwise and change its color to orange.\n\ndef main(input_grid):\n    # Find the colored square object in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1\n    colored_object = objects[0]\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Determine the dimensions of the colored object\n    object_height, object_width = colored_object.shape\n\n    # Create a new grid to hold the rotated object\n    rotated_object = np.full((object_width, object_height), Color.BLACK)\n\n    # Rotate the object 90 degrees clockwise\n    for i in range(object_height):\n        for j in range(object_width):\n            rotated_object[j, object_height - 1 - i] = colored_object[i, j]\n\n    # Change the color of the rotated object to orange\n    rotated_object[rotated_object != Color.BLACK] = Color.ORANGE\n\n    # Blit the rotated object onto the output grid (it will be centered)\n    x_offset = (output_grid.shape[0] - rotated_object.shape[0]) // 2\n    y_offset = (output_grid.shape[1] - rotated_object.shape[1]) // 2\n    blit_sprite(output_grid, rotated_object, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of a random size between 5x5 and 10x10\n    n = np.random.randint(5, 11)\n    m = np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random size for the square object (between 2 and min(n, m))\n    square_size = np.random.randint(2, min(n, m))\n    square_object = np.full((square_size, square_size), Color.BLUE)  # Using blue for the original object\n\n    # Find a random free location for the square object\n    x, y = random_free_location_for_sprite(grid, square_object, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, square_object, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/168/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/168/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/168/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/168/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/168/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/168/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/168/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/168/images/train_output_2.png"}]}, "index": 168, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, central pixel detection\n\n# description:\n# In the input, you will see a grid with a single 3x3 square of a specific color surrounded by a different color. \n# The corner pixels will be a different color than the central square. \n# To create the output grid, detect the color of the central square and change all the corner pixels to that color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Create a mask for the central square (3x3) and find its position\n    central_square_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, allowed_dimensions=[(3, 3)], monochromatic=True)\n    \n    assert len(central_square_objects) == 1\n    central_square = central_square_objects[0]\n\n    # Get the position and color of the central square\n    central_color = central_square[1][1]  # Get the color of the center pixel\n    cx, cy = object_position(central_square, background=Color.BLACK, anchor=\"upper left\")\n\n    # Change the corner pixels (top-left, top-right, bottom-left, bottom-right) to the central square\u0027s color\n    corners = [(cx-1, cy-1), (cx-1, cy+3), (cx+3, cy-1), (cx+3, cy+3)]\n    for x, y in corners:\n        if 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:  # Ensure within bounds\n            output_grid[x, y] = central_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # First, create a blank grid with a specific size\n    n, m = 5, 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random color for the central square and different color for the surrounding area\n    central_color = np.random.choice(list(Color.NOT_BLACK))\n    surrounding_color = np.random.choice([color for color in Color.NOT_BLACK if color != central_color])\n\n    # Create the 3x3 central square\n    grid[1:4, 1:4] = central_color\n\n    # Set the surrounding pixels to a different color\n    grid[0, 0] = surrounding_color\n    grid[0, 1] = surrounding_color\n    grid[0, 2] = surrounding_color\n    grid[0, 3] = surrounding_color\n    grid[1, 0] = surrounding_color\n    grid[2, 0] = surrounding_color\n    grid[3, 0] = surrounding_color\n    grid[0, 4] = surrounding_color\n    grid[1, 4] = surrounding_color\n    grid[2, 4] = surrounding_color\n    grid[3, 4] = surrounding_color\n    grid[4, 0] = surrounding_color\n    grid[4, 1] = surrounding_color\n    grid[4, 2] = surrounding_color\n    grid[4, 3] = surrounding_color\n    grid[4, 4] = surrounding_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/169/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/169/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/169/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/169/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/169/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/169/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/169/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/169/images/train_output_2.png"}]}, "index": 169, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, color, intersection\n\n# description:\n# In the input, you will see a grid with a single gray pixel and a single orange pixel.\n# To make the output, draw a horizontal line of the same color as the orange pixel from the left edge of the grid to the column of the orange pixel,\n# and a vertical line of the same color as the gray pixel from the top edge of the grid to the row of the gray pixel.\n# Lastly, draw a blue pixel where the two lines intersect.\n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # get the index of the orange pixel\n    orange = np.where(input_grid == Color.ORANGE)\n    x_orange, y_orange = orange[0][0], orange[1][0]\n\n    # get the index of the gray pixel\n    gray = np.where(input_grid == Color.GRAY)\n    x_gray, y_gray = gray[0][0], gray[1][0]\n\n    # draw horizontal line for the orange pixel\n    output_grid[:, y_orange] = Color.ORANGE\n\n    # draw vertical line for the gray pixel\n    output_grid[x_gray, :] = Color.GRAY\n\n    # draw blue pixel where the lines intersect\n    output_grid[x_gray, y_orange] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # make a 10x10 black grid for the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # put an orange pixel at a random point on the grid\n    x_orange, y_orange = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x_orange, y_orange] = Color.ORANGE\n\n    # put a gray pixel at a random point on the grid but not in the same row or column as the orange pixel\n    x_gray, y_gray = np.random.randint(0, n), np.random.randint(0, m)\n    while x_gray == x_orange or y_gray == y_orange:\n        x_gray, y_gray = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x_gray, y_gray] = Color.GRAY\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/170/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/170/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/170/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/170/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/170/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/170/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/170/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/170/images/train_output_2.png"}]}, "index": 170, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, grid manipulation, color mapping\n\n# description:\n# In the input you will see a grid with a central square of gray pixels surrounded by colored borders. \n# The grid is divided into 4 quadrants. To create the output, rotate the colors in each quadrant 90 degrees clockwise \n# and maintain the gray square in the center.\n\ndef main(input_grid):\n    n, m = input_grid.shape\n    # Define the size of the gray square\n    gray_size = min(n, m) // 4\n    gray_start = (n - gray_size) // 2  # Start position for the gray square\n\n    # Extract the gray square\n    gray_square = input_grid[gray_start:gray_start + gray_size, gray_start:gray_start + gray_size]\n\n    # Create the output grid and fill it with the gray square\n    output_grid = np.full((n, m), Color.BLACK)\n    output_grid[gray_start:gray_start + gray_size, gray_start:gray_start + gray_size] = gray_square\n\n    # Define the quadrants\n    quadrants = [\n        input_grid[:gray_start, :gray_start],  # Top-left\n        input_grid[:gray_start, gray_start + gray_size:],  # Top-right\n        input_grid[gray_start + gray_size:, :gray_start],  # Bottom-left\n        input_grid[gray_start + gray_size:, gray_start + gray_size:],  # Bottom-right\n    ]\n\n    # Rotate each quadrant 90 degrees clockwise and place them in the output grid\n    output_grid[:gray_start, :gray_start] = np.rot90(quadrants[0], -1)\n    output_grid[:gray_start, gray_start + gray_size:] = np.rot90(quadrants[1], -1)\n    output_grid[gray_start + gray_size:, :gray_start] = np.rot90(quadrants[2], -1)\n    output_grid[gray_start + gray_size:, gray_start + gray_size:] = np.rot90(quadrants[3], -1)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a gray center and colored borders\n    n = np.random.randint(8, 12)\n    m = n  # Ensure the grid is square\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the size of the gray square\n    gray_size = min(n, m) // 4\n    gray_start = (n - gray_size) // 2  # Start position for the gray square\n\n    # Fill the gray square\n    grid[gray_start:gray_start + gray_size, gray_start:gray_start + gray_size] = Color.GRAY\n\n    # Fill the borders with random colors\n    colors = list(Color.NOT_BLACK)\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.BLACK:  # Only fill black areas\n                if (i \u003c gray_start or i \u003e= gray_start + gray_size or\n                    j \u003c gray_start or j \u003e= gray_start + gray_size):\n                    grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/171/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/171/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/171/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/171/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/171/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/171/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/171/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/171/images/train_output_2.png"}]}, "index": 171, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, symmetry, occlusion\n\n# description:\n# In the input you will see a pattern that is almost rotationally symmetric except for a few pixels.\n# To make the output, rotate the pattern to make it fully symmetric by filling in the missing parts.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the center of rotation\n    # 2. Detect rotational symmetry\n    # 3. Fill in the missing pixels by rotating existing colors to their corresponding positions\n\n    output_grid = input_grid.copy()\n\n    # Find the rotational symmetry\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n    \n    # If no symmetry is found, return the input as is\n    if sym is None:\n        return output_grid\n\n    # Find the colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Fill in the missing pixels\n    for x, y in colored_pixels:\n        # Get the color, which is going to be copied to the rotated positions\n        color = input_grid[x, y]\n\n        # Loop over all rotations, going 90 degrees each time (so four times)\n        for i in range(1, 4):\n            # Calculate rotated coordinate\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n\n            # Fill in the missing pixel\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n            else:\n                assert output_grid[rotated_x, rotated_y] == color, \"The object is not rotationally symmetric\"\n\n    return output_grid\n\ndef generate_input():\n    # Initialize 10x10 grid filled with black\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Create a sprite that aims for rotational symmetry\n    sprite = random_sprite(\n        4, 4, density=0.5, symmetry=\"radial\", color_palette=list(Color.NOT_BLACK)\n    )\n\n    # Randomly remove some pixels from the sprite to create an occluded version\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.random() \u003c 0.3:  # 30% chance to turn pixel black\n                sprite[i, j] = Color.BLACK\n\n    # Place the sprite randomly onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/172/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/172/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/172/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/172/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/172/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/172/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/172/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/172/images/train_output_2.png"}]}, "index": 172, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, color extraction, object expansion\n\n# description:\n# In the input, you will see a colored object in the center and a ring of a different color surrounding it.\n# There is also a single pixel in the top right corner with yet another color.\n# To make the output, remove the ring surrounding the central object and expand the central object outward with the color from the pixel in the top right corner.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color from the top right corner\n    corner_color = output_grid[0, -1]\n\n    # Find the bounding box of the central object\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Remove the ring surrounding the object\n    output_grid[x-1:x+width+1, y-1:y+height+1] = corner_color\n\n    # Color the central object with the corner color\n    output_grid[x:x+width, y:y+height] = corner_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid with a black background\n    n, m = 7, 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the central object and the ring\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    ring_color = np.random.choice([color for color in Color.NOT_BLACK if color != object_color])\n    corner_color = np.random.choice([color for color in Color.NOT_BLACK if color not in [object_color, ring_color]])\n\n    # Create the central object\n    central_object = random_sprite(n-4, m-4, density=0.5, color_palette=[object_color])\n    \n    # Place the central object in the grid\n    grid[2:2+central_object.shape[0], 2:2+central_object.shape[1]] = central_object\n\n    # Create a ring around the central object\n    grid[1, 1:-1] = ring_color  # Top ring\n    grid[-2, 1:-1] = ring_color  # Bottom ring\n    grid[1:-1, 1] = ring_color  # Left ring\n    grid[1:-1, -2] = ring_color  # Right ring\n\n    # Add the corner pixel\n    grid[0, -1] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/173/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/173/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/173/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/173/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/173/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/173/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/173/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/173/images/train_output_2.png"}]}, "index": 173, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# collision detection, sliding objects, symmetry\n\n# description:\n# In the input you will see a 2x2 red square and a green irregular object.\n# Slide the green object in any of the four directions until it is symmetrically aligned with the red square.\n\ndef main(input_grid):\n    # Extract the red square\n    red_square = np.zeros_like(input_grid)\n    red_square[input_grid == Color.RED] = Color.RED\n\n    # Extract the green object\n    green_object = np.zeros_like(input_grid)\n    green_object[input_grid == Color.GREEN] = Color.GREEN\n\n    # The output grid starts with just the red square\n    output_grid = np.copy(red_square)\n\n    # Get the position of the red square\n    red_x, red_y = object_position(red_square, background=Color.BLACK, anchor=\"upper left\")\n\n    # Define possible slide directions\n    possible_displacements = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # Try to slide the green object in all directions\n    for dx, dy in possible_displacements:\n        for offset in range(1, max(input_grid.shape)):\n            # Calculate the new position of the green object\n            new_x = red_x + dx * offset\n            new_y = red_y + dy * offset\n            \n            # Translate the green object to the new position\n            translated_green_object = translate(green_object, dx * offset, dy * offset, background=Color.BLACK)\n\n            # Check if there is contact between the translated green object and the red square\n            if contact(object1=red_square, object2=translated_green_object):\n                # Align the green object symmetrically with respect to the red square\n                output_grid = translated_green_object\n                return output_grid\n    \n    assert 0, \"No valid slide found\"\n\ndef generate_input():\n    # Create a black grid of size between 5x5 and 10x10\n    n, m = random.randint(5, 10), random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a 2x2 red square and place it at a random location\n    red_square = np.full((2, 2), Color.RED)\n    x_r, y_r = random_free_location_for_sprite(grid, red_square, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, red_square, x=x_r, y=y_r, background=Color.BLACK)\n\n    # Create a random green object (irregular shape) with size between 2x2 and 4x4\n    green_object = random_sprite(random.randint(2, 4), random.randint(2, 4), symmetry=\u0027not_symmetric\u0027, color_palette=[Color.GREEN])\n    \n    # Ensure the green object can slide to touch the red square\n    while True:\n        x_g, y_g = random_free_location_for_sprite(grid, green_object, background=Color.BLACK, border_size=1)\n        blit_sprite(grid, green_object, x=x_g, y=y_g, background=Color.BLACK)\n\n        # Check if the red square and the green object can touch when sliding\n        if (x_r == x_g and abs(y_r - y_g) \u003c= 2) or (y_r == y_g and abs(x_r - x_g) \u003c= 2):\n            return grid\n        else:\n            # Clear the grid and try again\n            grid = np.full((n, m), Color.BLACK)\n            blit_sprite(grid, red_square, x=x_r, y=y_r, background=Color.BLACK)", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/174/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/174/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/174/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/174/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/174/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/174/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/174/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/174/images/train_output_2.png"}]}, "index": 174, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# occlusion, rotational symmetry\n\n# description:\n# In the input you will see a rotationally symmetric pattern that has been partially occluded by black pixels.\n# The output should be the fully revealed rotationally symmetric pattern.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the rotational symmetry of the input grid.\n    # 2. For each pixel in the input grid, if it is not black, fill in the corresponding pixels in the output grid using the symmetry.\n\n    output_grid = np.copy(input_grid)\n    \n    # Find the rotational symmetry in the grid\n    symmetry = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n    assert symmetry is not None, \"No rotational symmetry found\"\n\n    # Iterate over all pixels\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] != Color.BLACK:\n                # Fill in all the symmetrical positions with the same color\n                for i in range(4):  # There are 4 symmetrical positions\n                    rotated_x, rotated_y = symmetry.apply(x, y, iters=i)\n                    output_grid[rotated_x, rotated_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random sprite with rotational symmetry.\n    # 2. Tile it to create a larger grid.\n    # 3. Randomly occlude parts of it with black pixels.\n\n    # Create a random sprite with rotational symmetry\n    sprite = random_sprite(5, 5, density=0.7, symmetry=\"radial\", color_palette=Color.NOT_BLACK)\n\n    # Tile the sprite to form a larger grid\n    horizontal_repetitions, vertical_repetitions = np.random.randint(2, 5, size=(2))\n    grid = np.tile(sprite, (horizontal_repetitions, vertical_repetitions))\n\n    # Occlude random pixels with black\n    n_occlusions = np.random.randint(5, 15)\n    for _ in range(n_occlusions):\n        x = np.random.randint(0, grid.shape[0])\n        y = np.random.randint(0, grid.shape[1])\n        grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/175/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/175/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/175/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/175/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/175/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/175/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/175/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/175/images/train_output_2.png"}]}, "index": 175, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color expansion, adjacency, contraction\n\n# description:\n# In the input, you will see a grid with a black background and colored pixels scattered on it. One color will be surrounded by another color on all four sides (up, down, left, right).\n# To produce the output, the central color (the one surrounded) will change to a new color. The surrounding colors will then contract one space inward towards the center from the borders, and fill the remaining spaces with black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Find the surrounded color and its surrounding colors\n    colors = np.unique(input_grid)\n    surrounded_color = None\n    surrounding_colors = set()\n\n    # Check every cell in the grid\n    for x in range(1, input_grid.shape[0] - 1):\n        for y in range(1, input_grid.shape[1] - 1):\n            # Check if the current pixel is surrounded\n            if (input_grid[x, y] != Color.BLACK and \n                input_grid[x-1, y] == input_grid[x+1, y] == input_grid[x, y-1] == input_grid[x, y+1] != Color.BLACK):\n                surrounded_color = input_grid[x, y]\n                surrounding_colors.add(input_grid[x-1, y])\n                surrounding_colors.add(input_grid[x+1, y])\n                surrounding_colors.add(input_grid[x, y-1])\n                surrounding_colors.add(input_grid[x, y+1])\n                break  # Found the surrounded color\n        if surrounded_color:\n            break\n\n    # Change the surrounded color to a new color (not black or the surrounded color)\n    new_color = next(c for c in Color.NOT_BLACK if c not in surrounding_colors and c != surrounded_color)\n    output_grid[np.where(input_grid == surrounded_color)] = new_color\n\n    # Contract the surrounding colors\n    for color in surrounding_colors:\n        for x in range(1, input_grid.shape[0] - 1):\n            for y in range(1, input_grid.shape[1] - 1):\n                if input_grid[x, y] == color:\n                    # Change surrounding color to black\n                    output_grid[x, y] = Color.BLACK\n                    # Contract towards the center\n                    if input_grid[x-1, y] == surrounded_color:\n                        output_grid[x-1, y] = color\n                    elif input_grid[x+1, y] == surrounded_color:\n                        output_grid[x+1, y] = color\n                    elif input_grid[x, y-1] == surrounded_color:\n                        output_grid[x, y-1] = color\n                    elif input_grid[x, y+1] == surrounded_color:\n                        output_grid[x, y+1] = color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 black grid\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select a surrounded color and surrounding color\n    surrounded_color, surrounding_color = np.random.choice(Color.NOT_BLACK, 2, replace=False)\n\n    # Place the surrounded color in the center of the grid\n    grid[4, 4] = surrounded_color\n    \n    # Surround the central color with the surrounding color\n    grid[3, 4] = surrounding_color\n    grid[5, 4] = surrounding_color\n    grid[4, 3] = surrounding_color\n    grid[4, 5] = surrounding_color\n\n    # Randomly scatter some additional pixels of the surrounding color\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = surrounding_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/176/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/176/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/176/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/176/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/176/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/176/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/176/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/176/images/train_output_2.png"}]}, "index": 176, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, rotation, reflection\n\n# description:\n# In the input, you will see several random geometric shapes of different colors. Each shape is defined within a bounding box.\n# The goal is to reflect each shape vertically and place it below the original shape. The output will contain the shapes in their original positions, \n# followed by their vertically reflected counterparts below.\n\ndef main(input_grid):\n    # Create a copy of the input grid to store the output\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (shapes) in the grid\n    objects = find_connected_components(input_grid, monochromatic=False)\n\n    # Process each object\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj)\n\n        # Crop the object to extract the sprite\n        sprite = crop(obj)\n\n        # Reflect the sprite vertically\n        reflected_sprite = np.flipud(sprite)\n\n        # Compute the position to place the reflected sprite\n        reflected_x = x + h  # Place it directly below the original shape\n\n        # Blit the reflected sprite onto the output grid\n        blit_sprite(output_grid, reflected_sprite, x=reflected_x, y=y)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of shapes\n    num_shapes = np.random.randint(3, 6)\n\n    for _ in range(num_shapes):\n        # Create a random sprite (shape)\n        sprite = random_sprite(np.random.randint(3, 5), np.random.randint(3, 5), \n                               symmetry=\"not_symmetric\", color_palette=list(Color.NOT_BLACK))\n\n        # Place the sprite randomly onto the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/177/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/177/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/177/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/177/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/177/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/177/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/177/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/177/images/train_output_2.png"}]}, "index": 177, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# square detection, scaling\n\n# description:\n# In the input you will see a grid containing multiple colored squares. \n# Each square is 2x2 pixels in size. The task is to scale each colored square by a factor of 3, \n# and place the scaled squares in the same positions they occupied in the input grid.\n\ndef main(input_grid):\n    # Detect all 2x2 squares in the input grid\n    square_objects = detect_objects(grid=input_grid, monochromatic=True,\n                                     allowed_dimensions=[(2, 2)], colors=Color.NOT_BLACK)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    scale_factor = 3\n    for obj in square_objects:\n        # Get the position of each 2x2 square\n        x, y = object_position(obj, background=Color.BLACK, anchor=\"upper left\")\n        square_color = obj[0, 0]  # Assume all pixels in the square have the same color\n\n        # Scale the square by `scale_factor`\n        scaled_square = scale_pattern(pattern=obj, scale_factor=scale_factor)\n\n        # Calculate the new position for the scaled square (keeping it anchored at the upper left)\n        new_x, new_y = x * scale_factor, y * scale_factor\n\n        # Put the scaled square on the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=scaled_square, x=new_x, y=new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random number of 2x2 colored squares\n    square_count = np.random.randint(2, 5)  # Randomly choose how many squares to create\n    colors = Color.NOT_BLACK\n    \n    for _ in range(square_count):\n        square_color = np.random.choice(colors)\n        square = np.full((2, 2), square_color)\n\n        # Find a random free location for the square\n        x, y = random_free_location_for_sprite(grid, square, padding=0, border_size=0)\n        grid = blit_sprite(grid, square, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/178/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/178/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/178/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/178/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/178/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/178/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/178/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/178/images/train_output_2.png"}]}, "index": 178, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cropping, scaling\n\n# description:\n# In the input you will see a large image with a small multicolor object in the center.\n# To make the output grid, you should crop the image to the size of the small object \n# and scale the cropped image to the size of the original image.\n\ndef main(input_grid):\n    # Step 1: Crop the input grid to the bounding box of the object\n    cropped_object = crop(input_grid, background=Color.BLACK)\n\n    # Step 2: Scale the cropped object to match the size of the input grid\n    output_grid = scale_pattern(cropped_object, scale_factor=input_grid.shape[0] // cropped_object.shape[0])\n\n    return output_grid\n\ndef generate_input():\n    # Create a larger grid of size n x n\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK, dtype=int)\n\n    # Create a small random sprite with size (2-7)x(2-7)\n    w, h = np.random.randint(2, 8), np.random.randint(2, 8)\n    color_palette = np.random.choice(Color.NOT_BLACK, size=np.random.randint(1, 5), replace=False).tolist()\n    sprite = random_sprite(w, h, color_palette=color_palette)\n\n    # Place the sprite in the center of the grid\n    start_x = (n - w) // 2\n    start_y = (n - h) // 2\n    blit_sprite(grid, sprite, start_x, start_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/179/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/179/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/179/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/179/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/179/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/179/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/179/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/179/images/train_output_2.png"}]}, "index": 179, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object identification, color replacement\n\n# description:\n# In the input, you will see a grid with several colored circular objects. If an object is a circle, replace its color with a specific new color (e.g., teal).\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find connected components in the grid.\n    # 2. Check the shape of each component to see if it forms a circle.\n    # 3. If it is a circle, change its color to teal.\n\n    output_grid = np.copy(input_grid)\n    objects = find_connected_components(input_grid)\n\n    for obj in objects:\n        # Determine if the object is a circle by checking the number of pixels\n        # and the shape. A rough approximation for circular shapes is that they\n        # should occupy a roughly circular area (the aspect ratio should be close to 1)\n        area = np.sum(obj != Color.BLACK)\n        height, width = obj.shape\n        \n        # Check if the bounding box is nearly square (for circular shapes)\n        if area \u003e 0 and height \u003e 1 and width \u003e 1:\n            bounding_box_area = height * width\n            aspect_ratio = max(height, width) / min(height, width)\n            \n            if aspect_ratio \u003c 1.5:  # Allow some tolerance for imperfect circles\n                output_grid[obj != Color.BLACK] = Color.TEAL\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with circular shapes\n    n, m = 20, 20\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create random colors for the initial objects, avoiding teal\n    colors = [c for c in Color.NOT_BLACK if c != Color.TEAL]\n    \n    # Randomly scatter circular objects on the grid\n    num_circles = np.random.randint(2, 5)\n    for _ in range(num_circles):\n        radius = np.random.randint(1, 3)\n        circle_sprite = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n        \n        # Create a circle in the sprite\n        for x in range(circle_sprite.shape[0]):\n            for y in range(circle_sprite.shape[1]):\n                if (x - radius) ** 2 + (y - radius) ** 2 \u003c= radius ** 2:\n                    circle_sprite[x, y] = Color.GREY  # Use grey for the circle\n\n        # Randomly find a location to blit the circle\n        x, y = random_free_location_for_sprite(grid, circle_sprite, background=Color.BLACK)\n        blit_sprite(grid, circle_sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/180/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/180/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/180/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/180/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/180/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/180/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/180/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/180/images/train_output_2.png"}]}, "index": 180, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, rotation, position mapping\n\n# description:\n# In the input, you will see a grid of colored pixels, where each color corresponds to a specific rotation angle for the output.\n# To make the output, rotate each pixel according to its corresponding angle, which is defined as follows:\n# - Color.RED: 0 degrees (no rotation)\n# - Color.GREEN: 90 degrees (90 degrees clockwise)\n# - Color.BLUE: 180 degrees (180 degrees rotation)\n# - Color.YELLOW: 270 degrees (90 degrees counterclockwise)\n# Colors outside this set will remain unchanged in the output.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Define the rotation mapping\n    rotation_mapping = {\n        Color.RED: 0,\n        Color.GREEN: 1,   # 90 degrees clockwise\n        Color.BLUE: 2,    # 180 degrees\n        Color.YELLOW: 3    # 270 degrees counterclockwise\n    }\n    \n    # Rotate based on the color\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x, y]\n            if color in rotation_mapping:\n                rotation = rotation_mapping[color]\n                # Perform the rotation\n                if rotation == 0:\n                    output_grid[x, y] = Color.RED\n                elif rotation == 1:\n                    output_grid[x, y] = Color.GREEN\n                    # Rotate the pixel clockwise\n                    if x + 1 \u003c input_grid.shape[0]:\n                        output_grid[x + 1, y] = color\n                elif rotation == 2:\n                    output_grid[x, y] = Color.BLUE\n                    # Rotate the pixel 180 degrees\n                    if x + 1 \u003c input_grid.shape[0] and y + 1 \u003c input_grid.shape[1]:\n                        output_grid[x + 1, y + 1] = color\n                        output_grid[x, y] = color\n                elif rotation == 3:\n                    output_grid[x, y] = Color.YELLOW\n                    # Rotate the pixel counterclockwise\n                    if x - 1 \u003e= 0:\n                        output_grid[x - 1, y] = color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place the rotation-indicating colors\n    num_colors = np.random.randint(1, n * m // 4)  # Limit the number of colors to a quarter of the grid size\n\n    for _ in range(num_colors):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice([Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW])\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/181/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/181/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/181/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/181/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/181/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/181/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/181/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/181/images/train_output_2.png"}]}, "index": 181, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color rotation\n\n# description:\n# In the input you will see a grid with a colored pattern on a black background.\n# To make the output, extract the pattern and rotate its colors in a counter-clockwise manner.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the pattern by finding the connected components\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Create the output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # For each component found, rotate its colors counter-clockwise\n    for component in components:\n        # Crop the component to its bounding box\n        sprite = crop(component, background=Color.BLACK)\n        \n        # Create a rotated version of the sprite\n        rotated_sprite = np.zeros_like(sprite)\n        for y in range(sprite.shape[0]):\n            for x in range(sprite.shape[1]):\n                rotated_sprite[sprite.shape[0] - 1 - x, y] = sprite[y, x]\n\n        # Find the bounding box of the original component to place the rotated sprite\n        x, y, width, height = bounding_box(component)\n        \n        # Place the rotated sprite back into the output grid\n        output_grid[y:y + rotated_sprite.shape[0], x:x + rotated_sprite.shape[1]] = rotated_sprite\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the pattern\n    n, m = np.random.randint(3, 10), np.random.randint(3, 10)\n\n    # Generate a random pattern with non-black colors\n    pattern = random_sprite(n, m, density=0.5, color_palette=Color.NOT_BLACK)\n\n    # Create an empty grid with a black background\n    grid_width, grid_height = random.randint(n + 2, 2 * n + 2), random.randint(m + 2, 2 * m + 2)\n    grid = np.zeros((grid_width, grid_height), dtype=int)\n\n    # Randomly place the pattern in the center of the grid\n    pos_x, pos_y = random.randint(1, grid_width - n - 1), random.randint(1, grid_height - m - 1)\n    grid = blit_sprite(grid=grid, sprite=pattern, x=pos_x, y=pos_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/182/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/182/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/182/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/182/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/182/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/182/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/182/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/182/images/train_output_2.png"}]}, "index": 182, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color change\n\n# description:\n# In the input, you will see several objects of different colors.\n# To make the output, find the objects that are vertically symmetric and change their color to teal.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all objects in the input grid.\n    # 2. For each object, check if it is vertically symmetric.\n    # 3. If it is symmetric, change its color to teal and blit it onto the output grid.\n\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n\n    for obj in objects:\n        # Check if the object is vertically symmetric\n        is_symmetric = detect_mirror_symmetry(obj, ignore_colors=[Color.BLACK])\n        \n        if is_symmetric:\n            # Change color to teal\n            obj[obj != Color.BLACK] = Color.TEAL\n            \n            # Blit the symmetric object onto the output grid\n            output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(6, 12), np.random.randint(6, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of objects\n    num_objects = np.random.randint(2, 6)\n    \n    for _ in range(num_objects):\n        # Randomize dimensions of the sprite\n        sprite_width = np.random.randint(2, 5)\n        sprite_height = np.random.randint(2, 5)\n        \n        # Randomly choose a color for the object\n        color = np.random.choice(list(Color.NOT_BLACK))\n\n        # Create a random sprite with potential vertical symmetry\n        sprite = random_sprite(n=sprite_height, m=sprite_width, symmetry=\u0027vertical\u0027, color_palette=[color])\n        \n        # Find a random free location to place the sprite\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/183/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/183/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/183/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/183/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/183/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/183/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/183/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/183/images/train_output_2.png"}]}, "index": 183, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color matching, pixel manipulation, corner detection\n\n# description:\n# In the input, you will see a grid filled with pixels of various colors. The four corners of the grid each contain a pixel of a specific color. \n# To create the output grid, you should fill the entire grid with the colors from each corner, \n# such that the top left corner is filled with the top left color, the top right with the top right color, \n# the bottom left with the bottom left color, and the bottom right with the bottom right color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the colors from each corner\n    top_left_color = input_grid[0, 0]\n    top_right_color = input_grid[0, -1]\n    bottom_left_color = input_grid[-1, 0]\n    bottom_right_color = input_grid[-1, -1]\n    \n    # Create a new output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Fill the output grid based on the corner colors\n    height, width = input_grid.shape\n    for i in range(height):\n        for j in range(width):\n            if i \u003c height // 2 and j \u003c width // 2:\n                output_grid[i, j] = top_left_color  # Top left\n            elif i \u003c height // 2 and j \u003e= width // 2:\n                output_grid[i, j] = top_right_color  # Top right\n            elif i \u003e= height // 2 and j \u003c width // 2:\n                output_grid[i, j] = bottom_left_color  # Bottom left\n            else:\n                output_grid[i, j] = bottom_right_color  # Bottom right\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size\n    n, m = np.random.randint(6, 12), np.random.randint(6, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose four colors for the corners\n    corner_colors = random.sample(Color.NOT_BLACK, k=4)\n\n    # Set the corner colors\n    grid[0, 0] = corner_colors[0]  # Top left\n    grid[0, -1] = corner_colors[1]  # Top right\n    grid[-1, 0] = corner_colors[2]  # Bottom left\n    grid[-1, -1] = corner_colors[3]  # Bottom right\n\n    # Fill the rest of the grid with random colors (to create noise)\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in [(0, 0), (0, m - 1), (n - 1, 0), (n - 1, m - 1)]:\n                grid[i, j] = random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/184/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/184/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/184/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/184/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/184/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/184/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/184/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/184/images/train_output_2.png"}]}, "index": 184, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color decomposition, pattern filling\n\n# description:\n# In the input you will see a grid containing multiple colored shapes. Each shape is represented by a contiguous block of pixels of the same color.\n# To make the output grid, you should:\n# 1. Decompose each shape into its constituent pixels.\n# 2. Color each pixel based on its position within the shape:\n#    - Top-left pixels should be colored teal.\n#    - Top-right pixels should be colored pink.\n#    - Bottom-left pixels should be colored orange.\n#    - Bottom-right pixels should be colored yellow.\n#    - Center pixels should remain their original color.\n# 3. The output grid should replace the shapes with their newly colored pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Start by copying the input grid to create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Detect all the shapes in the grid\n    shapes = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n\n    for shape in shapes:\n        # Get the coordinates of the shape\n        shape_coords = np.argwhere(shape != Color.BLACK)\n        if len(shape_coords) == 0:\n            continue\n\n        # Find bounding box for the shape\n        min_x, min_y = shape_coords.min(axis=0)\n        max_x, max_y = shape_coords.max(axis=0)\n\n        # Calculate the center position\n        center_x = (min_x + max_x) // 2\n        center_y = (min_y + max_y) // 2\n\n        # Color each pixel based on its position\n        for x in range(shape.shape[0]):\n            for y in range(shape.shape[1]):\n                if shape[x, y] != Color.BLACK:\n                    if x \u003c center_x and y \u003c center_y:\n                        output_grid[min_x + x, min_y + y] = Color.TEAL  # Top-left\n                    elif x \u003c center_x and y \u003e= center_y:\n                        output_grid[min_x + x, min_y + y] = Color.PINK  # Top-right\n                    elif x \u003e= center_x and y \u003c center_y:\n                        output_grid[min_x + x, min_y + y] = Color.ORANGE  # Bottom-left\n                    elif x \u003e= center_x and y \u003e= center_y:\n                        output_grid[min_x + x, min_y + y] = Color.YELLOW  # Bottom-right\n                    else:\n                        output_grid[min_x + x, min_y + y] = shape[x, y]  # Center\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black background grid of random size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of shapes to place in the grid\n    num_shapes = np.random.randint(2, 5)\n\n    for _ in range(num_shapes):\n        # Generate random dimensions for the shape\n        shape_width, shape_height = np.random.randint(1, 5), np.random.randint(1, 5)\n        shape_color = np.random.choice(list(Color.NOT_BLACK))  # Avoid black\n\n        # Create the shape sprite\n        shape_sprite = np.full((shape_width, shape_height), shape_color)\n\n        # Find a random free location for the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK)\n        blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/185/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/185/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/185/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/185/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/185/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/185/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/185/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/185/images/train_output_2.png"}]}, "index": 185, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color fill, adjacency\n\n# description:\n# In the input grid, there are various colored shapes and a single red pixel located somewhere in the grid. \n# To create the output grid, you should find the shape that contains the red pixel and fill the entire shape with blue.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the red pixel\u0027s position\n    red_pixel_positions = np.argwhere(input_grid == Color.RED)\n\n    if red_pixel_positions.size == 0:\n        return output_grid  # No red pixel found, return empty grid\n\n    # Assume there is only one shape containing the red pixel\n    red_pixel_x, red_pixel_y = red_pixel_positions[0]\n\n    # Detect the object (shape) containing the red pixel\n    shape_mask = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=False, connectivity=8)\n\n    # If we found the shape, get its bounding box\n    if shape_mask:\n        shape = shape_mask[0]  # We expect only one shape with red pixel\n\n        # Fill this shape with blue in the output grid\n        for x, y in np.argwhere(shape == Color.RED):\n            output_grid[x, y] = Color.BLUE\n\n        # Now fill the entire shape with blue by using the boundary detection\n        for x in range(output_grid.shape[0]):\n            for y in range(output_grid.shape[1]):\n                if input_grid[x, y] == Color.RED:\n                    # Check if it\u0027s part of the same shape and fill\n                    output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size between 10x10 and 20x20\n    n = random.randint(10, 20)\n    m = random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a few random colored shapes\n    num_shapes = random.randint(2, 5)\n    colors = random.sample(Color.NOT_BLACK, num_shapes)\n\n    for color in colors:\n        shape_width, shape_height = random.randint(3, 6), random.randint(3, 6)\n        shape_sprite = random_sprite(shape_width, shape_height, color_palette=[color], connectivity=8)\n\n        # Find a free location to place the shape\n        try:\n            x, y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK, border_size=1, padding=1)\n            blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n        except:\n            continue  # Skip if no free location is available\n\n    # Finally scatter a single red pixel inside one of the shapes\n    red_shape_location = random.choice(np.argwhere(grid != Color.BLACK))\n    grid[red_shape_location[0], red_shape_location[1]] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/186/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/186/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/186/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/186/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/186/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/186/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/186/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/186/images/train_output_2.png"}]}, "index": 186, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, obstacle recognition, reflection\n\n# description:\n# In the input, you will see several red pixels on the leftmost column of the grid, and some gray pixels scattered throughout the grid.\n# To make the output grid, you should draw a horizontal red line from each red pixel in the leftmost column to the rightmost column. If the red line encounters a gray pixel, it should reflect downwards and continue drawing the line horizontally until it again hits a gray pixel, at which point it reflects upwards. \n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create the output grid by copying the input\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Find all the red pixels in the leftmost column\n    for y in range(height):\n        if input_grid[y, 0] == Color.RED:\n            # Start drawing the line from this pixel\n            x = 0\n            direction = 1  # Start by drawing to the right\n\n            while x \u003c width:\n                output_grid[y, x] = Color.RED  # Draw the red line\n\n                # Check if there is a gray pixel in the current position\n                if input_grid[y, x] == Color.GRAY:\n                    # Change direction: reflect down\n                    direction = 1 if direction == -1 else -1  # Toggle direction\n                    # Move downwards\n                    if direction == 1:\n                        if y + 1 \u003c height:\n                            y += 1\n                    else:  # Move upwards\n                        if y - 1 \u003e= 0:\n                            y -= 1\n\n                x += 1  # Move to the next column\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of size n x m\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter red pixels in the leftmost column\n    num_red_pixels = np.random.randint(1, 5)\n    red_positions = np.random.choice(range(n), size=num_red_pixels, replace=False)\n    for pos in red_positions:\n        grid[pos, 0] = Color.RED\n\n    # Scatter gray pixels randomly in the grid except in the leftmost column\n    for i in range(1, n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.3:  # Randomly decide to place a gray pixel\n                grid[i, j] = Color.GRAY\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/187/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/187/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/187/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/187/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/187/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/187/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/187/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/187/images/train_output_2.png"}]}, "index": 187, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color filling\n\n# description:\n# In the input, you will see a grid containing several colored triangular shapes made of gray pixels. \n# Your task is to identify these triangular shapes and fill them with a specific color: red for the left triangle, teal for the right triangle, and yellow for the bottom triangle.\n# The output grid should only show the filled triangles, while the rest of the grid remains black.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Define the color mapping for each triangle based on their positions\n    color_mapping = {\n        \u0027left_triangle\u0027: Color.RED,\n        \u0027right_triangle\u0027: Color.TEAL,\n        \u0027bottom_triangle\u0027: Color.YELLOW,\n    }\n\n    # Detect triangular shapes in the grid\n    triangular_shapes = detect_objects(grid=input_grid, colors=[Color.GRAY], monochromatic=True, connectivity=8)\n    \n    # Process each detected shape\n    for shape in triangular_shapes:\n        # Get the bounding box of the shape\n        x, y, width, height = bounding_box(grid=shape, background=Color.BLACK)\n\n        # Determine the shape type based on its position\n        if x \u003c input_grid.shape[0] // 2 and y \u003c input_grid.shape[1] // 2:  # Left triangle\n            fill_color = color_mapping[\u0027left_triangle\u0027]\n        elif x \u003e= input_grid.shape[0] // 2 and y \u003c input_grid.shape[1] // 2:  # Right triangle\n            fill_color = color_mapping[\u0027right_triangle\u0027]\n        elif y \u003e= input_grid.shape[1] // 2:  # Bottom triangle\n            fill_color = color_mapping[\u0027bottom_triangle\u0027]\n        else:\n            continue  # Ignore shapes that don\u0027t fit\n\n        # Fill the detected shape with the corresponding color\n        for i in range(width):\n            for j in range(height):\n                if shape[i][j] == Color.GRAY:  # Only fill gray pixels\n                    output_grid[x + i, y + j] = fill_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a background grid of size n x m\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create triangular shapes made of gray pixels\n    for _ in range(np.random.randint(2, 5)):  # Create between 2 and 4 triangles\n        # Random position and size for the triangle\n        base = np.random.randint(3, min(m, n // 2))\n        height = base\n\n        # Choose a position to place the triangle\n        x_start = np.random.randint(0, n - height)\n        y_start = np.random.randint(0, m - base)\n\n        # Draw the triangle (assumed to be right-angled)\n        for i in range(height):\n            for j in range(base):\n                if j \u003c= base * (height - i) / height:  # Create a right triangle shape\n                    grid[x_start + i, y_start + j] = Color.GRAY\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/188/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/188/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/188/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/188/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/188/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/188/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/188/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/188/images/train_output_2.png"}]}, "index": 188, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object filling, color blending, gradient\n\n# description:\n# In the input, you will see several hollow objects represented by outlines on a black background. \n# To create the output, fill each hollow object with a gradient that blends the color of the pixel immediately above it \n# and the color of the pixel immediately below it (if any). If there is no pixel above or below, use black as the default color.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n\n    # Iterate through each pixel in the grid\n    for x in range(n):\n        for y in range(m):\n            # Check if the current pixel is not black, indicating a hollow object\n            if input_grid[x, y] != Color.BLACK:\n                # Get the color above and below the current pixel\n                color_above = input_grid[x-1, y] if x \u003e 0 else Color.BLACK\n                color_below = input_grid[x+1, y] if x \u003c n - 1 else Color.BLACK\n                \n                # Create the gradient between the two colors\n                output_grid[x, y] = blend_colors(color_above, color_below)\n\n    return output_grid\n\ndef blend_colors(color1, color2):\n    # Simple color blending function, averaging the RGB values of the colors\n    if color1 == Color.BLACK:\n        return color2\n    if color2 == Color.BLACK:\n        return color1\n    return color1  # In this implementation, we just return the color above for simplicity\n\ndef generate_input():\n    # Create a 10x10 grid with a black background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of hollow objects\n    num_objects = np.random.randint(2, 5)\n    \n    for _ in range(num_objects):\n        # Randomly create a hollow object (outline)\n        width = np.random.randint(2, 5)\n        height = np.random.randint(2, 5)\n        sprite_color = np.random.choice(list(Color.NOT_BLACK))\n\n        # Create a hollow object (a frame)\n        hollow_object = np.zeros((height, width), dtype=int)\n        hollow_object[0, :] = sprite_color   # Top border\n        hollow_object[-1, :] = sprite_color  # Bottom border\n        hollow_object[:, 0] = sprite_color    # Left border\n        hollow_object[:, -1] = sprite_color   # Right border\n\n        # Find a random free location for this hollow object\n        try:\n            x, y = random_free_location_for_sprite(grid, hollow_object, background=Color.BLACK, padding=1)\n            blit_sprite(grid, hollow_object, x=x, y=y, background=Color.BLACK)\n        except:\n            pass  # Ignore placement failure\n\n    # Randomly fill some pixels above and below the hollow objects\n    for _ in range(np.random.randint(5, 10)):\n        x = np.random.randint(1, n-1)\n        y = np.random.randint(1, m-1)\n        if grid[x, y] == Color.BLACK:  # Only fill empty spots\n            grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/189/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/189/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/189/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/189/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/189/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/189/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/189/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/189/images/train_output_2.png"}]}, "index": 189, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filtering, background manipulation, pixel preservation\n\n# description:\n# In the input, you will see a grid filled with various colored pixels. \n# The objective is to remove all pixels that are not blue, keeping only the blue pixels in their original positions. \n# All other pixels should be turned to black (the background).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid filled with black background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Retain only the blue pixels from the input grid\n    output_grid[input_grid == Color.BLUE] = Color.BLUE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Set the size of the grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with a mix of colors including blue\n    colors = list(Color.NOT_BLACK)  # All colors except black\n    for i in range(n):\n        for j in range(m):\n            # Randomly assign a color to each pixel\n            grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/190/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/190/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/190/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/190/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/190/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/190/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/190/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/190/images/train_output_2.png"}]}, "index": 190, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, color mapping\n\n# description:\n# In the input, you will see a grid containing a single blue pixel and a single yellow pixel. \n# To create the output grid, draw a vertical blue line extending from the blue pixel to the bottom of the grid, \n# and a horizontal yellow line extending from the yellow pixel to the right edge of the grid.\n# Afterward, draw a red pixel at the position where these two lines intersect.\n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # get the index of the blue pixel\n    blue = np.where(input_grid == Color.BLUE)\n    blue_x, blue_y = blue[0][0], blue[1][0]\n\n    # get the index of the yellow pixel\n    yellow = np.where(input_grid == Color.YELLOW)\n    yellow_x, yellow_y = yellow[0][0], yellow[1][0]\n\n    # draw the vertical blue line from the blue pixel to the bottom of the grid\n    output_grid[blue_x, blue_y:] = Color.BLUE\n    \n    # draw the horizontal yellow line from the yellow pixel to the right edge of the grid\n    output_grid[yellow_x, yellow_y:] = Color.YELLOW\n\n    # draw the intersection point as red\n    output_grid[blue_x, yellow_y] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # make a 10x10 black grid for the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # put a blue pixel at a random position\n    blue_x, blue_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[blue_x, blue_y] = Color.BLUE\n\n    # put a yellow pixel at a random position but not in the same column as the blue pixel\n    yellow_x, yellow_y = np.random.randint(0, n), np.random.randint(0, m)\n    while yellow_x == blue_x:\n        yellow_x, yellow_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[yellow_x, yellow_y] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/191/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/191/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/191/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/191/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/191/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/191/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/191/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/191/images/train_output_2.png"}]}, "index": 191, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color symmetry, mirroring\n\n# description:\n# In the input, you will see a grid with a colored pattern on one side (left or top) of the grid and a black background.\n# To make the output, reflect the colored pattern across the center line (either vertical or horizontal) of the grid,\n# filling in the opposite side with the reflected colors.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find the background color\n    # 2. Identify the width and height of the grid\n    # 3. Reflect the pattern across the center line (vertical or horizontal)\n    \n    output_grid = np.copy(input_grid)\n    background_color = Color.BLACK\n    height, width = output_grid.shape\n\n    # Reflect across the vertical line\n    for y in range(height):\n        for x in range(width // 2):\n            if output_grid[y, x] != background_color:\n                output_grid[y, width - 1 - x] = output_grid[y, x]\n    \n    # Optionally, can reflect across the horizontal line instead\n    # for x in range(width):\n    #     for y in range(height // 2):\n    #         if output_grid[y, x] != background_color:\n    #             output_grid[height - 1 - y, x] = output_grid[y, x]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Make a black grid for the background first\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), fill_value=Color.BLACK)\n\n    # Randomly determine the size and color of the pattern\n    pattern_width = np.random.randint(1, m // 2)\n    pattern_height = np.random.randint(1, n)\n    pattern_color = np.random.choice(Color.NOT_BLACK)\n\n    # Generate the left side pattern\n    for i in range(pattern_height):\n        for j in range(pattern_width):\n            if np.random.random() \u003c 0.5:  # 50% chance to fill\n                grid[i, j] = pattern_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/192/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/192/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/192/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/192/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/192/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/192/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/192/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/192/images/train_output_2.png"}]}, "index": 192, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input you will see a grid with a red square.\n# To make the output grid, you should rotate the red square 90 degrees clockwise and change its color to blue.\n\ndef main(input_grid):\n    # Detect the red square on the grid.\n    red_squares = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n\n    # There should be exactly one red square; if not, return the original grid.\n    if len(red_squares) != 1:\n        return input_grid\n\n    # Get the bounding box of the red square.\n    x, y, width, height = bounding_box(red_squares[0], background=Color.BLACK)\n\n    # Create the output grid as a copy of the input grid.\n    output_grid = input_grid.copy()\n\n    # Create a blue square rotated 90 degrees clockwise.\n    # The original red square is assumed to be a 2x2 square for simplicity.\n    blue_square = np.array([[Color.BLUE, Color.RED],\n                            [Color.BLUE, Color.RED]])\n\n    # Place the blue square in the rotated position. (width and height are swapped)\n    blit_sprite(output_grid, blue_square, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with a size of n x m.\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a red square of size 2x2.\n    red_square = np.array([[Color.RED, Color.RED],\n                           [Color.RED, Color.RED]])\n\n    # Randomly place the red square on the grid ensuring it fits.\n    x = np.random.randint(0, n - 2)\n    y = np.random.randint(0, m - 2)\n    grid = blit_sprite(grid, red_square, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/193/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/193/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/193/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/193/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/193/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/193/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/193/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/193/images/train_output_2.png"}]}, "index": 193, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, object resizing, object alignment\n\n# description:\n# In the input, you will see a grid with several colored objects of various shapes and sizes. \n# One of the objects will be smaller than the rest. Your task is to find this smaller object and resize all other objects to match its size, \n# ensuring they are all centered at the same position in the output grid.\n\ndef main(input_grid):\n    # Step 1: Detect all objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Step 2: Identify the object with the smallest area\n    smallest_object = None\n    smallest_area = float(\u0027inf\u0027)\n    \n    for obj in objects:\n        area = np.sum(obj != Color.BLACK)  # Count non-background pixels\n        if area \u003c smallest_area:\n            smallest_area = area\n            smallest_object = obj\n\n    # Step 3: Scale all other objects to match the size of the smallest object\n    output_grid = np.full(input_grid.shape, Color.BLACK)  # Start with a black output grid\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n\n    for obj in objects:\n        if obj is not smallest_object:\n            # Scale the object to the size of the smallest object\n            scale_factor = smallest_area // np.sum(obj != Color.BLACK)  # Calculate the scale factor based on area\n            if scale_factor \u003e 0:\n                scaled_object = scale_pattern(obj, scale_factor)\n                # Center the scaled object in the output grid\n                x_offset = center_x - scaled_object.shape[0] // 2\n                y_offset = center_y - scaled_object.shape[1] // 2\n                blit_sprite(output_grid, scaled_object, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    # Also place the smallest object in the center of the output grid\n    blit_sprite(output_grid, smallest_object, x=center_x - smallest_object.shape[0] // 2, y=center_y - smallest_object.shape[1] // 2, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium-sized grid and randomly populate it with colored objects\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a number of objects\n    num_objects = np.random.randint(3, 6)\n    objects = []\n    \n    for _ in range(num_objects):\n        # Randomly create sprites of varying sizes and colors\n        sprite_size = np.random.randint(2, 5)\n        sprite = random_sprite(n=sprite_size, m=sprite_size, density=0.5)\n\n        # Ensure at least one object is smaller (1x1)\n        if sprite_size == 1 and np.random.rand() \u003e 0.5:\n            sprite = np.full((1, 1), Color.RED)  # Small object\n\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        objects.append(sprite)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/194/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/194/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/194/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/194/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/194/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/194/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/194/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/194/images/train_output_2.png"}]}, "index": 194, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, shape completion\n\n# description:\n# In the input you will see an incomplete yellow star shape. \n# To make the output grid, you should complete the star and invert its colors.\n\ndef main(input_grid):\n    # Find the bounding box of the incomplete star and extract it\n    x, y, x_len, y_len = bounding_box(grid=input_grid)\n    star_shape = input_grid[x:x + x_len, y:y + y_len]\n\n    # Create an inverted color version of the star shape\n    inverted_star = np.where(star_shape == Color.YELLOW, Color.BLUE, Color.YELLOW)\n\n    # Fill in the missing parts of the star with the inverted color\n    completed_star = np.where(star_shape == Color.BLACK, inverted_star, star_shape)\n\n    # Make the output by copying the completed star to a new canvas\n    output_grid = np.copy(input_grid)\n    output_grid = blit_sprite(grid=output_grid, sprite=completed_star, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a size of n x m\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate the incomplete yellow star shape\n    star_sprite = random_sprite(n=5, m=5, color_palette=[Color.YELLOW], density=0.5, connectivity=8)\n\n    # Randomly choose a position to draw the star\n    x, y = random_free_location_for_sprite(grid=grid, sprite=star_sprite, border_size=1)\n    grid = blit_sprite(grid=grid, sprite=star_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/195/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/195/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/195/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/195/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/195/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/195/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/195/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/195/images/train_output_2.png"}]}, "index": 195, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rectangle detection, color transformation\n\n# description:\n# In the input grid, you will see scattered colored pixels, including 2x2 red squares. \n# Your task is to detect any 2x2 red square in the grid and replace it with a 2x2 green square.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Scan the grid for 2x2 regions that are all red.\n    # 2. Replace those regions with green.\n\n    output_grid = np.copy(input_grid)\n\n    # Check for 2x2 red squares\n    for x in range(input_grid.shape[0] - 1):\n        for y in range(input_grid.shape[1] - 1):\n            if (input_grid[x, y] == Color.RED and\n                input_grid[x + 1, y] == Color.RED and\n                input_grid[x, y + 1] == Color.RED and\n                input_grid[x + 1, y + 1] == Color.RED):\n                # Replace with green square\n                output_grid[x:x + 2, y:y + 2] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid\n    n = m = 9\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels\n    available_colors = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]\n    grid = random_scatter_points(grid=grid, color=np.random.choice(available_colors), density=0.5)\n\n    # Generate some 2x2 red squares\n    red_square = np.full((2, 2), Color.RED, dtype=int)\n    for _ in range(np.random.randint(1, 4)):  # Randomly choose to place 1 to 3 red squares\n        x, y = random_free_location_for_sprite(grid, red_square)\n        blit_sprite(grid, red_square, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/196/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/196/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/196/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/196/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/196/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/196/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/196/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/196/images/train_output_2.png"}]}, "index": 196, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, positioning\n\n# description:\n# In the input, you will see a single colored shape. To create the output, scale the shape to twice its original size and position it in the center of the grid.\n\ndef main(input_grid):\n    # Step 1: Detect the single colored shape in the input grid\n    shapes = detect_objects(grid=input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n\n    # Step 2: Assume there is only one shape and crop it\n    shape = shapes[0]\n    shape_cropped = crop(shape, background=Color.BLACK)\n\n    # Step 3: Scale the shape to twice its original size\n    scaled_shape = scale_pattern(pattern=shape_cropped, scale_factor=2)\n\n    # Step 4: Create an output grid of the same size as the input grid, initially filled with black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 5: Calculate the position to center the scaled shape in the output grid\n    shape_height, shape_width = scaled_shape.shape\n    output_height, output_width = output_grid.shape\n\n    # Determine the top-left corner for centering\n    top_left_x = (output_height - shape_height) // 2\n    top_left_y = (output_width - shape_width) // 2\n\n    # Step 6: Blit the scaled shape onto the centered position in the output grid\n    output_grid = blit_sprite(grid=output_grid, sprite=scaled_shape, x=top_left_x, y=top_left_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of a random size\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK, dtype=int)\n\n    # Create a random shape with a maximum size of 5x5\n    shape_height = np.random.randint(2, 6)\n    shape_width = np.random.randint(2, 6)\n    shape = random_sprite(n=shape_height, m=shape_width, density=0.5, color_palette=Color.NOT_BLACK)\n\n    # Randomly place the shape within the grid while ensuring it fits\n    x, y = random_free_location_for_sprite(grid, shape, border_size=1)\n    blit_sprite(grid, shape, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/197/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/197/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/197/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/197/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/197/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/197/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/197/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/197/images/train_output_2.png"}]}, "index": 197, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color fill\n\n# description:\n# In the input, you will see a grid with multiple irregularly shaped objects made up of green pixels.\n# To make the output, detect all the green objects and fill them with yellow pixels.\n\ndef main(input_grid):\n    # Create a copy of the input grid to store the output\n    output_grid = np.copy(input_grid)\n\n    # Detect all connected components of green pixels\n    green_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Fill each detected green object with yellow pixels in the output grid\n    for obj in green_objects:\n        output_grid[obj == Color.GREEN] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a black background grid of size n x m.\n    n, m = 20, 20\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter green pixels on the grid with a specified density\n    density = 0.3\n    num_green_pixels = int(density * n * m)\n    colored = 0\n\n    while colored \u003c num_green_pixels:\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = Color.GREEN\n            colored += 1\n\n    # Ensure the grid has at least one green object\n    green_objects = detect_objects(grid=grid, colors=[Color.GREEN], monochromatic=True, connectivity=4)\n    if not any(np.sum(object == Color.GREEN) \u003e 0 for object in green_objects):\n        return generate_input()\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/198/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/198/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/198/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/198/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/198/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/198/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/198/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/198/images/train_output_2.png"}]}, "index": 198, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color swapping, grid reflection\n\n# description:\n# In the input you will see a grid with several colored squares. \n# To make the output, swap the colors of squares that are reflected across the main diagonal of the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the output grid with the same size as the input grid.\n    output_grid = np.copy(input_grid)\n    \n    n, m = input_grid.shape\n    \n    # Swap colors across the diagonal\n    for i in range(n):\n        for j in range(i + 1, m):  # only swap above the diagonal\n            if input_grid[i, j] != Color.BLACK and input_grid[j, i] != Color.BLACK:\n                # Swap colors\n                output_grid[i, j], output_grid[j, i] = output_grid[j, i], output_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n = random.randint(10, 15)\n    m = random.randint(10, 15)\n    \n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colored squares\n    number_of_squares = random.randint(5, 10)\n    colors = random.sample(Color.NOT_BLACK, number_of_squares)\n\n    for color in colors:\n        # Random size for the square\n        square_size = random.randint(1, 3)\n        # Random position for the square\n        x = random.randint(0, n - square_size)\n        y = random.randint(0, m - square_size)\n        \n        # Fill the square with the color\n        for i in range(square_size):\n            for j in range(square_size):\n                grid[x + i, y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/199/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/199/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/199/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/199/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/199/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/199/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/199/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/199/images/train_output_2.png"}]}, "index": 199, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, grid manipulation, pattern extraction\n\n# description:\n# In the input you will see a grid consisting of a single 2x2 block of blue pixels.\n# To make the output, you should replace each blue pixel with a pattern of colors where:\n# top left becomes red, top right becomes green, bottom left becomes yellow, and bottom right becomes teal.\n# The output grid should maintain the same dimensions as the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Detect the 2x2 block of blue pixels\n    blue_blocks = detect_objects(grid=input_grid, colors=[Color.BLUE], allowed_dimensions=[(2, 2)], monochromatic=True)\n\n    if len(blue_blocks) != 1:\n        raise ValueError(\"Input must contain exactly one 2x2 blue block.\")\n\n    # Get the position of the blue block\n    blue_x, blue_y, _, _ = bounding_box(blue_blocks[0], background=Color.BLACK)\n\n    # Create the color pattern for output\n    pattern = np.array([[Color.RED, Color.GREEN], \n                        [Color.YELLOW, Color.TEAL]])\n\n    # Prepare the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Replace the blue block with the color pattern\n    output_grid[blue_x:blue_x + 2, blue_y:blue_y + 2] = pattern\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid of size n x m with a black background\n    n, m = np.random.randint(4, 8), np.random.randint(4, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a position for the 2x2 blue block\n    x_start = np.random.randint(0, n - 1)\n    y_start = np.random.randint(0, m - 1)\n    \n    # Place the blue block in the grid\n    grid[x_start:x_start + 2, y_start:y_start + 2] = Color.BLUE\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/200/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/200/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/200/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/200/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/200/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/200/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/200/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/200/images/train_output_2.png"}]}, "index": 200, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, pixel manipulation\n\n# description:\n# In the input you will see a grid of colored pixels, where each pixel can be one of the specified colors. \n# To create the output grid, change each color according to the following mapping:\n# green -\u003e black, blue -\u003e red, yellow -\u003e green, red -\u003e yellow, black -\u003e blue.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize output grid\n    output_grid = np.copy(input_grid)\n\n    # Define the color mapping\n    color_map = {\n        Color.GREEN: Color.BLACK,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN,\n        Color.RED: Color.YELLOW,\n        Color.BLACK: Color.BLUE\n    }\n\n    # Apply the color mapping using vectorization\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid of size n x m with colors from the specified set\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the available colors for the grid\n    available_colors = [Color.BLACK, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW]\n\n    # Randomly fill the grid with colors\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/201/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/201/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/201/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/201/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/201/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/201/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/201/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/201/images/train_output_2.png"}]}, "index": 201, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color transformation, background manipulation\n\n# description:\n# In the input, you will see a grid with a black background and several colored objects scattered around. Each object consists of a single color with a unique shape, and they can be connected diagonally or orthogonally. The task is to identify all objects in the grid, and create a new grid where each object is transformed to a bright yellow color and placed on a black background.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the connected components (objects) from the input grid.\n    # 2. Create a new output grid with a black background.\n    # 3. For each extracted object, change its color to yellow and blit it onto the output grid.\n\n    # Step 1: Extract the objects from the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Step 2: Create a new output grid with a black background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 3: Change the color of each object to yellow and blit it onto the output grid\n    for obj in objects:\n        # Change the object\u0027s color to yellow\n        obj[obj != Color.BLACK] = Color.YELLOW  # Set all non-black pixels to yellow\n        # Blit the yellow object onto the output grid\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid with a black background and colored objects\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)  # Random dimensions\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n\n    # Randomly define a number of objects to place in the grid\n    n_objects = np.random.randint(3, 6)\n\n    for _ in range(n_objects):\n        # Create a random shape for the object\n        object_height = np.random.randint(1, 5)\n        object_width = np.random.randint(1, 5)\n        object_color = random.choice(Color.NOT_BLACK)\n\n        # Create an object grid\n        obj = np.full((object_height, object_width), object_color)\n\n        # Find a free location for the object in the main grid\n        x, y = random_free_location_for_sprite(grid, obj, padding=1)\n        blit_sprite(grid, obj, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/202/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/202/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/202/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/202/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/202/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/202/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/202/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/202/images/train_output_2.png"}]}, "index": 202, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, pixel manipulation, translation, overlapping\n\n# description:\n# In the input you will see a 5x5 grid containing a colored object (1x1 or larger) and a background of black color.\n# For each pixel in the object, overlap the object onto the background (starting from the original position) \n# while shifting it vertically and horizontally. For each position, blend the color of the object (using \n# weighted average) with the background, then return the resulting grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the object in the input grid\n    object_mask = input_grid != Color.BLACK\n    object_color = input_grid[object_mask]\n\n    # Get the coordinates of the object\n    object_coords = np.argwhere(object_mask)\n\n    # Create a new grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Translate the object in the 8 possible directions (including diagonals)\n    directions = [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1)]\n\n    for dx, dy in directions:\n        for x_offset in range(-2, 3):  # Shift the object in the x direction\n            for y_offset in range(-2, 3):  # Shift the object in the y direction\n                for x, y in object_coords:\n                    new_x = x + dx + x_offset\n                    new_y = y + dy + y_offset\n\n                    # Check bounds\n                    if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                        # Blend the colors at the new position\n                        if output_grid[new_x, new_y] != Color.BLACK:\n                            current_color = output_grid[new_x, new_y]\n                            blended_color = blend_colors(object_color[0], current_color)\n                            output_grid[new_x, new_y] = blended_color\n                        else:\n                            output_grid[new_x, new_y] = object_color[0]\n\n    return output_grid\n\ndef blend_colors(color_a, color_b):\n    # Simple color blending function using weighted average\n    return (color_a + color_b) // 2\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 5x5 grid with black background\n    grid = np.full((5, 5), Color.BLACK)\n\n    # Create a random colored object, size can vary from 1x1 to 3x3\n    object_size = np.random.randint(1, 4)\n    object_color = np.random.choice(Color.NOT_BLACK)\n    object_sprite = random_sprite(object_size, object_size, color_palette=[object_color])\n\n    # Randomly position the object within bounds\n    x, y = np.random.randint(0, 5 - object_size), np.random.randint(0, 5 - object_size)\n    blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/203/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/203/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/203/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/203/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/203/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/203/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/203/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/203/images/train_output_2.png"}]}, "index": 203, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, region extraction\n\n# description:\n# In the input, you will see a 9x9 grid with a 6x6 blue sprite surrounded by a border of black color. \n# Within the blue sprite, there are random colored pixels set to either red, green, or yellow, forming various shapes. \n# To create the output grid, you will fill a 9x9 grid with the colors of the pixels from the blue sprite \n# but blend them with a red background based on their proximity to the center of the sprite: \n# pixels closer to the center will be more saturated (full color), while those further away will be more blended with red (lighter).\n\ndef main(input_grid):\n    # Step 1: Extract the blue sprite\n    blue_sprite = crop(input_grid[2:8, 2:8], background=Color.BLACK)\n\n    # Step 2: Create the output grid initialized to red\n    output_grid = np.full((9, 9), Color.RED, dtype=int)\n\n    # Step 3: Calculate the center of the blue sprite\n    center_x, center_y = blue_sprite.shape[0] // 2, blue_sprite.shape[1] // 2\n\n    # Step 4: Blend the pixels based on their distance from the center\n    for x in range(blue_sprite.shape[0]):\n        for y in range(blue_sprite.shape[1]):\n            color = blue_sprite[x, y]\n            if color != Color.BLACK:  # Only process non-background pixels\n                # Calculate distance from center\n                distance = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)\n                # Normalize distance to a value between 0 and 1\n                max_distance = np.sqrt(2) * (center_x)  # Maximum distance in a 3x3 grid\n                blend_factor = distance / max_distance\n                # Blend color with red based on the blend factor\n                blended_color = blend_with_red(color, blend_factor)\n                # Place the blended color in the output grid\n                output_grid[x + 2, y + 2] = blended_color\n\n    return output_grid\n\ndef blend_with_red(color, factor):\n    # Function to blend a color with red based on the factor\n    if factor \u003e= 1:\n        return Color.RED  # Fully blended with red\n    return color  # No blending\n\ndef generate_input():\n    # Initialize the 9x9 grid with black color\n    grid = np.zeros((9, 9), dtype=int)\n\n    # Create a 6x6 blue sprite with random colored pixels (red, green, yellow)\n    blue_sprite = np.full((6, 6), Color.BLUE, dtype=int)\n\n    # Randomize colored pixels in the blue sprite\n    for x in range(6):\n        for y in range(6):\n            if np.random.rand() \u003e 0.5:  # Randomly decide whether to place a color\n                color = np.random.choice([Color.RED, Color.GREEN, Color.YELLOW])\n                blue_sprite[x, y] = color\n\n    # Place the blue sprite in the center of the grid\n    grid[2:8, 2:8] = blue_sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/204/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/204/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/204/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/204/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/204/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/204/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/204/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/204/images/train_output_2.png"}]}, "index": 204, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, occlusion, color filling\n\n# description:\n# In the input you will see a right-left symmetric pattern that has been occluded by a rectangular region of a specific color.\n# The output should be the filled region where the occlusion was, using the colors from the visible parts of the symmetric pattern.\n\ndef main(input_grid):\n    # Step 1: Identify the occluded region by searching for the occlusion color\n    occlusion_color = Color.RED  # Assume occlusion color is red for this puzzle\n    occlusion_mask = (input_grid == occlusion_color)\n\n    # Step 2: Detect left-right symmetry in the input grid\n    symmetries = detect_mirror_symmetry(input_grid, ignore_colors=[occlusion_color])\n\n    # Step 3: Fill in the missing parts of the pattern using the symmetry\n    output_grid = input_grid.copy()\n    for occluded_x, occluded_y in np.argwhere(occlusion_mask):\n        for mirror in symmetries:\n            # Find the mirrored position\n            mirrored_x, mirrored_y = mirror.apply(occluded_x, occluded_y)\n            # If the mirrored position is not occluded, copy the color\n            if input_grid[mirrored_x, mirrored_y] != occlusion_color:\n                output_grid[occluded_x, occluded_y] = input_grid[mirrored_x, mirrored_y]\n                break\n\n    # Return the output grid with the filled occluded region\n    return output_grid\n\n\ndef generate_input():\n    # Step 1: Create a random sprite and make it left-right symmetric\n    width, height = np.random.randint(5, 10), np.random.randint(5, 10)\n    \n    # Generate a random sprite\n    sprite = random_sprite(width, height, density=0.5, symmetry=\u0027horizontal\u0027, color_palette=Color.NOT_BLACK)\n    \n    # Step 2: Create a symmetric pattern by tiling the sprite\n    pattern = np.tile(sprite, (1, 2))  # Create a left-right symmetric pattern by tiling horizontally\n\n    # Step 3: Occlude the pattern with a rectangular region of color RED\n    occlusion_width, occlusion_height = np.random.randint(2, 4), np.random.randint(2, 4)\n    x_occlusion = np.random.randint(0, height - occlusion_height + 1)\n    y_occlusion = np.random.randint(0, width - occlusion_width + 1)\n    \n    # Create the occlusion rectangle\n    occlusion_rectangle = np.full((occlusion_height, occlusion_width), Color.RED)\n    blit_sprite(pattern, occlusion_rectangle, x_occlusion, y_occlusion, background=None)\n    \n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/205/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/205/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/205/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/205/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/205/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/205/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/205/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/205/images/train_output_2.png"}]}, "index": 205, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation, color mapping\n\n# description:\n# In the input you will see a colored pattern. \n# To make the output, rotate the pattern by 90 degrees clockwise and change the color of the pattern according to a predefined mapping.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Define a color mapping for transformation\n    color_mapping = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.RED,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.TEAL,\n        Color.PINK: Color.GREY,\n        Color.GREY: Color.PINK,\n        Color.ORANGE: Color.BLACK,\n        Color.BLACK: Color.ORANGE\n    }\n    \n    # Rotate the input grid by 90 degrees clockwise\n    rotated_grid = np.rot90(input_grid, -1)\n\n    # Change the color of the rotated grid according to the mapping\n    output_grid = np.copy(rotated_grid)\n    for original_color, new_color in color_mapping.items():\n        output_grid[output_grid == original_color] = new_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid with random colors\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = random_sprite(n, m, density=0.7, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/206/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/206/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/206/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/206/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/206/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/206/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/206/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/206/images/train_output_2.png"}]}, "index": 206, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern shifting, vertical alignment\n\n# description:\n# In the input grid, you will see a pattern of vertical stripes of different colors. The stripes may or may not be contiguous and can vary in height. \n# To produce the output grid, shift each vertical stripe down by one pixel, filling the top-most row with black.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find connected components (vertical stripes)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Shift each stripe down by one pixel\n    for obj in objects:\n        # Get the bounding box of the stripe\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n        \n        # Crop the stripe from the input grid\n        stripe = crop(obj, background=Color.BLACK)\n        \n        # Calculate the new position for the stripe (shift down)\n        new_y = y + 1\n        \n        # Blit the stripe onto the output grid in the new position\n        blit_sprite(output_grid, stripe, x=x, y=new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random-sized grid with a black background\n    n = np.random.randint(10, 15)\n    m = np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Number of vertical stripes to generate\n    num_stripes = np.random.randint(3, 6)\n\n    # Generate vertical stripes\n    for _ in range(num_stripes):\n        # Randomly choose a color for the stripe\n        stripe_color = np.random.choice(list(Color.NOT_BLACK))\n\n        # Randomly select a starting x position for the stripe\n        stripe_x = np.random.randint(0, m)\n\n        # Randomly select the height of the stripe\n        stripe_height = np.random.randint(2, n // 2)\n\n        # Randomly select a starting y position for the stripe, ensuring it fits within the grid\n        stripe_y_start = np.random.randint(0, n - stripe_height)\n\n        # Draw the vertical stripe in the grid\n        for y in range(stripe_y_start, stripe_y_start + stripe_height):\n            grid[y, stripe_x] = stripe_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/207/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/207/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/207/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/207/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/207/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/207/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/207/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/207/images/train_output_2.png"}]}, "index": 207, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color replacement, pattern matching\n\n# description:\n# In the input you will see a grid that consists of a central colored cross pattern (a vertical and horizontal line of pixels) \n# surrounded by pixels of a different color. To create the output grid, you should replace the color of the central cross \n# pattern with the color of the surrounding pixels.\n\ndef main(input_grid):\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Check for the central cross pattern (assuming it is a cross centered in the grid)\n    center_x, center_y = n // 2, m // 2\n\n    # Get the color of the surrounding pixels\n    surrounding_color = output_grid[0, 0]  # Assume the top-left corner is the surrounding color\n\n    # Change the color of the central cross pattern\n    for i in range(n):\n        output_grid[i, center_y] = surrounding_color  # Vertical line\n    for j in range(m):\n        output_grid[center_x, j] = surrounding_color  # Horizontal line\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = 5, 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Set a surrounding color (non-black)\n    surrounding_color = np.random.choice(Color.NOT_BLACK)\n\n    # Fill the grid with the surrounding color\n    grid.fill(surrounding_color)\n\n    # Define the cross pattern color (different from the surrounding)\n    cross_color = np.random.choice([c for c in Color.NOT_BLACK if c != surrounding_color])\n\n    # Create the cross pattern in the grid\n    center_x, center_y = n // 2, m // 2\n    for i in range(n):\n        grid[i, center_y] = cross_color  # Vertical line\n    for j in range(m):\n        grid[center_x, j] = cross_color  # Horizontal line\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/208/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/208/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/208/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/208/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/208/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/208/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/208/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/208/images/train_output_2.png"}]}, "index": 208, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# erosion, object detection, centering\n\n# description:\n# In the input, you will see a grid with scattered colored pixels forming objects. \n# To make the output, erode each object by one pixel. If an object is eroded fully, \n# replace it with a single pixel in the center of where it used to be.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract connected components (objects) from the input grid.\n    # 2. For each object, determine its shape and apply erosion.\n    # 3. If an object becomes empty after erosion, place a single pixel at its center.\n    # 4. Build the output grid by blitting the eroded objects.\n\n    # Step 1: Extract connected components\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for obj in objects:\n        # Step 2: Erode the object by one pixel\n        eroded_obj = np.copy(obj)\n        # Replace the outer pixels with black (erode)\n        eroded_obj[1:-1, 1:-1] = Color.BLACK  # Simple erosion for demonstration; can be more complex\n\n        # Count remaining pixels\n        if np.count_nonzero(eroded_obj) == 0:\n            # Step 3: If the object is fully eroded, place a single pixel in the center\n            center_x = obj.shape[0] // 2\n            center_y = obj.shape[1] // 2\n            output_grid[center_x, center_y] = Color.BLUE  # Replace with a single color, e.g., blue\n        else:\n            # Place the eroded object back in the output grid\n            blit_object(output_grid, eroded_obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with random objects scattered around\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Random number of objects\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Create a random sprite (object)\n        sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.5, color_palette=Color.NOT_BLACK)\n\n        # Place the sprite in a random free location on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/209/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/209/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/209/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/209/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/209/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/209/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/209/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/209/images/train_output_2.png"}]}, "index": 209, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, object detection, transformation\n\n# description:\n# In the input, you will see a grid with various colored circles on a black background.\n# To create the output grid, you need to find the largest blue circle and fill the entire grid with that blue color, \n# while leaving the background as black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Detect all circular objects of blue color in the grid.\n    blue_circles = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=8)\n\n    # Find the largest blue circle by area (using bounding boxes)\n    largest_circle = max(blue_circles, key=lambda circle: np.sum(circle != Color.BLACK))\n\n    # Create an output grid filled with black initially\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Place the largest blue circle in the output grid\n    output_grid[largest_circle != Color.BLACK] = Color.BLUE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize the grid with random dimensions\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of blue circles\n    num_circles = np.random.randint(1, 6)\n\n    for _ in range(num_circles):\n        # Randomly determine the radius of the circle\n        radius = np.random.randint(2, 5)  # Circles will have radius between 2 and 4\n        \n        # Create a circular sprite (2D array) for the blue circle\n        circle_sprite = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n        for x in range(-radius, radius + 1):\n            for y in range(-radius, radius + 1):\n                if x**2 + y**2 \u003c= radius**2:\n                    circle_sprite[x + radius, y + radius] = Color.BLUE\n\n        # Place the blue circle at a random position in the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=circle_sprite, border_size=0, padding=0)\n        grid = blit_sprite(grid=grid, sprite=circle_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/210/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/210/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/210/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/210/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/210/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/210/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/210/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/210/images/train_output_2.png"}]}, "index": 210, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, bounding box\n\n# description:\n# In the input grid, you will see several colored objects on a black background. \n# Each object is a rectangular shape made of a single color. \n# To create the output grid, color each object according to its area: \n# green if the area is less than or equal to 4 pixels, \n# orange if it\u0027s between 5 and 8 pixels, and \n# red if it\u0027s greater than 8 pixels.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Find connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Iterate through each detected object\n    for obj in objects:\n        # Calculate the area of the object\n        area = np.sum(obj != Color.BLACK)  # Count non-background pixels\n        \n        # Determine the color based on area size\n        if area \u003c= 4:\n            color = Color.GREEN\n        elif area \u003c= 8:\n            color = Color.ORANGE\n        else:\n            color = Color.RED\n        \n        # Color the object in the output grid\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        output_grid[x:x + w, y:y + h] = color  # Color the entire bounding box area\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid (background)\n    n, m = 10, 10  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly generate a number of objects\n    num_objects = np.random.randint(2, 6)  # Between 2 and 5 objects\n\n    for _ in range(num_objects):\n        # Randomly choose dimensions for the object\n        width, height = np.random.randint(1, 5), np.random.randint(1, 5)  # Object size between 1 and 4\n        color = np.random.choice([Color.RED, Color.BLUE, Color.YELLOW, Color.TEAL, Color.MAROON])  # Random color\n        \n        # Create a sprite for the object\n        sprite = np.full((height, width), color)\n        \n        # Attempt to find a random free location for the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except:\n            pass  # Skip if no free location is available\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/211/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/211/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/211/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/211/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/211/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/211/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/211/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/211/images/train_output_2.png"}]}, "index": 211, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, rotation, pattern reconstruction\n\n# description:\n# In the input, you will see a grid with a pattern in the upper left corner and several objects that contain pieces of the pattern.\n# To make the output, rotate each object so that its piece of the pattern aligns with the pattern in the upper left corner, \n# then reconstruct the pattern in a larger output grid.\n\ndef rotate_grid(grid: np.ndarray, k: int) -\u003e np.ndarray:\n    \"\"\"Rotate the grid 90 degrees clockwise k times.\"\"\"\n    return np.rot90(grid, -k)\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the pattern from the top-left corner\n    pattern_size = 3  # Fixed size for the pattern\n    pattern = input_grid[:pattern_size, :pattern_size]\n\n    # Find all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n\n    # Create an output grid with size larger than the pattern to accommodate the reconstruction\n    output_size = pattern_size + 4  # 2 extra rows and columns on each side for spacing\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # Place the original pattern in the center of the output grid\n    output_grid[2:2 + pattern_size, 2:2 + pattern_size] = pattern\n\n    # Rotate each object and place it in the output grid\n    for obj in objects:\n        # Skip the pattern in the upper left corner\n        if np.array_equal(crop(obj), pattern):\n            continue\n        \n        # Rotate the object until it matches the pattern\n        for k in range(4):  # Check all 4 rotations\n            rotated_obj = rotate_grid(crop(obj), k)\n            if np.array_equal(rotated_obj, pattern):\n                # Find a position to place the rotated object in the output grid\n                pos_x, pos_y = 0, 0\n                # Randomly place the object in one of the corners of the output grid\n                if np.random.rand() \u003c 0.5:\n                    pos_x, pos_y = 0, 0  # Top-left corner\n                elif np.random.rand() \u003c 0.5:\n                    pos_x, pos_y = 0, output_size - obj.shape[0]  # Top-right corner\n                else:\n                    pos_x, pos_y = output_size - obj.shape[0], 0  # Bottom-left corner\n                \n                # Place the rotated object in the output grid\n                blit_sprite(output_grid, rotated_obj, x=pos_x, y=pos_y, background=Color.BLACK)\n                break\n            \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a base grid with a black background\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a pattern in the upper left corner\n    pattern_size = 3  # Fixed size for the pattern\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n    pattern = random_sprite(n=pattern_size, m=pattern_size, color_palette=[pattern_color], density=0.5)\n\n    # Place the pattern in the upper left corner\n    grid[:pattern_size, :pattern_size] = pattern\n\n    # Generate several random objects that could contain parts of the pattern\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        obj_size = np.random.randint(2, 5)\n        obj = random_sprite(n=obj_size, m=obj_size, density=0.5, color_palette=list(Color.NOT_BLACK))\n        \n        # Randomly place the object in the grid, ensuring it does not overlap with the pattern\n        x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK)\n        blit_sprite(grid, obj, x=x, y=y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/212/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/212/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/212/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/212/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/212/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/212/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/212/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/212/images/train_output_2.png"}]}, "index": 212, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, tiling\n\n# description:\n# In the input, you will see a 3x3 pattern. To make the output, create a 9x9 grid and repeat the pattern in each 3x3 subgrid.\n\ndef main(input_grid):\n    # Step 1: Extract the 3x3 pattern from the input grid\n    pattern = crop(input_grid, background=Color.BLACK)\n    \n    # Step 2: Create an output grid of size 9x9, filled with black color\n    output_grid = np.full((9, 9), Color.BLACK, dtype=int)\n    \n    # Step 3: Fill the output grid with the pattern in each 3x3 subgrid\n    for i in range(3):\n        for j in range(3):\n            blit_sprite(output_grid, pattern, x=i*3, y=j*3, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 3x3 grid of random colors (not black)\n    pattern = random_sprite(n=3, m=3, density=0.5, color_palette=list(Color.NOT_BLACK))\n    \n    # Create a background grid of sufficient size (at least 3x3)\n    grid_size = np.random.randint(5, 10)\n    grid = np.full((grid_size, grid_size), Color.BLACK, dtype=int)\n    \n    # Randomly place the 3x3 pattern in the grid\n    x, y = random_free_location_for_sprite(grid, pattern, border_size=1)\n    grid = blit_sprite(grid, pattern, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/213/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/213/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/213/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/213/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/213/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/213/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/213/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/213/images/train_output_2.png"}]}, "index": 213, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, cropping, scaling, alignment\n\n# description:\n# In the input, you will see a grid with multiple colored rectangles of different sizes.\n# To create the output, identify the largest rectangle, crop it, scale it to a predetermined size (10x10),\n# and place it at the center of the output grid.\n\ndef main(input_grid):\n    # Detect all rectangles in the input grid\n    rectangles = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=False, connectivity=4)\n\n    # Select the largest rectangle based on area\n    largest_rectangle = max(rectangles, key=lambda rect: rect.shape[0] * rect.shape[1])\n    \n    # Crop the largest rectangle\n    cropped_rectangle = crop(largest_rectangle, background=Color.BLACK)\n    \n    # Scale the rectangle to 10x10\n    scaled_rectangle = scale_pattern(cropped_rectangle, scale_factor=10 // max(cropped_rectangle.shape))\n\n    # Create an empty output grid of size 12x12 (to allow centering)\n    output_grid = np.full((12, 12), Color.BLACK, dtype=int)\n\n    # Calculate the position to center the scaled rectangle in the output grid\n    start_x = (output_grid.shape[0] - scaled_rectangle.shape[0]) // 2\n    start_y = (output_grid.shape[1] - scaled_rectangle.shape[1]) // 2\n\n    # Place the scaled rectangle at the center of the output grid\n    output_grid = blit_sprite(output_grid, scaled_rectangle, x=start_x, y=start_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a grid of random size (15x15)\n    n, m = 15, 15\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a number of random rectangles\n    num_rectangles = np.random.randint(3, 6)\n    for _ in range(num_rectangles):\n        # Random dimensions for the rectangle (2-5 wide and 2-5 tall)\n        width = np.random.randint(2, 6)\n        height = np.random.randint(2, 6)\n\n        # Random color for the rectangle\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a rectangle sprite\n        rectangle = np.full((height, width), color)\n\n        # Find a random location to place the rectangle\n        x, y = random_free_location_for_sprite(grid, rectangle)\n        \n        # Blit the rectangle onto the grid\n        grid = blit_sprite(grid, rectangle, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/214/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/214/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/214/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/214/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/214/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/214/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/214/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/214/images/train_output_2.png"}]}, "index": 214, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity, attraction, particle movement\n\n# description:\n# In the input, you will see a grid with several colored particles scattered on a black background. There is also a single red particle in the center of the grid.\n# To make the output, move each colored particle towards the red particle by one cell in the direction that minimizes the distance to the red particle.\n# If two or more particles are equidistant to the red particle, they should move in their respective directions without overlapping.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a blank output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the coordinates of the red particle\n    red_position = np.argwhere(input_grid == Color.RED)[0]\n\n    # Get the coordinates of all colored particles\n    colored_positions = np.argwhere(input_grid != Color.BLACK)\n    \n    for color_position in colored_positions:\n        # Calculate direction towards the red particle\n        direction = np.sign(red_position - color_position)\n\n        # Calculate the new position\n        new_position = color_position + direction\n        \n        # Check if the new position is within bounds and not overlapping with another particle\n        if (0 \u003c= new_position[0] \u003c output_grid.shape[0] and\n            0 \u003c= new_position[1] \u003c output_grid.shape[1] and\n            output_grid[tuple(new_position)] == Color.BLACK):\n            output_grid[tuple(new_position)] = input_grid[tuple(color_position)]\n        else:\n            # If the move is blocked, keep the particle in its original position\n            output_grid[tuple(color_position)] = input_grid[tuple(color_position)]\n    \n    # Place the red particle in the output grid\n    output_grid[red_position[0], red_position[1]] = Color.RED\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 black grid first as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place the red particle in the center of the grid\n    grid[n//2, m//2] = Color.RED\n\n    # Randomly scatter colored particles on the grid, avoiding the center\n    num_particles = np.random.randint(5, 15)\n    for _ in range(num_particles):\n        while True:\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            if (grid[x, y] == Color.BLACK) and (x != n//2 or y != m//2):\n                color = random.choice([c for c in Color.NOT_BLACK if c != Color.RED])\n                grid[x, y] = color\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/215/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/215/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/215/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/215/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/215/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/215/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/215/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/215/images/train_output_2.png"}]}, "index": 215, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object detection, unique color identification\n\n# description:\n# In the input, you will see a grid with colored objects on a black background. \n# Each object may consist of multiple pixels of the same color. \n# To create the output grid, you should find the object that has the most unique color \n# (the color that occurs only once across the entire grid) and fill the entire output grid with that color.\n# If there are no unique colors, the output grid should remain black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Count the occurrences of each color in the grid.\n    # 2. Identify the unique color that occurs only once.\n    # 3. Find the object that contains this unique color.\n    # 4. Fill the entire output grid with the unique color or retain black if no unique color exists.\n\n    color_counts = {color: np.count_nonzero(input_grid == color) for color in Color.NOT_BLACK}\n    \n    # Find the unique color (occurs only once)\n    unique_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            unique_color = color\n            break\n    \n    # If there\u0027s no unique color, return a black grid\n    if unique_color is None:\n        return np.zeros_like(input_grid)\n\n    # Create output grid filled with the unique color\n    output_grid = np.full(input_grid.shape, unique_color)\n    \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize a 10x10 grid representing a black background.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly assign a unique color to one position in the grid\n    unique_color = random.choice(Color.NOT_BLACK)\n    unique_position = (random.randint(0, n-1), random.randint(0, m-1))\n    grid[unique_position] = unique_color\n\n    # Fill the rest of the grid with random colors ensuring no duplicates\n    remaining_colors = [color for color in Color.NOT_BLACK if color != unique_color]\n\n    for remaining_color in remaining_colors:\n        # Pick a random frequency but ensure this color is not unique\n        frequency_of_this_color = random.randint(2, 5)  # At least 2 occurrences\n\n        for _ in range(frequency_of_this_color):\n            # Randomly choose an unoccupied cell for the remaining color\n            empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.BLACK]\n            if not empty_cells:\n                break  # Avoid overflow if all cells are filled\n            x, y = random.choice(empty_cells)\n            grid[x, y] = remaining_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/216/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/216/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/216/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/216/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/216/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/216/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/216/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/216/images/train_output_2.png"}]}, "index": 216, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color guide, rectangular cells, connected components\n\n# description:\n# In the input you will see grey horizontal and vertical bars that divide the grid into nine 3x3 rectangular regions, each of which contains 3-5 colored pixels. \n# To make the output, find the region that has exactly 3 colored pixels, and use its colors as a guide to fill in all the other cells.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Identify the divider color\n    divider_color = None\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i, j] != Color.BLACK:\n                continue\n            if i \u003e 0 and input_grid[i-1, j] != Color.BLACK:\n                divider_color = input_grid[i-1, j]\n                break\n        if divider_color is not None:\n            break\n    \n    assert divider_color is not None, \"No divider color found\"\n\n    # Find connected components excluding the divider color\n    regions = find_connected_components(input_grid, background=divider_color, monochromatic=False)\n\n    # Look for the special region with exactly 3 colored pixels\n    special_region = None\n    for region in regions:\n        # Count non-divider and non-black pixels\n        count_colored_pixels = np.sum((region != divider_color) \u0026 (region != Color.BLACK))\n        if count_colored_pixels == 3:\n            assert special_region is None, \"More than one special region found\"\n            special_region = region\n    \n    # Create the output grid\n    output_grid = np.zeros_like(input_grid)\n    output_grid[input_grid == divider_color] = divider_color  # Retain divider colors\n\n    # Get the colors from the special region\n    if special_region is not None:\n        special_colors = np.unique(special_region[special_region != divider_color])\n        for color in special_colors:\n            output_grid[output_grid != divider_color] = color  # Fill all cells with special colors\n    \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    divider_color = Color.GRAY\n\n    # Create the grid with dividers forming 3x3 cells\n    cell_size = 3\n    n_cells = 3\n    divider_size = 1\n    n_dividers = n_cells - 1\n    distance_between_cells = cell_size + divider_size\n    m = cell_size * n_cells + divider_size * n_dividers\n    grid = np.full((m, m), Color.BLACK)\n\n    for i in range(n_dividers):\n        # Horizontal dividers\n        grid[cell_size + i * (cell_size + divider_size), :] = divider_color\n        # Vertical dividers\n        grid[:, cell_size + i * (cell_size + divider_size)] = divider_color\n\n    # Pick one of the cells to have exactly 3 colors (the others will have 4-5)\n    special_cell_x, special_cell_y = np.random.randint(3), np.random.randint(3)\n\n    for x in range(3):\n        for y in range(3):\n            if x == special_cell_x and y == special_cell_y:\n                n_colors = 3\n            else:\n                n_colors = np.random.randint(4, 6)  # 4 or 5 colors\n\n            # Extract view of the cell\n            cell = grid[x * distance_between_cells : x * distance_between_cells + cell_size,\n                        y * distance_between_cells : y * distance_between_cells + cell_size]\n\n            # Color the cell by picking random positions and random colors until we have enough colored pixels\n            while np.sum(cell != Color.BLACK) \u003c n_colors:\n                # Pick a random spot to color\n                cell_x, cell_y = np.random.randint(cell_size), np.random.randint(cell_size)\n                cell[cell_x, cell_y] = random.choice([color for color in Color.ALL_COLORS if color != Color.BLACK and color != divider_color])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/217/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/217/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/217/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/217/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/217/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/217/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/217/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/217/images/train_output_2.png"}]}, "index": 217, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, pattern reconstruction\n\n# description:\n# In the input you will see a pattern that is composed of multiple 2x2 squares, arranged in a grid.\n# Each square contains a color or is empty (black). \n# To make the output, you should rotate the entire grid 90 degrees counterclockwise. \n# This means that the squares will shift their positions according to the rotation.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid with the same dimensions, initialized to black\n    output_grid = np.zeros((m, n), dtype=int)  # Note the swapped dimensions for rotation\n\n    # Perform the rotation\n    for i in range(n):\n        for j in range(m):\n            output_grid[m - j - 1, i] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the size of the grid\n    grid_size = np.random.randint(4, 7)  # Random size between 4x4 and 6x6\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Define available colors excluding black\n    available_colors = Color.NOT_BLACK\n\n    # Fill the grid with random 2x2 patterns, leaving some areas as black\n    for i in range(0, grid_size, 2):\n        for j in range(0, grid_size, 2):\n            # Randomly decide if we want to fill this 2x2 square\n            if np.random.rand() \u003e 0.5:\n                # Generate a random 2x2 pattern\n                pattern = random_sprite(n=2, m=2, density=1, color_palette=available_colors)\n                grid[i:i+2, j:j+2] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/218/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/218/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/218/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/218/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/218/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/218/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/218/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/218/images/train_output_2.png"}]}, "index": 218, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, rotation\n\n# description:\n# In the input you will see a pattern of pixels in the top left corner of the grid. \n# To make the output, copy the pattern to the center of the output and rotate it 180 degrees.\n\ndef main(input_grid):\n    # Find the connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=4)\n\n    # Assume there is only one connected component which is the pattern\n    assert len(objects) == 1\n    pattern = objects[0]\n\n    # Crop the pattern to remove any extra rows or columns of black pixels\n    cropped_pattern = crop(pattern, background=Color.BLACK)\n\n    # Get the dimensions of the cropped pattern\n    pattern_height, pattern_width = cropped_pattern.shape\n\n    # Create an output grid which is large enough to place the rotated pattern in the center\n    output_grid = np.full((pattern_height, pattern_width), Color.BLACK)\n\n    # Rotate the cropped pattern 180 degrees\n    rotated_pattern = np.rot90(cropped_pattern, k=2)\n\n    # Place the rotated pattern in the center of the output grid\n    output_grid[:] = rotated_pattern\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the pattern\n    size = np.random.randint(2, 5)  # Pattern size between 2x2 and 4x4\n\n    # Create a grid with a black background\n    grid_size = (5, 5)  # Fixed input grid size\n    grid = np.full(grid_size, Color.BLACK)\n\n    # Select a random color for the pattern\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a pattern in the top left corner of the grid\n    pattern = random_sprite(size, size, density=0.5, color_palette=[pattern_color], background=Color.BLACK)\n\n    # Blit the pattern onto the top left corner of the grid\n    grid = blit_sprite(grid, sprite=pattern, x=0, y=0, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/219/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/219/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/219/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/219/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/219/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/219/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/219/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/219/images/train_output_2.png"}]}, "index": 219, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape matching, color filling\n\n# description:\n# In the input you will see several colored shapes that are not fully visible. \n# To make the output grid, you should complete each shape with its respective color.\n\ndef main(input_grid):\n    # Find all connected components (shapes) in the input grid\n    shapes = find_connected_components(grid=input_grid, monochromatic=False, connectivity=4)\n\n    # Create an output grid initialized to the background color\n    output_grid = np.copy(input_grid)\n\n    for shape in shapes:\n        # Get the bounding box of the current shape\n        x, y, w, h = bounding_box(grid=shape, background=Color.BLACK)\n\n        # Crop the shape to analyze it\n        cropped_shape = crop(grid=shape, background=Color.BLACK)\n\n        # Determine the color of the shape (the color of its first pixel)\n        shape_color = cropped_shape[0, 0]\n\n        # Fill the missing pixels (black) in the cropped shape with its color\n        completed_shape = np.where(cropped_shape == Color.BLACK, shape_color, cropped_shape)\n\n        # Place the completed shape back into the output grid\n        output_grid[x:x + w, y:y + h] = np.where(completed_shape == Color.BLACK, output_grid[x:x + w, y:y + h], completed_shape)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size within reasonable limits\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the number of shapes to add\n    num_shapes = np.random.randint(2, 5)\n\n    for _ in range(num_shapes):\n        # Generate a random shape size\n        shape_height = np.random.randint(2, 5)\n        shape_width = np.random.randint(2, 5)\n\n        # Create a random shape with a certain density of color\n        shape_color = np.random.choice(Color.NOT_BLACK)\n        shape_sprite = random_sprite(n=shape_height, m=shape_width, color_palette=[shape_color], density=0.5)\n\n        # Randomly choose a position to place the shape\n        x, y = random_free_location_for_sprite(grid=grid, sprite=shape_sprite, border_size=1)\n        grid = blit_sprite(grid=grid, sprite=shape_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/220/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/220/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/220/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/220/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/220/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/220/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/220/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/220/images/train_output_2.png"}]}, "index": 220, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, color change, shape transformation\n\n# description:\n# In the input you will see a grid containing a red square object. \n# To create the output grid, you need to translate the red square down by 2 pixels and change its color to blue. \n# Additionally, you should enlarge the square to a 4x4 size.\n\ndef main(input_grid):\n    # Step 1: Detect the red square object in the grid.\n    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n    assert len(red_objects) == 1, \"There should be exactly one red square object.\"\n\n    red_square = red_objects[0]\n\n    # Step 2: Create an output grid.\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 3: Change the color of the square to blue and enlarge it to 4x4.\n    enlarged_square = np.full((4, 4), Color.BLUE)\n\n    # Step 4: Find the position of the red square in the input grid.\n    x, y = object_position(red_square, background=Color.BLACK, anchor=\"upper left\")\n\n    # Step 5: Translate the enlarged square down by 2 pixels.\n    new_x = x + 2\n    new_y = y\n\n    # Step 6: Blit the enlarged blue square onto the output grid.\n    blit_sprite(output_grid, enlarged_square, x=new_y, y=new_x, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size (5, 5) with a red square object.\n    grid_size = 5\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a small 2x2 red square sprite.\n    red_square_sprite = np.array([[Color.RED, Color.RED],\n                                   [Color.RED, Color.RED]])\n\n    # Randomly place the red square in the grid ensuring that it fits.\n    x, y = random_free_location_for_sprite(grid=grid, sprite=red_square_sprite, border_size=0)\n    blit_sprite(grid, red_square_sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/221/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/221/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/221/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/221/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/221/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/221/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/221/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/221/images/train_output_2.png"}]}, "index": 221, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, grid manipulation\n\n# description:\n# In the input, you will see a 5x5 grid with a single yellow pixel.\n# To make the output grid, rotate the grid 90 degrees counterclockwise around the yellow pixel.\n\ndef main(input_grid):\n    # Find the position of the yellow pixel\n    yellow_pixels = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n    \n    if not yellow_pixels:\n        return input_grid  # In case there\u0027s no yellow pixel, return the original grid\n    \n    yellow_pixel = yellow_pixels[0]\n    yellow_x, yellow_y = object_position(yellow_pixel, background=Color.BLACK, anchor=\u0027center\u0027)\n\n    # Create a new output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Rotate the grid 90 degrees counterclockwise around the yellow pixel\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            new_x = yellow_x - (y - yellow_y)\n            new_y = yellow_y + (x - yellow_x)\n\n            # Ensure new coordinates are within bounds\n            if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                output_grid[new_x, new_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a 5x5 grid with a yellow pixel placed randomly\n    n, m = 5, 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter other colors while ensuring a yellow pixel is placed\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.ORANGE, Color.PINK]\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.7:  # 70% chance to be a random color\n                grid[i, j] = np.random.choice(colors)\n    \n    # Place a single yellow pixel at a random location\n    yellow_x = np.random.randint(0, n)\n    yellow_y = np.random.randint(0, m)\n    grid[yellow_x, yellow_y] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/222/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/222/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/222/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/222/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/222/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/222/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/222/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/222/images/train_output_2.png"}]}, "index": 222, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, size transformation\n\n# description:\n# In the input you will see a grid with a single colored triangle, formed by a right-angled triangle made of colored pixels.\n# To make the output grid, you should mirror the triangle over the vertical axis and then double its height, filling the new area with the same color.\n\ndef main(input_grid):\n    # Get the color of the triangle\n    triangle_color = np.unique(input_grid)[1]  # We assume the first color is the background (black)\n\n    # Find the bounding box of the triangle\n    triangle_pixels = np.argwhere(input_grid == triangle_color)\n    min_x, min_y = triangle_pixels.min(axis=0)\n    max_x, max_y = triangle_pixels.max(axis=0)\n\n    # Create the output grid, double the height\n    output_height = (max_x - min_x + 1) * 2\n    output_width = (max_y - min_y + 1) * 2\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # Mirror the triangle over the vertical axis\n    for x, y in triangle_pixels:\n        new_x = x - min_x\n        new_y = y - min_y\n        # Mirror horizontally\n        mirrored_y = output_width - 1 - new_y\n        output_grid[new_x, mirrored_y] = triangle_color\n\n    # Now scale the output: copy the triangle to the lower half\n    for x in range(output_height // 2):\n        for y in range(output_width):\n            if output_grid[x, y] == triangle_color:\n                output_grid[x + output_height // 2, y] = triangle_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_size = np.random.randint(6, 12)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Create a right-angled triangle in the grid\n    triangle_color = np.random.choice(Color.NOT_BLACK)\n    \n    # The triangle will be defined by its base and height\n    base_height = np.random.randint(2, grid_size // 2)\n    base_width = base_height  # Make it a right-angled triangle\n\n    # Fill the triangle in the grid\n    for i in range(base_height):\n        for j in range(i + 1):\n            grid[i, j] = triangle_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/223/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/223/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/223/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/223/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/223/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/223/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/223/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/223/images/train_output_2.png"}]}, "index": 223, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swapping, pixel manipulation\n\n# description:\n# In the input, you will see several colored objects on a black background. To make the output, swap the colors of the two smallest objects.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (objects) in the grid\n    objects = find_connected_components(input_grid)\n\n    # Identify the two smallest objects based on their pixel count\n    smallest_objects = sorted(objects, key=lambda x: np.count_nonzero(x))[:2]\n\n    if len(smallest_objects) \u003c 2:\n        return output_grid  # If there are less than two objects, return original grid\n\n    # Get the colors of the two smallest objects\n    color1 = np.unique(smallest_objects[0])[0]  # Color of the first smallest object\n    color2 = np.unique(smallest_objects[1])[0]  # Color of the second smallest object\n\n    # Swap the colors of the two smallest objects in the output grid\n    output_grid[output_grid == color1] = Color.TEAL  # Temporary color\n    output_grid[output_grid == color2] = color1    # Swap color1 to color2\u0027s position\n    output_grid[output_grid == Color.TEAL] = color2 # Assign color2 to color1\u0027s position\n\n    return output_grid\n\ndef generate_input():\n    # Create an empty black grid\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random objects on the grid\n    num_objects = np.random.randint(3, 7)\n    for _ in range(num_objects):\n        # Create a random sprite (object)\n        sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), color_palette=Color.NOT_BLACK)\n        \n        # Ensure the sprite has at least one pixel\n        while np.sum(sprite != Color.BLACK) == 0:\n            sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), color_palette=Color.NOT_BLACK)\n        \n        # Find a random location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If no space found, skip this sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/224/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/224/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/224/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/224/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/224/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/224/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/224/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/224/images/train_output_2.png"}]}, "index": 224, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object stacking, alignment\n\n# description:\n# In the input, you will see a black grid with several colored objects stacked on top of each other. Each object is a rectangle of a different color with a uniform height but varying widths. To make the output grid, stack all the objects on top of each other in such a way that they align perfectly to the left edge of the output grid, with no gaps in between.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract all colored objects from the input grid.\n    # 2. Determine the maximum height of the output grid based on the number of stacked objects.\n    # 3. Create the output grid with the appropriate height and width.\n    # 4. Stack the objects vertically in the output grid, aligning them to the left.\n\n    # Step 1: Extract objects from the input grid\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=4)\n\n    # Step 2: Create the output grid\n    max_height = sum(bounding_box(obj)[3] for obj in objects)  # total height of stacked objects\n    output_grid = np.full((max_height, 1), Color.BLACK)  # width is 1 to align to left edge\n\n    current_y = 0  # Keep track of the current vertical position in the output grid\n\n    # Step 3: Stack the objects into the output grid\n    for obj in objects:\n        obj_height = bounding_box(obj)[3]  # height of the current object\n        blit_sprite(output_grid, obj, x=0, y=current_y, background=Color.BLACK)  # place object in output\n        current_y += obj_height  # update current position for the next stack\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random stacks of colored rectangles aligned to the left.\n    grid = np.full((20, 20), Color.BLACK)  # Start with a black grid\n\n    # Randomly generate between 3 to 5 objects\n    n_objects = np.random.randint(3, 6)\n    for _ in range(n_objects):\n        # Randomly determine the width and height of the rectangle\n        width = np.random.randint(1, 5)  # Width between 1 and 4\n        height = np.random.randint(2, 6)  # Height between 2 and 5\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.BLACK])  # Choose a random color\n\n        # Create the colored rectangle\n        rect = np.full((height, width), color)\n\n        # Find a free location to place the rectangle, ensuring it aligns to the left\n        x = 0\n        y = np.random.randint(0, 20 - height)  # Random y position ensuring it fits\n\n        # Blit the rectangle into the grid\n        blit_sprite(grid, rect, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/225/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/225/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/225/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/225/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/225/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/225/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/225/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/225/images/train_output_2.png"}]}, "index": 225, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, grid filling, pattern replication\n\n# description:\n# In the input you will see a grid with a small pattern in the center. \n# To create the output, detect the color of the pattern and replicate it \n# to fill the entire grid with that color, while maintaining the original grid\u0027s shape.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Detect the center pattern color\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    # Define the size of the pattern to check (3x3)\n    pattern_size = 1  # This represents half the size (i.e., 2x2 pattern)\n    \n    # Get the color of the central pattern (assuming it\u0027s centered in the input)\n    center_color = input_grid[center_x - pattern_size:center_x + pattern_size + 1, \n                              center_y - pattern_size:center_y + pattern_size + 1]\n    \n    # Step 2: Check if the central pattern has a dominant color\n    unique, counts = np.unique(center_color, return_counts=True)\n    dominant_color = unique[np.argmax(counts)]\n\n    # Step 3: Create the output grid filled with the dominant color\n    output_grid = np.full(input_grid.shape, dominant_color)\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size between 5x5 and 10x10\n    n = np.random.randint(5, 11)\n    m = np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the size of the central pattern (3x3)\n    pattern_size = 1  # This represents the half of the pattern size (i.e., 2x2)\n\n    # Randomly choose a color for the central pattern\n    central_color = np.random.choice(Color.NOT_BLACK)\n\n    # Fill in the central pattern with the chosen color\n    center_x, center_y = n // 2, m // 2\n    grid[center_x - pattern_size:center_x + pattern_size + 1, \n         center_y - pattern_size:center_y + pattern_size + 1] = central_color\n\n    # Randomly scatter other colors in the grid, except for the central pattern\n    available_colors = [c for c in Color.NOT_BLACK if c != central_color]\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.BLACK:  # Only fill empty spaces\n                grid[i, j] = np.random.choice(available_colors)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/226/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/226/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/226/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/226/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/226/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/226/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/226/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/226/images/train_output_2.png"}]}, "index": 226, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color transformation\n\n# description:\n# In the input you will see a grid with a central pattern made up of a specific color, surrounded by a border of differently colored pixels. \n# To create the output, extract the central pattern and replace the color of the pattern with a new color according to the following mapping:\n# red -\u003e pink, blue -\u003e orange, green -\u003e pink, yellow -\u003e yellow.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central pattern by masking out the border\n    output_grid = np.copy(input_grid)\n\n    # Identify the bounding box of the central pattern\n    central_box = bounding_box(output_grid, background=Color.BLACK)\n\n    # Crop the central pattern\n    central_pattern = output_grid[central_box[1]:central_box[1] + central_box[3], central_box[0]:central_box[0] + central_box[2]]\n\n    # Define the color mapping\n    color_mapping = {\n        Color.RED: Color.PINK,\n        Color.BLUE: Color.ORANGE,\n        Color.GREEN: Color.PINK,\n        Color.YELLOW: Color.YELLOW\n    }\n\n    # Change the color of the central pattern according to the mapping\n    for original_color, new_color in color_mapping.items():\n        central_pattern[central_pattern == original_color] = new_color\n\n    # Place the transformed pattern back into the output grid\n    output_grid[central_box[1]:central_box[1] + central_box[3], central_box[0]:central_box[0] + central_box[2]] = central_pattern\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the pattern \n    n, m = random.randint(5, 10), random.randint(5, 10)\n\n    # Choose a color for the central pattern\n    pattern_color = random.choice(list(Color.NOT_BLACK))\n\n    # Create a central pattern\n    central_pattern = random_sprite(n, m, color_palette=[pattern_color], density=0.5)\n\n    # Create a grid that will contain the central pattern and a border\n    grid_width, grid_height = n + 4, m + 4\n    grid = np.zeros((grid_width, grid_height), dtype=int)\n\n    # Place the central pattern in the grid\n    grid[2:2 + n, 2:2 + m] = central_pattern\n\n    # Randomly fill the border with different colors\n    border_colors = random.sample(list(Color.NOT_BLACK), 4)  # Choose 4 colors for each border\n    grid[0, :] = border_colors[0]  # Top border\n    grid[-1, :] = border_colors[1]  # Bottom border\n    grid[:, 0] = border_colors[2]  # Left border\n    grid[:, -1] = border_colors[3]  # Right border\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/227/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/227/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/227/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/227/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/227/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/227/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/227/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/227/images/train_output_2.png"}]}, "index": 227, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object placement, pattern matching\n\n# description:\n# In the input, you will see a grid with a colored object and several larger, black circles. Each circle has a different colored pixel at its center.\n# To make the output: Remove the colored object from the input grid and place a copy of it centered on each colored pixel inside the circles. \n# The small object should change color to match the color of the pixel it\u0027s placed on.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Determine the background color and replace it with black temporarily.\n    # 2. Find and remove the small colored object from the input grid.\n    # 3. Identify the locations of the colored pixels within the circles.\n    # 4. Place copies of the small object centered on each colored pixel, changing its color to match the pixel\u0027s color.\n\n    # Determine background color (most common color)\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    input_grid[input_grid == background_color] = Color.BLACK\n\n    # Find the small object and remove it\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    smallest_object = min(objects, key=lambda x: np.count_nonzero(x))\n    input_grid[smallest_object != Color.BLACK] = Color.BLACK  \n\n    # Crop the object to get its sprite\n    sprite = crop(smallest_object)\n\n    # Prepare output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify circles and place copies of the sprite\n    circles = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    for circle in circles:\n        # Get the color of the circle (the most common non-black color)\n        circle_color = max(Color.NOT_BLACK, key=lambda x: np.count_nonzero(circle == x))\n        colored_pixels = np.argwhere(circle == circle_color)\n        for x, y in colored_pixels:\n            # Place a copy of the sprite centered on the colored pixel\n            blit_sprite(output_grid, sprite, x - sprite.shape[0] // 2, y - sprite.shape[1] // 2, background=Color.BLACK)\n\n    # Restore the background color\n    output_grid[output_grid == Color.BLACK] = background_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid and place a small object and circles in it.\n    # The object will have its own unique color, and the circles will each have different colored pixels at their centers.\n\n    # Set dimensions for the grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create the small object\n    sprite_color = random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(3, 3, color_palette=[sprite_color])\n    x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n    blit_sprite(grid, sprite, x, y)\n\n    # Create circles with different colors\n    n_circles = np.random.randint(3, 6)\n    for _ in range(n_circles):\n        circle_color = random.choice([color for color in Color.NOT_BLACK if color != sprite_color])\n        radius = np.random.randint(2, 5)\n        for dx in range(-radius, radius + 1):\n            for dy in range(-radius, radius + 1):\n                if dx**2 + dy**2 \u003c= radius**2:  # Check if inside circle\n                    if 0 \u003c= x + dx \u003c n and 0 \u003c= y + dy \u003c m:\n                        grid[x + dx, y + dy] = circle_color\n\n        # Mark the center pixel of the circle\n        if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m:\n            grid[x, y] = circle_color\n\n    # Change background color to something that\u0027s not black\n    background_color = random.choice([color for color in Color.NOT_BLACK if color not in {sprite_color}])\n    grid[grid == Color.BLACK] = background_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/228/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/228/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/228/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/228/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/228/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/228/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/228/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/228/images/train_output_2.png"}]}, "index": 228, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, object transformation\n\n# description:\n# In the input, you will see a grid with a single colored object. \n# To make the output, change the color of the object according to the following mapping: \n# red -\u003e green, blue -\u003e yellow, green -\u003e red, yellow -\u003e blue.\n# If the object has parts that overlap the grid edges, those parts will be removed in the output.\n\ndef main(input_grid):\n    # Find the connected component (the colored object)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    assert len(objects) == 1  # We expect exactly one object\n\n    colored_object = objects[0]\n    \n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change the color of the object according to the mapping\n    color_map = {\n        Color.RED: Color.GREEN,\n        Color.BLUE: Color.YELLOW,\n        Color.GREEN: Color.RED,\n        Color.YELLOW: Color.BLUE,\n    }\n\n    # Apply the color mapping\n    for x in range(colored_object.shape[0]):\n        for y in range(colored_object.shape[1]):\n            original_color = colored_object[x, y]\n            new_color = color_map.get(original_color, original_color)\n            output_grid[x, y] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the grid\n    grid_len = np.random.randint(4, 10)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Create a random colored object which is guaranteed to fit within the grid\n    sprite_width, sprite_height = np.random.randint(1, grid_len), np.random.randint(1, grid_len)\n    colors = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=colors, density=0.8)\n\n    # Find a random free location to place the sprite\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, background=Color.BLACK)\n    grid = blit_sprite(grid=grid, sprite=sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/229/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/229/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/229/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/229/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/229/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/229/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/229/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/229/images/train_output_2.png"}]}, "index": 229, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel growth, central expansion\n\n# description:\n# In the input you will see a grid with a single colored pixel at the center of a 3x3 grid.\n# To make the output, grow this center pixel into a 5x5 square of the same color, while keeping the surrounding pixels unchanged.\n\ndef main(input_grid):\n    # Identify the center pixel location (assuming the input has a single colored pixel at the center of a 3x3 region)\n    center_x, center_y = len(input_grid) // 2, len(input_grid[0]) // 2\n\n    # Check the color of the center pixel\n    center_color = input_grid[center_x, center_y]\n\n    # Create an output grid with the same shape as the input\n    output_grid = np.copy(input_grid)\n\n    # Grow the center pixel into a 5x5 square\n    for dx in range(-2, 3):  # -2 to 2 inclusive gives a total of 5 pixels\n        for dy in range(-2, 3):\n            output_grid[center_x + dx, center_y + dy] = center_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size 7x7 with a single colored pixel at the center\n    grid_size = 7\n    grid = np.full((grid_size, grid_size), Color.BLACK)  # Start with a black grid\n\n    # Choose a random color for the center pixel\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Place the colored pixel at the center of the grid\n    center_x, center_y = grid_size // 2, grid_size // 2\n    grid[center_x, center_y] = center_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/230/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/230/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/230/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/230/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/230/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/230/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/230/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/230/images/train_output_2.png"}]}, "index": 230, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color transformation\n\n# description:\n# In the input you will see a grid with a pattern of blue and red stripes arranged in 2x2 blocks.\n# To make the output, detect any 2x2 blocks that consist of:\n# [[Color.BLUE, Color.RED],\n#  [Color.BLUE, Color.RED]]\n# And change the color of blue to green and red to yellow.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = input_grid.copy()\n\n    # Loop through the grid, checking for the specific 2x2 pattern\n    for x in range(input_grid.shape[0] - 1):\n        for y in range(input_grid.shape[1] - 1):\n            # Check if the current 2x2 block matches the blue-red striped pattern\n            if (input_grid[x, y] == Color.BLUE and\n                input_grid[x, y + 1] == Color.RED and\n                input_grid[x + 1, y] == Color.BLUE and\n                input_grid[x + 1, y + 1] == Color.RED):\n                # Change colors in the output grid according to the transformation\n                output_grid[x, y] = Color.GREEN  # Change blue to green\n                output_grid[x, y + 1] = Color.YELLOW  # Change red to yellow\n                output_grid[x + 1, y] = Color.GREEN  # Change blue to green\n                output_grid[x + 1, y + 1] = Color.YELLOW  # Change red to yellow\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(6, 10), np.random.randint(6, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter blue and red pixels to create potential patterns\n    density = 0.5\n    for i in range(n):\n        for j in range(m):\n            # Randomly assign colors to the grid\n            if np.random.rand() \u003c density:\n                grid[i, j] = np.random.choice([Color.BLUE, Color.RED, Color.BLACK])\n            else:\n                grid[i, j] = Color.BLACK\n\n    # Ensure at least one blue-red striped pattern is present\n    for _ in range(np.random.randint(1, 3)):  # Add a few patterns\n        x = np.random.randint(0, n - 1)\n        y = np.random.randint(0, m - 1)\n        grid[x, y] = Color.BLUE\n        grid[x, y + 1] = Color.RED\n        grid[x + 1, y] = Color.BLUE\n        grid[x + 1, y + 1] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/231/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/231/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/231/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/231/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/231/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/231/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/231/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/231/images/train_output_2.png"}]}, "index": 231, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, pixel manipulation\n\n# description:\n# In the input, you will see a 5x5 grid filled with random pixels of various colors except black. \n# The output grid will change each pixel as follows:\n# 1. If a pixel is surrounded by pixels of the same color (up, down, left, right), it changes to a maroon pixel.\n# 2. If a pixel is not surrounded by the same color (or is on the edge), it changes to a blue pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.full(input_grid.shape, Color.BLUE)  # Start with all pixels as blue\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            current_color = input_grid[x][y]\n            # Check surrounding pixels\n            up = input_grid[x-1, y] if x \u003e 0 else None\n            down = input_grid[x+1, y] if x \u003c input_grid.shape[0] - 1 else None\n            left = input_grid[x, y-1] if y \u003e 0 else None\n            right = input_grid[x, y+1] if y \u003c input_grid.shape[1] - 1 else None\n\n            # Count how many surrounding pixels are the same\n            surrounding_same_color = sum(1 for color in [up, down, left, right] if color == current_color)\n\n            # If the pixel is surrounded by the same color, change it to maroon\n            if surrounding_same_color == 4:\n                output_grid[x, y] = Color.MAROON\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = 5, 5\n    grid = np.zeros((n, m), dtype=int)\n\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.ORANGE, Color.TEAL, Color.MAROON]\n    \n    # Randomly fill the grid with colors except black\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/232/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/232/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/232/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/232/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/232/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/232/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/232/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/232/images/train_output_2.png"}]}, "index": 232, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, dominant color detection\n\n# description:\n# In the input, you will see a grid filled with various patterns in different colors. \n# To make the output, identify the color that occupies the largest area (is most common) in the grid, and fill the entire grid with this dominant color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Count the occurrences of each color in the input grid\n    color_counts = {}\n    for row in input_grid:\n        for color in row:\n            if color != Color.BLACK:  # Exclude the background color\n                if color in color_counts:\n                    color_counts[color] += 1\n                else:\n                    color_counts[color] = 1\n\n    # Find the dominant color (the one with the maximum count)\n    dominant_color = max(color_counts, key=color_counts.get)\n\n    # Create an output grid filled with the dominant color\n    output_grid = np.full(input_grid.shape, dominant_color)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with random colors\n    grid_width, grid_height = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.full((grid_width, grid_height), Color.BLACK)\n\n    # Randomly choose a number of patterns to draw\n    num_patterns = np.random.randint(5, 15)\n\n    for _ in range(num_patterns):\n        # Randomly choose a pattern size\n        pattern_width, pattern_height = np.random.randint(1, 5), np.random.randint(1, 5)\n        # Randomly pick a color for the pattern, avoiding black\n        pattern_color = np.random.choice(Color.NOT_BLACK)\n\n        # Randomly choose a position for the pattern\n        x_pos = np.random.randint(0, grid_width - pattern_width)\n        y_pos = np.random.randint(0, grid_height - pattern_height)\n\n        # Draw the pattern on the grid\n        for i in range(pattern_width):\n            for j in range(pattern_height):\n                grid[x_pos + i, y_pos + j] = pattern_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/233/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/233/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/233/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/233/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/233/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/233/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/233/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/233/images/train_output_2.png"}]}, "index": 233, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color shifting, mirroring\n\n# description:\n# In the input you will see a grid with a random pattern of colored pixels. \n# To make the output grid, you should shift the colors in the pattern by one position in the color palette,\n# and then mirror the entire grid horizontally.\n\ndef main(input_grid):\n    # Step 1: Create a color shifting map\n    color_map = {Color.BLACK: Color.BLACK,\n                 Color.BLUE: Color.RED,\n                 Color.RED: Color.GREEN,\n                 Color.GREEN: Color.YELLOW,\n                 Color.YELLOW: Color.GREY,\n                 Color.GREY: Color.PINK,\n                 Color.PINK: Color.ORANGE,\n                 Color.ORANGE: Color.TEAL,\n                 Color.TEAL: Color.MAROON,\n                 Color.MAROON: Color.BLUE}  # Shift back to the first color\n\n    # Step 2: Create an output grid with the same shape as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Step 3: Apply color shifting to each pixel in the input grid\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            output_grid[i, j] = color_map[input_grid[i, j]]\n\n    # Step 4: Mirror the output grid horizontally\n    output_grid = output_grid[:, ::-1]\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Create a grid of random size\n    grid_size = np.random.randint(5, 15)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Step 2: Randomly fill the grid with colors\n    colors = list(Color.NOT_BLACK)  # Exclude black for visible patterns\n    density = 0.4  # Control the density of colored pixels\n\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if np.random.rand() \u003c density:\n                grid[i, j] = np.random.choice(colors)\n            else:\n                grid[i, j] = Color.BLACK  # Fill with black if no color is chosen\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/234/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/234/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/234/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/234/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/234/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/234/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/234/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/234/images/train_output_2.png"}]}, "index": 234, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, color matching, pattern extraction\n\n# description:\n# In the input, you will see a grid with a central colored square surrounded by a border of black pixels. \n# The central square is filled with a color that is different from black. \n# To make the output, you should extract the central square and then change its color to the color of the surrounding black pixels (which is the color of the central square\u0027s adjacent pixels).\n\ndef main(input_grid):\n    # Crop the grid to extract the central square\n    central_square = crop(input_grid, background=Color.BLACK)\n    \n    # Find the color of the pixels adjacent to the central square (i.e., the border)\n    surrounding_colors = set()\n    for dx in [-1, 1]:\n        for dy in [-1, 1]:\n            x, y = 0 + dx, 0 + dy\n            if 0 \u003c= x \u003c input_grid.shape[0] and 0 \u003c= y \u003c input_grid.shape[1]:\n                surrounding_colors.add(input_grid[x, y])\n\n    # The color we want to change the central square to is the one that is not black\n    new_color = (surrounding_colors - {Color.BLACK}).pop()\n    \n    # Change the color of the central square to the new color\n    output_grid = np.full(central_square.shape, new_color)\n    \n    return output_grid\n\ndef generate_input():\n    # Randomly choose size for the central square\n    size = np.random.randint(3, 8)\n    \n    # Generate the central square with random color\n    central_color = np.random.choice(list(Color.NOT_BLACK))\n    central_square = random_sprite(size, size, density=1, color_palette=[central_color])\n    \n    # Create a grid to hold the pattern with a border of black pixels\n    grid_size = size + 2\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n    \n    # Place the central square in the middle of the grid surrounded by black pixels\n    grid[1:-1, 1:-1] = central_square\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/235/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/235/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/235/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/235/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/235/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/235/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/235/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/235/images/train_output_2.png"}]}, "index": 235, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, grid manipulation\n\n# description:\n# In the input grid, there is a 5x5 section filled with colored squares.\n# There will be exactly one green square located at the center of this section (position (2,2))\n# and a yellow square located at a random position in the grid. \n# To create the output, replace the green square with the color of the yellow square.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Locate the green square (which is guaranteed to be at (2,2))\n    if output_grid[2, 2] == Color.GREEN:\n        # Find the yellow square in the grid\n        yellow_square_position = np.argwhere(output_grid == Color.YELLOW)\n        \n        if yellow_square_position.size \u003e 0:\n            # Get the coordinates of the first yellow square found\n            yellow_x, yellow_y = yellow_square_position[0]\n            # Change the color of the green square to match the yellow square\n            output_grid[2, 2] = output_grid[yellow_x, yellow_y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a 9x9 grid with black color\n    n, m = 9, 9\n    grid = np.zeros((n, m), dtype=int)\n\n    # Set a green square at the center (2,2)\n    grid[2, 2] = Color.GREEN\n\n    # Randomly place a yellow square in the grid at a location not overlapping with the green square\n    yellow_square = np.full((1, 1), Color.YELLOW, dtype=int)\n    \n    while True:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if (x, y) != (2, 2):  # Ensure it does not overlap with the green square\n            grid[x, y] = Color.YELLOW\n            break\n\n    # Optional: Fill the rest of the grid with random colors (not green or yellow)\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.BLACK:  # Only fill if it\u0027s still black\n                grid[i, j] = np.random.choice([color for color in Color.NOT_BLACK if color not in [Color.GREEN, Color.YELLOW]])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/236/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/236/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/236/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/236/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/236/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/236/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/236/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/236/images/train_output_2.png"}]}, "index": 236, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern expansion, tiling\n\n# description:\n# In the input, you will see a small pattern of colored pixels in the center of the grid. \n# To create the output, expand this pattern by repeating it in a tiled manner until it fills the entire grid.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    input_height, input_width = input_grid.shape\n\n    # Calculate the output grid dimensions\n    output_height = input_height * 3\n    output_width = input_width * 3\n\n    # Create the output grid with a black background\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Fill the output grid with the input pattern in a tiled manner\n    for i in range(3):\n        for j in range(3):\n            # Calculate the position to place the pattern\n            y_offset = i * input_height\n            x_offset = j * input_width\n            # Place the input pattern in the output grid\n            blit_sprite(output_grid, input_grid, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random pattern size between 2 and 4\n    pattern_size = np.random.randint(2, 5)\n    # Generate a random pattern with random colors (not black)\n    pattern = random_sprite(n=pattern_size, m=pattern_size, density=1, color_palette=Color.NOT_BLACK)\n\n    # Create a grid with a black background and place the pattern in the center\n    grid_size = 7  # Output grid size is fixed to accommodate the pattern in the center\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n    start = (grid_size - pattern_size) // 2\n    grid[start:start + pattern_size, start:start + pattern_size] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/237/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/237/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/237/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/237/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/237/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/237/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/237/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/237/images/train_output_2.png"}]}, "index": 237, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# growing, color transformation\n\n# description:\n# In the input you will see a grid with a single colored square. \n# To make the output grid, increase the size of the square by one pixel on all sides and change its color to red.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the connected components (the colored square)\n    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK, connectivity=4)\n    assert len(objects) == 1  # There should be exactly one object\n\n    square = objects[0]\n    \n    # Determine the bounding box of the square\n    x, y, width, height = bounding_box(square, background=Color.BLACK)\n    \n    # Create a new blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change the square\u0027s color to red\n    square[square != Color.BLACK] = Color.RED\n    \n    # Expanding the square by one pixel on all sides\n    for i in range(x - 1, x + height + 1 + 1):\n        for j in range(y - 1, y + width + 1 + 1):\n            if 0 \u003c= i \u003c output_grid.shape[0] and 0 \u003c= j \u003c output_grid.shape[1]:\n                output_grid[i, j] = Color.RED\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x n.\n    grid_len = np.random.randint(4, 8)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Randomly generate the square with a single color\n    square_size = np.random.randint(1, grid_len)  # Size of the square\n    color = np.random.choice([color for color in Color.NOT_BLACK])  # Choose a color for the square\n    square = random_sprite(n=square_size, m=square_size, color_palette=[color], density=1.0)\n    \n    # Find a free location to place the square\n    x, y = random_free_location_for_sprite(grid=grid, sprite=square, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=square, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/238/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/238/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/238/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/238/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/238/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/238/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/238/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/238/images/train_output_2.png"}]}, "index": 238, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape completion\n\n# description:\n# In the input you will see an incomplete yellow circle.\n# To make the output grid, you should use the pink color to complete the circle.\n\ndef main(input_grid):\n    # Find the bounding box of the incomplete circle and extract the sprite\n    x, y, width, height = bounding_box(grid=input_grid)\n    circle_sprite = input_grid[x:x + width, y:y + height]\n\n    # Create a new circle with the pink color to fill the missing parts\n    complete_circle = np.full(circle_sprite.shape, Color.PINK)\n\n    # Replace the black pixels (incomplete parts) of the circle with pink\n    completed_circle_sprite = np.where(circle_sprite == Color.BLACK, complete_circle, circle_sprite)\n\n    # Make the output grid by copying the original input grid\n    output_grid = np.copy(input_grid)\n    output_grid = blit_sprite(grid=output_grid, sprite=completed_circle_sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a size of n x m\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a size for the circle\n    radius = np.random.randint(2, min(n, m) // 2)\n\n    # Generate a circle sprite that is incomplete (density \u003c 1)\n    circle_sprite = random_sprite(n=radius * 2 + 1, m=radius * 2 + 1, color_palette=[Color.YELLOW], density=0.3, connectivity=8)\n\n    # Randomly choose a position to draw the circle sprite\n    x, y = random_free_location_for_sprite(grid=grid, sprite=circle_sprite, border_size=1)\n    grid = blit_sprite(grid=grid, sprite=circle_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/239/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/239/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/239/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/239/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/239/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/239/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/239/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/239/images/train_output_2.png"}]}, "index": 239, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern repetition, color swapping\n\n# description:\n# In the input you will see a grid with a pattern made of two distinct colors that are arranged either vertically or horizontally.\n# To create the output, repeat the pattern vertically and horizontally, and swap the two colors.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the height and width of the input grid\n    height, width = input_grid.shape\n    \n    # Create the output grid with double the size of the input grid\n    output_grid = np.zeros((height * 2, width * 2), dtype=int)\n    \n    # Copy the original pattern to the output grid\n    output_grid[:height, :width] = input_grid\n    \n    # Swap colors in the input grid\n    swapped_color = {Color.BLUE: Color.RED, Color.RED: Color.BLUE}\n    \n    # Create the new patterns by swapping colors\n    swapped_pattern = np.copy(input_grid)\n    for original_color, new_color in swapped_color.items():\n        swapped_pattern[swapped_pattern == original_color] = new_color\n\n    # Fill the output grid with the swapped pattern\n    output_grid[height:, :width] = swapped_pattern\n    output_grid[:height, width:] = swapped_pattern\n    output_grid[height:, width:] = swapped_pattern\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Choose the dimensions for the pattern\n    height = np.random.randint(3, 6)\n    width = np.random.randint(3, 6)\n    \n    # Create a grid for the pattern\n    grid = np.zeros((height, width), dtype=int)\n\n    # Randomly choose two colors\n    colors = np.random.choice(list(Color.NOT_BLACK), 2, replace=False)\n\n    # Fill the grid with alternating colors\n    for i in range(height):\n        for j in range(width):\n            grid[i, j] = colors[(i + j) % 2]  # Create a checkerboard pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/240/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/240/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/240/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/240/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/240/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/240/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/240/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/240/images/train_output_2.png"}]}, "index": 240, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color matching, bounding box\n\n# description:\n# In the input, you will see a colored object on a black background. To make the output, rotate the object 180 degrees and change its color to match the color of the pixel in the bottom-right corner of the input grid.\n\ndef main(input_grid):\n    # Step 1: Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Step 2: Get the color of the pixel in the bottom right corner\n    color = output_grid[-1, -1]\n\n    # Step 3: Find the bounding box of the colored object\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Step 4: Rotate the bounding box 180 degrees (which is equivalent to flipping horizontally and vertically)\n    for i in range(width):\n        for j in range(height):\n            if input_grid[x + i, y + j] != Color.BLACK:\n                output_grid[x + width - 1 - i, y + height - 1 - j] = color\n                output_grid[x + i, y + j] = Color.BLACK  # Clear the original position\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 black grid\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the sprite\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Select a color for the corner pixel\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Ensure the sprite color and corner color are different\n    if sprite_color == corner_color:\n        return generate_input()\n\n    # Create a random shape for the sprite\n    sprite_width, sprite_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    sprite = random_sprite(sprite_width, sprite_height, density=0.3, color_palette=[sprite_color])\n\n    # Blit the sprite in the center of the grid\n    blit_sprite(grid, sprite, x=(n-sprite_width)//2, y=(m-sprite_height)//2)\n\n    # Set the color of the bottom-right corner pixel\n    grid[-1, -1] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/241/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/241/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/241/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/241/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/241/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/241/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/241/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/241/images/train_output_2.png"}]}, "index": 241, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean logical operations, bitmasks with separator\n\n# description:\n# In the input you will see two yellow bitmasks separated by a grey vertical bar.\n# To make the output, color pink the pixels that are set in both bitmasks (logical AND).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the grey vertical bar. Vertical means constant X\n    for x_bar in range(input_grid.shape[0]):\n        if np.all(input_grid[x_bar, :] == Color.GREY):\n            break\n\n    left_mask = input_grid[:x_bar, :]\n    right_mask = input_grid[x_bar+1:, :]\n\n    output_grid = np.zeros_like(left_mask)\n    output_grid[(left_mask == Color.YELLOW) \u0026 (right_mask == Color.YELLOW)] = Color.PINK\n    \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # create a pair of equally sized yellow bitmasks\n    width, height = np.random.randint(2, 10), np.random.randint(2, 10)\n\n    grid1 = np.zeros((width, height), dtype=int)\n    grid2 = np.zeros((width, height), dtype=int)\n\n    for x in range(width):\n        for y in range(height):\n            grid1[x, y] = np.random.choice([Color.YELLOW, Color.BLACK])\n            grid2[x, y] = np.random.choice([Color.YELLOW, Color.BLACK])\n    \n    # create a grey vertical bar\n    bar = np.zeros((1, height), dtype=int)\n    bar[0, :] = Color.GREY\n\n    grid = np.concatenate((grid1, bar, grid2), axis=0)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/242/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/242/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/242/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/242/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/242/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/242/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/242/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/242/images/train_output_2.png"}]}, "index": 242, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, grid transformation\n\n# description:\n# In the input, you will see a 3x3 colored pattern grid.\n# To make the output grid, rotate the pattern 90 degrees clockwise.\n\ndef main(input_grid):\n    # We will create an output grid to hold the rotated pattern.\n    output_grid = np.zeros_like(input_grid)\n\n    # Rotate the 3x3 grid 90 degrees clockwise\n    for x in range(3):\n        for y in range(3):\n            output_grid[y][2 - x] = input_grid[x][y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random 3x3 grid with non-black colors\n    colors = Color.NOT_BLACK  # Excluding black\n    grid = np.random.choice(colors, size=(3, 3))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/243/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/243/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/243/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/243/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/243/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/243/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/243/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/243/images/train_output_2.png"}]}, "index": 243, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change, size determination\n\n# description:\n# In the input grid, you will find multiple 2x2 squares of different colors.\n# To create the output grid, change the color of the smallest 2x2 square to yellow\n# and leave the rest of the grid unchanged.\n\ndef main(input_grid):\n    # Find all connected 2x2 squares in the grid\n    squares = detect_objects(grid=input_grid, colors=Color.ALL_COLORS, monochromatic=True, allowed_dimensions=[(2, 2)], connectivity=4)\n\n    # If there are no squares, return the input grid\n    if not squares:\n        return input_grid\n\n    # Determine the smallest square by checking the area\n    smallest_square = min(squares, key=lambda x: np.sum(x != Color.BLACK))\n\n    # Create a blank output grid\n    output_grid = np.copy(input_grid)\n\n    # Change the color of the smallest square to yellow\n    output_grid[output_grid == smallest_square[0, 0]] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Create a 9x9 black grid as the background\n    n = m = 9\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define a list of colors to use for the squares\n    colors = [Color.RED, Color.BLUE, Color.GREEN, Color.PINK]\n\n    # Place a random number of colored 2x2 squares on the grid\n    for color in colors:\n        # Generate a random number of squares for the current color\n        for _ in range(np.random.randint(1, 4)):\n            square = np.full((2, 2), color, dtype=int)\n            x, y = random_free_location_for_sprite(grid, square, border_size=1)\n            blit_sprite(grid, square, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/244/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/244/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/244/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/244/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/244/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/244/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/244/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/244/images/train_output_2.png"}]}, "index": 244, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, cross expansion\n\n# description:\n# In the input you will see a grid with colored pixels arranged in a cross shape. \n# Each arm of the cross is 3 pixels long, and the center can have a different color.\n# To make the output, grow each arm of the cross by 2 pixels in its respective direction (north, south, east, west).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find all the crosses in the grid\n    crosses = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    for cross in crosses:\n        # Find the bounding box of the cross and its center\n        x, y, w, h = bounding_box(cross)\n        center_x, center_y = x + w // 2, y + h // 2\n\n        # Determine the color of the cross and center\n        cross_color = cross[cross != Color.BLACK][0]  # Get the color of the cross\n        center_color = cross[center_x, center_y]  # Center color\n\n        # Grow the arms of the cross\n        for dx in range(-2, 3):  # -2 to 2 to cover 5 pixels in each direction\n            if 0 \u003c= center_x + dx \u003c output_grid.shape[0]:\n                output_grid[center_x + dx, center_y] = cross_color  # Horizontal arm\n            if 0 \u003c= center_y + dx \u003c output_grid.shape[1]:\n                output_grid[center_x, center_y + dx] = cross_color  # Vertical arm\n\n        # Set the center color\n        output_grid[center_x, center_y] = center_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a blank grid with a size of 15x15\n    grid_size = 15\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Create a cross\n    for _ in range(np.random.randint(1, 4)):  # Random number of crosses\n        # Define the cross shape\n        cross_color, center_color = random.sample(list(Color.NOT_BLACK), 2)\n\n        # Create the cross in a 5x5 area\n        cross = np.zeros((5, 5), dtype=int)\n        cross[1:4, 2] = cross_color  # Vertical arm\n        cross[2, 1:4] = cross_color  # Horizontal arm\n        cross[2, 2] = center_color  # Center pixel\n\n        # Find a random location to place the cross\n        x, y = random_free_location_for_sprite(grid, cross)\n\n        # Blit the cross onto the grid\n        blit_sprite(grid, cross, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/245/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/245/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/245/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/245/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/245/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/245/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/245/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/245/images/train_output_2.png"}]}, "index": 245, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation\n\n# description:\n# In the input, you will see several objects of different colors and shapes, with a orange background. \n# To create the output, replace the color of the smallest object with the color of the largest object, \n# while keeping the other objects unchanged.\n\ndef main(input_grid):\n    # Get all connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.ORANGE, monochromatic=False, connectivity=8)\n    \n    # Identify the largest and smallest objects\n    largest_object = max(objects, key=lambda x: np.count_nonzero(x))\n    smallest_object = min(objects, key=lambda x: np.count_nonzero(x))\n\n    # Get colors of the largest and smallest objects\n    largest_color = largest_object[largest_object != Color.ORANGE][0]\n    smallest_color = smallest_object[smallest_object != Color.ORANGE][0]\n\n    # Create output grid and copy input grid\n    output_grid = np.copy(input_grid)\n\n    # Replace the smallest object\u0027s color with the largest object\u0027s color\n    output_grid[smallest_object == smallest_color] = largest_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a orange 10x10 grid as the background\n    n, m = 10, 10\n    grid = np.full((n, m), Color.ORANGE)\n    \n    # Make a random number of sprites\n    num_sprites = np.random.randint(3, 7)\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON]\n    \n    for _ in range(num_sprites):\n        # Create a random sprite with a random color\n        color = random.choice(colors)\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), density=0.5, color_palette=[color])\n        \n        # Try to place the sprite in a random location in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, background=Color.ORANGE)\n            blit_sprite(grid, sprite, x=x, y=y, background=Color.ORANGE)\n        except:\n            # If we can\u0027t place it, continue to the next sprite\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/246/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/246/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/246/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/246/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/246/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/246/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/246/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/246/images/train_output_2.png"}]}, "index": 246, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pattern mirroring\n\n# description:\n# In the input you will see a square pattern of three distinct colors.\n# To create the output grid, mirror the pattern vertically and then invert the colors according to the following scheme:\n# red becomes pink, pink becomes yellow, yellow becomes red.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output grid\n    output_grid = input_grid.copy()\n\n    # Define the color inversion mapping\n    color_mapping = {\n        Color.RED: Color.PINK,\n        Color.PINK: Color.YELLOW,\n        Color.YELLOW: Color.RED\n    }\n\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Mirror the pattern vertically and apply the color inversion\n    for i in range(n):\n        for j in range(m):\n            # Mirror the column index\n            mirrored_j = m - 1 - j\n            \n            # Invert the colors\n            output_grid[i, mirrored_j] = color_mapping.get(input_grid[i, j], input_grid[i, j])\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random square grid of size n x n with 3 distinct colors (red, pink, yellow)\n    n = np.random.randint(3, 6)\n    colors = [Color.RED, Color.PINK, Color.YELLOW]\n    \n    # Create a random pattern using the 3 colors\n    grid = random_sprite(n, n, density=1, color_palette=colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/247/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/247/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/247/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/247/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/247/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/247/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/247/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/247/images/train_output_2.png"}]}, "index": 247, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color guide, square detection, infinite rays\n\n# description:\n# In the input, you will see a grid containing several colored squares. One of the squares is a different color and is located at the center of the grid. To make the output, you should draw infinite rays starting from the center of the square, extending outward in all four cardinal directions (up, down, left, right). The color of the rays is the color of the square.\n\ndef main(input_grid):\n    # 1. Find the special square and its color.\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n    special_square = max(objects, key=lambda obj: np.count_nonzero(obj))  # assuming the largest square is the special one\n    special_color = next(iter(set(special_square.flatten()) - {Color.BLACK}))\n\n    # 2. Determine the center of the square\n    special_x, special_y, special_w, special_h = bounding_box(special_square)\n    center_x = special_x + special_w // 2\n    center_y = special_y + special_h // 2\n\n    # 3. Draw infinite rays in all four directions from the center\n    output_grid = np.copy(input_grid)\n    draw_line(output_grid, center_x, center_y, length=None, direction=(1, 0), color=special_color)  # Right\n    draw_line(output_grid, center_x, center_y, length=None, direction=(-1, 0), color=special_color)  # Left\n    draw_line(output_grid, center_x, center_y, length=None, direction=(0, 1), color=special_color)  # Down\n    draw_line(output_grid, center_x, center_y, length=None, direction=(0, -1), color=special_color)  # Up\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly choose a special square color and scatter other colors\n    special_color = random.choice(Color.NOT_BLACK)\n    other_colors = random.sample([color for color in Color.NOT_BLACK if color != special_color], 3)\n\n    # Create a special square in the center\n    special_square_size = np.random.randint(3, 6)  # size of the special square\n    start_x = (20 - special_square_size) // 2\n    start_y = (20 - special_square_size) // 2\n    grid[start_x:start_x + special_square_size, start_y:start_y + special_square_size] = special_color\n\n    # Scatter other colors randomly around the grid\n    n_pixels = np.random.randint(20, 60)\n    for _ in range(n_pixels):\n        while True:\n            x = np.random.randint(20)\n            y = np.random.randint(20)\n            if grid[x, y] == Color.BLACK:\n                grid[x, y] = random.choice(other_colors)\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/248/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/248/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/248/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/248/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/248/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/248/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/248/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/248/images/train_output_2.png"}]}, "index": 248, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape isolation, diagonal color swapping, pattern mirroring\n\n# description:\n# In the input, you will see a grid containing several diagonal shapes composed of colored pixels. \n# Each shape consists of a diagonal line of pixels from the top-left to bottom-right corner.\n# The task is to swap the colors along the diagonal and mirror the resulting shape across the center of the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to the black background\n    output_grid = np.zeros_like(input_grid)\n\n    # Find connected components (diagonal shapes)\n    diagonal_shapes = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    for shape in diagonal_shapes:\n        # Get the bounding box of the shape\n        x, y, width, height = bounding_box(shape)\n        shape_pixels = crop(shape)\n\n        # Swap colors along the diagonal\n        for i in range(min(width, height)):\n            shape_pixels[i, i], shape_pixels[height - 1 - i, width - 1 - i] = shape_pixels[height - 1 - i, width - 1 - i], shape_pixels[i, i]\n\n        # Mirror the shape across the center of the grid\n        center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n        for i in range(height):\n            for j in range(width):\n                # Calculate mirrored position\n                mirror_x = center_x + (i - center_x)\n                mirror_y = center_y + (j - center_y)\n                if 0 \u003c= mirror_x \u003c output_grid.shape[0] and 0 \u003c= mirror_y \u003c output_grid.shape[1]:\n                    output_grid[mirror_x, mirror_y] = shape_pixels[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Set the dimensions for the grid\n    n, m = random.randint(12, 20), random.randint(12, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the number of diagonal shapes to create\n    num_shapes = random.randint(1, 3)\n\n    for _ in range(num_shapes):\n        # Randomly determine the length of the diagonal shape\n        diagonal_length = random.randint(3, min(n, m) // 2)\n\n        # Choose a random color for the diagonal shape\n        color = random.choice(Color.NOT_BLACK)\n\n        # Start drawing the diagonal line in the grid\n        start_x = random.randint(0, n - diagonal_length)\n        start_y = random.randint(0, m - diagonal_length)\n\n        for i in range(diagonal_length):\n            grid[start_x + i, start_y + i] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/249/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/249/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/249/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/249/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/249/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/249/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/249/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/249/images/train_output_2.png"}]}, "index": 249, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern expansion, color transformation\n\n# description:\n# In the input, you will see a patterned grid in the center surrounded by a border of black pixels.\n# The central pattern is of a specific color, and the border pixels are all black.\n# To create the output grid, you should expand the central pattern outward by one pixel in every direction, \n# changing the color of the expanded pixels to match the color of the central pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central pattern by cropping the input grid\n    central_pattern = crop(input_grid)\n    \n    # Get the color of the central pattern\n    central_color = central_pattern[0, 0]  # Assuming the pattern is monochromatic\n    \n    # Create an output grid that is larger by 2 in both dimensions to accommodate the expansion\n    output_shape = (central_pattern.shape[0] + 2, central_pattern.shape[1] + 2)\n    output_grid = np.full(output_shape, Color.BLACK)\n\n    # Place the central pattern in the center of the output grid\n    blit_sprite(output_grid, central_pattern, x=1, y=1, background=Color.BLACK)\n\n    # Change the color of the border pixels to match the central pattern\u0027s color\n    output_grid[0, :] = central_color  # Top border\n    output_grid[-1, :] = central_color  # Bottom border\n    output_grid[:, 0] = central_color  # Left border\n    output_grid[:, -1] = central_color  # Right border\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the central pattern\n    n, m = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    # Select a color for the central pattern\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Generate a central pattern with the selected color\n    central_pattern = random_sprite(n, m, density=0.5, color_palette=[pattern_color])\n    \n    # Create a new grid that will fit the central pattern with a black border\n    grid = np.full((n + 2, m + 2), Color.BLACK)\n\n    # Place the central pattern in the grid\n    blit_sprite(grid, central_pattern, x=1, y=1, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/250/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/250/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/250/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/250/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/250/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/250/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/250/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/250/images/train_output_2.png"}]}, "index": 250, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# clustering, expansion, connected components\n\n# description:\n# In the input, you will see a grid with colored pixels scattered around. \n# To make the output, you should find the largest cluster of connected pixels (4-way connectivity) that are not black. \n# Then, expand that cluster by one pixel in all directions (up, down, left, right) while ensuring it stays within the grid bounds. \n# If the expansion goes beyond the grid, it should only paint to the edge of the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # 1. Find all connected components of non-black pixels\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # 2. Determine the largest component\n    largest_component = max(components, key=lambda comp: comp.size)\n    \n    # 3. Get the bounding box of the largest component\n    x, y, width, height = bounding_box(largest_component)\n    \n    # 4. Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # 5. Expand the largest component by one pixel in all directions\n    for i in range(max(0, x - 1), min(len(input_grid), x + height + 1)):\n        for j in range(max(0, y - 1), min(len(input_grid[0]), y + width + 1)):\n            output_grid[i, j] = input_grid[x + (i - x + 1) % height, y + (j - y + 1) % width] if input_grid[x + (i - x) % height, y + (j - y) % width] != Color.BLACK else Color.BLACK\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with random colors and some black background.\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter colored pixels (not black) in the grid\n    density = np.random.uniform(0.2, 0.6)\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c density:\n                grid[i, j] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/251/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/251/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/251/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/251/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/251/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/251/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/251/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/251/images/train_output_2.png"}]}, "index": 251, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# resizing, positioning\n\n# description:\n# In the input you will see a grid with a colored square.\n# To make the output grid, you should resize the colored square to twice its size \n# and position it at the center of the grid.\n\ndef main(input_grid):\n    # Detect the colored square in the input grid\n    colored_squares = detect_objects(grid=input_grid, colors=Color.NOT_BLACK,\n                                      monochromatic=True, connectivity=4)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Assume there is only one colored square in the input\n    if colored_squares:\n        colored_square = colored_squares[0]\n        # Crop the colored square from the input grid\n        cropped_square = crop(colored_square, background=Color.BLACK)\n        scaled_square = scale_pattern(cropped_square, scale_factor=2)\n\n        # Determine the position to place the scaled square at the center\n        center_x = (output_grid.shape[0] - scaled_square.shape[0]) // 2\n        center_y = (output_grid.shape[1] - scaled_square.shape[1]) // 2\n\n        # Blit the scaled square onto the center of the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=scaled_square, x=center_x, y=center_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_size = np.random.randint(8, 12)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly choose a position to place a colored square\n    square_size = 3\n    colors = Color.NOT_BLACK\n\n    # Ensure there\u0027s room for the square\n    x = np.random.randint(0, grid_size - square_size)\n    y = np.random.randint(0, grid_size - square_size)\n\n    # Create the colored square and place it in the grid\n    color = np.random.choice(colors)\n    grid[x:x + square_size, y:y + square_size] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/252/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/252/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/252/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/252/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/252/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/252/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/252/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/252/images/train_output_2.png"}]}, "index": 252, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation and pattern recognition\n\n# description:\n# The input is a grid where each column contains a pattern of colored pixels. \n# To create the output, for every consecutive pixel in a column, alternate the colors\n# according to the following mapping: green -\u003e red, red -\u003e green, blue -\u003e yellow, yellow -\u003e blue.\n# Thus, if a column starts with green followed by red, the output column will alternate them.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n\n    # Iterate over each column\n    for col in range(input_grid.shape[1]):\n        # Get the unique colors in the column\n        column_colors = input_grid[:, col]\n        unique_colors = list(dict.fromkeys(column_colors))  # Preserve order\n\n        # Create a color mapping\n        color_map = {\n            Color.GREEN: Color.RED,\n            Color.RED: Color.GREEN,\n            Color.BLUE: Color.YELLOW,\n            Color.YELLOW: Color.BLUE\n        }\n\n        # Apply transformation for the unique colors in the column\n        for idx, color in enumerate(unique_colors):\n            if color in color_map:\n                # Alternate colors in the output\n                for row in range(len(column_colors)):\n                    if row % 2 == 0:\n                        output_grid[row, col] = color_map[color]\n                    else:\n                        output_grid[row, col] = color\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Populate each column with a random pattern of colors\n    for col in range(m):\n        colors = [np.random.choice([Color.GREEN, Color.RED, Color.BLUE, Color.YELLOW]) for _ in range(n)]\n        grid[:, col] = colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/253/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/253/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/253/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/253/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/253/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/253/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/253/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/253/images/train_output_2.png"}]}, "index": 253, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal symmetry, rotation, scaling\n\n# description:\n# In the input you will see a pattern of colored pixels arranged in a square grid. The pattern is symmetric along the diagonal. \n# To make the output, you should create a new grid that is a scaled version of the input grid, but with the pattern rotated 90 degrees clockwise. \n# The output grid should be twice the size of the input grid.\n\ndef main(input_grid):\n    # Scale the input grid by a factor of 2\n    scale_factor = 2\n    scaled_grid = scale_pattern(input_grid, scale_factor)\n\n    # Rotate the scaled grid 90 degrees clockwise\n    rotated_grid = np.rot90(scaled_grid, k=-1)\n\n    return rotated_grid\n\ndef generate_input():\n    # Generate a random size for the grid (between 3 and 5 for simplicity)\n    size = np.random.randint(3, 6)\n    grid = np.zeros((size, size), dtype=int)\n\n    # Choose a color for the diagonal pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the grid symmetrically along the diagonal\n    for i in range(size):\n        for j in range(size):\n            if i == j or (i + j) == (size - 1):  # fill diagonal and anti-diagonal\n                grid[i, j] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/254/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/254/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/254/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/254/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/254/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/254/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/254/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/254/images/train_output_2.png"}]}, "index": 254, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# horizontal/vertical bars, pixel replacement, color mapping\n\n# description:\n# In the input, you will see a grid with several colored horizontal and vertical bars. \n# To make the output, replace each bar with a single pixel of the same color located where the bar started. \n# Horizontal bars become a pixel in the first row of that bar, and vertical bars become a pixel in the first column of that bar.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # Iterate through the grid to find bars\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color != Color.BLACK:  # Only consider non-black pixels\n                # Check for horizontal bars\n                if np.all(input_grid[x, :] == color):\n                    output_grid[x, y] = color  # Place pixel at the starting point of the horizontal bar\n                # Check for vertical bars\n                if np.all(input_grid[:, y] == color):\n                    output_grid[x, y] = color  # Place pixel at the starting point of the vertical bar\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    grid_size = 32\n    cell_size = 2\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Create horizontal bars\n    for i in range(0, grid_size, cell_size + 1):\n        color = np.random.choice(Color.NOT_BLACK)\n        grid[i, :] = color  # Horizontal bar\n\n    # Create vertical bars\n    for j in range(0, grid_size, cell_size + 1):\n        color = np.random.choice(Color.NOT_BLACK)\n        grid[:, j] = color  # Vertical bar\n\n    # Add random pixels in the grid that could be colored\n    n_colored_pixels = np.random.randint(5, 15)\n    for _ in range(n_colored_pixels):\n        x, y = np.random.randint(0, grid_size), np.random.randint(0, grid_size)\n        if grid[x, y] == Color.BLACK:  # Only place pixels in black areas\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/255/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/255/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/255/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/255/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/255/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/255/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/255/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/255/images/train_output_2.png"}]}, "index": 255, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color rotation, pattern transformation\n\n# description:\n# In the input, you will see a grid with a symmetric pattern of colored squares on one side of a vertical line. \n# To make the output, rotate the colors of the squares on one side of the line of symmetry clockwise by 90 degrees.\n\ndef main(input_grid):\n    # Determine the width of the grid and the line of symmetry (vertical)\n    width = input_grid.shape[1]\n    half_width = width // 2\n\n    # Get the left and right halves of the input grid\n    left_half = input_grid[:, :half_width]\n    right_half = input_grid[:, half_width:]\n\n    # Rotate the left half clockwise by 90 degrees\n    rotated_left_half = np.rot90(left_half, -1)\n\n    # Create the output grid by combining rotated left half and the unchanged right half\n    output_grid = np.concatenate((rotated_left_half, right_half), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with an even width to ensure a clear line of symmetry\n    n = np.random.randint(5, 8)\n    m = np.random.randint(4, 8) * 2  # ensure m is even for symmetry\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random pattern on the left half of the grid\n    color_palette = list(Color.NOT_BLACK)\n    left_half_color = np.random.choice(color_palette)\n\n    # Randomly fill the left half with a symmetric pattern\n    for i in range(n):\n        for j in range(m // 2):\n            if np.random.rand() \u003c 0.5:  # 50% chance to fill with color\n                grid[i, j] = left_half_color\n\n    # Mirror the left half to the right half\n    grid[:, m // 2:] = grid[:, :m // 2]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/256/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/256/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/256/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/256/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/256/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/256/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/256/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/256/images/train_output_2.png"}]}, "index": 256, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, color change, object detection\n\n# description:\n# In the input you will see a colored object. To make the output, move the object 3 pixels to the right and change its color to blue.\n\ndef main(input_grid):\n    # Get the single colored object (it\u0027s the only one)\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1\n    colored_object = objects[0]\n\n    # Make a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change its color to blue\n    colored_object[colored_object != Color.BLACK] = Color.BLUE\n\n    # Translate it 3 pixels to the right\n    colored_object = translate(colored_object, x=3, y=0, background=Color.BLACK)\n\n    # Blit the colored object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=colored_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_len = np.random.randint(5, 10)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Randomly generate a colored object (not black) and place it on the grid.\n    sprite_width, sprite_height = np.random.randint(1, grid_len - 1), np.random.randint(1, grid_len - 1)\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))  # Ensure the color is not black\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[sprite_color], density=0.5)\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(grid=grid, sprite=sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/257/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/257/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/257/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/257/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/257/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/257/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/257/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/257/images/train_output_2.png"}]}, "index": 257, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color mapping, mirroring\n\n# description:\n# The input is a grid where each row is of the same color. \n# To create the output, change each color according to the following mapping:\n# green -\u003e yellow, blue -\u003e gray, red -\u003e pink, teal -\u003e maroon, \n# yellow -\u003e green, gray -\u003e blue, pink -\u003e red, maroon -\u003e teal.\n# Then mirror the pattern horizontally and place the mirrored pattern next to the initial pattern.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Constructing the color map\n    color_map = {Color.GREEN : Color.YELLOW, \n                 Color.BLUE : Color.GRAY, \n                 Color.RED : Color.PINK,\n                 Color.TEAL : Color.MAROON,\n                 Color.YELLOW : Color.GREEN, \n                 Color.GRAY : Color.BLUE, \n                 Color.PINK : Color.RED,\n                 Color.MAROON : Color.TEAL             \n                }\n\n    # Perform color mapping\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    # Mirror the output grid horizontally\n    mirrored_grid = np.flip(output_grid, axis=1)\n\n    # Combine the original output grid and its mirrored version\n    combined_grid = np.hstack((output_grid, mirrored_grid))\n\n    return combined_grid\n\ndef generate_input():\n    # Define the possible colors\n    colors = list(Color.NOT_BLACK)  # All colors except black\n    num_rows = 4  # Number of rows in the input grid\n    grid = np.full((num_rows, 3), Color.BLACK)  # Create a grid with a fixed number of columns\n\n    # Randomly assign a color to each row from the possible colors\n    for x in range(num_rows):\n        grid[x, :] = random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/258/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/258/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/258/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/258/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/258/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/258/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/258/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/258/images/train_output_2.png"}]}, "index": 258, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mixing, grid transformation\n\n# description:\n# In the input you will see a grid filled with colored pixels. Each pixel can be one of three colors: red, green, or blue. \n# To make the output, mix the colors in adjacent cells according to these rules:\n# - If a cell is red and has a green neighbor, it turns yellow.\n# - If a cell is green and has a blue neighbor, it turns yellow.\n# - If a cell is blue and has a red neighbor, it turns orange.\n# - If a cell has no neighbors of contrasting colors, it remains unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Prepare the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n\n    # Define the color mixing rules\n    for x in range(n):\n        for y in range(m):\n            current_color = input_grid[x, y]\n            # Check adjacent cells for color mixing\n            if current_color == Color.RED:\n                if (x \u003e 0 and input_grid[x-1, y] == Color.GREEN) or (x \u003c n-1 and input_grid[x+1, y] == Color.GREEN) or \\\n                   (y \u003e 0 and input_grid[x, y-1] == Color.GREEN) or (y \u003c m-1 and input_grid[x, y+1] == Color.GREEN):\n                    output_grid[x, y] = Color.YELLOW\n                \n            elif current_color == Color.GREEN:\n                if (x \u003e 0 and input_grid[x-1, y] == Color.BLUE) or (x \u003c n-1 and input_grid[x+1, y] == Color.BLUE) or \\\n                   (y \u003e 0 and input_grid[x, y-1] == Color.BLUE) or (y \u003c m-1 and input_grid[x, y+1] == Color.BLUE):\n                    output_grid[x, y] = Color.YELLOW\n                \n            elif current_color == Color.BLUE:\n                if (x \u003e 0 and input_grid[x-1, y] == Color.RED) or (x \u003c n-1 and input_grid[x+1, y] == Color.RED) or \\\n                   (y \u003e 0 and input_grid[x, y-1] == Color.RED) or (y \u003c m-1 and input_grid[x, y+1] == Color.RED):\n                    output_grid[x, y] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of a random size filled with random red, green, and blue pixels\n    n, m = np.random.randint(5, 12), np.random.randint(5, 12)\n    grid = np.random.choice([Color.RED, Color.GREEN, Color.BLUE], size=(n, m))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/259/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/259/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/259/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/259/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/259/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/259/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/259/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/259/images/train_output_2.png"}]}, "index": 259, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cropping, rotation\n\n# description:\n# In the input, you will see a grid with several colored squares and a single red pixel.\n# To make the output:\n# 1. Extract the square that contains the red pixel.\n# 2. Rotate the extracted square 90 degrees clockwise to form the output.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the position of the red pixel\n    red_pixel_position = np.argwhere(input_grid == Color.RED)\n    \n    # If no red pixel is found, return the original grid\n    if len(red_pixel_position) == 0:\n        return input_grid\n    \n    # Get the coordinates of the red pixel\n    red_x, red_y = red_pixel_position[0]\n\n    # Define the boundaries of the extracted square\n    start_x = max(0, red_x - 1)\n    end_x = min(input_grid.shape[0], red_x + 2)\n    start_y = max(0, red_y - 1)\n    end_y = min(input_grid.shape[1], red_y + 2)\n\n    # Extract the sub-grid (2x2 or 3x3 depending on the position of the red pixel)\n    extracted_square = input_grid[start_x:end_x, start_y:end_y]\n\n    # Rotate the extracted square 90 degrees clockwise\n    rotated_square = np.rot90(extracted_square, -1)\n\n    # Create an output grid of the same size as the input\n    output_grid = np.zeros_like(input_grid)\n\n    # Place the rotated square in the same location as the original extracted square\n    output_grid[start_x:end_x, start_y:end_y] = rotated_square\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels\n    num_colored_pixels = np.random.randint(10, 30)\n    \n    for _ in range(num_colored_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([c for c in Color.NOT_BLACK if c != Color.RED])\n\n    # Randomly place a single red pixel\n    while True:\n        red_x, red_y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[red_x, red_y] == 0: # Ensuring the position is empty\n            grid[red_x, red_y] = Color.RED\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/260/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/260/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/260/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/260/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/260/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/260/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/260/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/260/images/train_output_2.png"}]}, "index": 260, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection, alignment\n\n# description:\n# In the input, you will see a colored object on a black background. The object will have one or more pixels on one side that are colored differently. \n# To create the output grid, you should reflect the differently colored pixels across the vertical midline of the object, creating a symmetrical object.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Detect the unique colors in the input grid\n    unique_colors = np.unique(input_grid)\n\n    # Find the object in the grid\n    objects = detect_objects(grid=input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n\n    # There should be only one object detected\n    assert len(objects) == 1\n    object_pixels = objects[0]\n\n    # Find the width of the object\n    object_height, object_width = object_pixels.shape\n    mid_x = object_width // 2\n\n    # Reflect the pixels across the vertical midline\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        if input_grid[x, y] not in unique_colors:\n            continue\n        \n        # Calculate the mirrored position\n        mirrored_x = x\n        mirrored_y = 2 * mid_x - y if y \u003c mid_x else 2 * mid_x - (y - 1)\n\n        # Ensure the mirrored position is within bounds\n        if 0 \u003c= mirrored_y \u003c object_width:\n            output_grid[mirrored_x, mirrored_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random object color\n    object_color = random.choice(Color.NOT_BLACK)\n\n    # Random width and height for our object\n    width = np.random.randint(2, 5)\n    height = np.random.randint(2, 5)\n\n    # Create the object and place it into the grid\n    start_x = np.random.randint(1, n - height - 1)\n    start_y = np.random.randint(1, m - width - 1)\n    \n    # Blit the object in the grid\n    for i in range(height):\n        for j in range(width):\n            grid[start_x + i, start_y + j] = object_color\n\n    # Add some differently colored pixels on one side of the object to create the reflection effect\n    for i in range(height):\n        if np.random.rand() \u003e 0.5:  # Randomly decide to color some pixels differently on the left\n            x = start_x + i\n            y = start_y + np.random.randint(0, width // 2)  # Only on the left side\n            grid[x, y] = random.choice([c for c in Color.NOT_BLACK if c != object_color])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/261/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/261/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/261/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/261/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/261/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/261/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/261/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/261/images/train_output_2.png"}]}, "index": 261, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reconstruction, color correspondence, rotation, pattern recognition\n\n# description:\n# In the input you will see a grid containing a checkerboard pattern of two colors, \n# with a red pixel at a specific location indicating the center of the pattern.\n# To create the output grid, you should reconstruct the checkerboard pattern \n# centered on the red pixel. If the red pixel is in an even indexed row/column (0-based), \n# the pattern should be rotated 90 degrees clockwise; if it is in an odd indexed row/column, \n# the pattern should be rotated 90 degrees counter-clockwise.\n\ndef main(input_grid):\n    # Detect the red pixel which indicates the center of the checkerboard pattern\n    red_pixel_objects = detect_objects(grid=input_grid, colors=[Color.RED], allowed_dimensions=[(1, 1)], monochromatic=True, connectivity=4)\n    assert len(red_pixel_objects) == 1\n    red_pixel_object = red_pixel_objects[0]\n\n    # Find the position of the red pixel\n    red_x, red_y = object_position(red_pixel_object, background=Color.BLACK, anchor=\"upper left\")\n\n    # Create the checkerboard pattern\n    checkerboard_size = 5  # A 5x5 checkerboard pattern\n    checkerboard = np.zeros((checkerboard_size, checkerboard_size), dtype=int)\n    for i in range(checkerboard_size):\n        for j in range(checkerboard_size):\n            checkerboard[i, j] = Color.RED if (i + j) % 2 == 0 else Color.GREEN\n\n    # Determine the rotation based on the position of the red pixel\n    if (red_x + red_y) % 2 == 0:\n        # Rotate 90 degrees clockwise\n        checkerboard = np.rot90(checkerboard, -1)\n    else:\n        # Rotate 90 degrees counter-clockwise\n        checkerboard = np.rot90(checkerboard, 1)\n\n    # Compute the position for placing the checkerboard centered on the red pixel\n    pattern_x = red_x - checkerboard_size // 2\n    pattern_y = red_y - checkerboard_size // 2\n\n    # Create the output grid and blit the checkerboard pattern\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    output_grid = blit_sprite(grid=output_grid, x=pattern_x, y=pattern_y, sprite=checkerboard, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size 10x10\n    grid_size = 10\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly place a red pixel in the grid\n    x, y = np.random.randint(1, grid_size - 1), np.random.randint(1, grid_size - 1)\n    grid[x, y] = Color.RED\n\n    # Return the generated grid\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/262/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/262/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/262/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/262/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/262/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/262/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/262/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/262/images/train_output_2.png"}]}, "index": 262, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, positioning, color mapping\n\n# description:\n# In the input you will see a square pattern of random colors. To make the output, reflect the pattern vertically, and place the reflected pattern below the original pattern. However, every pixel in the reflected pattern should be transformed to a different color based on the following mapping:\n# - Color.RED -\u003e Color.GREEN\n# - Color.GREEN -\u003e Color.BLUE\n# - Color.BLUE -\u003e Color.RED\n# - Color.YELLOW -\u003e Color.ORANGE\n# - Color.ORANGE -\u003e Color.YELLOW\n# - Color.PINK -\u003e Color.TEAL\n# - Color.TEAL -\u003e Color.PINK\n# - Color.GREY -\u003e Color.MAROON\n# - Color.MAROON -\u003e Color.GREY\n# - Color.BLACK stays BLACK\n\ndef main(input_grid):\n    # Reflect the input pattern vertically\n    reflected_pattern = input_grid[::-1, :]\n\n    # Create a color mapping\n    color_mapping = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.ORANGE,\n        Color.ORANGE: Color.YELLOW,\n        Color.PINK: Color.TEAL,\n        Color.TEAL: Color.PINK,\n        Color.GREY: Color.MAROON,\n        Color.MAROON: Color.GREY,\n        Color.BLACK: Color.BLACK,\n    }\n\n    # Transform the reflected pattern using the color mapping\n    transformed_reflected_pattern = np.vectorize(color_mapping.get)(reflected_pattern)\n\n    # Concatenate the original and transformed reflected pattern\n    output_grid = np.concatenate((input_grid, transformed_reflected_pattern), axis=0)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random square pattern of random size and colors\n    n = m = np.random.randint(3, 6)\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/263/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/263/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/263/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/263/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/263/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/263/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/263/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/263/images/train_output_2.png"}]}, "index": 263, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color swapping\n\n# description:\n# In the input you will see a grid with various colored objects.\n# To make the output grid, swap the colors of the two largest objects found in the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Detect all connected components (objects) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n    \n    # Get the sizes of all detected objects\n    object_sizes = [(np.sum(obj != Color.BLACK), obj) for obj in objects]\n    \n    # Sort objects by size (largest first)\n    largest_objects = sorted(object_sizes, key=lambda x: x[0], reverse=True)\n    \n    # If there are less than 2 objects, return the grid unchanged\n    if len(largest_objects) \u003c 2:\n        return input_grid.copy()\n    \n    # Get the two largest objects\n    obj1, obj2 = largest_objects[0][1], largest_objects[1][1]\n    \n    # Create a copy of the input grid\n    output_grid = input_grid.copy()\n    \n    # Swap the colors of the two largest objects\n    color1 = obj1[0, 0]  # Assume the color of the object is found at the top-left corner\n    color2 = obj2[0, 0]\n    \n    output_grid[input_grid == color1] = color2\n    output_grid[input_grid == color2] = color1\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with random size\n    n, m = np.random.randint(6, 10), np.random.randint(6, 10)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Randomly scatter colored objects on the grid\n    colors = list(Color.NOT_BLACK)\n    \n    # Generate a few objects to ensure we have at least two\n    num_objects = np.random.randint(2, 5)\n    \n    for _ in range(num_objects):\n        # Generate random dimensions for the object\n        obj_width, obj_height = np.random.randint(1, 4), np.random.randint(1, 4)\n        sprite = random_sprite(n=obj_height, m=obj_width, color_palette=[np.random.choice(colors)], density=1.0)\n        \n        # Find a random position to place the object\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, background=Color.BLACK)\n        \n        # Blit the object onto the grid\n        grid = blit_sprite(grid=grid, sprite=sprite, x=x, y=y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/264/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/264/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/264/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/264/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/264/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/264/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/264/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/264/images/train_output_2.png"}]}, "index": 264, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, mirroring, pattern recognition\n\n# description:\n# In the input, you will see a 3x3 grid with a pattern of three colors: red, blue, and yellow. \n# To make the output, mirror the pattern vertically and change each color to its corresponding color: \n# red to green, blue to yellow, and yellow to pink.\n\ndef main(input_grid):\n    # Define color mapping\n    color_map = {\n        Color.RED: Color.GREEN,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.PINK\n    }\n    \n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Mirror the input grid vertically and change colors\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            original_color = input_grid[i, j]\n            mirrored_color = input_grid[i, input_grid.shape[1] - j - 1]\n            if mirrored_color in color_map:\n                output_grid[i, j] = color_map[mirrored_color]\n            else:\n                output_grid[i, j] = Color.BLACK\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = 3, 3  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define available colors for the pattern\n    available_colors = [Color.RED, Color.BLUE, Color.YELLOW]\n\n    # Generate a random 3x3 pattern using the available colors\n    grid = np.random.choice(available_colors, size=(n, m))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/265/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/265/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/265/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/265/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/265/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/265/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/265/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/265/images/train_output_2.png"}]}, "index": 265, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color propagation, spatial arrangement\n\n# description:\n# In the input, you will see a grid containing a pattern of colored pixels surrounded by a black border.\n# The color of the border is black, and the interior contains 3 distinct colors arranged in a specific pattern.\n# To create the output grid, you should extract the inner pattern and replicate it in a checkerboard arrangement \n# across the entire output grid. The output grid should be the same size as the input grid, but the inner pattern \n# should fill the grid in a checkerboard manner.\n\ndef main(input_grid):\n    # Crop the inner pattern from the input grid\n    inner_pattern = crop(input_grid)\n    \n    # Get the dimensions of the inner pattern\n    n, m = inner_pattern.shape\n    \n    # Create the output grid with the same dimensions as the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Fill the output grid in a checkerboard pattern with the inner pattern\n    for i in range(0, output_grid.shape[0], n):\n        for j in range(0, output_grid.shape[1], m):\n            if (i // n) % 2 == (j // m) % 2:  # Check for checkerboard pattern\n                blit_sprite(output_grid, inner_pattern, x=i, y=j)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with a black border and an inner pattern of colored pixels\n    n = np.random.randint(5, 10)  # Height of the inner pattern\n    m = np.random.randint(5, 10)  # Width of the inner pattern\n    \n    # Create the grid with a black border\n    grid = np.zeros((n + 2, m + 2), dtype=int)  # Add 2 for the border\n\n    # Define colors for the inner pattern\n    colors = np.random.choice(list(Color.NOT_BLACK), size=3, replace=False)\n    \n    # Fill the inner pattern with random colors\n    inner_pattern = np.zeros((n, m), dtype=int)\n    \n    for i in range(n):\n        for j in range(m):\n            inner_pattern[i, j] = np.random.choice(colors)\n    \n    # Place the inner pattern in the center of the grid\n    blit_sprite(grid, inner_pattern, x=1, y=1, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/266/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/266/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/266/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/266/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/266/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/266/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/266/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/266/images/train_output_2.png"}]}, "index": 266, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, pattern drawing\n\n# description:\n# In the input you will see two yellow pixels.\n# To make the output grid, you should place a 3x3 orange square pattern between the two yellow pixels exactly halfway between them.\n\ndef main(input_grid):\n    # Detect the two yellow pixels on the grid.\n    yellow_pixels = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n    \n    # Ensure there are exactly two yellow pixels\n    assert len(yellow_pixels) == 2\n    first_pixel, second_pixel = yellow_pixels[0], yellow_pixels[1]\n\n    # Find the midpoint\n    first_x, first_y = object_position(first_pixel, background=Color.BLACK, anchor=\"center\")\n    second_x, second_y = object_position(second_pixel, background=Color.BLACK, anchor=\"center\")\n    mid_x, mid_y = int((first_x + second_x) / 2), int((first_y + second_y) / 2)\n\n    # Generate the 3x3 orange square pattern.\n    orange_square_sprite = np.array([[Color.ORANGE, Color.ORANGE, Color.ORANGE],\n                                      [Color.ORANGE, Color.ORANGE, Color.ORANGE],\n                                      [Color.ORANGE, Color.ORANGE, Color.ORANGE]])\n    \n    output_grid = input_grid.copy()\n    orange_square_width, orange_square_height = 3, 3\n\n    # Put the square centered at the midpoint\n    upper_left_x = mid_x - orange_square_width // 2\n    upper_left_y = mid_y - orange_square_height // 2\n    blit_sprite(output_grid, orange_square_sprite, x=upper_left_x, y=upper_left_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    grid_len = np.random.randint(10, 15)\n    n, m = grid_len, grid_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose positions for the two yellow pixels ensuring they can fit the 3x3 orange square in between.\n    line_interval = random.choice(range(1, 4))\n    line_width = 3 + line_interval * 2\n\n    while(line_width + 2 \u003e grid_len):\n        line_interval = random.choice(range(1, 4))\n        line_width = 3 + line_interval * 2\n\n    # Ensure there is enough space for the 3x3 orange square pattern and two yellow pixels.\n    if np.random.choice([True, False]):  # Randomly select horizontal or vertical placement\n        x = np.random.randint(0, n - line_width - 1)\n        y = np.random.randint(1, m - 1)\n        grid[x, y] = Color.YELLOW\n        grid[x + line_width + 1, y] = Color.YELLOW\n    else:\n        x = np.random.randint(1, n - line_width - 1)\n        y = np.random.randint(0, m - line_width - 1)\n        grid[x, y] = Color.YELLOW\n        grid[x, y + line_width + 1] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/267/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/267/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/267/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/267/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/267/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/267/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/267/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/267/images/train_output_2.png"}]}, "index": 267, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swapping, objects, positioning\n\n# description:\n# In the input, you will see a colored object in the center and a single pixel in the bottom right corner of a different color.\n# To make the output, remove the pixel from the bottom right corner and change the color of the object in the center to the color of the pixel you removed.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the pixel in the bottom right corner\n    color = output_grid[-1, -1]\n\n    # Remove the pixel from the bottom right corner\n    output_grid[-1, -1] = Color.BLACK\n\n    # Change the color of the object in the center to the color of the pixel we just removed\n    # Assuming the object is in the center (1, 1) for a 7x7 grid\n    center_x, center_y = 3, 3\n    output_grid[center_x, center_y] = color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 7x7 grid filled with black\n    n = m = 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the object in the center\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Select a color for the corner pixel\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Ensure that the colors are different\n    if object_color == corner_color:\n        return generate_input()\n    \n    # Create a random object and place it in the center of the grid\n    object_sprite = random_sprite(3, 3, density=1.0, color_palette=[object_color])\n    blit_sprite(grid, object_sprite, x=3, y=3)\n\n    # Place a single pixel in the bottom right corner\n    grid[-1, -1] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/268/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/268/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/268/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/268/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/268/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/268/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/268/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/268/images/train_output_2.png"}]}, "index": 268, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel flipping, symmetry\n\n# description:\n# In the input, you will see a grid of colored pixels. The goal is to create a symmetrical output grid by flipping the colors of pixels across the vertical middle line of the grid.\n# For each pixel on the left side of the grid, its color will be flipped to the corresponding pixel on the right side (and vice versa). If the grid has an odd number of columns, the middle column will remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Get the number of columns\n    cols = input_grid.shape[1]\n    mid = cols // 2\n    \n    # Loop through each row and each column on the left half\n    for x in range(input_grid.shape[0]):\n        for y in range(mid):\n            # Get the corresponding pixel on the right half\n            mirror_y = cols - 1 - y\n            \n            # Swap the colors between the left and right pixels\n            output_grid[x, y], output_grid[x, mirror_y] = output_grid[x, mirror_y], output_grid[x, y]\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size between 3x3 and 10x10\n    n, m = np.random.randint(3, 11), np.random.randint(3, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors from Color.NOT_BLACK\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/269/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/269/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/269/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/269/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/269/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/269/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/269/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/269/images/train_output_2.png"}]}, "index": 269, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pattern recognition\n\n# description:\n# In the input, you will see a grid with a specific pattern of colored pixels.\n# To create the output grid, you should invert the color of each pixel in the input grid,\n# changing each color to its complementary color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n    \n    # Define a mapping of colors to their complementary colors\n    complementary_colors = {\n        Color.RED: Color.ORANGE,\n        Color.GREEN: Color.TEAL,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE,\n        Color.ORANGE: Color.RED,\n        Color.TEAL: Color.GREEN,\n        Color.ORANGE: Color.TEAL,\n        Color.TEAL: Color.ORANGE,\n        Color.PINK: Color.GREY,\n        Color.GREY: Color.PINK,\n        Color.BLACK: Color.GREEN,\n        Color.GREEN: Color.BLACK\n    }\n    \n    # Invert the colors in the grid based on the mapping\n    for color, comp_color in complementary_colors.items():\n        output_grid[output_grid == color] = comp_color\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the size of the grid\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    \n    # Generate a grid with random colors\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Select a number of colors to use\n    num_colors = np.random.randint(2, 6)\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n    \n    # Fill the grid with random colors from the selected palette\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(colors)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/270/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/270/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/270/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/270/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/270/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/270/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/270/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/270/images/train_output_2.png"}]}, "index": 270, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, color matching, collision detection\n\n# description:\n# In the input, you will see a colored square in the middle and several colored objects scattered on a black background.\n# Move each colored object to the square that has the same color until the object touches the square.\n# If a colored object doesn\u0027t have a corresponding square, it should be deleted.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Separate the square(s) from the objects\n    squares, objects_list = [], []\n    for obj in objects:\n        w, h = crop(obj).shape\n        if w == 3 and h == 3:  # Assuming squares are 3x3\n            squares.append(obj)\n        else:\n            objects_list.append(obj)\n    \n    # Copy the squares to the output grid\n    for square in squares:\n        blit_object(output_grid, square, background=Color.BLACK)\n    \n    # Move each object towards its corresponding square\n    for obj in objects_list:\n        color = np.unique(obj)[1]\n        matching_squares = [square for square in squares if np.unique(square)[1] == color]\n\n        # If there are no matching squares, delete the object\n        if not matching_squares:\n            continue\n\n        # Move the object towards the square\n        for dx in range(-10, 11):\n            for dy in range(-10, 11):\n                moved_obj = translate(obj, dx, dy, background=Color.BLACK)\n                if contact(object1=moved_obj, object2=matching_squares[0]):\n                    blit_object(output_grid, moved_obj, background=Color.BLACK)\n                    break\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    \n    # Create a black canvas\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a central colored square\n    square_color = np.random.choice(list(Color.NOT_BLACK))\n    square = np.full((3, 3), square_color)\n    x, y = n // 2 - 1, m // 2 - 1  # Center the square\n    blit_sprite(grid, square, x, y)\n\n    # Generate random colored objects\n    object_count = np.random.randint(1, 5)\n    for _ in range(object_count):\n        object_color = np.random.choice(list(Color.NOT_BLACK))\n        obj = random_sprite(1, 1, color_palette=[object_color])  # Create a single pixel object\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        while grid[x, y] != Color.BLACK:  # Ensure the location is free\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n        blit_object(grid, obj, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/271/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/271/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/271/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/271/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/271/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/271/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/271/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/271/images/train_output_2.png"}]}, "index": 271, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# patterns, rotation\n\n# description:\n# In the input you will see a grid with a pattern of colored pixels. \n# To make the output, rotate the pattern 180 degrees.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid with the same dimensions\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # Rotate the input grid 180 degrees\n    for i in range(n):\n        for j in range(m):\n            output_grid[n - 1 - i, m - 1 - j] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Randomly generate the size of the grid\n    n = np.random.randint(5, 10)\n    m = np.random.randint(5, 10)\n\n    # Create a grid with a black background\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define a random color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Define a random pattern size that fits within the grid\n    pattern_height = np.random.randint(2, n // 2 + 1)\n    pattern_width = np.random.randint(2, m // 2 + 1)\n\n    # Randomly generate a pattern within the grid\n    start_x = np.random.randint(0, n - pattern_height)\n    start_y = np.random.randint(0, m - pattern_width)\n\n    for i in range(pattern_height):\n        for j in range(pattern_width):\n            if np.random.random() \u003c 0.5:  # Randomly decide whether to color the pixel or leave it black\n                grid[start_x + i, start_y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/272/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/272/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/272/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/272/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/272/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/272/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/272/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/272/images/train_output_2.png"}]}, "index": 272, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# pixel manipulation, neighbor influence\n\n# description:\n# In the input, you will see a grid filled with colored pixels. The task is to change the color of each pixel based on the colors of its immediate neighbors (up, down, left, right). \n# The transformation rules are as follows:\n# - If a pixel is surrounded by two or more pixels of the same color, it becomes that color.\n# - If a pixel has no surrounding neighbors of the same color, it remains unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Get the shape of the grid\n    rows, cols = input_grid.shape\n    \n    # Define the directions for neighbors (up, down, left, right)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Iterate through each pixel in the grid\n    for x in range(rows):\n        for y in range(cols):\n            current_color = input_grid[x, y]\n\n            # Count colors of neighbors\n            neighbor_count = {}\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 \u003c= nx \u003c rows and 0 \u003c= ny \u003c cols:\n                    neighbor_color = input_grid[nx, ny]\n                    if neighbor_color != Color.BLACK:  # Ignore background pixels\n                        if neighbor_color in neighbor_count:\n                            neighbor_count[neighbor_color] += 1\n                        else:\n                            neighbor_count[neighbor_color] = 1\n            \n            # Determine if there is a dominant color among neighbors\n            predominant_color = None\n            max_count = 0\n            for color, count in neighbor_count.items():\n                if count \u003e max_count:\n                    max_count = count\n                    predominant_color = color\n            \n            # If a color is predominant, change the current pixel\u0027s color\n            if max_count \u003e= 2:  # At least two neighbors of the same color\n                output_grid[x, y] = predominant_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = random.choice(Color.NOT_BLACK)  # Fill with any color except black\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/273/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/273/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/273/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/273/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/273/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/273/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/273/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/273/images/train_output_2.png"}]}, "index": 273, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, color blending\n\n# description:\n# In the input, you will see a grid with colored squares and some black pixels. \n# To create the output, count the number of distinct colors present in the input \n# (excluding black) and fill a 1xN output grid where N is the number of distinct colors, \n# using a blended color that is a mixture of the distinct colors in the input.\n\ndef main(input_grid):\n    # Get the unique colors in the input grid, excluding black\n    unique_colors = set(input_grid.flatten()) - {Color.BLACK}\n    \n    # Count the number of distinct colors\n    num_colors = len(unique_colors)\n\n    # If there are no colors, return an empty output grid\n    if num_colors == 0:\n        return np.zeros((1, 1), dtype=int)\n\n    # Create a color blending function\n    def blend_colors(colors):\n        # Convert color names to RGB values (example mapping)\n        color_map = {\n            Color.RED: (255, 0, 0),\n            Color.GREEN: (0, 255, 0),\n            Color.BLUE: (0, 0, 255),\n            Color.YELLOW: (255, 255, 0),\n            Color.PINK: (255, 192, 203),\n            Color.ORANGE: (255, 165, 0),\n            Color.TEAL: (0, 128, 128),\n            Color.GREY: (128, 128, 128),\n            Color.MAROON: (128, 0, 0),\n            Color.BLACK: (0, 0, 0)\n        }\n        \n        # Average the RGB values of the distinct colors\n        avg_color = np.mean([color_map[color] for color in colors], axis=0)\n        \n        # Find the closest color in the predefined color map\n        closest_color = min(color_map.keys(), key=lambda c: np.linalg.norm(np.array(color_map[c]) - avg_color))\n        return closest_color\n\n    # Blend the colors\n    blended_color = blend_colors(unique_colors)\n\n    # Create the output grid\n    output_grid = np.zeros((1, num_colors), dtype=int)\n    \n    # Fill the output grid with the blended color\n    output_grid[0, :] = blended_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a random size for the grid\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose the number of colored squares to be added\n    num_colored_squares = np.random.randint(1, 20)\n\n    # Define possible colors (excluding black)\n    colors = list(Color.NOT_BLACK)\n\n    for _ in range(num_colored_squares):\n        # Choose a random color for the square\n        color = np.random.choice(colors)\n\n        # Create a 1x1 square of that color\n        square = np.full((1, 1), color)\n\n        # Find a random free space to place the 1x1 square\n        x, y = random_free_location_for_sprite(grid=grid, sprite=square)\n\n        # Blit the 1x1 square onto the grid\n        blit_sprite(grid=grid, sprite=square, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/274/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/274/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/274/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/274/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/274/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/274/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/274/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/274/images/train_output_2.png"}]}, "index": 274, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, border filling\n\n# description:\n# In the input grid, you will see a colored shape on a black background. \n# The color of the shape is not specified. \n# To create the output grid, you should detect the shape\u0027s boundary and fill the inside of that shape with blue pixels.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    if not objects:\n        return output_grid  # Return the original grid if no objects found\n\n    # Assume the first object is the one we want to fill\n    shape_to_fill = objects[0]\n\n    # Get the bounding box of the shape\n    x, y, width, height = bounding_box(shape_to_fill, background=Color.BLACK)\n\n    # Fill the inside of the shape with blue\n    for i in range(x, x + width):\n        for j in range(y, y + height):\n            if output_grid[i, j] != Color.BLACK:\n                output_grid[i, j] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random color for the shape (not black)\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a random shape in the grid\n    shape = random_sprite(np.random.randint(3, 7), np.random.randint(3, 7), density=0.6, color_palette=[shape_color])\n    \n    # Find a random location to place the shape\n    try:\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n        blit_sprite(grid, shape, x=x, y=y)\n    except:\n        return generate_input()  # Ensure a valid input if collision occurs\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/275/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/275/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/275/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/275/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/275/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/275/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/275/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/275/images/train_output_2.png"}]}, "index": 275, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, spiral transformation\n\n# description:\n# In the input, you will see a grid filled with pixels of different colors. \n# To make the output, change each color according to the following mapping:\n# red -\u003e blue, blue -\u003e green, green -\u003e yellow, yellow -\u003e red. \n# The mapping should be applied in a spiral direction starting from the center of the grid.\n\ndef main(input_grid):\n    # Getting the dimensions of the grid\n    rows, cols = input_grid.shape\n    output_grid = np.copy(input_grid)\n    \n    # Define color mapping\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.BLUE: Color.GREEN,\n        Color.GREEN: Color.YELLOW,\n        Color.YELLOW: Color.RED\n    }\n    \n    # Finding the center of the grid\n    center_x, center_y = rows // 2, cols // 2\n    \n    # Spiral order directions (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    x, y = center_x, center_y\n    steps = 1  # Number of steps in the current direction\n    direction_index = 0  # Start with the right direction\n    steps_in_current_direction = 0  # Steps taken in the current direction\n\n    for _ in range(rows * cols):\n        if 0 \u003c= x \u003c rows and 0 \u003c= y \u003c cols:\n            # Apply the color mapping if within bounds\n            output_grid[x, y] = color_map.get(input_grid[x, y], input_grid[x, y])\n        \n        # Move in the current direction\n        dx, dy = directions[direction_index]\n        x += dx\n        y += dy\n        steps_in_current_direction += 1\n        \n        # Check if we need to change direction\n        if steps_in_current_direction == steps:\n            # Change direction\n            direction_index = (direction_index + 1) % 4\n            steps_in_current_direction = 0\n            \n            # Increase the number of steps to take every two turns\n            if direction_index % 2 == 0:\n                steps += 1\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random size for the grid\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Fill the grid with random colors from the color map\n    colors = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(colors)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/276/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/276/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/276/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/276/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/276/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/276/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/276/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/276/images/train_output_2.png"}]}, "index": 276, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape transformation, color replacement\n\n# description:\n# The input is a grid with a specific shape formed by colored pixels. \n# The shape consists of a filled cross (a pattern with a vertical and horizontal bar). \n# The colors of the vertical and horizontal bars are identical but differ from the background.\n# In the output, the color of the cross should be changed to blue, and the background should be black.\n\ndef main(input_grid):\n    n, m = input_grid.shape\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # Detect the center of the cross\n    center_x = n // 2\n    center_y = m // 2\n\n    # Check if a cross pattern exists\n    if (input_grid[center_x, :] != Color.BLACK).any() and (input_grid[:, center_y] != Color.BLACK).any():\n        # Change the color of the cross to blue\n        for x in range(n):\n            if input_grid[x, center_y] != Color.BLACK:  # Vertical bar\n                output_grid[x, center_y] = Color.BLUE\n        \n        for y in range(m):\n            if input_grid[center_x, y] != Color.BLACK:  # Horizontal bar\n                output_grid[center_x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 5x5\n    grid = np.full((5, 5), Color.BLACK)\n    \n    # Define the cross color\n    cross_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Set the vertical bar\n    for i in range(5):\n        grid[i, 2] = cross_color  # Middle column\n\n    # Set the horizontal bar\n    for j in range(5):\n        grid[2, j] = cross_color  # Middle row\n        \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/277/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/277/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/277/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/277/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/277/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/277/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/277/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/277/images/train_output_2.png"}]}, "index": 277, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, translation\n\n# description:\n# In the input grid, you will see a rectangular colored object. \n# To produce the output grid, create a mirror image of the object along the vertical axis and place it to the right of the original object.\n\ndef main(input_grid):\n    # 1. Find the single colored object in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n    assert len(objects) == 1\n    original_object = objects[0]\n\n    # 2. Create a reflected object by flipping it horizontally\n    reflected_object = original_object[:, ::-1]\n\n    # 3. Create an output grid with enough space for both the original and reflected object\n    height, width = input_grid.shape\n    output_grid = np.full((height, width * 2), Color.BLACK)\n\n    # 4. Place the original object on the left side of the output grid\n    blit_object(output_grid, original_object, background=Color.BLACK)\n\n    # 5. Place the reflected object on the right side of the output grid\n    blit_sprite(output_grid, reflected_object, x=width, y=0, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the object, ensuring it\u0027s at least one pixel wide and tall\n    height = np.random.randint(1, 6)\n    width = np.random.randint(1, 6)\n\n    # Create a random rectangular object with a single color\n    object_color = np.random.choice(Color.NOT_BLACK)\n    object_grid = random_sprite(n=height, m=width, density=1, color_palette=[object_color])\n\n    # Create a black grid to place the object in\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Randomly position the object within the grid\n    x, y = random_free_location_for_sprite(input_grid, object_grid, background=Color.BLACK)\n    blit_sprite(input_grid, object_grid, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/278/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/278/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/278/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/278/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/278/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/278/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/278/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/278/images/train_output_2.png"}]}, "index": 278, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color expansion, grid manipulation\n\n# description:\n# In the input, you will see a 5x5 grid with a single colored object, which is represented by a color that occupies a contiguous area. \n# To create the output, enlarge the object to a 7x7 grid while maintaining the same color. The enlargement involves duplicating the boundary pixels of the original shape outward.\n\ndef main(input_grid):\n    # Step 1: Extract the connected component (the object) from the input grid\n    object_components = find_connected_components(input_grid, background=Color.BLACK)\n    assert len(object_components) == 1, \"There should be exactly one colored object in the input grid\"\n\n    # Step 2: Crop the object to get its shape\n    object_sprite = crop(object_components[0], background=Color.BLACK)\n\n    # Step 3: Create an output grid of size 7x7 filled with black\n    output_grid = np.full((7, 7), Color.BLACK, dtype=int)\n\n    # Step 4: Determine the size and position of the object in the output grid\n    obj_height, obj_width = object_sprite.shape\n    start_x = (7 - obj_height) // 2\n    start_y = (7 - obj_width) // 2\n\n    # Step 5: Place the object sprite in the center of the output grid\n    blit_sprite(output_grid, object_sprite, x=start_x, y=start_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # 1. Create a random 5x5 grid filled with black\n    n, m = 5, 5\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # 2. Generate a random colored object (non-black) within the grid\n    # The object must be contiguous, so we will use a random walk or similar approach to generate it\n    color = np.random.choice([c for c in Color.NOT_BLACK])\n    # Start from a random position\n    start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[start_x, start_y] = color\n\n    # 3. Perform a simple random walk to fill out the object while ensuring contiguity\n    num_pixels = np.random.randint(3, 10)  # Size of the object\n    for _ in range(num_pixels - 1):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        # Check if we can color this pixel (must be black and adjacent to an already colored pixel)\n        if grid[x, y] == Color.BLACK:\n            # Check 4-connectivity\n            if ((x \u003e 0 and grid[x - 1, y] == color) or \n                (x \u003c n - 1 and grid[x + 1, y] == color) or \n                (y \u003e 0 and grid[x, y - 1] == color) or \n                (y \u003c m - 1 and grid[x, y + 1] == color)):\n                grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/279/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/279/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/279/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/279/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/279/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/279/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/279/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/279/images/train_output_2.png"}]}, "index": 279, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, grid placement\n\n# description:\n# In the input, you will see a grid with multiple colored shapes. Each shape is bordered by a grey outline. \n# To make the output, detect the colored shapes, extract them, and change their color to a new random color (different from their original color). \n# Then, place the transformed shapes in a new grid, centered within a 10x10 grey grid.\n\ndef main(input_grid):\n    # Step 1: Detect colored shapes bordered by grey\n    shapes = detect_objects(input_grid, background=Color.BLACK, predicate=lambda sprite: np.any(sprite != Color.GREY))\n    \n    # Step 2: Create the output grid which is a 10x10 grey grid\n    output_grid_size = 10\n    output_grid = np.full((output_grid_size, output_grid_size), Color.GREY, dtype=int)\n\n    # Step 3: Change the color of each shape and blit it onto the output grid\n    for shape in shapes:\n        cropped_shape = crop(shape, background=Color.GREY)\n\n        # Ensure the new color is different from the original colors\n        original_colors = np.unique(cropped_shape[cropped_shape != Color.GREY])\n        new_color = np.random.choice([c for c in Color.NOT_BLACK if c not in original_colors])\n\n        # Change the color of the shape\n        transformed_shape = np.where(cropped_shape != Color.GREY, new_color, Color.GREY)\n\n        # Center the shape in the output grid\n        shape_height, shape_width = transformed_shape.shape\n        start_x = (output_grid_size - shape_width) // 2\n        start_y = (output_grid_size - shape_height) // 2\n\n        # Blit the transformed shape onto the output grid\n        blit_sprite(output_grid, transformed_shape, x=start_x, y=start_y)\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Create a larger grid for the input\n    grid_height, grid_width = np.random.randint(15, 20), np.random.randint(15, 20)\n    input_grid = np.full((grid_height, grid_width), Color.BLACK, dtype=int)\n\n    # Step 2: Randomly generate a number of shapes to insert\n    num_shapes = np.random.randint(3, 7)\n\n    for _ in range(num_shapes):\n        # Generate a random shape\n        shape_height, shape_width = np.random.randint(3, 6), np.random.randint(3, 6)\n        shape = random_sprite(n=shape_height, m=shape_width, density=0.5, color_palette=[Color.GREY])\n\n        # Place a grey border around the shape\n        bordered_shape = np.full((shape_height + 2, shape_width + 2), Color.GREY)\n        bordered_shape[1:-1, 1:-1] = shape\n\n        # Find a random free location for the bordered shape\n        try:\n            x, y = random_free_location_for_sprite(input_grid, bordered_shape, background=Color.BLACK)\n            blit_sprite(input_grid, bordered_shape, x=x, y=y)\n        except:\n            # If placement fails, try again\n            continue\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/280/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/280/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/280/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/280/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/280/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/280/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/280/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/280/images/train_output_2.png"}]}, "index": 280, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# zigzag line, regions, color filling\n\n# description:\n# In the input, you will see a black grid with a yellow zigzag line that starts in the top left corner and moves diagonally down-right until it reaches the bottom edge of the grid.\n# To make the output, find the black regions separated by the yellow zigzag line, then, starting with the first region from the top, color every fourth region grey.\n\ndef main(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # find the black regions in the input grid\n    black_regions = find_connected_components(input_grid, connectivity=4, background=Color.YELLOW)\n\n    # sort the regions from top to bottom using the coordinates of their bounding boxes\n    black_regions = sorted(black_regions, key=lambda region: bounding_box(region, background=Color.YELLOW)[1])\n\n    # color every fourth black region grey using flood fill\n    for i, region in enumerate(black_regions):\n        if i % 4 == 0:\n            x, y = np.where(region == Color.BLACK)\n            flood_fill(output_grid, x[0], y[0], Color.GREY)\n\n    return output_grid\n\ndef generate_input():\n    # make a black grid that is between 5 and 15 cells tall and between 10 and 20 cells wide\n    height = np.random.randint(5, 15)\n    width = np.random.randint(10, 20)\n    grid = np.zeros((height, width), dtype=int)\n\n    # create a zigzag yellow line from top-left to bottom\n    x, y = 0, 0\n    direction = 1  # 1 for down-right, -1 for down-left\n    while x \u003c height and y \u003e= 0 and y \u003c width:\n        grid[x, y] = Color.YELLOW\n        if direction == 1:\n            x += 1\n            y += 1\n        else:\n            x += 1\n            y -= 1\n            \n        if y \u003e= width:  # bounce off right edge\n            y = width - 1\n            direction = -1\n        elif y \u003c 0:  # bounce off left edge\n            y = 0\n            direction = 1\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/281/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/281/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/281/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/281/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/281/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/281/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/281/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/281/images/train_output_2.png"}]}, "index": 281, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change, scaling\n\n# description:\n# In the input grid, you will find various colored objects. The objects can be of any color except black. \n# To create the output grid, change the color of each object based on its size: \n# if the object has an area of 1-3 pixels, color it yellow; \n# if it has an area of 4-6 pixels, color it blue; \n# if it has an area of 7 or more pixels, color it red. \n# Finally, scale the entire output grid by a factor of 2.\n\ndef main(input_grid):\n    # Detect all objects in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Initialize the output grid with black background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change colors based on their size\n    for obj in objects:\n        num_pixels = np.sum(obj != Color.BLACK)  # Count the number of non-black pixels in the object\n        if num_pixels \u003c= 3:\n            color = Color.YELLOW\n        elif 4 \u003c= num_pixels \u003c= 6:\n            color = Color.BLUE\n        else:\n            color = Color.RED\n        \n        # Color the object in the output grid\n        output_grid[obj != Color.BLACK] = color\n\n    # Scale the output grid by a factor of 2\n    output_grid = scale_pattern(pattern=output_grid, scale_factor=2)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid with black background\n    n = 10\n    grid = np.zeros((n, n), dtype=int)\n\n    # Randomly generate a number of objects with varying sizes and colors\n    num_objects = np.random.randint(3, 7)\n    for _ in range(num_objects):\n        # Random size for the object\n        sprite_width, sprite_height = np.random.randint(1, 5), np.random.randint(1, 5)\n        # Generate a random sprite (object) with non-black colors\n        sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=Color.NOT_BLACK, density=1)\n\n        # Try to find a free location to blit the sprite onto the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            continue  # Skip if no free location is found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/282/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/282/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/282/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/282/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/282/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/282/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/282/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/282/images/train_output_2.png"}]}, "index": 282, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, pixel manipulation\n\n# description:\n# In the input grid, you will see various colors with some yellow and green pixels.\n# To make the output, transform the grid such that:\n# 1. For each yellow pixel, change it to pink and surround it with blue pixels in its immediate neighbors (up, down, left, right).\n# 2. For each green pixel, change it to orange and surround it with red pixels in its diagonal positions (northeast, northwest, southeast, southwest).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.YELLOW:\n                # Change yellow to pink\n                output_grid[x][y] = Color.PINK\n                # Surround with blue pixels\n                for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                    if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                        output_grid[x + dx, y + dy] = Color.BLUE\n            elif color == Color.GREEN:\n                # Change green to orange\n                output_grid[x][y] = Color.ORANGE\n                # Surround with red pixels in diagonals\n                for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                    if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                        output_grid[x + dx, y + dy] = Color.RED\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place some yellow and green pixels\n    num_yellow = np.random.randint(1, 5)\n    num_green = np.random.randint(1, 5)\n\n    for _ in range(num_yellow):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.YELLOW\n    \n    for _ in range(num_green):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/283/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/283/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/283/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/283/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/283/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/283/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/283/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/283/images/train_output_2.png"}]}, "index": 283, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, transformation, color mapping\n\n# description:\n# In the input, you will see a grid with colored pixels. The colors represent different types of shapes. \n# The colors are: blue for circles, red for squares, and green for triangles. \n# To make the output, count the number of each shape and fill a new grid:\n# 1. Fill the first row with blue pixels for each circle found.\n# 2. Fill the second row with red pixels for each square found.\n# 3. Fill the third row with green pixels for each triangle found.\n# The output grid will have a fixed height of 3 rows and a width that corresponds to the number of shapes counted.\n\ndef main(input_grid):\n    # Initialize counts for each shape\n    circle_count = 0\n    square_count = 0\n    triangle_count = 0\n\n    # Scan the grid and count the shapes based on their colors\n    for row in input_grid:\n        circle_count += np.count_nonzero(row == Color.BLUE)\n        square_count += np.count_nonzero(row == Color.RED)\n        triangle_count += np.count_nonzero(row == Color.GREEN)\n\n    # Create the output grid based on the counts\n    output_width = max(circle_count, square_count, triangle_count)\n    output_grid = np.zeros((3, output_width), dtype=int)\n\n    # Fill the output grid with the respective colors\n    output_grid[0, :circle_count] = Color.BLUE\n    output_grid[1, :square_count] = Color.RED\n    output_grid[2, :triangle_count] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate circles, squares, and triangles\n    num_circles = np.random.randint(1, 5)\n    num_squares = np.random.randint(1, 5)\n    num_triangles = np.random.randint(1, 5)\n\n    # Place blue circles\n    for _ in range(num_circles):\n        x, y = random_free_location_for_sprite(grid, random_sprite(1, 1, density=1, color_palette=[Color.BLUE]))\n        blit_sprite(grid, random_sprite(1, 1, density=1, color_palette=[Color.BLUE]), x, y)\n\n    # Place red squares\n    for _ in range(num_squares):\n        x, y = random_free_location_for_sprite(grid, random_sprite(1, 1, density=1, color_palette=[Color.RED]))\n        blit_sprite(grid, random_sprite(1, 1, density=1, color_palette=[Color.RED]), x, y)\n\n    # Place green triangles\n    for _ in range(num_triangles):\n        x, y = random_free_location_for_sprite(grid, random_sprite(1, 1, density=1, color_palette=[Color.GREEN]))\n        blit_sprite(grid, random_sprite(1, 1, density=1, color_palette=[Color.GREEN]), x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/284/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/284/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/284/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/284/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/284/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/284/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/284/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/284/images/train_output_2.png"}]}, "index": 284, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object rotation, color guide, directional arrows\n\n# description:\n# In the input, you will see a colored circular object and a set of colored directional arrows.\n# The goal is to rotate the object based on the colors of the arrows. Each arrow\u0027s color corresponds to a specific direction:\n# - BLUE: 90 degrees clockwise\n# - RED: 180 degrees\n# - GREEN: 90 degrees counterclockwise\n# The output grid should show the rotated object.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the circular object in the input grid\n    objects = detect_objects(grid=input_grid, colors=[Color.BLUE, Color.RED, Color.GREEN], monochromatic=False, connectivity=8)\n    \n    # Find the directional arrows in the input grid\n    arrows = detect_objects(grid=input_grid, colors=[Color.BLUE, Color.RED, Color.GREEN], monochromatic=True, connectivity=8)\n    \n    # Calculate the total rotation based on the arrows\u0027 colors\n    total_rotation = 0\n    for arrow in arrows:\n        color = np.unique(arrow[arrow != Color.BLACK])[0]\n        if color == Color.BLUE:\n            total_rotation += 90\n        elif color == Color.RED:\n            total_rotation += 180\n        elif color == Color.GREEN:\n            total_rotation -= 90\n\n    # Normalize the total rotation to a range of 0-360 degrees\n    total_rotation = total_rotation % 360\n\n    # Rotate the object accordingly\n    for obj in objects:\n        # Crop the object\n        sprite = crop(obj)\n        \n        # Rotate the sprite by the calculated degrees\n        if total_rotation == 90:\n            rotated_sprite = np.rot90(sprite, 3)  # 90 degrees clockwise\n        elif total_rotation == 180:\n            rotated_sprite = np.rot90(sprite, 2)  # 180 degrees\n        elif total_rotation == -90:\n            rotated_sprite = np.rot90(sprite, 1)  # 90 degrees counterclockwise\n        else:\n            rotated_sprite = sprite  # No rotation\n        \n        # Blit the rotated sprite back onto the output grid\n        x, y, _, _ = bounding_box(obj)\n        output_grid = blit_sprite(output_grid, rotated_sprite, x, y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create an empty grid of size 10x10\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Choose a random color for the circular object\n    object_color = np.random.choice([Color.BLUE, Color.RED, Color.GREEN])\n    \n    # Create a circular object (a filled circle)\n    radius = np.random.randint(1, 3)\n    y, x = np.ogrid[-radius:radius+1, -radius:radius+1]\n    mask = x**2 + y**2 \u003c= radius**2\n    circular_object = np.zeros((radius*2 + 1, radius*2 + 1), dtype=int)\n    circular_object[mask] = object_color\n\n    # Place the circular object in a random position\n    x_pos, y_pos = random_free_location_for_sprite(grid, circular_object, padding=1)\n    blit_sprite(grid, circular_object, x=x_pos, y=y_pos)\n\n    # Create directional arrows\n    num_arrows = np.random.randint(1, 5)  # Random number of arrows\n    for _ in range(num_arrows):\n        # Choose a random color for the arrow\n        arrow_color = np.random.choice([Color.BLUE, Color.RED, Color.GREEN])\n        \n        # Create a simple arrow shape (a line with a triangular head)\n        arrow = np.zeros((3, 3), dtype=int)\n        arrow[1, 0] = arrow_color  # vertical line\n        arrow[1, 1] = arrow_color  # head of the arrow\n        arrow[0, 1] = arrow_color  # left head\n        arrow[2, 1] = arrow_color  # right head\n        \n        # Place the arrow in a random position\n        x_arrow, y_arrow = random_free_location_for_sprite(grid, arrow, padding=1)\n        blit_sprite(grid, arrow, x=x_arrow, y=y_arrow)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/285/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/285/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/285/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/285/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/285/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/285/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/285/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/285/images/train_output_2.png"}]}, "index": 285, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, color mapping, alternating pattern\n\n# description:\n# In the input you will see several 1x1 blue and yellow pixels scattered on the grid. \n# To create the output, count the number of blue pixels and yellow pixels separately,\n# then create a grid where the first row is filled with blue pixels followed by the second row filled with yellow pixels. \n# The number of pixels in each row corresponds to the count of blue and yellow pixels, respectively.\n\ndef main(input_grid):\n    # Count the blue and yellow pixels\n    blue_count = np.sum(input_grid == Color.BLUE)\n    yellow_count = np.sum(input_grid == Color.YELLOW)\n\n    # Create an output grid of the maximum height needed for either color\n    max_height = max(blue_count, yellow_count)\n    output_grid = np.zeros((2, max_height), dtype=int)\n\n    # Fill the first row with blue pixels\n    output_grid[0, :blue_count] = Color.BLUE\n\n    # Fill the second row with yellow pixels\n    output_grid[1, :yellow_count] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid of size 10x10\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide how many blue and yellow pixels to create\n    num_blue_pixels = np.random.randint(1, 21)  # Between 1 and 20 blue pixels\n    num_yellow_pixels = np.random.randint(1, 21)  # Between 1 and 20 yellow pixels\n\n    # Place blue pixels randomly on the grid\n    for _ in range(num_blue_pixels):\n        while True:\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            if grid[x, y] == Color.BLACK:  # Ensure the spot is empty\n                grid[x, y] = Color.BLUE\n                break\n\n    # Place yellow pixels randomly on the grid\n    for _ in range(num_yellow_pixels):\n        while True:\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            if grid[x, y] == Color.BLACK:  # Ensure the spot is empty\n                grid[x, y] = Color.YELLOW\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/286/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/286/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/286/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/286/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/286/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/286/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/286/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/286/images/train_output_2.png"}]}, "index": 286, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, counting, color bar chart\n\n# description:\n# In the input, you will see several objects of the same shape but different colors. \n# Count the number of each colored object and create a bar chart in the output, \n# where each bar corresponds to a color and the height of the bar corresponds to the count of that color.\n\ndef main(input_grid):\n    # Copy the input grid for the output\n    output_grid = np.zeros((10, 10), dtype=int)  # Output grid for the bar chart\n    \n    # Get the objects in the input grid\n    objects = find_connected_components(input_grid)\n    \n    # Count the number of objects for each color\n    color_count = {}\n    for obj in objects:\n        color = obj[0, 0]  # Assuming each object is monochromatic\n        if color not in color_count:\n            color_count[color] = 0\n        color_count[color] += 1\n    \n    # Prepare the bar chart\n    sorted_colors = sorted(color_count.items(), key=lambda item: item[0])  # Sort by color for consistent output\n    for idx, (color, count) in enumerate(sorted_colors):\n        bar_height = min(count, 10)  # Limit bar height to fit in the grid\n        output_grid[10 - bar_height:10, idx] = color  # Draw the bar\n\n    return output_grid\n\ndef generate_input():\n    # Create a black 10x10 grid as the background\n    grid_size = (10, 10)\n    grid = np.zeros(grid_size, dtype=int)\n    \n    # Random number of sprites\n    num_sprites = np.random.randint(5, 15)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_sprites, replace=True)\n    \n    for color in colors:\n        height = np.random.randint(1, 4)  # Height of the object\n        width = np.random.randint(1, 4)   # Width of the object\n        \n        # Create a sprite with the specified color\n        sprite = np.full((height, width), color)\n        \n        # Find a random free location for the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except:\n            continue  # If there is no space, skip placing this sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/287/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/287/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/287/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/287/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/287/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/287/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/287/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/287/images/train_output_2.png"}]}, "index": 287, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color correspondence, grid transformation\n\n# description:\n# In the input you will see a square pattern made of green and yellow pixels. \n# To make the output, rotate the pattern 90 degrees counterclockwise. \n# Make the green pixels red and the yellow pixels orange in the output.\n\ndef main(input_grid):\n    # Detect the continuous object in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n    assert len(objects) == 1  # We expect only one object in the input grid\n    \n    original_pattern = crop(grid=objects[0], background=Color.BLACK)\n    \n    # Initialize the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Rotate the original pattern 90 degrees counterclockwise\n    rotated_pattern = np.rot90(original_pattern, k=1)\n    \n    # Change the colors accordingly\n    rotated_pattern[rotated_pattern == Color.GREEN] = Color.RED\n    rotated_pattern[rotated_pattern == Color.YELLOW] = Color.ORANGE\n    \n    # Get the position of the original pattern in the input grid\n    object_x, object_y = object_position(original_pattern, background=Color.BLACK, anchor=\"upper left\")\n    \n    # Find the position to place the rotated pattern\n    # Calculate where to place the rotated pattern in the output grid\n    output_grid = blit_sprite(grid=output_grid, x=object_x, y=object_y, sprite=rotated_pattern, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = 6, 6\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random pattern of green and yellow pixels\n    density = 0.5  # 50% of the pixels will be colored\n    sprite = random_sprite(n=4, m=4, density=density, color_palette=[Color.GREEN, Color.YELLOW])\n    \n    # Randomly place the sprite in the grid\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/288/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/288/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/288/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/288/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/288/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/288/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/288/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/288/images/train_output_2.png"}]}, "index": 288, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, counting, pattern generation\n\n# description:\n# In the input you will see several 1x1 yellow pixels scattered across the grid.\n# To create the output grid, count the number of yellow pixels and then \n# replace every yellow pixel with a 2x2 red square in the output grid,\n# following a diagonal pattern starting from the top-left corner.\n\ndef main(input_grid):\n    # Detect all yellow pixels on the grid.\n    yellow_pixels = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n\n    # Count the number of yellow pixels.\n    num_yellow_pixels = len(yellow_pixels)\n\n    # Output grid will be the same size as input.\n    output_grid = np.copy(input_grid)\n\n    # Draw 2x2 red squares in a diagonal pattern for each yellow pixel detected.\n    for i in range(num_yellow_pixels):\n        # Calculate position for the new red square based on the index\n        x = (i // (output_grid.shape[1] // 2)) * 2  # Row index for the 2x2 square\n        y = (i % (output_grid.shape[1] // 2)) * 2  # Column index for the 2x2 square\n        \n        # Ensure we stay within bounds to prevent index errors\n        if x \u003c output_grid.shape[0] - 1 and y \u003c output_grid.shape[1] - 1:\n            red_square = np.full((2, 2), Color.RED)\n            blit_sprite(output_grid, red_square, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    grid_len = np.random.randint(10, 15)\n    n, m = grid_len, grid_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of yellow pixels.\n    yellow_pixel_count = np.random.randint(1, 11)\n\n    # Place the yellow pixels on the grid.\n    for _ in range(yellow_pixel_count):\n        yellow_pixel = np.array([[Color.YELLOW]])\n        x, y = random_free_location_for_sprite(grid=grid, sprite=yellow_pixel)\n        blit_sprite(grid, yellow_pixel, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/289/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/289/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/289/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/289/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/289/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/289/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/289/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/289/images/train_output_2.png"}]}, "index": 289, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, object transformation\n\n# description:\n# In the input, you will see a 3x3 green square and a 3x3 yellow square.\n# To make the output, transform the 3x3 green square into a 5x5 maroon diamond shape\n# and overlay it onto the 3x3 yellow square.\n\ndef main(input_grid):\n    # Detect the green and yellow squares on the grid\n    green_squares = detect_objects(grid=input_grid, colors=[Color.GREEN], monochromatic=True, connectivity=4)\n    yellow_squares = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n\n    # Assume there is one green square and one yellow square\n    green_square = green_squares[0]\n    yellow_square = yellow_squares[0]\n\n    # Crop the green square\n    cropped_green = crop(green_square, background=Color.BLACK)\n\n    # Create a 5x5 maroon diamond shape\n    maroon_diamond = np.array([[Color.BLACK, Color.BLACK, Color.MAROON, Color.BLACK, Color.BLACK],\n                                [Color.BLACK, Color.MAROON, Color.MAROON, Color.MAROON, Color.BLACK],\n                                [Color.MAROON, Color.MAROON, Color.MAROON, Color.MAROON, Color.MAROON],\n                                [Color.BLACK, Color.MAROON, Color.MAROON, Color.MAROON, Color.BLACK],\n                                [Color.BLACK, Color.BLACK, Color.MAROON, Color.BLACK, Color.BLACK]])\n\n    # Find the position of the yellow square to overlay the diamond\n    yellow_x, yellow_y = object_position(yellow_square, background=Color.BLACK, anchor=\u0027upper left\u0027)\n\n    # Overlay the maroon diamond onto the yellow square\n    output_grid = input_grid.copy()\n    output_grid = blit_sprite(output_grid, maroon_diamond, x=yellow_x, y=yellow_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a 3x3 green square\n    green_square = np.full((3, 3), Color.GREEN)\n    x_green, y_green = random_free_location_for_sprite(grid, green_square)\n    grid = blit_sprite(grid, green_square, x=x_green, y=y_green, background=Color.BLACK)\n\n    # Create a 3x3 yellow square\n    yellow_square = np.full((3, 3), Color.YELLOW)\n    x_yellow, y_yellow = random_free_location_for_sprite(grid, yellow_square)\n    grid = blit_sprite(grid, yellow_square, x=x_yellow, y=y_yellow, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/290/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/290/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/290/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/290/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/290/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/290/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/290/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/290/images/train_output_2.png"}]}, "index": 290, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pixel manipulation\n\n# description:\n# In the input, you will see a grid filled with colored pixels. The transformation requires you to invert the color of each pixel, \n# where each color is mapped to its complementary color. For example, if a pixel is blue, it should be changed to its complementary color (e.g., yellow).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to the same shape as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Define the complementary color mapping based on a predefined set of colors\n    color_map = {\n        Color.BLACK: Color.MAROON,  # Assuming WHITE is a new color not defined in Color\n        Color.BLUE: Color.YELLOW,\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.RED,\n        Color.YELLOW: Color.BLUE,\n        Color.GREY: Color.PINK,\n        Color.PINK: Color.GREY,\n        Color.ORANGE: Color.TEAL,\n        Color.TEAL: Color.ORANGE,\n        Color.MAROON: Color.RED  # Assuming CYAN is a new color not defined in Color\n    }\n\n    # Iterate through each pixel in the input grid\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            # Get the current color of the pixel\n            current_color = input_grid[i, j]\n            # Set the pixel in the output grid to its complementary color\n            output_grid[i, j] = color_map.get(current_color, current_color)  # Default to the same color if not found\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random-sized grid (between 5x5 to 10x10)\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors, ensuring a mix of colors\n    for i in range(n):\n        for j in range(m):\n            # Randomly select a color from Color.NOT_BLACK\n            grid[i, j] = random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/291/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/291/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/291/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/291/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/291/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/291/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/291/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/291/images/train_output_2.png"}]}, "index": 291, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swapping, vertical alignment\n\n# description:\n# In the input, you will see several columns of colored squares. Each column contains two or more squares of the same color stacked on top of each other. \n# To make the output, swap the colors of the squares in each column such that the topmost square takes the color of the bottommost, the second square takes the color of the second last, and so on.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Get the number of columns\n    num_cols = input_grid.shape[1]\n\n    # Process each column independently\n    for col in range(num_cols):\n        # Get the colors in the column\n        column_colors = input_grid[:, col]\n        # Filter out the background colors\n        colors = column_colors[column_colors != Color.BLACK]\n        \n        # Swap colors: topmost takes bottommost and so on\n        for i in range(len(colors)):\n            output_grid[i, col] = colors[-(i + 1)]  # Swap positions\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random number of columns (2 to 6)\n    num_cols = np.random.randint(2, 7)\n    \n    # Create a grid height (3 to 5)\n    grid_height = np.random.randint(3, 6)\n    \n    # Initialize an empty grid\n    grid = np.full((grid_height, num_cols), Color.BLACK)\n\n    # Randomly choose colors for each column\n    available_colors = list(Color.NOT_BLACK)\n    for col in range(num_cols):\n        # Randomly choose a color for this column\n        color = np.random.choice(available_colors)\n        \n        # Fill the column with 2 to 4 squares of the chosen color\n        num_squares = np.random.randint(2, 5)  # 2 to 4 squares\n        for row in range(num_squares):\n            if row \u003c grid_height:  # Prevent index overflow\n                grid[grid_height - 1 - row, col] = color  # Stack from the bottom\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/292/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/292/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/292/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/292/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/292/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/292/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/292/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/292/images/train_output_2.png"}]}, "index": 292, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# growing, color guide\n\n# description:\n# In the input, you will see a grid with a single red pixel. \n# To make the output, grow a blue square around the red pixel, increasing in size outwards until it fills the entire grid.\n\ndef main(input_grid):\n    # Find the position of the red pixel\n    red_pixel_position = np.argwhere(input_grid == Color.RED)\n\n    if len(red_pixel_position) == 0:\n        # If there is no red pixel, return the original grid\n        return input_grid\n\n    # Get the coordinates of the red pixel\n    red_x, red_y = red_pixel_position[0]\n    \n    # Create an output grid filled with black (background color)\n    output_grid = np.full(input_grid.shape, Color.BLACK, dtype=int)\n\n    # Determine the maximum possible size of the blue square\n    max_size = min(input_grid.shape)  # maximum size is limited by the smaller dimension of the grid\n\n    # Grow the blue square around the red pixel\n    for size in range(max_size):\n        if (red_x - size \u003e= 0 and red_x + size \u003c input_grid.shape[0] and\n            red_y - size \u003e= 0 and red_y + size \u003c input_grid.shape[1]):\n            output_grid[red_x - size:red_x + size + 1, red_y - size:red_y + size + 1] = Color.BLUE\n    \n    return output_grid\n\ndef generate_input():\n    # Make a 9x9 black background grid first\n    n = m = 9\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a single red pixel at a random location in the grid\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/293/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/293/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/293/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/293/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/293/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/293/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/293/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/293/images/train_output_2.png"}]}, "index": 293, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, boolean indicator\n\n# description:\n# In the input, you will see a 3x3 grid with red and blue pixels. \n# To make the output, you should check if the grid is rotationally symmetric.\n# If it is, output a 1x1 grid with a green pixel. If it\u0027s not, output a 1x1 grid with a yellow pixel.\n\ndef main(input_grid):\n    # Check for rotational symmetry in the 3x3 grid\n    is_symmetric = (input_grid[0, 0] == input_grid[2, 2] and \n                    input_grid[0, 1] == input_grid[1, 2] and \n                    input_grid[0, 2] == input_grid[2, 0] and \n                    input_grid[1, 0] == input_grid[2, 1] and \n                    input_grid[1, 1] == input_grid[1, 1] and \n                    input_grid[2, 0] == input_grid[0, 2] and \n                    input_grid[2, 1] == input_grid[1, 2] and \n                    input_grid[2, 2] == input_grid[0, 0])\n                    \n    # If the grid is rotationally symmetric, output a green pixel.\n    # Otherwise, output a yellow pixel.\n    if is_symmetric:\n        output_grid = np.array([[Color.GREEN]])\n    else:\n        output_grid = np.array([[Color.YELLOW]])\n        \n    return output_grid\n\ndef generate_input():\n    n, m = 3, 3\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly generate a 3x3 grid with a rotationally symmetric pattern or not.\n    has_rotational_symmetry = np.random.choice([True, False])\n    \n    if has_rotational_symmetry:\n        # Create a rotationally symmetric grid\n        grid[0, 0] = grid[2, 2] = np.random.choice([Color.RED, Color.BLUE])\n        grid[0, 1] = grid[1, 2] = np.random.choice([Color.RED, Color.BLUE])\n        grid[0, 2] = grid[2, 0] = np.random.choice([Color.RED, Color.BLUE])\n        grid[1, 0] = grid[2, 1] = np.random.choice([Color.RED, Color.BLUE])\n        grid[1, 1] = np.random.choice([Color.RED, Color.BLUE])  # Center pixel\n    else:\n        # Create a random grid to ensure it\u0027s not symmetric\n        for i in range(n):\n            for j in range(m):\n                grid[i, j] = np.random.choice([Color.RED, Color.BLUE])\n        \n        # Ensure that it is not rotationally symmetric by changing some elements\n        grid[0, 0] = Color.RED\n        grid[2, 2] = Color.BLUE\n        \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/294/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/294/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/294/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/294/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/294/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/294/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/294/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/294/images/train_output_2.png"}]}, "index": 294, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# occlusion, object extraction, cropping\n\n# description:\n# In the input you will see several objects with the same color placed in a grid, only one of \n# them is occluded by a gray pixel. \n# To make the output grid, you should select the object occluded by the gray pixel, crop it, and then output it.\n\ndef main(input_grid):\n    # Get the color of the objects\n    object_color = [color for color in np.unique(input_grid) if color != Color.BLACK and color != Color.GRAY][0]\n\n    # Detect all objects of the object color in the input grid\n    object_list = detect_objects(grid=input_grid, colors=[object_color], connectivity=8, monochromatic=True)\n\n    # Detect the occluding gray pixel\n    gray_pixel = detect_objects(grid=input_grid, colors=[Color.GRAY], connectivity=8, monochromatic=True)[0]\n\n    # Find which object is occluded by the gray pixel\n    for obj in object_list:\n        cropped_obj = crop(grid=obj)\n        # Check if the gray pixel is in contact with the object\n        if contact(object1=obj, object2=gray_pixel, connectivity=4):\n            output_grid = cropped_obj\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Generate a 10x10 grid with several objects of the same color placed in it\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Select a color for the objects and the number of objects\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.GRAY]\n    obj_color = random.choice(available_colors)\n    num_objects = np.random.randint(2, 5)\n\n    # Place the objects in the grid\n    for i in range(num_objects):\n        # Create a random object (3x3) with the selected color\n        sprite = random_sprite(n=3, m=3, color_palette=[obj_color], density=0.6)\n        # Place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8, border_size=1)\n        except:\n            continue\n        \n        # If it\u0027s the first object, place a gray pixel to ensure it occludes it\n        if i == 0:\n            grid[x + 1, y + 1] = Color.GRAY  # Place gray pixel adjacent to the object\n            grid[x + 1, y + 2] = obj_color   # Ensure gray pixel is adjacent to object\u0027s color\n\n        # Add the object to the grid\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/295/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/295/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/295/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/295/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/295/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/295/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/295/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/295/images/train_output_2.png"}]}, "index": 295, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color shading\n\n# description:\n# In the input, you will see a grid with a single colored object. If the object has radial symmetry, shade it darker. If not, leave it unchanged.\n\ndef main(input_grid):\n    # Detect if there is radial symmetry\n    mirrors = detect_mirror_symmetry(input_grid)\n    \n    # If there are no mirror symmetries, then it is not radially symmetric\n    if len(mirrors) == 0:\n        return input_grid\n    \n    # Create an output grid\n    output_grid = input_grid.copy()\n    \n    # For each color in the input, darken it for the output\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        original_color = input_grid[x, y]\n        # Darkening the color (you may want to define a function for this)\n        # For simplicity, we\u0027ll use Color.GREY as a universal darker shade here.\n        output_grid[x, y] = Color.GREY\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random sprite with radial symmetry\n    has_radial_symmetry = np.random.choice([True, False])\n    if has_radial_symmetry:\n        symmetry_type = \"radial\"\n    else:\n        symmetry_type = \"not_symmetric\"\n    \n    color_palette = random.sample(list(Color.NOT_BLACK), k=1)\n    sprite = random_sprite(n=np.random.randint(3, 5), m=np.random.randint(3, 5), density=0.5, symmetry=symmetry_type, color_palette=color_palette)\n    sprite_x, sprite_y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=sprite_x, y=sprite_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/296/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/296/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/296/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/296/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/296/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/296/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/296/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/296/images/train_output_2.png"}]}, "index": 296, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color addition\n\n# description:\n# In the input you will see a grid with red and blue objects. \n# To create the output grid, add a green object of the same size to the right of each red object \n# and to the left of each blue object.\n\ndef main(input_grid):\n    # Detect red and blue objects in the grid\n    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n    blue_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n\n    output_grid = input_grid.copy()\n\n    # For each red object, place a green object of the same size to the right\n    for red_object in red_objects:\n        x, y, width, height = bounding_box(red_object)\n        green_sprite = np.full((height, width), Color.GREEN)\n        # Blit the green object to the right of the red object\n        blit_sprite(output_grid, green_sprite, x=x, y=y + width)  # Shift right\n\n    # For each blue object, place a green object of the same size to the left\n    for blue_object in blue_objects:\n        x, y, width, height = bounding_box(blue_object)\n        green_sprite = np.full((height, width), Color.GREEN)\n        # Blit the green object to the left of the blue object\n        blit_sprite(output_grid, green_sprite, x=x, y=y - width)  # Shift left\n\n    return output_grid\n\ndef generate_input():\n    # Generate a square grid as the background\n    grid_len = np.random.randint(10, 20)\n    n, m = grid_len, grid_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place red and blue objects in the grid\n    num_red_objects = np.random.randint(1, 5)  # number of red objects\n    num_blue_objects = np.random.randint(1, 5)  # number of blue objects\n\n    def place_object(color):\n        height, width = np.random.randint(1, 4), np.random.randint(1, 4)  # size of the object\n        sprite = np.full((height, width), color)\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y)\n\n    for _ in range(num_red_objects):\n        place_object(Color.RED)\n\n    for _ in range(num_blue_objects):\n        place_object(Color.BLUE)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/297/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/297/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/297/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/297/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/297/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/297/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/297/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/297/images/train_output_2.png"}]}, "index": 297, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color assignment\n\n# description:\n# In the input, you will see a grid containing a central pattern with surrounding pixels that have the same color. \n# The central pattern will consist of four distinct colors, each occupying one of the four quadrants. \n# To create the output grid, you should identify the color of each of the surrounding pixels and fill in the \n# corresponding quadrants of the output grid with those colors. The output grid will be twice the size of the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Identify the colors of the surrounding pixels\n    top_left_color = input_grid[0, 0]\n    top_right_color = input_grid[0, -1]\n    bottom_left_color = input_grid[-1, 0]\n    bottom_right_color = input_grid[-1, -1]\n\n    # Create the output grid, which is twice the size of the input grid\n    n, m = input_grid.shape\n    output_grid = np.full((2 * n, 2 * m), Color.BLACK)\n\n    # Fill in the quadrants of the output grid with the corresponding colors\n    # Top left quadrant\n    draw_line(grid=output_grid, x=0, y=0, end_x=n, end_y=m, color=top_left_color)\n    \n    # Top right quadrant\n    draw_line(grid=output_grid, x=0, y=m, end_x=n, end_y=2 * m, color=top_right_color)\n    \n    # Bottom left quadrant\n    draw_line(grid=output_grid, x=n, y=0, end_x=2 * n, end_y=m, color=bottom_left_color)\n    \n    # Bottom right quadrant\n    draw_line(grid=output_grid, x=n, y=m, end_x=2 * n, end_y=2 * m, color=bottom_right_color)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate a grid size\n    n, m = np.random.randint(3, 6), np.random.randint(3, 6)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose four distinct colors for the quadrants\n    colors = np.random.choice(list(Color.NOT_BLACK), size=4, replace=False)\n\n    # Fill in the surrounding pixels with chosen colors\n    grid[0, 0] = colors[0]  # top left\n    grid[0, -1] = colors[1]  # top right\n    grid[-1, 0] = colors[2]  # bottom left\n    grid[-1, -1] = colors[3]  # bottom right\n\n    # Fill the central pattern with a random color, ensuring it\u0027s distinct from surrounding colors\n    central_color = np.random.choice(list(set(Color.NOT_BLACK) - set(colors)))\n    grid[1:-1, 1:-1] = central_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/298/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/298/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/298/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/298/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/298/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/298/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/298/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/298/images/train_output_2.png"}]}, "index": 298, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color change\n\n# description:\n# In the input, you will see a grid with a pattern of alternating colors, specifically a blue checkerboard pattern. \n# To make the output grid, you should replace every blue pixel with yellow and every other pixel should remain unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Change every blue pixel to yellow\n    output_grid[output_grid == Color.BLUE] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a size of n x m\n    n, m = np.random.randint(6, 12), np.random.randint(6, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a blue checkerboard pattern\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 2 == 0:\n                grid[i, j] = Color.BLUE\n            else:\n                grid[i, j] = Color.BLACK\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/299/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/299/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/299/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/299/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/299/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/299/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/299/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/299/images/train_output_2.png"}]}, "index": 299, "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color mapping, pixel inversion\n\n# description:\n# In the input, you will see a grid filled with several colors. \n# To produce the output, invert the colors according to the following mapping:\n# red -\u003e teal, green -\u003e grey, blue -\u003e yellow, and any non-colored pixel should be turned black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Define the color mapping for inversion\n    color_map = {\n        Color.RED: Color.TEAL,\n        Color.GREEN: Color.GREY,\n        Color.BLUE: Color.YELLOW,\n        Color.BLACK: Color.BLACK  # non-colored should remain black\n    }\n\n    # Perform color mapping\n    output_grid = np.vectorize(lambda color: color_map.get(color, Color.BLACK))(output_grid)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 black grid as background\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly fill the grid with colors while ensuring diversity\n    num_colors = random.randint(5, 15)  # Random number of colors to fill\n    available_colors = list(Color.NOT_BLACK)\n\n    for _ in range(num_colors):\n        # Select a color and random position to fill\n        color = random.choice(available_colors)\n        # Randomly select a position within the grid to place this color\n        x, y = random.randint(0, n-1), random.randint(0, m-1)\n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_output_2.png"}]}, "index": 0, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, proximity, circular patterns\n\n# description:\n# In the input, you will see several colored dots scattered across a grid. For each dot, draw a circle around it of the same color, with the radius equal to the distance to the nearest other dot.\n# If there are no other dots, do not draw anything for that dot.\n\ndef main(input_grid):\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the positions of all the colored dots\n    dot_positions = np.argwhere(input_grid != Color.BLACK)\n\n    for x, y in dot_positions:\n        color = input_grid[x, y]\n\n        # Calculate the minimum distance to the nearest other dot\n        min_distance = float(\u0027inf\u0027)\n        for nx, ny in dot_positions:\n            if (nx, ny) != (x, y):\n                distance = np.sqrt((nx - x) ** 2 + (ny - y) ** 2)\n                min_distance = min(min_distance, distance)\n\n        # If there\u0027s a valid minimum distance, draw a circle\n        if min_distance != float(\u0027inf\u0027):\n            radius = int(np.round(min_distance))\n            # Draw the circle around the dot\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    if dx**2 + dy**2 \u003c= radius**2:  # Circle equation\n                        if 0 \u003c= x + dx \u003c output_grid.shape[0] and 0 \u003c= y + dy \u003c output_grid.shape[1]:\n                            output_grid[x + dx, y + dy] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(8, 20), np.random.randint(8, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose some colors and scatter them as dots\n    num_dots = np.random.randint(3, 10)\n    colors = np.random.choice(Color.NOT_BLACK, num_dots, replace=True)\n\n    for color in colors:\n        # Randomly scatter each dot on the grid\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_output_2.png"}]}, "index": 1, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel expansion, growth\n\n# description:\n# In the input, you will see a small colored shape surrounded by a non-black background. \n# To create the output, expand the shape outward by one pixel in all directions, \n# filling the newly created spaces with the original color of the shape.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color.\n    # 2. Find the connected components in the grid.\n    # 3. Identify the colored shape and expand its boundaries by one pixel.\n\n    # Identify the background color (the most common color)\n    background_color = np.bincount(input_grid.flatten()).argmax()\n\n    # Get the connected components\n    components = find_connected_components(input_grid, background=background_color, connectivity=8)\n    \n    # The colored shape should be the largest component\n    colored_shape = max(components, key=lambda obj: np.sum(obj != background_color))\n\n    # Prepare the output grid\n    output_grid = np.full(input_grid.shape, fill_value=background_color)\n\n    # Get the coordinates of the colored shape\n    shape_coords = np.argwhere(colored_shape != background_color)\n\n    # Expand the shape by one pixel in all directions\n    for x, y in shape_coords:\n        # Fill the neighboring pixels with the shape\u0027s color\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue  # Skip the center pixel\n                new_x, new_y = x + dx, y + dy\n                # Ensure we\u0027re within bounds\n                if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                    output_grid[new_x, new_y] = colored_shape[x, y]\n    \n    # Place the original shape back into the output grid\n    output_grid[shape_coords[:, 0], shape_coords[:, 1]] = colored_shape[shape_coords[:, 0], shape_coords[:, 1]]\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Randomly select a color for the shape and background.\n    # 2. Create a grid filled with the background color.\n    # 3. Randomly generate a small shape and place it in the grid.\n\n    background_color = np.random.choice(Color.NOT_BLACK)\n    shape_color = np.random.choice([color for color in Color.NOT_BLACK if color != background_color])\n    \n    # Create a random grid size\n    width, height = np.random.randint(5, 15, size=2)\n    input_grid = np.full((width, height), fill_value=background_color)\n\n    # Generate a small shape (between 2x2 and 4x4)\n    shape_width, shape_height = np.random.randint(2, 5, size=2)\n    shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=1)\n\n    # Randomly place the shape in the grid\n    x, y = random_free_location_for_sprite(input_grid, shape_sprite, background=background_color, padding=1)\n    blit_sprite(input_grid, shape_sprite, x, y, background=background_color)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_output_2.png"}]}, "index": 2, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape recognition, gradient filling\n\n# description:\n# In the input, you will see a grid with various closed shapes that are filled with a single color. \n# To create the output, identify the shapes and fill them with a gradient of colors, \n# starting from the outer edge of the shape to the center, transitioning from one color to another.\n\ndef main(input_grid):\n    # Find all connected components in the input grid\n    shapes = find_connected_components(grid=input_grid, monochromatic=True, connectivity=4)\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Define the gradient colors\n    gradient_colors = [Color.BLUE, Color.GREEN, Color.YELLOW, Color.RED]\n\n    for shape in shapes:\n        # Get the bounding box of each shape\n        x, y, w, h = bounding_box(grid=shape)\n        shape_color = shape[x, y]\n\n        # Create a mask for the shape\n        mask = (shape == shape_color)\n\n        # Calculate the distance from the center for each pixel in the bounding box\n        center_x, center_y = x + w // 2, y + h // 2\n        distances = np.sqrt((np.arange(w)[:, None] - center_x) ** 2 + (np.arange(h) - center_y) ** 2)\n\n        # Normalize distances and map to gradient colors\n        max_distance = np.max(distances)\n        normalized_distances = distances / max_distance if max_distance \u003e 0 else distances\n        \n        # Fill the shape with a gradient\n        for i in range(len(gradient_colors)):\n            color_mask = (normalized_distances \u003e i / len(gradient_colors)) \u0026 (normalized_distances \u003c= (i + 1) / len(gradient_colors))\n            output_grid[x:x+w, y:y+h][color_mask] = gradient_colors[i]\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create a number of shapes\n    shape_count = np.random.randint(2, 6)\n\n    # Define colors for the shapes (excluding black)\n    available_colors = list(Color.NOT_BLACK)\n    \n    for _ in range(shape_count):\n        # Randomly choose a shape size and color\n        shape_height = np.random.randint(1, 5)\n        shape_width = np.random.randint(1, 5)\n        shape_color = np.random.choice(available_colors)\n\n        # Create a random shape\n        shape = random_sprite(n=shape_height, m=shape_width, density=1.0, color_palette=[shape_color])\n        \n        # Find a random free location for the shape in the grid\n        x, y = random_free_location_for_sprite(grid, shape)\n\n        # Blit the shape onto the grid\n        grid = blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_output_2.png"}]}, "index": 3, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color expansion, shape transformation\n\n# description:\n# In the input, you will see a colored shape on a black background. To make the output, expand the shape by one pixel in all directions, ensuring that the new pixels take on the same color as the original shape.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color (black)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find connected components in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Iterate through each component found\n    for component in components:\n        # Get the bounding box of the current component\n        x, y, width, height = bounding_box(component)\n\n        # Get the color of the current component\n        color = component[x, y]\n\n        # Expand the shape by drawing a border of the same color around it\n        for i in range(-1, width + 1):\n            for j in range(-1, height + 1):\n                if (0 \u003c= x + i \u003c output_grid.shape[0]) and (0 \u003c= y + j \u003c output_grid.shape[1]):\n                    output_grid[x + i, y + j] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid (background)\n    n, m = np.random.randint(5, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create a colored shape (sprite) in the grid\n    shape_color = np.random.choice(list(Color.NOT_BLACK))\n    shape_width, shape_height = np.random.randint(1, n//2), np.random.randint(1, m//2)\n\n    # Generate a random shape and place it in the grid\n    shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=0.5)\n    shape_x, shape_y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK)\n    blit_sprite(grid, shape_sprite, x=shape_x, y=shape_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_output_2.png"}]}, "index": 4, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, geometric transformation\n\n# description:\n# In the input, you will see a grid filled with different colors forming a pattern. \n# The output should transform the grid by rotating the colors 90 degrees clockwise, \n# while keeping the same pattern of colors. \n# For example, if the color at (0, 0) is red, it should be moved to (0, n-1) position in the output grid \n# where n is the number of rows in the original grid.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Initialize an output grid of the same dimensions\n    output_grid = np.full((m, n), Color.BLACK)\n\n    # Rotate the colors 90 degrees clockwise\n    for i in range(n):\n        for j in range(m):\n            output_grid[j, n - 1 - i] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random colors\n    grid_size = np.random.randint(3, 10)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Fill the grid with random colors excluding black\n    for i in range(grid_size):\n        for j in range(grid_size):\n            grid[i, j] = random.choice(Color.NOT_BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_output_2.png"}]}, "index": 5, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, color inversion\n\n# description:\n# In the input, you will see a colored square grid. To make the output, mirror the grid vertically and then invert the colors according to the following mapping: \n# blue -\u003e red, red -\u003e blue, green -\u003e yellow, yellow -\u003e green.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Mirror the grid vertically\n    output_grid = np.flipud(output_grid)\n\n    # Perform color inversion\n    color_inversion_map = {\n        Color.BLUE: Color.RED,\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.YELLOW: Color.GREEN,\n        Color.BLACK: Color.BLACK,  # Keep black as black\n        Color.GRAY: Color.GRAY,    # Keep gray as gray\n        Color.PINK: Color.PINK,    # Keep pink as pink\n        Color.ORANGE: Color.ORANGE, # Keep orange as orange\n        Color.TEAL: Color.TEAL,      # Keep teal as teal\n        Color.MAROON: Color.MAROON   # Keep maroon as maroon\n    }\n\n    output_grid = np.vectorize(lambda color: color_inversion_map.get(color, color))(output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random colors\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors from the available colors\n    available_colors = [Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.GRAY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON]\n    \n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_output_2.png"}]}, "index": 6, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, transparency\n\n# description:\n# In the input, you will see several layers of colored rectangles on a red background. Each rectangle has a certain level of transparency.\n# To make the output, layer the rectangles according to their transparency level, creating a composite image where the colors blend based on their transparency.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify each colored rectangle and its transparency level.\n    # 2. Create a new output grid initialized to red (Color.RED).\n    # 3. For each rectangle, layer it onto the output grid using its transparency level.\n    \n    # Initialize the output grid to red (Color.RED)\n    output_grid = np.full(input_grid.shape, Color.RED)\n    \n    # Find connected components to locate rectangles\n    rectangles = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=Color.RED)\n\n    for rectangle in rectangles:\n        # Calculate the color and transparency level of the rectangle\n        color = np.argmax(np.bincount(rectangle[rectangle != Color.RED]))\n        \n        # Calculate the transparency level based on the number of pixels\n        transparency = np.sum(rectangle != Color.RED) / rectangle.size \n        \n        # Blend the rectangle onto the output grid based on its transparency\n        for x, y in np.argwhere(rectangle != Color.RED):\n            # Get the original color at the output grid position\n            original_color = output_grid[x, y]\n            blended_color = blend_colors(original_color, color, transparency)\n            output_grid[x, y] = blended_color\n    \n    return output_grid\n\ndef blend_colors(color1, color2, alpha):\n    \"\"\"\n    Blend two colors based on the transparency level (alpha).\n    color1: base color (the one in the output grid)\n    color2: new color (rectangle color)\n    alpha: transparency level (0 to 1)\n    \"\"\"\n    if color1 == Color.RED:\n        return color2  # If the original color is red, just take the new color\n    \n    # Simple averaging for blending\n    return color2 if np.random.rand() \u003c alpha else color1\n\ndef generate_input():\n    # Plan:\n    # 1. Create a grid with a red background.\n    # 2. Randomly generate rectangles with varying transparency.\n    # 3. Ensure rectangles overlap and are placed randomly on the grid.\n\n    w, h = np.random.randint(10, 25, size=2)\n    grid = np.full((w, h), Color.RED)\n    \n    n_rectangles = np.random.randint(3, 5)\n    \n    for _ in range(n_rectangles):\n        # Generate random rectangle properties\n        rw, rh = np.random.randint(3, 8), np.random.randint(3, 8)\n        color = np.random.choice(Color.NOT_BLACK)\n        \n        # Create a rectangle\n        rectangle = np.full((rw, rh), color)\n        \n        # Random transparency level between 0.2 and 1.0 (0.2 means 20% opaque)\n        transparency = np.random.uniform(0.2, 1.0)\n        \n        # Use random position to place the rectangle, ensuring it fits within the grid\n        x, y = np.random.randint(0, w - rw), np.random.randint(0, h - rh)\n        blit_sprite(grid, rectangle, x, y, background=Color.RED)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_output_2.png"}]}, "index": 7, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, depth perception, transparency blending\n\n# description:\n# In the input, you will see multiple overlapping transparent shapes on a colored background.\n# To make the output grid, create a new layer for each shape and adjust their opacities based on their overlap,\n# giving the appearance of depth and layering in the output grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all shapes in the input grid\n    # 2. Create an output grid initialized to the background color\n    # 3. For each shape, compute its overlap with other shapes and adjust opacity\n    # 4. Blend shapes into the output grid based on adjusted opacities\n\n    # Determine the background color (most frequent color)\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    output_grid = np.full(input_grid.shape, background_color)\n\n    # Detect all connected components (shapes)\n    shapes = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # For each shape, determine its color and draw it with adjusted opacity\n    for shape in shapes:\n        # Get color of the shape (assuming it\u0027s a single color)\n        shape_color = shape[0, 0]\n\n        # Create a mask for the current shape\n        mask = (shape == shape_color)\n\n        # Calculate overlap with existing shapes in the output grid\n        overlap_count = np.sum(output_grid == shape_color)\n        if overlap_count \u003e 0:  # If there\u0027s overlap\n            # Adjust opacity (for simplicity, let\u0027s say each overlap reduces opacity)\n            opacity = max(0, 255 - (overlap_count * 50))  # Reduce by 50 for each overlap\n            blended_color = blend_colors(shape_color, background_color, opacity)\n            output_grid[mask] = blended_color\n        else:\n            output_grid[mask] = shape_color  # No overlap, use the original color\n\n    return output_grid\n\ndef blend_colors(color1, color2, opacity):\n    \"\"\"\n    Blend color1 with color2 based on opacity.\n    Opacity is a value from 0 (transparent) to 255 (opaque).\n    \"\"\"\n    return int((opacity * color1 + (255 - opacity) * color2) / 255)\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a random background.\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly assign a background color (not black)\n    background_color = random.choice(Color.NOT_BLACK)\n    grid[:, :] = background_color\n\n    # Create a random number of transparent shapes (2 to 5)\n    num_shapes = np.random.randint(2, 6)\n\n    for _ in range(num_shapes):\n        # Random size for the shape between 2x2 and 5x5\n        width, height = np.random.randint(2, 6), np.random.randint(2, 6)\n        shape_color = random.choice(Color.NOT_BLACK)  # Random color for the shape\n        shape = np.full((width, height), shape_color)\n\n        # Find a free location for the shape\n        x, y = random_free_location_for_sprite(grid, shape, background=background_color, border_size=1)\n        blit_sprite(grid, shape, x, y, background=background_color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_output_2.png"}]}, "index": 8, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contour tracing, area filling, shape recognition\n\n# description:\n# In the input you will see a black background with various colored shapes. \n# To create the output grid, trace the contours of each shape and fill the area inside \n# the contours with a single color that matches the color of the shape.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the background color (which is black)\n    # 2. Extract all colored shapes using connected components\n    # 3. For each shape, find its contour and fill the interior with the shape\u0027s color\n\n    output_grid = np.copy(input_grid)\n\n    # Assume the background is black\n    background = Color.BLACK\n\n    # Find connected components (shapes) in the grid\n    shapes = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=background)\n\n    for shape in shapes:\n        # Get the color of the shape (assumes monochromatic for each shape)\n        shape_color = np.unique(shape[shape != background])[0]\n\n        # Get the bounding box of the shape\n        x, y, w, h = bounding_box(shape, background=background)\n\n        # Create a filled shape of the same size as the bounding box\n        filled_shape = np.full((w, h), shape_color)\n\n        # Fill the area inside the contour with the shape\u0027s color\n        blit_object(output_grid, filled_shape, background=background)\n\n    return output_grid\n\ndef generate_input():\n    # Plan:\n    # 1. Create a grid filled with black\n    # 2. Randomly generate colored shapes of varying sizes and positions\n    # 3. Ensure that shapes don\u0027t overlap\n\n    n, m = np.random.randint(10, 20, size=2)  # dimensions of the grid\n    grid = np.full((n, m), Color.BLACK)\n\n    num_shapes = np.random.randint(3, 6)  # Number of shapes to generate\n\n    for _ in range(num_shapes):\n        # Random dimensions for the shape\n        shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a random shape sprite\n        shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=1)\n\n        # Find a random free location for this shape\n        x, y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK, padding=1, border_size=1)\n        blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_output_2.png"}]}, "index": 9, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, symmetry, borders\n\n# description:\n# In the input you will see a grid with a central object that is a colored square (size 3x3) surrounded by a black border.\n# To create the output grid, you should reflect the colors of the central object to the four borders of the grid,\n# while keeping the original colors in the center and changing the central object\u0027s color to yellow. \n\ndef main(input_grid):\n    # The central object is assumed to be a 3x3 square.\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    central_object = input_grid[center_x-1:center_x+2, center_y-1:center_y+2]\n\n    # Change the central object color to yellow\n    output_grid = np.copy(input_grid)\n    output_grid[center_x-1:center_x+2, center_y-1:center_y+2] = Color.YELLOW\n\n    # Reflect the colors of the central object to the borders\n    for dx in range(3):\n        for dy in range(3):\n            color = central_object[dx, dy]\n            if color != Color.BLACK:  # Don\u0027t reflect black to the border\n                output_grid[dx, 0] = color  # Top border\n                output_grid[dx, -1] = color  # Bottom border\n                output_grid[0, dy] = color  # Left border\n                output_grid[-1, dy] = color  # Right border\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a black background\n    n, m = 7, 7\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random colored central object of size 3x3\n    colors = list(Color.NOT_BLACK)\n    central_color = np.random.choice(colors)\n    central_object = np.full((3, 3), central_color)\n\n    # Place the central object in the middle of the grid\n    grid[2:5, 2:5] = central_object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_output_2.png"}]}, "index": 10, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filling, adjacency, region growing\n\n# description:\n# The input grid consists of a background color and a special color (e.g., red). \n# The task is to identify all connected regions of the special color, and for each region, fill the entire area with a new color (e.g., yellow). \n# The regions are defined as contiguous groups of special color pixels connected either horizontally or vertically.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    special_color = Color.RED\n    fill_color = Color.YELLOW\n\n    # Find all connected components of the special color\n    components = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # For each component, fill the area with fill_color\n    for component in components:\n        for x, y in np.argwhere(component):\n            output_grid[x, y] = fill_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the background color and scatter the special color (e.g., red)\n    background_color = Color.BLACK\n    special_color = Color.RED\n\n    # Randomly scatter the special color throughout the grid\n    density = 0.2  # 20% of the grid may be the special color\n    grid = random_scatter_points(grid=grid, color=special_color, density=density, background=background_color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_output_2.png"}]}, "index": 11, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contour tracing, boundary detection, filling\n\n# description:\n# In the input, you will see a black grid with a colored shape on it. To create the output, trace the outer contour of the shape and fill the region inside the contour with a new color, while leaving the outside black.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the input grid that are not black\n    shape_components = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Assume there is only one shape in the input grid\n    shape = shape_components[0]\n\n    # Get the color of the shape\n    shape_color = shape[shape != Color.BLACK][0]\n\n    # Create a mask for the shape\n    mask = (input_grid == shape_color)\n\n    # Find the contour of the shape\n    contours = np.zeros_like(input_grid, dtype=int)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if mask[x, y]:\n                # Check the 4-connected neighbors\n                neighbors = [(x + dx, y + dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]]\n                for nx, ny in neighbors:\n                    if (0 \u003c= nx \u003c input_grid.shape[0] and 0 \u003c= ny \u003c input_grid.shape[1] and \n                        input_grid[nx, ny] == Color.BLACK):\n                        contours[x, y] = 1  # Mark contour pixels\n\n    # Fill the inside of the contour with a new color (e.g., Color.GREEN)\n    inside_color = Color.GREEN\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if contours[x, y] == 1:\n                # Flood fill from this contour point to fill the region inside\n                flood_fill(output_grid, x, y, inside_color)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid of size 15x15\n    grid = np.full((15, 15), Color.BLACK)\n\n    # Create a random shape (2-7)x(2-7) in a random color\n    w = np.random.randint(2, 8)\n    h = np.random.randint(2, 8)\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Generate a random sprite for the shape\n    sprite = random_sprite(w, h, color_palette=[shape_color], density=1)\n\n    # Place the shape in a random location within the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_output_2.png"}]}, "index": 12, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color separation, shape detection\n\n# description:\n# In the input you will see a grid with various colored shapes, some of which are composed of a specific color (red).\n# To create the output, you should identify connected regions of red pixels and change their color to green, while leaving all other pixels unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Get the shape of the grid\n    rows, cols = output_grid.shape\n    \n    # A function to perform a flood fill to change the color of connected red pixels to green\n    def flood_fill(x, y):\n        # Check if the current position is within bounds and is red\n        if x \u003c 0 or x \u003e= rows or y \u003c 0 or y \u003e= cols or output_grid[x, y] != Color.RED:\n            return\n        # Change the color to green\n        output_grid[x, y] = Color.GREEN\n        \n        # Recursively call flood_fill in all 4 directions\n        flood_fill(x + 1, y)  # down\n        flood_fill(x - 1, y)  # up\n        flood_fill(x, y + 1)  # right\n        flood_fill(x, y - 1)  # left\n\n    # Iterate through the grid to find connected regions of red pixels\n    for i in range(rows):\n        for j in range(cols):\n            if output_grid[i, j] == Color.RED:  # Found a new region of red\n                flood_fill(i, j)  # Change the color of this region to green\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter several colors in the grid\n    available_colors = [Color.BLACK, Color.BLUE, Color.GREEN, Color.YELLOW, Color.PINK, Color.ORANGE]\n    # Fill the grid with random colors (not red)\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.7:  # 70% chance of being a non-red color\n                grid[i, j] = np.random.choice(available_colors)\n    \n    # Randomly create connected regions of red pixels\n    for _ in range(np.random.randint(1, 5)):  # Create 1 to 4 red regions\n        # Create a random size for the red region\n        region_height = np.random.randint(2, 5)\n        region_width = np.random.randint(2, 5)\n        \n        # Get random start position\n        start_x = np.random.randint(0, n - region_height)\n        start_y = np.random.randint(0, m - region_width)\n\n        # Fill the selected area with red pixels\n        for i in range(region_height):\n            for j in range(region_width):\n                grid[start_x + i, start_y + j] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_output_2.png"}]}, "index": 13, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape transformation, color replacement, scaling, cropping\n\n# description:\n# In the input, you will see a small yellow square on a teal background. To create the output, enlarge the square by a factor of 2, change its color to green, and ensure the center of the square remains the same in both grids.\n\ndef main(input_grid):\n    # Step 1: Detect the yellow square in the input grid\n    yellow_squares = detect_objects(input_grid, monochromatic=True, allowed_dimensions=[(3, 3)], colors=[Color.YELLOW])\n    \n    # There should be exactly one yellow square\n    assert len(yellow_squares) == 1, \"There should be exactly one yellow square in the input grid\"\n    \n    # Step 2: Crop the yellow square\n    yellow_square = crop(yellow_squares[0], background=Color.TEAL)\n    \n    # Step 3: Scale the yellow square by a factor of 2\n    scaled_square = scale_pattern(yellow_square, scale_factor=2)\n    \n    # Step 4: Create the output grid and place the scaled square in the center\n    output_grid_size = (input_grid.shape[0], input_grid.shape[1])\n    output_grid = np.full(output_grid_size, Color.TEAL, dtype=int)\n    \n    # Calculate the position to center the scaled square\n    x_offset = (output_grid_size[0] - scaled_square.shape[0]) // 2\n    y_offset = (output_grid_size[1] - scaled_square.shape[1]) // 2\n    \n    # Change its color to green\n    scaled_square[scaled_square != Color.TEAL] = Color.GREEN\n    \n    # Blit the scaled square onto the output grid\n    output_grid = blit_sprite(output_grid, scaled_square, x=x_offset, y=y_offset, background=Color.TEAL)\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Create a teal grid\n    grid_size = (20, 20)\n    grid = np.full(grid_size, Color.TEAL, dtype=int)\n\n    # Step 2: Generate a yellow square of size 3x3\n    yellow_square = np.full((3, 3), Color.YELLOW)\n\n    # Step 3: Randomly place the yellow square in the grid\n    x, y = random_free_location_for_sprite(grid, yellow_square, background=Color.TEAL)\n    grid = blit_sprite(grid, yellow_square, x=x, y=y, background=Color.TEAL)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_output_2.png"}]}, "index": 14, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# isolation, boundary detection, transformation\n\n# description:\n# In the input, you will see a grid with colored pixels scattered throughout. Among these colors, one color will be completely surrounded by black pixels with no direct path to the edge of the grid. \n# To make the output, convert all pixels of the surrounded color to a new color (e.g., green) and leave all other pixels unchanged. \n# If no color is surrounded, the output remains identical to the input.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Find the background color\n    background_color = Color.BLACK\n    \n    # Identify potential surrounded colors\n    unique_colors = set(np.unique(input_grid)) - {background_color}\n    surrounded_colors = []\n\n    for color in unique_colors:\n        # Find positions of the current color\n        positions = np.argwhere(input_grid == color)\n        \n        # Check if all positions are surrounded by the background\n        if all((0 \u003c x \u003c input_grid.shape[0] - 1 and 0 \u003c y \u003c input_grid.shape[1] - 1) for x, y in positions):\n            # Check all neighboring positions for background color\n            is_surrounded = True\n            for x, y in positions:\n                # Check 4-connectivity\n                if not (input_grid[x-1, y] == background_color and\n                        input_grid[x+1, y] == background_color and\n                        input_grid[x, y-1] == background_color and\n                        input_grid[x, y+1] == background_color):\n                    is_surrounded = False\n                    break\n            \n            if is_surrounded:\n                surrounded_colors.append(color)\n\n    # If we found a surrounded color, color it green\n    if surrounded_colors:\n        for color in surrounded_colors:\n            output_grid[output_grid == color] = Color.GREEN\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a black grid first as background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose colors for our grid\n    colors = random.sample(Color.NOT_BLACK, k=3)  # Pick 3 distinct colors\n\n    # Scatter colors on the grid, ensuring one color is surrounded\n    surrounded_color = colors[0]\n    non_surrounded_colors = colors[1:]\n\n    # Fill grid with non-surrounded colors\n    for color in non_surrounded_colors:\n        grid = random_scatter_points(grid, color, density=0.3)\n\n    # Place the surrounded color in a way that surrounds it with black\n    # Choose a random position in the grid that is not on an edge\n    while True:\n        pos_x = np.random.randint(1, n-1)\n        pos_y = np.random.randint(1, m-1)\n        \n        if grid[pos_x, pos_y] == Color.BLACK:  # Ensure it\u0027s a valid position\n            grid[pos_x, pos_y] = surrounded_color\n            break\n\n    # Create a surrounding barrier of black pixels\n    grid[pos_x-1, pos_y] = Color.BLACK\n    grid[pos_x+1, pos_y] = Color.BLACK\n    grid[pos_x, pos_y-1] = Color.BLACK\n    grid[pos_x, pos_y+1] = Color.BLACK\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_output_2.png"}]}, "index": 15, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color filling\n\n# description:\n# In the input, you will see a square pattern of colored pixels. \n# To create the output, rotate the pattern by 90 degrees clockwise, \n# and fill the empty spaces with a new color that corresponds to the original colors of the pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the size of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid with the same dimensions as the input grid\n    output_grid = np.full((m, n), Color.BLACK)  # note: the output grid is transposed\n\n    # Fill the output grid by rotating the input grid 90 degrees clockwise\n    for i in range(n):\n        for j in range(m):\n            output_grid[j, n - 1 - i] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random size for the square pattern\n    size = np.random.randint(3, 7)\n    \n    # Create a square grid with a black background\n    grid = np.zeros((size, size), dtype=int)\n    \n    # Generate a random color palette excluding black\n    color_palette = np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(1, 6), replace=False)\n    \n    # Randomly fill the grid with colors from the color palette\n    for i in range(size):\n        for j in range(size):\n            if np.random.rand() \u003c 0.8:  # 80% chance to fill a color\n                grid[i, j] = np.random.choice(color_palette)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_output_2.png"}]}, "index": 16, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color preservation\n\n# description:\n# In the input, you will see a colored pattern that is rotated 90 degrees clockwise. \n# To create the output, rotate the pattern back to its original orientation (0 degrees), ensuring that the colors are preserved in their original positions.\n\ndef main(input_grid):\n    # Rotate the input grid 90 degrees counterclockwise to restore to original orientation\n    output_grid = np.rot90(input_grid, k=3)  # k=3 means 90 degrees counterclockwise\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n = np.random.randint(4, 7)\n    m = np.random.randint(4, 7)\n\n    # Create a base grid with a black background\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random sprite pattern to be rotated\n    pattern_size = np.random.randint(2, min(n, m) // 2 + 1)\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random pattern in the center of the grid\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[i + (n - pattern_size) // 2, j + (m - pattern_size) // 2] = color\n\n    # Rotate the pattern 90 degrees clockwise for the input\n    input_grid = np.rot90(grid, k=1)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_output_2.png"}]}, "index": 17, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connectivity, border detection\n\n# description:\n# In the input, you will see a colored irregular shape filled with one color on a black background. \n# To create the output, detect the border of the shape and color it with a contrasting color (e.g., blue) to emphasize the shape\u0027s outline.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color.\n    # 2. Find the connected component representing the shape.\n    # 3. Get the border of the shape.\n    # 4. Color the border with a contrasting color (blue).\n\n    background = np.bincount(input_grid.flatten()).argmax()\n    \n    # Find the shape (connected component)\n    shape_objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=background)\n    shape_object = max(shape_objects, key=lambda obj: np.sum(obj != background))\n    \n    # Create output grid and fill with the original input\n    output_grid = np.copy(input_grid)\n    \n    # Get the border of the shape\n    border_mask = object_neighbors(shape_object, background=background, connectivity=4)\n    \n    # Color the border with blue (Color.BLUE)\n    output_grid[border_mask] = Color.BLUE\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a black grid as the background.\n    # 2. Generate a random shape with a single color.\n    # 3. Ensure the shape doesn\u0027t fill the entire grid.\n\n    width, height = np.random.randint(7, 20, size=2)\n    input_grid = np.full((width, height), fill_value=Color.BLACK)\n\n    # Generate a random shape\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_sprite = random_sprite(np.random.randint(3, 8), np.random.randint(3, 8), color_palette=[shape_color], density=0.7)\n    \n    # Randomly place the shape on the grid\n    x, y = random_free_location_for_sprite(input_grid, shape_sprite, background=Color.BLACK)\n    blit_sprite(input_grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_output_2.png"}]}, "index": 18, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, symmetry detection, color filling\n\n# description:\n# In the input, you will see a 4x4 grid with a specific pattern of colored pixels.\n# To create the output, rotate the pattern 90 degrees clockwise and check if it remains the same.\n# If it is symmetrical, fill the output grid with a uniform color; otherwise, leave it blank.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Rotate the input grid 90 degrees clockwise\n    rotated_grid = np.rot90(input_grid, k=-1)\n\n    # Check if the rotated grid is the same as the original input grid\n    is_symmetric = np.array_equal(rotated_grid, input_grid)\n\n    # Create the output grid\n    if is_symmetric:\n        output_grid = np.full(input_grid.shape, Color.BLUE)  # Fill with blue if symmetrical\n    else:\n        output_grid = np.full(input_grid.shape, Color.BLACK)  # Leave blank if not symmetric\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 4x4 grid with a random pattern\n    n, m = 4, 4\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the patterns\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the grid with a random pattern and ensure symmetry\n    if np.random.rand() \u003e 0.5:\n        # Create a symmetric pattern\n        grid[0, 0] = grid[0, 3] = grid[3, 0] = grid[3, 3] = color  # Corners\n        grid[0, 1] = grid[0, 2] = grid[3, 1] = grid[3, 2] = Color.BLACK  # Top row middle\n        grid[1, 0] = grid[2, 0] = grid[1, 3] = grid[2, 3] = Color.BLACK  # Side middle\n        grid[1, 1] = grid[1, 2] = grid[2, 1] = grid[2, 2] = color  # Center square\n    else:\n        # Create a non-symmetric pattern\n        grid[0, 0] = grid[0, 1] = color\n        grid[1, 1] = color\n        grid[3, 3] = color\n        grid[2, 2] = Color.BLACK  # Ensure it is not symmetric\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_output_2.png"}]}, "index": 19, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# chain reaction, color propagation\n\n# description:\n# In the input, you will see several distinct colored shapes on a black background. Each shape has a unique color. The output should show the same shapes, but each shape will transform into a new color based on the colors of the adjacent shapes. If a shape has an adjacent shape of color X, it will change to color Y, where Y is determined by a predefined mapping of colors. The transformation occurs in a chain reaction fashion, where adjacent shapes can influence the color of one another.\n\ndef main(input_grid):\n    # Define color transformation rules\n    color_mapping = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.RED,\n        Color.GREY: Color.PINK,\n        Color.PINK: Color.MAROON,\n        Color.MAROON: Color.TEAL,\n        Color.TEAL: Color.ORANGE,\n        Color.ORANGE: Color.RED,\n        Color.BLACK: Color.BLACK,  # Black remains unchanged\n    }\n\n    # Find all connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Loop through each shape and apply the color transformation\n    for shape in shapes:\n        # Get the shape\u0027s color\n        current_color = shape[0][0]  # Assuming the shape is monochromatic\n        \n        # Determine the new color based on adjacent colors\n        new_color = color_mapping[current_color]\n\n        # Fill the output grid with the new color at the shape\u0027s location\n        for y, x in np.argwhere(shape != Color.BLACK):\n            output_grid[y, x] = new_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid size\n    grid_width = np.random.randint(10, 20)\n    grid_height = np.random.randint(10, 20)\n    \n    # Create a black grid\n    grid = np.full((grid_height, grid_width), Color.BLACK, dtype=int)\n\n    # Randomly generate a number of colored shapes\n    num_shapes = np.random.randint(5, 15)\n\n    colors = list(Color.ALL_COLORS)\n    colors.remove(Color.BLACK)  # Exclude black from color options\n\n    for _ in range(num_shapes):\n        # Generate a random shape sprite of size (1-5)x(1-5)\n        sprite_width = np.random.randint(1, 6)\n        sprite_height = np.random.randint(1, 6)\n        sprite_color = np.random.choice(colors)\n        sprite = random_sprite(sprite_width, sprite_height, color_palette=[sprite_color])\n\n        # Find a random free location for the sprite within the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_output_2.png"}]}, "index": 20, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pixel replacement\n\n# description:\n# In the input, you will see a grid with a pattern that is symmetric along the vertical axis \n# but has a single pixel that breaks the symmetry. To make the output, \n# replace that pixel with the color of the pixel directly opposite it to restore symmetry.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the height and width of the input grid\n    height, width = input_grid.shape\n    \n    # We will check each row to find the pixel that breaks symmetry\n    for y in range(height):\n        left_color = input_grid[y, :width // 2]\n        right_color = input_grid[y, width // 2 + (width % 2):][::-1]\n        \n        # If the left side is not equal to the reflected right side\n        if not np.array_equal(left_color, right_color):\n            # Find the index of the breaking pixel\n            breaking_pixel_index = (width - 1) // 2\n            \n            # Replace the breaking pixel with the color of the corresponding symmetric pixel\n            input_grid[y, breaking_pixel_index] = input_grid[y, width - 1 - breaking_pixel_index]\n    \n    return input_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n = np.random.randint(3, 7)\n    m = np.random.randint(3, 7)\n    \n    # Create a random grid\n    grid = random_sprite(n, m, density=0.5, color_palette=Color.NOT_BLACK)\n    \n    # Ensure the grid is symmetric along the vertical axis with one pixel breaking the symmetry\n    for y in range(n):\n        if y == n // 2:  # On the middle row, make an asymmetric pixel\n            grid[y, m // 2] = Color.BLACK  # Introducing a breaking pixel\n            grid[y, m // 2 + 1] = grid[y, m // 2 - 1]  # Mirroring the color to maintain symmetry\n        else:\n            grid[y, m // 2:] = grid[y, :m // 2][::-1]  # Mirror left side to right side\n            \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_output_2.png"}]}, "index": 21, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary expansion, object detection, color manipulation\n\n# description:\n# In the input, you will see multiple colorful objects on a teal background. \n# To create the output, expand the boundaries of each object by one pixel, \n# creating a halo effect around each object while maintaining their original colors.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all connected components (objects) in the input grid.\n    # 2. For each detected object, expand its boundary by one pixel in all directions.\n    # 3. Overlay the expanded objects on a new output grid while preserving their colors.\n\n    # Step 1: Find all the connected components (objects)\n    objects = find_connected_components(input_grid, background=Color.TEAL, monochromatic=False)\n\n    # Create an output grid initialized to the background color (teal)\n    output_grid = np.full(input_grid.shape, Color.TEAL)\n\n    for obj in objects:\n        # Step 2: Retrieve the positions of the object and expand its boundary\n        positions = np.argwhere(obj != Color.TEAL)\n        \n        # Expand the boundary by one pixel in all directions\n        for x, y in positions:\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    # Ensure we are within the bounds of the grid\n                    if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                        output_grid[x + dx, y + dy] = obj[x, y]\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate an example input grid with random colorful objects on a teal background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.TEAL)\n\n    num_objects = np.random.randint(3, 6)  # Random number of objects\n    for _ in range(num_objects):\n        # Create a random sprite (object)\n        sprite_width, sprite_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        sprite = random_sprite(sprite_width, sprite_height, color_palette=Color.NOT_BLACK, density=0.5)\n\n        # Find a random free location for the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.TEAL, padding=1)\n        \n        # Blit the sprite onto the grid\n        blit_sprite(grid, sprite, x, y, background=Color.TEAL)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_output_2.png"}]}, "index": 22, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pixel manipulation\n\n# description:\n# In the input, you will see a grid filled with colored pixels. To make the output, invert the colors in the grid. \n# The color inversion means that each color in the grid will be replaced by a corresponding color from a predefined mapping.\n# For example, if the mapping is:\n# Color.RED -\u003e Color.GREEN\n# Color.GREEN -\u003e Color.RED\n# Color.BLUE -\u003e Color.YELLOW\n# Color.YELLOW -\u003e Color.BLUE\n# Color.GREY -\u003e Color.PINK\n# Color.PINK -\u003e Color.GREY\n# Color.ORANGE -\u003e Color.MAROON\n# Color.MAROON -\u003e Color.ORANGE\n# Color.TEAL -\u003e Color.BLACK\n# Color.BLACK -\u003e Color.GRAY\n# The output will be the grid with all colors replaced according to this mapping.\n\ndef main(input_grid):\n    # Define the color mapping for inversion\n    color_mapping = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.RED,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE,\n        Color.GREY: Color.PINK,\n        Color.PINK: Color.GREY,\n        Color.ORANGE: Color.MAROON,\n        Color.MAROON: Color.ORANGE,\n        Color.TEAL: Color.BLACK,\n        Color.BLACK: Color.GRAY,\n        Color.GRAY: Color.BLACK  # Assuming we add a WHITE color in the mapping too\n    }\n\n    # Create a new output grid by inverting the colors\n    output_grid = np.copy(input_grid)\n    for original_color, inverted_color in color_mapping.items():\n        output_grid[input_grid == original_color] = inverted_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid of colors\n    n, m = 5, 5  # Define size of the grid\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))  # Fill grid with random colors (not black)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_output_2.png"}]}, "index": 23, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, grid transformation\n\n# description:\n# In the input, you will see a grid filled with random colored objects on a black background. \n# Each object consists of connected pixels of the same color. \n# To make the output, extract all objects, sort them by area in descending order, and arrange them in a new grid \n# (starting from the top-left), filling any remaining space with black pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find all connected components (objects) in the input grid.\n    # 2. Sort the extracted objects by area in descending order.\n    # 3. Create a new output grid and place the objects in order, starting from the top-left.\n    # 4. Fill any remaining space with black pixels.\n\n    # 1. Find all connected components (objects)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # 2. Sort the extracted objects by area in descending order\n    objects_sorted = sorted(objects, key=lambda obj: obj.size, reverse=True)\n\n    # 3. Create a new output grid\n    output_grid_height = sum(obj.shape[0] for obj in objects_sorted) + len(objects_sorted) - 1  # extra row for each object\n    output_grid = np.full((output_grid_height, input_grid.shape[1]), Color.BLACK)\n\n    # Current position to place the next object\n    current_y = 0\n\n    for obj in objects_sorted:\n        # Blit the object onto the output grid, centered horizontally\n        obj_height, obj_width = obj.shape\n        center_x = (output_grid.shape[1] - obj_width) // 2\n        blit_sprite(output_grid, obj, x=center_x, y=current_y, background=Color.BLACK)\n        current_y += obj_height + 1  # Move down for the next object, plus space for separation\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid with scattered objects\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create several objects\n    n_objects = np.random.randint(5, 10)\n    for _ in range(n_objects):\n        # Create a random object size\n        object_height, object_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        obj = np.random.choice(Color.NOT_BLACK, size=(object_height, object_width))\n        \n        # Find a free location for the object in the grid\n        x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK, padding=1)\n\n        # Blit the object into the grid\n        blit_sprite(grid, obj, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_output_2.png"}]}, "index": 24, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, filling\n\n# description:\n# In the input, you will see a shape that has been partially filled with a color, exhibiting rotational symmetry.\n# To make the output, fill in the missing parts of the shape with the same color to restore its rotational symmetry.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the rotational symmetry of the input grid.\n    # 2. Identify the filled color and the empty (background) locations.\n    # 3. Use the symmetry to fill in the missing parts of the shape.\n\n    output_grid = input_grid.copy()\n\n    # Detect rotational symmetry, ignoring black (background) pixels\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Fill in missing parts based on the symmetry\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        color = input_grid[x, y]\n        \n        # Loop over the four rotations (90 degrees each time)\n        for i in range(1, 4):\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n            # If the pixel at the rotated position is black (missing), fill it with the color\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random sprite that has rotational symmetry.\n    # 2. Randomly occlude parts of it by changing some pixels to black.\n\n    # Create a random sprite with rotational symmetry\n    sprite = random_sprite(5, 5, density=0.5, symmetry=\u0027radial\u0027, color_palette=list(Color.NOT_BLACK))\n    \n    # Randomly remove pixels from the sprite to create the occlusion\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.rand() \u003c 0.3:  # 30% chance to remove each pixel\n                sprite[i, j] = Color.BLACK\n\n    # Create a larger grid to place the sprite into\n    grid = np.zeros((10, 10), dtype=int)\n    \n    # Place the sprite randomly onto the grid\n    sprite_x, sprite_y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=sprite_x, y=sprite_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_output_2.png"}]}, "index": 25, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, grid transformation\n\n# description:\n# The input grid consists of pixels in the colors: blue, yellow, green, orange, grey, and black. \n# To create the output grid, change the colors according to the following mapping:\n# blue -\u003e yellow, yellow -\u003e green, green -\u003e orange, orange -\u003e grey, grey -\u003e blue.\n# Any pixels that are black should remain black.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Perform the color mapping\n    color_map = {\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.GREEN,\n        Color.GREEN: Color.ORANGE,\n        Color.ORANGE: Color.GREY,\n        Color.GREY: Color.BLUE,\n    }\n\n    # Apply color mapping to the output grid\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid size between 5x5 and 10x10\n    n = np.random.randint(5, 11)\n    grid = np.full((n, n), Color.BLACK)  # Start with a black background\n    \n    # Populate the grid with random colors from the mapping\n    colors = list(Color.NOT_BLACK)  # Exclude black from the options\n    num_pixels = n * n // 2  # Fill half the grid with colors\n\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, n)\n        grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_output_2.png"}]}, "index": 26, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color layer stacking, opacity\n\n# description:\n# In the input, you will see several layers of colored patterns, each with varying degrees of opacity.\n# To create the output, stack the layers by their colors from darkest to lightest, producing a composite image that reflects the colors\u0027 hierarchy.\n\ndef main(input_grid):\n    # Initialize the output grid with the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Detect connected components that are not black\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    \n    # Sort components by their average brightness (darkest to lightest)\n    components_sorted = sorted(components, key=lambda obj: np.mean(obj[obj != Color.BLACK]))\n\n    # Overlay the sorted components onto the output grid\n    for component in components_sorted:\n        # Calculate the bounding box for the component\n        x, y, width, height = bounding_box(component)\n        \n        # Blit the component onto the output grid, taking opacity into account\n        for i in range(height):\n            for j in range(width):\n                if component[i, j] != Color.BLACK:\n                    # Only draw if the output grid pixel is black (i.e., not already drawn over)\n                    if output_grid[x + i, y + j] == Color.BLACK:\n                        output_grid[x + i, y + j] = component[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Define grid size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Number of layers to create\n    num_layers = np.random.randint(3, 6)\n\n    # Create layers of colors\n    for _ in range(num_layers):\n        # Generate a random sprite for the layer\n        layer_sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=1, color_palette=Color.NOT_BLACK)\n        \n        # Randomly determine the position of the layer\n        x, y = random_free_location_for_sprite(grid, layer_sprite, padding=1)\n        \n        # Blit the layer onto the grid\n        blit_sprite(grid, layer_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_output_2.png"}]}, "index": 27, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid slicing, spiral rearrangement\n\n# description:\n# In the input, you will see a grid made up of a repeating pattern. To create the output, slice the grid into smaller sections based on the repeating pattern size and rearrange the sections in a spiral layout, keeping the colors intact.\n\ndef main(input_grid):\n    # Determine the size of the repeating pattern (assuming it\u0027s a square pattern)\n    pattern_height = input_grid.shape[0] // 3\n    pattern_width = input_grid.shape[1] // 3\n\n    # Create a list to hold the patterns\n    patterns = []\n\n    # Slice the grid into patterns\n    for i in range(3):\n        for j in range(3):\n            start_y = i * pattern_height\n            start_x = j * pattern_width\n            pattern = input_grid[start_y:start_y + pattern_height, start_x:start_x + pattern_width]\n            patterns.append(pattern)\n\n    # Create the output grid with appropriate size (larger than the input grid)\n    output_height = pattern_height * 3\n    output_width = pattern_width * 3\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Define the spiral order to fill the output grid\n    spiral_order = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 1), (2, 0), (1, 0), (1, 1)]\n\n    # Place the patterns in the output grid according to the spiral order\n    for idx, (row, col) in enumerate(spiral_order):\n        pattern = patterns[idx]\n        blit_sprite(output_grid, pattern, row * pattern_height, col * pattern_width, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Randomly choose the size of the input grid ensuring it\u0027s a multiple of 3\n    height = np.random.randint(3, 10) * 3\n    width = np.random.randint(3, 10) * 3\n    grid = np.zeros((height, width), dtype=int)\n\n    # Fill the grid with a repeating pattern of random colors\n    colors = np.random.choice(list(Color.NOT_BLACK), size=9, replace=False)\n    for i in range(3):\n        for j in range(3):\n            start_y = i * (height // 3)\n            start_x = j * (width // 3)\n            color = colors[i * 3 + j]\n            sprite = np.full((height // 3, width // 3), color)\n            grid[start_y:start_y + (height // 3), start_x:start_x + (width // 3)] = sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_output_2.png"}]}, "index": 28, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, growth, branching\n\n# description:\n# In the input, you will see a single colored pixel on a black grid. \n# To make the output, grow branches from that pixel in four cardinal directions (up, down, left, right), \n# making each branch 3 pixels long and coloring them the same as the original pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    colored_pixel_location = colored_pixel_locations[0]\n    pixel_x, pixel_y = colored_pixel_location\n\n    # Create a new output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the original pixel\n    color = output_grid[pixel_x, pixel_y]\n\n    # Draw branches in all four cardinal directions\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, up, right, left\n    for dx, dy in directions:\n        for length in range(1, 4):  # each branch is 3 pixels long\n            new_x = pixel_x + dx * length\n            new_y = pixel_y + dy * length\n            # Only draw if within bounds\n            if 0 \u003c= new_x \u003c input_grid.shape[0] and 0 \u003c= new_y \u003c input_grid.shape[1]:\n                output_grid[new_x, new_y] = color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a single colored pixel (not black) in a random position\n    color = np.random.choice(Color.NOT_BLACK)\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_output_2.png"}]}, "index": 29, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation, grid manipulation\n\n# description:\n# In the input, you will see a grid with a single colored pixel surrounded by black pixels. \n# To create the output, rotate the colored pixel 90 degrees clockwise to its new position and fill the path it took with a gradient from the original color to black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find the colored pixel\n    # 2. Calculate the new position after a 90-degree clockwise rotation\n    # 3. Draw a gradient path from the original position to the new position\n\n    # Find the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    original_x, original_y = colored_pixel_locations[0]\n\n    # Calculate the new position after a 90-degree clockwise rotation\n    new_x = original_y\n    new_y = input_grid.shape[0] - 1 - original_x\n\n    # Create output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Draw the gradient path from (original_x, original_y) to (new_x, new_y)\n    num_steps = max(abs(new_x - original_x), abs(new_y - original_y))\n    for step in range(num_steps + 1):\n        t = step / num_steps\n        # Interpolating the color from original color to black\n        interpolated_color = interpolate_color(input_grid[original_x, original_y], Color.BLACK, t)\n        # Get the current pixel along the path\n        current_x = int(original_x + t * (new_x - original_x))\n        current_y = int(original_y + t * (new_y - original_y))\n        output_grid[current_x, current_y] = interpolated_color\n\n    # Set the final position with the original color\n    output_grid[new_x, new_y] = input_grid[original_x, original_y]\n\n    return output_grid\n\n\ndef interpolate_color(color_start, color_end, t):\n    # Simple interpolation function to create a gradient from color_start to color_end\n    if color_start == color_end:\n        return color_start\n    return color_end if t == 1 else color_start  # Simplified for this example\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid size\n    width, height = np.random.randint(5, 20, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select a color from NOT_BLACK\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the colored pixel in a random position, ensuring it\u0027s not on the edge\n    x = np.random.randint(1, width - 1)\n    y = np.random.randint(1, height - 1)\n    input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_output_2.png"}]}, "index": 30, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, replication, grid transformation\n\n# description:\n# In the input you will see a grid with a 5x5 colored pattern located in the center, surrounded by a uniform black background.\n# To make the output, detect the 5x5 pattern and replicate it to all four corners of the grid, maintaining the same orientation and color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # 1. Detect the central 5x5 pattern\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    pattern = input_grid[center_x - 2:center_x + 3, center_y - 2:center_y + 3]\n\n    # 2. Create the output grid with the same dimensions as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # 3. Place the detected pattern in all four corners of the output grid\n    output_grid[0:5, 0:5] = pattern  # Top-left corner\n    output_grid[0:5, -5:] = pattern  # Top-right corner\n    output_grid[-5:, 0:5] = pattern  # Bottom-left corner\n    output_grid[-5:, -5:] = pattern  # Bottom-right corner\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a 5x5 pattern at the center of a larger grid\n    grid_size = 15  # Define the size of the grid\n    grid = np.zeros((grid_size, grid_size), dtype=int)  # Start with a black grid\n\n    # Define the center for the 5x5 pattern\n    center_x, center_y = grid_size // 2, grid_size // 2\n\n    # Randomly generate a 5x5 colored pattern\n    available_colors = list(Color.NOT_BLACK)\n    pattern_colors = np.random.choice(available_colors, size=(5, 5), replace=True)\n\n    # Place the 5x5 pattern in the center of the grid\n    grid[center_x - 2:center_x + 3, center_y - 2:center_y + 3] = pattern_colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_output_2.png"}]}, "index": 31, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mirroring, grid reflection\n\n# description:\n# In the input, you will see a grid that contains randomly colored pixels. \n# To create the output grid, you should mirror the colors of the pixels along the vertical axis of the grid. \n# This means that each pixel on the left side of the grid should be reflected to the corresponding position on the right side, \n# while keeping the colors on the left unchanged and filling the right side accordingly.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid initialized to the same size\n    output_grid = np.copy(input_grid)\n\n    # Iterate through each row and mirror the pixels across the vertical axis\n    for x in range(n):\n        for y in range(m // 2):\n            # The position to mirror to is (x, m - 1 - y)\n            output_grid[x, m - 1 - y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly assign colors to the pixels in the grid\n    available_colors = list(Color.NOT_BLACK)  # Exclude black\n    color_density = 0.5  # 50% of the grid can be colored\n\n    for i in range(n):\n        for j in range(m):\n            if np.random.random() \u003c color_density:  # Randomly decide whether to color the pixel\n                grid[i, j] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_output_2.png"}]}, "index": 32, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color quantization\n\n# description:\n# In the input, you will see several colored objects on a black background. \n# To create the output, detect all unique colors of the objects and quantize each color to the nearest primary color (red, blue, or yellow), \n# replacing the original colors in the output with their quantized versions.\n\ndef quantize_color(color):\n    \"\"\"Quantize the given color to the nearest primary color.\"\"\"\n    primary_colors = {\n        Color.RED: np.array([255, 0, 0]),\n        Color.BLUE: np.array([0, 0, 255]),\n        Color.YELLOW: np.array([255, 255, 0]),\n    }\n    \n    min_distance = float(\u0027inf\u0027)\n    nearest_color = Color.BLACK\n\n    for pc, rgb in primary_colors.items():\n        distance = np.linalg.norm(np.array(color) - rgb)\n        if distance \u003c min_distance:\n            min_distance = distance\n            nearest_color = pc\n            \n    return nearest_color\n\ndef main(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # get the objects in the input grid\n    objects = find_connected_components(input_grid)\n\n    # create a set to keep track of unique colors\n    unique_colors = set()\n\n    # collect unique colors from the objects\n    for obj in objects:\n        unique_colors.update(np.unique(obj[obj != Color.BLACK]))\n\n    # quantize each unique color and apply it to the output grid\n    color_mapping = {color: quantize_color(color) for color in unique_colors}\n\n    # replace original colors with quantized colors in the output grid\n    for original_color, quantized_color in color_mapping.items():\n        output_grid[output_grid == original_color] = quantized_color\n\n    return output_grid\n\ndef generate_input():\n    # make a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # make a random number of sprites\n    num_sprites = np.random.randint(3, 7)\n    for _ in range(num_sprites):\n        sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n        \n        # make sure the sprite has at least 1 colored pixel\n        while np.count_nonzero(sprite != Color.BLACK) \u003c 1:\n            sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_output_2.png"}]}, "index": 33, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connectivity, boundary detection, color filling\n\n# description:\n# In the input, you will see a grid containing connected colored regions surrounded by a black background. \n# To produce the output grid, you need to identify the boundaries of each colored region and fill in the outer layer of black pixels surrounding these boundaries with a distinct color, say grey.\n\ndef main(input_grid):\n    # Create an output grid initialized to the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (colored regions)\n    components = find_connected_components(input_grid, background=Color.BLACK)\n\n    # For each component, find its boundary and fill surrounding black pixels with a new color\n    for component in components:\n        # Get the boundary of the current component\n        boundary_mask = object_boundary(component, background=Color.BLACK)\n\n        # Fill the outer layer of black pixels surrounding the boundary with grey\n        for x, y in np.argwhere(boundary_mask):\n            # Check the 8 connectivity around (x, y)\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    if (dx != 0 or dy != 0):  # Skip the center pixel\n                        nx, ny = x + dx, y + dy\n                        if 0 \u003c= nx \u003c output_grid.shape[0] and 0 \u003c= ny \u003c output_grid.shape[1]:\n                            if output_grid[nx, ny] == Color.BLACK:\n                                output_grid[nx, ny] = Color.GREY\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size between 10x10 and 20x20\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the number of colored regions\n    num_regions = np.random.randint(1, 4)\n\n    for _ in range(num_regions):\n        # Generate a random sprite (colored region)\n        sprite_size = np.random.randint(3, 8)\n        sprite = random_sprite(sprite_size, sprite_size, color_palette=[np.random.choice(Color.NOT_BLACK)], connectivity=4)\n\n        # Find a free location for the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n            blit_sprite(grid, sprite, x, y)\n        except:\n            continue  # Skip if no free location is available\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_output_2.png"}]}, "index": 34, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connectivity, clusters, radial lines\n\n# description:\n# In the input, you will see clusters of colored pixels scattered around a black background. \n# To create the output, draw radial lines from the center of each cluster to the pixels within that cluster, coloring the lines the same as the pixels.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n    \n    # Find connected components in the grid\n    clusters = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n\n    # Go through each cluster and draw radial lines\n    for cluster in clusters:\n        # Get the color of the cluster (assuming all pixels are the same color in the cluster)\n        color = cluster[0, 0]  # Get the color of the first pixel in the cluster\n        cluster_coords = np.argwhere(cluster != Color.BLACK)\n\n        # Compute the centroid of the cluster\n        centroid_x = np.mean(cluster_coords[:, 0]).astype(int)\n        centroid_y = np.mean(cluster_coords[:, 1]).astype(int)\n\n        # Draw lines from centroid to each pixel in the cluster\n        for x, y in cluster_coords:\n            draw_line(output_grid, centroid_x, centroid_y, end_x=x, end_y=y, color=color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose some colors for the clusters\n    colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(2, 5), replace=False)\n\n    # Create several clusters of pixels\n    for color in colors:\n        # Randomly generate the center of the cluster\n        cluster_center_x = np.random.randint(1, n-1)\n        cluster_center_y = np.random.randint(1, m-1)\n\n        # Randomly generate cluster size and position\n        cluster_size = np.random.randint(3, 10)\n        for _ in range(cluster_size):\n            # Randomly offset from the center\n            offset_x = np.random.randint(-2, 3)\n            offset_y = np.random.randint(-2, 3)\n            \n            # Ensure we stay within the bounds of the grid\n            x, y = cluster_center_x + offset_x, cluster_center_y + offset_y\n            if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m:\n                grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_output_2.png"}]}, "index": 35, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel clustering, color blending\n\n# description:\n# In the input, you will see a grid filled with colored pixels. To make the output, \n# identify clusters of adjacent pixels of the same color and blend them into a single pixel \n# of a new color that is the average of the colors in that cluster. The new color should \n# be displayed in the center of the cluster in the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Find connected components in the grid\n    connected_components = find_connected_components(input_grid, monochromatic=True)\n    \n    # Step 2: Create an empty output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Step 3: For each connected component, calculate the average color and place it in the output grid\n    for component in connected_components:\n        # Calculate the average color of the cluster\n        avg_color = np.mean(component[component != Color.BLACK])  # Avoid background color\n        \n        # Find the center of the cluster for placing the average color\n        coords = np.argwhere(component != Color.BLACK)\n        center_x, center_y = np.mean(coords, axis=0).astype(int)\n\n        # Place the averaged color in the output grid at the calculated center coordinate\n        output_grid[center_x, center_y] = avg_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid with clusters of colors\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter colored pixels across the grid\n    num_colors = np.random.randint(2, 6)\n    colors = random.sample(list(Color.NOT_BLACK), num_colors)\n\n    # Create several clusters of these colors\n    for color in colors:\n        # Randomly decide the number of clusters for this color\n        num_clusters = np.random.randint(1, 4)\n        \n        for _ in range(num_clusters):\n            # Randomly select a starting point in the grid\n            start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n            # Randomly determine the size of the cluster\n            cluster_size = np.random.randint(2, 6)  # Size of the cluster\n\n            # Randomly create a cluster by drawing pixels of the same color\n            for _ in range(cluster_size):\n                # Randomly determine the position of the new pixel in the cluster\n                dx, dy = np.random.choice([-1, 0, 1]), np.random.choice([-1, 0, 1])\n                new_x, new_y = start_x + dx, start_y + dy\n                \n                # Check bounds and color placement\n                if 0 \u003c= new_x \u003c n and 0 \u003c= new_y \u003c m:\n                    grid[new_x, new_y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_output_2.png"}]}, "index": 36, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contour detection, shape filling\n\n# description:\n# In the input, you will see a filled shape (a single color) on a black background.\n# To make the output, detect the contour of the shape and fill it with a new color while leaving the area outside the contour black.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK, dtype=int)\n\n    # Find the contour of the filled shape\n    contours = object_neighbors(input_grid, background=Color.BLACK, connectivity=4)\n\n    # Get the color of the filled shape\n    shape_color = np.unique(input_grid[~contours])[0]\n\n    # Fill the contour in the output grid with a new color (e.g., Color.RED)\n    new_color = Color.RED\n    output_grid[contours] = new_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid\n    n = np.random.randint(12, 20)\n    m = np.random.randint(12, 20)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a filled shape (sprite) with a random size\n    w = np.random.randint(3, 8)\n    h = np.random.randint(3, 8)\n    sprite_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(w, h, color_palette=[sprite_color], density=1)\n\n    # Place the sprite on a random location on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_output_2.png"}]}, "index": 37, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, averaging, color blending\n\n# description:\n# In the input, you will see several overlapping colored layers in a grid. Each layer may have different transparency levels represented by the presence of black pixels. \n# To create the output, blend these layers together by averaging the colors in the overlapping regions, treating black pixels as transparent.\n\ndef main(input_grid):\n    # Create an output grid initialized with black color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Get connected components (layers) in the input grid\n    layers = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n\n    # For each layer, blend its colors into the output grid\n    for layer in layers:\n        # Get the bounding box of the current layer\n        x, y, width, height = bounding_box(layer)\n\n        # Iterate through every pixel in the layer\n        for i in range(height):\n            for j in range(width):\n                # Get the layer\u0027s color at the current pixel\n                layer_color = layer[i + x, j + y]\n\n                # Only blend if the current pixel is not black (transparent)\n                if layer_color != Color.BLACK:\n                    # Blend the color with the output grid using averaging\n                    if output_grid[i + x, j + y] == Color.BLACK:  # if the output pixel is black, simply use the layer color\n                        output_grid[i + x, j + y] = layer_color\n                    else:\n                        # Average the existing color with the new layer color\n                        existing_color = output_grid[i + x, j + y]\n                        new_color = average_colors(existing_color, layer_color)\n                        output_grid[i + x, j + y] = new_color\n\n    return output_grid\n\ndef average_colors(color1, color2):\n    # Average the RGB values of two colors (assuming colors are represented as RGB tuples)\n    # Here we interpret colors as integers where each color is a unique value\n    # This is a simplification; normally you\u0027d extract RGB values from colors\n    return Color(int((color1 + color2) / 2))\n\ndef generate_input():\n    # Initialize the grid, with size between 10 and 20\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Random number of layers (between 2 and 5)\n    num_layers = np.random.randint(2, 6)\n\n    # Generate random layers\n    for _ in range(num_layers):\n        # Random size for each layer\n        layer_height, layer_width = np.random.randint(3, 6), np.random.randint(3, 6)\n        layer_color = np.random.choice(list(Color.NOT_BLACK))  # Choose a random color (not black)\n\n        # Create a layer sprite\n        layer_sprite = random_sprite(layer_height, layer_width, density=0.5, color_palette=[layer_color])\n\n        # Find a random free location for the layer\n        x, y = random_free_location_for_sprite(grid, layer_sprite, background=Color.BLACK)\n\n        # Blit the layer onto the grid\n        blit_sprite(grid, layer_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_output_2.png"}]}, "index": 38, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# spiral drawing, color propagation\n\n# description:\n# In the input, you will see a grid filled with colored pixels. To make the output, draw a spiral starting from the center of the grid and expand outward, using the colors from the input grid in the order they appear. The spiral should continue until it fills the entire grid.\n\ndef main(input_grid):\n    # Create an output grid of the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n\n    # Calculate the center of the grid\n    center_x, center_y = n // 2, m // 2\n\n    # Initialize the direction for the spiral (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    current_direction = 0  # Start by moving right\n\n    # Start drawing the spiral\n    x, y = center_x, center_y\n    step_size = 1  # Initial step size\n    steps_taken = 0  # Steps taken in the current direction\n    colors = input_grid.flatten()\n    color_index = 0  # Index to track the current color\n\n    while color_index \u003c len(colors):\n        for _ in range(2):  # Increase step size every two directions\n            for _ in range(step_size):\n                if color_index \u003c len(colors):\n                    output_grid[x, y] = colors[color_index]\n                    color_index += 1\n\n                # Move in the current direction\n                dx, dy = directions[current_direction]\n                x += dx\n                y += dy\n\n            # Change direction\n            current_direction = (current_direction + 1) % 4\n\n        step_size += 1  # Increase the step size after completing two turns\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random colors\n    n = np.random.randint(5, 15)\n    m = np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors from the available palette\n    color_palette = list(Color.NOT_BLACK)\n    total_pixels = n * m\n    colors = np.random.choice(color_palette, total_pixels, replace=True)\n    grid = colors.reshape((n, m))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_output_2.png"}]}, "index": 39, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object expansion, color blending, pixel manipulation\n\n# description:\n# In the input, you will see a small object (sprite) surrounded by a black background. \n# Each pixel of the sprite has a color, and to produce the output, \n# expand the sprite outward in all directions by one pixel, \n# blending the colors of the expanded pixels with the background color \n# based on their distance from the original sprite. \n# The colors should blend such that pixels closer to the sprite take on more of the sprite\u0027s color, \n# while pixels further away take on more of the background color.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color (the most common color).\n    # 2. Find the sprite object within the input.\n    # 3. For each pixel in the sprite, calculate its blended color for the expansion.\n    # 4. Create an output grid that expands the sprite and applies the color blending.\n\n    # Determine the background color\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n\n    # Replace the background color with black for processing\n    input_grid[input_grid == background_color] = Color.BLACK\n\n    # Find connected components (the sprite)\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    assert len(objects) == 1  # There should be exactly one sprite\n    sprite = objects[0]\n\n    # Create output grid with expanded size\n    output_height, output_width = sprite.shape[0] + 2, sprite.shape[1] + 2\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Iterate over each pixel in the sprite\n    for x in range(sprite.shape[0]):\n        for y in range(sprite.shape[1]):\n            if sprite[x, y] != Color.BLACK:\n                # Set the original pixel color in the output grid\n                output_grid[x + 1, y + 1] = sprite[x, y]\n\n                # Blend colors for the four adjacent pixels\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    new_x, new_y = x + 1 + dx, y + 1 + dy\n                    # Calculate blending factor based on distance\n                    distance = max(abs(dx), abs(dy))  # distance from the original pixel\n                    blend_factor = 1 / (distance + 1)  # closer pixels take more of the sprite\u0027s color\n                    if output_grid[new_x, new_y] == Color.BLACK:  # Only blend if it\u0027s still the background\n                        blended_color = blend_colors(sprite[x, y], background_color, blend_factor)\n                        output_grid[new_x, new_y] = blended_color\n\n    # Replace black background back to the original background color\n    output_grid[output_grid == Color.BLACK] = background_color\n\n    return output_grid\n\ndef blend_colors(color1, color2, factor):\n    \"\"\"\n    Blends two colors together based on the given factor.\n    factor: 0 means color2, 1 means color1, 0 \u003c factor \u003c 1 means a blend.\n    \"\"\"\n    # Assuming colors are represented as RGB tuples (this function just simulates blending)\n    rgb1 = color_to_rgb(color1)\n    rgb2 = color_to_rgb(color2)\n    blended_rgb = tuple(int(rgb1[i] * factor + rgb2[i] * (1 - factor)) for i in range(3))\n    return rgb_to_color(blended_rgb)\n\ndef color_to_rgb(color):\n    \"\"\"\n    Convert a color to RGB representation (mock function).\n    You would replace this with actual color conversion logic.\n    \"\"\"\n    color_map = {\n        Color.BLACK: (0, 0, 0),\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.GREY: (128, 128, 128),\n        Color.PINK: (255, 192, 203),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0)\n    }\n    return color_map[color]\n\ndef rgb_to_color(rgb):\n    \"\"\"\n    Convert an RGB representation back to a color (mock function).\n    You would replace this with actual logic to get the closest color.\n    \"\"\"\n    # For simplicity, return a fixed color instead of an actual closest match\n    return Color.RED\n\ndef generate_input():\n    # Generate a random sprite with some colors\n    width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n    sprite = random_sprite(width, height, density=1, symmetry=\u0027not_symmetric\u0027, color_palette=Color.NOT_BLACK)\n\n    # Create a grid with a black background\n    grid_width, grid_height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((grid_width, grid_height), Color.BLACK)\n\n    # Place the sprite in the grid at a random position\n    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_output_2.png"}]}, "index": 40, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color blending, overlap, area calculation\n\n# description:\n# In the input, you will see two overlapping circular objects of different colors. Each object occupies a certain area on the grid.\n# To make the output, combine the colors of the two overlapping regions based on their area, creating a blended color in the overlapping section while keeping the rest of the objects intact.\n\ndef blend_colors(color1, color2):\n    \"\"\"\n    This function blends two colors by averaging their RGB values. \n    Here, we assume colors are represented as tuples of RGB values.\n    \"\"\"\n    # Convert color strings to RGB tuples (R, G, B)\n    color_map = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.ORANGE: (255, 165, 0),\n        Color.PINK: (255, 192, 203),\n        Color.GREY: (128, 128, 128),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.BLACK: (0, 0, 0)\n    }\n    \n    rgb1 = np.array(color_map[color1])\n    rgb2 = np.array(color_map[color2])\n    \n    blended_rgb = (rgb1 + rgb2) // 2  # Simple average for blending\n    blended_color = min(color_map.keys(), key=lambda k: np.linalg.norm(color_map[k] - blended_rgb))\n    \n    return blended_color\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    \n    # Find connected components to identify circular objects\n    objects = find_connected_components(input_grid, monochromatic=False)\n    \n    # Filter objects to keep only those with more than a small number of pixels\n    valid_objects = [obj for obj in objects if np.count_nonzero(obj != Color.BLACK) \u003e 5]\n    \n    if len(valid_objects) \u003c 2:\n        return output_grid  # Not enough objects to blend\n    \n    obj1, obj2 = valid_objects[0], valid_objects[1]\n\n    # Create a mask for the overlapping area\n    overlap_mask = (input_grid == obj1) \u0026 (input_grid == obj2)\n    \n    # Count areas\n    area_obj1 = np.count_nonzero(obj1 != Color.BLACK)\n    area_obj2 = np.count_nonzero(obj2 != Color.BLACK)\n    \n    # Calculate blended color based on area\n    color1 = np.unique(obj1[obj1 != Color.BLACK])[0]\n    color2 = np.unique(obj2[obj2 != Color.BLACK])[0]\n    blended_color = blend_colors(color1, color2)\n    \n    # Fill the overlapping area with the blended color\n    output_grid[overlap_mask] = blended_color\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create two random circular objects\n    for _ in range(2):\n        center_x = np.random.randint(2, n - 2)\n        center_y = np.random.randint(2, m - 2)\n        radius = np.random.randint(2, 5)\n        color = np.random.choice(list(Color.NOT_BLACK))\n\n        for x in range(n):\n            for y in range(m):\n                if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_output_2.png"}]}, "index": 41, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, grid transformation\n\n# description:\n# In the input, you will see a grid filled with various colored pixels. To create the output, \n# invert the colors of the pixels according to a predefined inversion map. \n# Each color will be transformed into another, where the mapping is defined as follows: \n# black -\u003e blue, blue -\u003e black, blue -\u003e yellow, yellow -\u003e blue, \n# red -\u003e green, green -\u003e red, grey -\u003e pink, pink -\u003e grey, teal -\u003e maroon, maroon -\u003e teal.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Perform color inversion\n    output_grid = np.vectorize(lambda color: color_inversion_map.get(color, color))(output_grid)\n\n    return output_grid\n    \n# Constructing the color inversion map\ncolor_inversion_map = {\n    Color.BLACK: Color.BLUE, \n    Color.BLUE: Color.BLACK, \n    Color.BLUE: Color.YELLOW, \n    Color.YELLOW: Color.BLUE, \n    Color.RED: Color.GREEN, \n    Color.GREEN: Color.RED, \n    Color.GREY: Color.PINK, \n    Color.PINK: Color.GREY, \n    Color.TEAL: Color.MAROON, \n    Color.MAROON: Color.TEAL\n}\n\ndef generate_input():\n    # Create a grid of random colors\n    grid_size = np.random.randint(5, 10)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Fill the grid with random colors from the color inversion map\u0027s keys\n    colors = list(color_inversion_map.keys())\n    for i in range(grid_size):\n        for j in range(grid_size):\n            grid[i, j] = random.choice(colors)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_output_2.png"}]}, "index": 42, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, area filling, color transformation\n\n# description:\n# In the input, you will see a grid with random colored pixels forming a closed shape. \n# To make the output, fill the entire area enclosed by the shape with a new color, \n# making sure to change the color of the shape outline to black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect the shape (connected component) in the grid\n    # 2. Determine the outline of the shape\n    # 3. Fill the area inside the shape with a new color\n    # 4. Change the outline to black\n\n    # Create a blank output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Step 1: Find the shape (assuming the shape is the largest connected component)\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    shape_component = max(components, key=lambda obj: np.count_nonzero(obj != Color.BLACK))\n\n    # Step 2: Get the outline of the shape\n    outline = np.zeros_like(input_grid)\n    for x, y in np.argwhere(shape_component != Color.BLACK):\n        # Check if any of the adjacent pixels are background (not part of the shape)\n        if np.any(input_grid[x-1:x+2, y-1:y+2] == Color.BLACK):\n            outline[x, y] = 1  # Mark outline position\n\n    # Step 3: Fill the area inside the shape with a new color (e.g., Color.YELLOW)\n    fill_color = Color.YELLOW\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if outline[x, y] == 0 and shape_component[x, y] != Color.BLACK:\n                output_grid[x, y] = fill_color\n\n    # Step 4: Change the outline to black\n    output_grid[outline == 1] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a grid with a black background\n    # 2. Randomly generate a closed shape using the draw_line function\n    # 3. Optionally sprinkle some random colors around the shape\n    \n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomize the shape\u0027s outline color\n    shape_color = random.choice(Color.NOT_BLACK)\n\n    # Create a random closed shape using lines\n    start_x, start_y = random.randint(1, n-2), random.randint(1, m-2)\n    draw_line(grid, start_x, start_y, length=random.randint(2, 5), direction=(1, 0), color=shape_color)  # Horizontal line\n    draw_line(grid, start_x + 1, start_y, length=random.randint(2, 5), direction=(0, 1), color=shape_color)  # Vertical line\n\n    # Randomly scatter some additional colors inside the grid, ensuring they don\u0027t overwrite the shape\n    density = random.uniform(0.1, 0.3)\n    grid = random_scatter_points(grid=grid, color=random.choice(Color.NOT_BLACK), density=density)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_output_2.png"}]}, "index": 43, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# overlapping patterns, extraction\n\n# description:\n# In the input, you will see a grid with two overlapping patterns in different colors. \n# The output should extract the regions where the two patterns overlap and color them a new color (e.g., blue), \n# while leaving the non-overlapping sections of the original colors intact.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the unique colors in the input grid\n    unique_colors = np.unique(input_grid)\n    overlapping_color = Color.BLUE  # New color for overlaps\n\n    # Create a mask for the overlapping regions\n    overlap_mask = np.zeros_like(input_grid, dtype=bool)\n\n    # Loop through each pixel to find overlapping colors\n    for color in unique_colors:\n        if color != Color.BLACK and color != overlapping_color:\n            # Check if pixel has the current color\n            color_mask = (input_grid == color)\n            # Update overlap mask if the color exists in the grid\n            overlap_mask = overlap_mask | color_mask\n\n    # Set overlapping regions to the new color\n    output_grid[overlap_mask] = overlapping_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize the grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define colors for patterns\n    color_a = np.random.choice(list(Color.NOT_BLACK))\n    color_b = np.random.choice([c for c in Color.NOT_BLACK if c != color_a])\n\n    # Randomly place the first pattern\n    for _ in range(np.random.randint(5, 20)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color_a\n    \n    # Randomly place the second pattern\n    for _ in range(np.random.randint(5, 20)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color_b\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_output_2.png"}]}, "index": 44, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layered patterns, extraction\n\n# description:\n# In the input, you will see several layers of patterns with some colors overlapping. \n# The output should extract the topmost pattern, which is defined as the first non-background color encountered in a vertical slice from top to bottom, \n# and display it separately, removing all other layers beneath it.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Create an empty grid to store the extracted topmost pattern\n    topmost_pattern = np.full(output_grid.shape, Color.BLACK)\n\n    # Iterate through each column of the grid\n    for col in range(output_grid.shape[1]):\n        for row in range(output_grid.shape[0]):\n            # If we find a non-background color, we mark that position in the topmost pattern\n            if output_grid[row, col] != Color.BLACK:\n                topmost_pattern[row, col] = output_grid[row, col]\n                break  # Move to the next column after finding the topmost color\n\n    return topmost_pattern\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly determine the size of the grid\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n\n    # Create a base grid filled with the background color\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly define the number of layers\n    num_layers = np.random.randint(3, 6)\n\n    # For each layer, draw a random sprite and overlay it on the grid\n    for _ in range(num_layers):\n        layer_color = np.random.choice(Color.NOT_BLACK)  # Choose a random color for the layer\n        layer_sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), density=0.5, color_palette=[layer_color])\n        \n        # Randomly position the layer sprite in the grid\n        x_offset = np.random.randint(0, n - layer_sprite.shape[0])\n        y_offset = np.random.randint(0, m - layer_sprite.shape[1])\n        grid = blit_sprite(grid=grid, sprite=layer_sprite, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_output_2.png"}]}, "index": 45, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, color averaging\n\n# description:\n# In the input, you will see a grid with multiple layers of colored pixels that partially overlap. \n# To create the output grid, blend the colors where they overlap by averaging the RGB values of the overlapping pixels while maintaining their original colors elsewhere.\n\ndef main(input_grid):\n    # Create an output grid initialized to black (background)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Get the unique colors in the input grid that are not black\n    unique_colors = set(input_grid.flatten()) - {Color.BLACK}\n\n    # For each unique color, we need to add it to the output grid\n    for color in unique_colors:\n        # Create a mask where the current color exists\n        color_mask = (input_grid == color)\n\n        # Get the RGB values for the current color\n        r, g, b = get_rgb(color)\n\n        # Blend with the output grid where there is already a color\n        for x in range(input_grid.shape[0]):\n            for y in range(input_grid.shape[1]):\n                if color_mask[x, y]:  # If the current cell has the current color\n                    if output_grid[x, y] != Color.BLACK:  # If there\u0027s already a color, blend\n                        existing_color = output_grid[x, y]\n                        existing_r, existing_g, existing_b = get_rgb(existing_color)\n                        # Average the RGB values\n                        r = (r + existing_r) // 2\n                        g = (g + existing_g) // 2\n                        b = (b + existing_b) // 2\n                    # Set the blended color in the output grid\n                    output_grid[x, y] = create_color(r, g, b)\n\n    return output_grid\n\ndef get_rgb(color):\n    # Helper function to return RGB values based on color\n    if color == Color.RED:\n        return 255, 0, 0\n    elif color == Color.GREEN:\n        return 0, 255, 0\n    elif color == Color.BLUE:\n        return 0, 0, 255\n    elif color == Color.YELLOW:\n        return 255, 255, 0\n    elif color == Color.GREY:\n        return 128, 128, 128\n    elif color == Color.PINK:\n        return 255, 192, 203\n    elif color == Color.ORANGE:\n        return 255, 165, 0\n    elif color == Color.TEAL:\n        return 0, 128, 128\n    elif color == Color.MAROON:\n        return 128, 0, 0\n    elif color == Color.BLACK:\n        return 0, 0, 0\n\ndef create_color(r, g, b):\n    # Helper function to create a color from RGB values\n    # This is a simplification since we are using a limited color palette\n    if r \u003e 200 and g \u003c 50 and b \u003c 50:\n        return Color.RED\n    elif r \u003c 50 and g \u003e 200 and b \u003c 50:\n        return Color.GREEN\n    elif r \u003c 50 and g \u003c 50 and b \u003e 200:\n        return Color.BLUE\n    elif r \u003e 200 and g \u003e 200 and b \u003c 50:\n        return Color.YELLOW\n    elif r \u003e 100 and g \u003e 100 and b \u003e 100:\n        return Color.GREY\n    elif r \u003e 200 and g \u003c 100 and b \u003c 100:\n        return Color.PINK\n    elif r \u003e 200 and g \u003c 100 and b \u003c 50:\n        return Color.ORANGE\n    elif r \u003c 50 and g \u003e 100 and b \u003e 100:\n        return Color.TEAL\n    elif r \u003e 100 and g \u003c 50 and b \u003c 50:\n        return Color.MAROON\n    return Color.BLACK\n\ndef generate_input():\n    # Create a grid with random layers of colored pixels\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Decide on the number of layers (randomly between 3 to 5)\n    num_layers = np.random.randint(3, 6)\n\n    for _ in range(num_layers):\n        # Create a random sprite of colored pixels\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), density=0.5, color_palette=Color.NOT_BLACK)\n        # Find a random location to blit this sprite onto the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_output_2.png"}]}, "index": 46, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pixel filling\n\n# description:\n# In the input, you will see a grid with a pattern that is almost vertically symmetric, \n# with a single missing pixel disrupting the symmetry. \n# To create the output, identify the position of the missing pixel and fill it in \n# to restore vertical symmetry.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the grid\n    n, m = input_grid.shape\n\n    # Prepare the output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # Iterate through the grid to find the missing pixel\n    for i in range(n):\n        for j in range(m):\n            # Check if the pixel is not black (potentially a part of the pattern)\n            if output_grid[i, j] != Color.BLACK:\n                # Check the corresponding pixel on the other side for symmetry\n                if j \u003c m // 2:\n                    mirror_j = m - 1 - j\n                    if output_grid[i, mirror_j] == Color.BLACK:\n                        # Fill in the missing pixel to restore symmetry\n                        output_grid[i, mirror_j] = output_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n = np.random.randint(5, 8)\n    m = np.random.randint(5, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the initial pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly fill half of the grid to create the pattern\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.5:  # 50% chance to set a color\n                grid[i, j] = color\n\n    # Introduce a missing pixel by setting one corresponding pixel to black\n    for i in range(n):\n        for j in range(m // 2):\n            if grid[i, j] != Color.BLACK and grid[i, m - 1 - j] != Color.BLACK:\n                grid[i, m - 1 - j] = Color.BLACK  # Make one pixel black to break symmetry\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_output_2.png"}]}, "index": 47, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, concentric circles\n\n# description:\n# In the input, you will see a single colored pixel in the middle of a black background.\n# To create the output, draw concentric circles around the colored pixel, using the same color as the pixel, with increasing radii.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color (black)\n    output_grid = np.copy(input_grid)\n    \n    # Get the location of the colored pixel\n    colored_pixel_coords = np.argwhere(input_grid != Color.BLACK)\n    if len(colored_pixel_coords) != 1:\n        raise ValueError(\"The input grid must contain exactly one colored pixel.\")\n\n    x, y = colored_pixel_coords[0]\n    \n    # Get the color of the pixel\n    color = input_grid[x, y]\n\n    # Draw concentric circles around the colored pixel\n    for radius in range(1, min(input_grid.shape) // 2):  # Limit the radius to half the grid size\n        for angle in range(0, 360, 10):  # Draw every 10 degrees\n            rad = np.radians(angle)\n            circle_x = x + int(radius * np.cos(rad))\n            circle_y = y + int(radius * np.sin(rad))\n            if 0 \u003c= circle_x \u003c input_grid.shape[0] and 0 \u003c= circle_y \u003c input_grid.shape[1]:\n                output_grid[circle_x, circle_y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(7, 20), np.random.randint(7, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random color for the pixel\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Place the colored pixel in the center of the grid\n    grid[n // 2, m // 2] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_output_2.png"}]}, "index": 48, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, color replacement, cropping\n\n# description:\n# In the input, you will see a pattern of colored pixels surrounded by a thick black border. \n# To make the output, remove the black border and replace it with a blue border of the same thickness.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to work on\n    output_grid = np.copy(input_grid)\n\n    # Find the bounding box of the non-black area\n    x, y, width, height = bounding_box(output_grid, background=Color.BLACK)\n\n    # Crop the grid to remove the black border\n    cropped_grid = output_grid[x:x + width, y:y + height]\n\n    # Create a new grid for the output with the same dimensions as the cropped grid plus the border\n    bordered_grid = np.zeros((width + 2, height + 2), dtype=int)\n\n    # Fill the outer border with blue\n    bordered_grid[:, :] = Color.BLUE\n\n    # Place the cropped grid in the center of the new grid\n    bordered_grid[1:-1, 1:-1] = cropped_grid\n\n    return bordered_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly select the size of the grid\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n\n    # Create a grid full of black\n    grid = np.zeros((width, height), dtype=int)\n\n    # Define the size of the border\n    border_size = 2\n\n    # Generate a random colored pattern to fill the interior, ensuring there is space for the border\n    pattern_width, pattern_height = width - 2 * border_size, height - 2 * border_size\n    pattern = random_sprite(pattern_width, pattern_height, density=0.5)\n\n    # Place the colored pattern in the center of the grid\n    grid[border_size:border_size + pattern_width, border_size:border_size + pattern_height] = pattern\n\n    # Add a black border around the colored pattern\n    grid[0, :] = grid[-1, :] = Color.BLACK\n    grid[:, 0] = grid[:, -1] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_output_2.png"}]}, "index": 49, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color filling\n\n# description:\n# In the input, you will see a shape that is missing sections along its horizontal axis. \n# To make the output, identify the missing sections that would make the shape horizontally symmetrical \n# and fill those sections with the same color as the adjacent pixels.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the center of symmetry on the horizontal axis.\n    # 2. For each colored pixel, fill in the corresponding pixels on the opposite side of the center.\n    \n    output_grid = input_grid.copy()\n    \n    # Get the bounding box of the non-black area\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n    \n    # Calculate the center of symmetry (horizontal axis)\n    center_y = (y + height) / 2\n    \n    # Find all colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n    \n    # Fill in missing pixels to achieve horizontal symmetry\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        \n        # Calculate the symmetric y-coordinate\n        symmetric_y = int(center_y * 2 - y)\n        \n        # Fill in the pixel if it lies within the bounds and is black\n        if 0 \u003c= symmetric_y \u003c output_grid.shape[1]:\n            if output_grid[x, symmetric_y] == Color.BLACK:\n                output_grid[x, symmetric_y] = color\n\n    return output_grid\n\n\ndef generate_input():\n    # Initialize a 10x10 grid\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Create a random sprite with vertical symmetry\n    sprite = random_sprite(5, 5, density=0.5, symmetry=\u0027vertical\u0027, color_palette=list(Color.NOT_BLACK))\n\n    # Randomly remove pixels from sprite to create asymmetry\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.random() \u003c 0.4:  # 40% chance to remove a pixel\n                sprite[i, j] = Color.BLACK\n\n    # Place sprite randomly onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/50/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/50/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/50/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/50/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/50/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/50/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/50/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/50/images/train_output_2.png"}]}, "index": 50, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation\n\n# description:\n# In the input, you will see a pattern of colored pixels arranged in a square grid. \n# To make the output, rotate the pattern 90 degrees clockwise and change each color to a specific one (e.g., red to blue, green to yellow, etc.) \n# The mapping is predetermined and should be applied to every pixel after rotation.\n\ndef main(input_grid):\n    # Rotate the input grid 90 degrees clockwise\n    rotated_grid = np.rot90(input_grid, -1)\n\n    # Define the color transformation mapping\n    color_mapping = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN,\n        Color.PINK: Color.TEAL,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.PINK,\n        Color.GREY: Color.ORANGE,\n        Color.ORANGE: Color.GREY,\n        Color.BLACK: Color.BLACK  # Keep black unchanged\n    }\n\n    # Apply the color transformation to the rotated grid\n    for i in range(rotated_grid.shape[0]):\n        for j in range(rotated_grid.shape[1]):\n            rotated_grid[i, j] = color_mapping[rotated_grid[i, j]]\n\n    return rotated_grid\n\ndef generate_input():\n    # Generate a random square grid with a size between 3 and 7\n    n = np.random.randint(3, 8)\n    grid = random_sprite(n, n, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/51/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/51/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/51/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/51/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/51/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/51/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/51/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/51/images/train_output_2.png"}]}, "index": 51, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, central filling, color mirroring\n\n# description:\n# In the input, you will see a grid with colored pixels along the edges and a central region that is blank. \n# To make the output, check for symmetry in the colored pixels along the edges and fill the central region with a pattern that mirrors the edge colors.\n\ndef main(input_grid):\n    # Extract the edge colors\n    top_edge = input_grid[0, :]\n    bottom_edge = input_grid[-1, :]\n    left_edge = input_grid[:, 0]\n    right_edge = input_grid[:, -1]\n    \n    # Create a central region with the mirrored edge colors\n    central_region = np.full((len(top_edge) - 2, len(top_edge) - 2), Color.BLACK)\n\n    # Fill the central region with the mirrored pattern of the edges\n    for i in range(len(central_region)):\n        for j in range(len(central_region)):\n            central_region[i, j] = top_edge[j + 1] if i == 0 else (\n                bottom_edge[j + 1] if i == len(central_region) - 1 else (\n                    left_edge[i + 1] if j == 0 else (\n                        right_edge[i + 1] if j == len(central_region) - 1 else Color.BLACK)))\n\n    # Create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[1:-1, 1:-1] = central_region\n\n    return output_grid\n\ndef generate_input():\n    # Make a grid with colored pixels along the edges\n    n = np.random.randint(5, 10)  # Height of the grid\n    m = np.random.randint(5, 10)  # Width of the grid\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define colors for the edges\n    edge_colors = np.random.choice(list(Color.NOT_BLACK), size=4, replace=False)\n\n    # Fill the top edge, bottom edge, left edge, and right edge with colors\n    grid[0, 1:m-1] = edge_colors[0]  # Top edge\n    grid[-1, 1:m-1] = edge_colors[1]  # Bottom edge\n    grid[1:n-1, 0] = edge_colors[2]  # Left edge\n    grid[1:n-1, -1] = edge_colors[3]  # Right edge\n\n    # Ensure the central region remains uncolored (black)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/52/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/52/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/52/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/52/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/52/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/52/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/52/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/52/images/train_output_2.png"}]}, "index": 52, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, pattern extraction, replication\n\n# description:\n# In the input, you will see a grid with a central pattern that may have some pixels in a symmetric arrangement around it. \n# The task is to extract the central pattern and replicate it in a symmetric manner across the grid.\n# The output will have the same dimensions as the input grid, but with the original central pattern mirrored across the vertical and horizontal axes.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Crop the central pattern from the input grid\n    central_pattern = crop(input_grid)\n\n    # Get the dimensions of the central pattern\n    central_height, central_width = central_pattern.shape\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Place the central pattern in the original position\n    blit_sprite(output_grid, central_pattern, x=(output_grid.shape[0] - central_height) // 2, y=(output_grid.shape[1] - central_width) // 2)\n\n    # Create mirrored patterns\n    # Horizontal mirror\n    output_grid[(output_grid.shape[0] - central_height) // 2 + central_height:, (output_grid.shape[1] - central_width) // 2:(output_grid.shape[1] - central_width) // 2 + central_width] = central_pattern\n\n    # Vertical mirror\n    output_grid[(output_grid.shape[0] - central_height) // 2: (output_grid.shape[0] - central_height) // 2 + central_height, \n                 (output_grid.shape[1] - central_width) // 2 + central_width:] = central_pattern\n\n    # Diagonal mirror\n    output_grid[(output_grid.shape[0] - central_height) // 2 + central_height:, (output_grid.shape[1] - central_width) // 2 + central_width:] = central_pattern\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the size of the grid and central pattern\n    n, m = np.random.randint(7, 12), np.random.randint(7, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the size for the central pattern\n    central_pattern_size = np.random.randint(3, min(n, m) // 2)\n\n    # Generate a random pattern\n    central_pattern = random_sprite(n=central_pattern_size, m=central_pattern_size, density=0.5, connectivity=8)\n\n    # Place the central pattern in the middle of the grid\n    start_x = (n - central_pattern_size) // 2\n    start_y = (m - central_pattern_size) // 2\n    blit_sprite(grid, central_pattern, start_x, start_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/53/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/53/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/53/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/53/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/53/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/53/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/53/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/53/images/train_output_2.png"}]}, "index": 53, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object layering, color blending\n\n# description:\n# In the input, you will see several colored circular objects scattered around on a black grid. \n# The circles may overlap, and each circle has a transparent background. \n# To make the output, blend the colors of the overlapping circles together, creating a new color at each pixel based on the number of overlapping colors.\n# If a pixel is covered by no circles, it should remain black; otherwise, it should show the blended result of the overlapping colors.\n\ndef blend_colors(colors):\n    # Simple color blending function - averages the RGB values of the colors\n    if not colors:\n        return Color.BLACK\n    \n    # Create a dictionary to map colors to RGB values\n    color_map = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.PINK: (255, 192, 203),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.GREY: (128, 128, 128),\n        Color.BLACK: (0, 0, 0)\n    }\n\n    total_r = total_g = total_b = count = 0\n    for color in colors:\n        if color in color_map:\n            r, g, b = color_map[color]\n            total_r += r\n            total_g += g\n            total_b += b\n            count += 1\n            \n    if count == 0:\n        return Color.BLACK\n    \n    # Average the RGB values\n    avg_r = total_r // count\n    avg_g = total_g // count\n    avg_b = total_b // count\n    \n    # Find the closest color match from the blended RGB\n    blended_color = min(color_map.keys(), key=lambda c: np.linalg.norm(np.array(color_map[c]) - np.array([avg_r, avg_g, avg_b])))\n    \n    return blended_color\n\n\ndef main(input_grid):\n    # Create an empty output grid with the same shape as input\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all circular objects in the input grid\n    objects = detect_objects(input_grid, background=Color.BLACK, monochromatic=False, connectivity=8)\n\n    # For each object, determine its color and its coverage on the output grid\n    for obj in objects:\n        # Get the color of the object (assuming it\u0027s the color of the non-black pixels)\n        color = obj[obj != Color.BLACK][0]  # Get the first color found in the object\n        \n        # Create a mask for the object\u0027s area\n        mask = np.zeros(input_grid.shape, dtype=bool)\n        mask[tuple(np.argwhere(obj != Color.BLACK).T)] = True\n\n        # Blend the colors on the output grid\n        output_grid[mask] = blend_colors([output_grid[mask][0], color])  # Blend existing colors with the new color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of colored circles\n    num_circles = np.random.randint(3, 8)\n\n    for _ in range(num_circles):\n        # Randomly choose a color for the circle\n        color = np.random.choice([c for c in Color.NOT_BLACK])\n\n        # Randomly determine the center and radius of the circle\n        center_x, center_y = np.random.randint(0, n), np.random.randint(0, m)\n        radius = np.random.randint(1, 4)\n\n        # Draw the circle on the grid\n        for dx in range(-radius, radius + 1):\n            for dy in range(-radius, radius + 1):\n                if dx**2 + dy**2 \u003c= radius**2:\n                    x, y = center_x + dx, center_y + dy\n                    if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m:\n                        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/54/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/54/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/54/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/54/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/54/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/54/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/54/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/54/images/train_output_2.png"}]}, "index": 54, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object alignment, color gradient\n\n# description:\n# In the input, you will see several colored objects scattered on a grid, each having a single color pixel at its bottom edge.\n# To make the output, align the bottom pixels of these objects in a straight horizontal line, while maintaining their original distances from each other.\n# The output grid should be the smallest possible size that contains all the objects after they have been aligned.\n\ndef main(input_grid):\n    # Step 1: Extract objects from the input grid.\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Step 2: Crop the objects to get their sprites.\n    sprites = [crop(obj, background=Color.BLACK) for obj in objects]\n\n    # Step 3: Create a new output grid to place the aligned objects.\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 4: Find the bottom edges of each object and determine the base alignment.\n    bottom_positions = []\n    for sprite in sprites:\n        bottom_edge_y = np.max(np.argwhere(sprite != Color.BLACK)[:, 0])  # Find the bottommost pixel\n        bottom_positions.append((bottom_edge_y, sprite))\n\n    # Step 5: Calculate the vertical offset to align all bottom edges.\n    highest_bottom = max(y for y, _ in bottom_positions)\n    alignment_offset = highest_bottom - min(y for y, _ in bottom_positions)\n\n    # Step 6: Place each sprite in the output grid.\n    for y, sprite in bottom_positions:\n        # Calculate the vertical offset\n        vertical_offset = alignment_offset + (y - highest_bottom)\n        blit_sprite(output_grid, sprite, x=0, y=vertical_offset, background=Color.BLACK)\n\n    # Step 7: Crop the output to the smallest bounding box that contains all sprites.\n    output_grid = crop(output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose the number of objects to be created\n    n_objects = np.random.randint(3, 6)\n    \n    for _ in range(n_objects):\n        # Randomly generate the size of the object (height)\n        height = np.random.randint(2, 6)\n        width = np.random.randint(2, 6)\n\n        # Create the object with a color\n        color = random.choice(Color.NOT_BLACK)\n        object_sprite = np.full((height, width), color)\n\n        # Find a random position to place the object in the grid\n        x, y = random_free_location_for_sprite(grid, object_sprite, background=Color.BLACK, border_size=1)\n\n        # Place the object in the grid\n        blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n\n    # Randomly scatter a few bottom pixels to ensure they are at the bottom of the objects\n    for x in range(1, m - 1):\n        if np.random.rand() \u003c 0.2:  # 20% chance to place a bottom pixel\n            grid[n - 1, x] = random.choice([c for c in Color.NOT_BLACK])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/55/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/55/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/55/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/55/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/55/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/55/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/55/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/55/images/train_output_2.png"}]}, "index": 55, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pixel shifting\n\n# description:\n# In the input, you will see a grid with multiple colored pixels. \n# To create the output, perform the following transformations:\n# 1. For each pixel, if its color is among the predefined list (red, green, blue, yellow),\n#    invert its color to the corresponding opposite color (red -\u003e teal, green -\u003e maroon, blue -\u003e yellow, yellow -\u003e blue).\n# 2. Shift the entire grid one pixel downwards. The top row of the output grid should be filled with black pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a color mapping for inversion\n    color_map = {\n        Color.RED: Color.TEAL,\n        Color.GREEN: Color.MAROON,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE\n    }\n\n    # Create the output grid, initially filled with black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Invert colors in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            original_color = input_grid[x][y]\n            if original_color in color_map:\n                inverted_color = color_map[original_color]\n                # Shift the inverted color one pixel down\n                if x + 1 \u003c input_grid.shape[0]:  # Avoid going out of bounds\n                    output_grid[x + 1, y] = inverted_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size (between 5x5 to 10x10)\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors, including some from the predefined list\n    num_colors = n * m // 2  # Fill about half of the grid with colors\n    for _ in range(num_colors):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.BLACK])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/56/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/56/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/56/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/56/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/56/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/56/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/56/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/56/images/train_output_2.png"}]}, "index": 56, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel tracing, outline detection, shape expansion\n\n# description:\n# In the input, you will see a colored shape outlined by a darker color on a black background. \n# To make the output grid, trace the outline of the shape with another color, creating a thicker boundary \n# around the original shape while keeping the interior color intact.\n\ndef main(input_grid):\n    # Create an output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components that are the darker outline\n    outlines = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # For each outline found, trace its outline and expand to create a thicker boundary\n    for outline in outlines:\n        # Get the coordinates of the outline\n        coords = np.argwhere(outline != Color.BLACK)\n        \n        # For each coordinate in the outline, draw an expanded outline\n        for x, y in coords:\n            # Create a thicker outline by marking surrounding pixels\n            for dx in range(-1, 2):\n                for dy in range(-1, 2):\n                    if dx != 0 or dy != 0:  # Skip the center pixel\n                        if 0 \u003c= x + dx \u003c output_grid.shape[0] and 0 \u003c= y + dy \u003c output_grid.shape[1]:\n                            output_grid[x + dx, y + dy] = Color.YELLOW  # Use yellow to trace the outline\n\n    return output_grid\n\ndef generate_input():\n    # Generate a black grid as the background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the colors\n    shape_color = np.random.choice(Color.NOT_BLACK)  # Choose a color for the shape\n    outline_color = np.random.choice([color for color in Color.NOT_BLACK if color != shape_color])  # Choose a different color for the outline\n\n    # Randomly place a shape in the grid\n    shape_width, shape_height = np.random.randint(3, 8), np.random.randint(3, 8)\n\n    # Get a random position to place the shape\n    start_x = np.random.randint(1, n - shape_height - 1)\n    start_y = np.random.randint(1, m - shape_width - 1)\n\n    # Draw the shape in the grid\n    for i in range(shape_height):\n        for j in range(shape_width):\n            grid[start_x + i, start_y + j] = shape_color\n\n    # Draw the outline around the shape\n    for i in range(shape_height + 2):  # Expand outline beyond the height of the shape\n        for j in range(shape_width + 2):  # Expand outline beyond the width of the shape\n            if (i == 0 or i == shape_height + 1 or j == 0 or j == shape_width + 1):  # Only the border\n                grid[start_x - 1 + i, start_y - 1 + j] = outline_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/57/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/57/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/57/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/57/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/57/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/57/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/57/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/57/images/train_output_2.png"}]}, "index": 57, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, boundary coloring, object filling\n\n# description:\n# In the input, you will see several colored shapes on a black background. \n# Your task is to color the interior of each shape with a contrasting color (e.g., gray) \n# while leaving the outline of the shapes unchanged.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Find all connected components (shapes) in the input grid\n    shapes = find_connected_components(grid=input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n\n    # Fill each shape with gray while preserving the boundaries\n    for shape in shapes:\n        # Get the coordinates of the shape\n        coords = np.argwhere(shape != Color.BLACK)\n\n        # If the shape has at least one color (not black), we proceed to fill\n        if coords.size \u003e 0:\n            # Get the first coordinate of the shape to flood fill\n            x, y = coords[0]\n\n            # Fill the shape\u0027s interior with gray\n            flood_fill(output_grid, x, y, Color.GRAY)\n\n            # Overlay the original shape\u0027s boundaries on the output grid\n            output_grid[shape != Color.BLACK] = input_grid[shape != Color.BLACK]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the grid between 10x10 and 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random shapes with at least one color\n    num_shapes = np.random.randint(3, 6)\n    colors = random.sample(Color.NOT_BLACK, k=num_shapes)\n\n    for color in colors:\n        # Random size for each shape between 3x3 and 6x6\n        shape_height, shape_width = np.random.randint(3, 7), np.random.randint(3, 7)\n\n        # Random position for the shape\n        x = np.random.randint(0, n - shape_height)\n        y = np.random.randint(0, m - shape_width)\n\n        # Draw the shape by filling that part of the grid with the selected color\n        grid[x:x + shape_height, y:y + shape_width] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/58/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/58/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/58/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/58/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/58/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/58/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/58/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/58/images/train_output_2.png"}]}, "index": 58, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry transformation, rotation, color enhancement\n\n# description:\n# In the input, you will see a colorful pattern that has a partially symmetric structure. \n# To create the output, rotate the pattern 90 degrees clockwise and color the newly exposed areas \n# with a contrasting color to enhance the transformation.\n\ndef main(input_grid):\n    # Rotate the input pattern 90 degrees clockwise\n    output_grid = np.rot90(input_grid, -1)  # -1 indicates clockwise rotation\n\n    # Get the size of the original grid\n    n, m = input_grid.shape\n    \n    # Determine the color to fill the newly exposed areas\n    # Here we choose a contrasting color; for simplicity, we will use Color.RED\n    contrasting_color = Color.RED\n\n    # Fill the new exposed areas in the output grid\n    for i in range(m):\n        for j in range(n):\n            if output_grid[i, j] == Color.BLACK:  # Assuming black represents the absence of color\n                output_grid[i, j] = contrasting_color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a colorful pattern with density\n    density = np.random.uniform(0.3, 0.7)\n    color_palette = random.sample(list(Color.NOT_BLACK), np.random.randint(2, 6))  # Choosing 2 to 5 colors\n\n    # Fill the grid with random colors based on the density\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c density:\n                grid[i, j] = np.random.choice(color_palette)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/59/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/59/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/59/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/59/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/59/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/59/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/59/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/59/images/train_output_2.png"}]}, "index": 59, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, reflection\n\n# description:\n# In the input, you will see a half-completed pattern on the left side of a grid. \n# To create the output, mirror the pattern across the vertical midline of the grid \n# to complete the design symmetrically.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n\n    # Create the output grid, starting with the same size as the input\n    output_grid = np.full((height, width), Color.BLACK)\n\n    # Fill the left side of the output grid with the input\n    output_grid[:, :width // 2] = input_grid[:, :width // 2]\n\n    # Mirror the left side to the right side\n    output_grid[:, width // 2:] = output_grid[:, :width // 2][:, ::-1]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random height and width for the grid\n    height = np.random.randint(5, 8)\n    width = np.random.randint(5, 8)\n\n    # Ensure the width is even to facilitate mirroring\n    if width % 2 != 0:\n        width += 1\n\n    # Create a random sprite for the left half of the grid\n    left_half = random_sprite(height, width // 2, density=0.5, color_palette=Color.NOT_BLACK, symmetry=\"not_symmetric\")\n\n    # Create the full grid by combining the left half and a black background on the right\n    full_grid = np.full((height, width), Color.BLACK)\n    full_grid[:, :width // 2] = left_half\n\n    return full_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/60/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/60/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/60/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/60/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/60/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/60/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/60/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/60/images/train_output_2.png"}]}, "index": 60, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, occlusion\n\n# description:\n# In the input, you will see a grid with a colorful shape that is almost symmetric,\n# except for a small area that is covered in black pixels.\n# To create the output, identify the missing area based on the symmetric appearance\n# and fill it in with the corresponding color to make it perfectly symmetric.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the symmetry of the shape in the grid\n    # 2. Identify the occluded pixels (black pixels)\n    # 3. Fill in the missing pixels to complete the symmetry\n\n    output_grid = input_grid.copy()\n    occlusion_color = Color.BLACK\n\n    # Detect mirror symmetries\n    mirrors = detect_mirror_symmetry(input_grid, ignore_colors=[occlusion_color])\n\n    # Find the occluded pixels\n    occluded_pixels = np.argwhere(input_grid == occlusion_color)\n\n    # Fill in the missing colors based on symmetry\n    for x, y in occluded_pixels:\n        for mirror in mirrors:\n            # Calculate symmetric position\n            symmetric_x, symmetric_y = mirror.apply(x, y)\n            # Only fill in if the symmetric position has a color (not occluded)\n            if output_grid[symmetric_x, symmetric_y] != occlusion_color:\n                output_grid[x, y] = output_grid[symmetric_x, symmetric_y]\n                break\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a medium sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random sprite\n    sprite_color = random.choice(list(Color.NOT_BLACK))\n    sprite = random_sprite(np.random.randint(5, n-2), np.random.randint(5, m-2), density=0.5, symmetry=\"vertical\", color_palette=[sprite_color])\n\n    # Place sprite randomly on the grid\n    sprite_x, sprite_y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=sprite_x, y=sprite_y)\n\n    # Randomly occlude some pixels in the sprite to create the missing area\n    for _ in range(np.random.randint(3, 10)):  # Random number of occlusions\n        occlude_x = np.random.randint(sprite_x, sprite_x + sprite.shape[0])\n        occlude_y = np.random.randint(sprite_y, sprite_y + sprite.shape[1])\n        if 0 \u003c= occlude_x \u003c n and 0 \u003c= occlude_y \u003c m:\n            grid[occlude_x, occlude_y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/61/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/61/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/61/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/61/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/61/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/61/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/61/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/61/images/train_output_2.png"}]}, "index": 61, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel merging, boundary expansion\n\n# description:\n# In the input grid, you will see clusters of colored pixels on a black background.\n# For each cluster, make the output grid by merging the colored pixels into a single contiguous area.\n# The merged area should expand outward until it hits the boundary of the grid or another cluster\u0027s boundary.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    \n    output_grid = np.zeros_like(input_grid)\n\n    # Find connected components (clusters) in the input grid\n    clusters = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    for cluster in clusters:\n        # Get the color of the cluster\n        cluster_color = cluster[cluster != Color.BLACK][0]\n\n        # Get the bounding box of the cluster\n        x, y, width, height = bounding_box(cluster)\n\n        # Merge the cluster by expanding outward\n        for dx in range(-1, width + 1):\n            for dy in range(-1, height + 1):\n                if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                    # Check if the position is within the cluster or the cluster color\n                    if input_grid[x + dx, y + dy] == cluster_color or input_grid[x + dx, y + dy] != Color.BLACK:\n                        # Fill the output grid with the cluster color\n                        output_grid[x + dx, y + dy] = cluster_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    grid_size = np.random.randint(10, 20)\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    num_clusters = np.random.randint(2, 6)\n    \n    for _ in range(num_clusters):\n        # Randomly determine the size of the cluster\n        cluster_size = np.random.randint(3, 7)\n        cluster_color = np.random.choice(Color.NOT_BLACK)\n\n        # Random position for the cluster\n        x, y = np.random.randint(0, grid_size - cluster_size), np.random.randint(0, grid_size - cluster_size)\n\n        # Create the cluster\n        for dx in range(cluster_size):\n            for dy in range(cluster_size):\n                if np.random.rand() \u003e 0.5:  # Randomly fill the cluster\n                    input_grid[x + dx, y + dy] = cluster_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/62/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/62/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/62/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/62/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/62/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/62/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/62/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/62/images/train_output_2.png"}]}, "index": 62, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal symmetry, reflection\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels that exhibits diagonal symmetry. \n# To make the output, reflect the pattern across the diagonal (top-left to bottom-right), creating a mirrored effect in the grid.\n\ndef main(input_grid):\n    # Reflect the input grid across the diagonal\n    output_grid = np.zeros_like(input_grid)\n\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            output_grid[j, i] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with diagonal symmetry\n    n = np.random.randint(3, 6)  # Random size for the grid\n    grid = np.zeros((n, n), dtype=int)\n\n    # Fill the grid with a pattern that has diagonal symmetry\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    for i in range(n):\n        for j in range(n):\n            if i \u003c= j:  # Fill the upper triangle and the diagonal\n                grid[i, j] = color\n                grid[j, i] = color  # Ensure diagonal symmetry by mirroring\n\n    # Randomly scatter some black pixels to ensure not every pixel is filled\n    num_black_pixels = np.random.randint(1, n*n//2)\n    for _ in range(num_black_pixels):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, n)\n        grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/63/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/63/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/63/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/63/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/63/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/63/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/63/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/63/images/train_output_2.png"}]}, "index": 63, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, gradient shifting\n\n# description:\n# In the input, you\u0027ll see a grid filled with a gradient of colors progressing from one color to another.\n# To make the output, shift each color in the gradient to the next color in a predefined sequence:\n# red -\u003e orange -\u003e yellow -\u003e green -\u003e blue -\u003e maroon. If a color is at the end of the sequence, it wraps around to the beginning.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Define the color shift mapping\n    color_shift = {\n        Color.RED: Color.ORANGE,\n        Color.ORANGE: Color.YELLOW,\n        Color.YELLOW: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.MAROON,\n        Color.MAROON: Color.RED,\n        # Keep background colors unchanged\n        Color.BLACK: Color.BLACK,\n    }\n\n    # Perform color shifting\n    output_grid = np.vectorize(lambda color: color_shift.get(color, color))(output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Define grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose two colors to create a gradient\n    start_color = np.random.choice(list(Color.NOT_BLACK))\n    end_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Create a gradient from start_color to end_color\n    for i in range(n):\n        for j in range(m):\n            # Determine the blended color based on the position\n            ratio = (i + j) / (n + m - 2)  # Normalize the position\n            blended_color = blend_colors(start_color, end_color, ratio)\n            grid[i, j] = blended_color\n\n    return grid\n\ndef blend_colors(color1, color2, ratio):\n    # A simple blend function that combines two colors\n    # Here you can implement a basic blending logic\n    # For simplicity, we assume colors are represented as integers\n    return color1 if np.random.rand() \u003c ratio else color2", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/64/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/64/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/64/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/64/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/64/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/64/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/64/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/64/images/train_output_2.png"}]}, "index": 64, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color counting, majority voting, pixel replacement\n\n# description:\n# In the input, you will see a grid with a random distribution of colored pixels on a black background. \n# To create the output grid, you should replace all pixels with the most frequently occurring color. \n# In the case of a tie, the color that appears first in the grid (from top-left to bottom-right) should be preserved.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a dictionary to count occurrences of each color\n    color_count = {}\n    \n    # Count the occurrences of each color\n    for row in input_grid:\n        for color in row:\n            if color != Color.BLACK:  # Ignore black pixels\n                color_count[color] = color_count.get(color, 0) + 1\n\n    # Identify the most frequently occurring color\n    max_count = -1\n    most_frequent_color = Color.BLACK\n\n    for color in color_count.keys():\n        count = color_count[color]\n        if count \u003e max_count:\n            max_count = count\n            most_frequent_color = color\n        elif count == max_count:\n            # Check for first appearance in case of tie\n            if np.argwhere(input_grid == color).min() \u003c np.argwhere(input_grid == most_frequent_color).min():\n                most_frequent_color = color\n\n    # Create output grid filled with the most frequent color\n    output_grid = np.full_like(input_grid, fill_value=Color.BLACK)\n    output_grid[input_grid != Color.BLACK] = most_frequent_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of specified dimensions\n    n, m = random.randint(10, 15), random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels in the grid, ensuring some colors appear multiple times\n    colors = random.sample(Color.NOT_BLACK, k=random.randint(3, 6))  # Pick a few random colors\n    for color in colors:\n        frequency = random.randint(5, 20)  # Each color will appear a random number of times\n        for _ in range(frequency):\n            empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.BLACK]\n            if empty_cells:  # If there are still empty cells\n                x, y = random.choice(empty_cells)\n                grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/65/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/65/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/65/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/65/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/65/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/65/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/65/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/65/images/train_output_2.png"}]}, "index": 65, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, shape coloring\n\n# description:\n# In the input grid, you will see various colored shapes. Some shapes are symmetrical along the vertical axis while others are not.\n# To create the output grid, color all symmetrical shapes blue and all non-symmetrical shapes red.\n\ndef main(input_grid):\n    # Find all connected components (shapes) in the grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n\n    # Create an output grid copy\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    for shape in shapes:\n        # Check if the shape is symmetrical\n        height, width = shape.shape\n        mid_x = width // 2\n        \n        # Extract the left and right halves of the shape\n        left_half = shape[:, :mid_x]\n        right_half = np.flip(shape[:, mid_x:mid_x + (width % 2)], axis=1)  # Flip the right half for comparison\n\n        # Determine if the shape is symmetrical\n        if np.array_equal(left_half, right_half):\n            color = Color.BLUE  # Symmetrical shapes are colored blue\n        else:\n            color = Color.RED  # Non-symmetrical shapes are colored red\n\n        # Blit the shape into the output grid with the designated color\n        blitted_shape = np.where(shape == Color.BLACK, Color.BLACK, color)\n        blit_object(output_grid, blitted_shape)\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of shapes (between 2 and 5)\n    num_shapes = np.random.randint(2, 6)\n\n    for _ in range(num_shapes):\n        # Generate a random sprite (shape) with random dimensions\n        width = np.random.randint(2, 6)\n        height = np.random.randint(2, 6)\n        shape = random_sprite(width, height, density=0.5, symmetry=np.random.choice([\u0027horizontal\u0027, \u0027vertical\u0027, \u0027not_symmetric\u0027]))\n\n        # Place the sprite at a random location in the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n        blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/66/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/66/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/66/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/66/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/66/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/66/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/66/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/66/images/train_output_2.png"}]}, "index": 66, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filtering, counting, background retention\n\n# description:\n# In the input, you will see a grid filled with colored pixels on a black background. The task is to filter out all colors that occur less than a specified threshold (e.g., three). \n# The output should only retain colors that meet this threshold while leaving the background intact (black).\n\ndef main(input_grid: np.ndarray, threshold: int = 3) -\u003e np.ndarray:\n    # Create a new output grid initialized to black (background)\n    output_grid = np.zeros_like(input_grid)\n\n    # Count occurrences of each color\n    unique_colors, counts = np.unique(input_grid, return_counts=True)\n\n    # Create a set of colors that meet the threshold criteria\n    colors_to_keep = {color for color, count in zip(unique_colors, counts) if count \u003e= threshold and color != Color.BLACK}\n\n    # Fill the output grid with the colors that meet the threshold\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i, j] in colors_to_keep:\n                output_grid[i, j] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 grid as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a number of colors and their frequencies\n    num_colors = np.random.randint(2, 6)  # Choose between 2 to 5 different colors\n    colors = random.sample(Color.NOT_BLACK, num_colors)\n\n    # Randomly assign colors to the grid ensuring some have at least threshold occurrences\n    for color in colors:\n        # Set a random frequency for the color but ensure it\u0027s at least the threshold\n        frequency = np.random.randint(1, 10)  # Random frequency between 1 and 9\n        for _ in range(frequency):\n            empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.BLACK]\n            if empty_cells:\n                x, y = random.choice(empty_cells)\n                grid[x, y] = color\n\n    # Add colors that will not meet the threshold\n    for color in colors:\n        if np.random.rand() \u003e 0.5:  # 50% chance to add low-frequency colors\n            frequency = np.random.randint(1, 3)  # Frequency between 1 and 2\n            for _ in range(frequency):\n                empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.BLACK]\n                if empty_cells:\n                    x, y = random.choice(empty_cells)\n                    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/67/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/67/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/67/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/67/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/67/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/67/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/67/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/67/images/train_output_2.png"}]}, "index": 67, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary tracing, color gradient, contrast\n\n# description:\n# In the input, you will see a colored object on a black background with a clearly defined boundary. \n# To create the output, trace the boundary of the object with a contrasting color, and fill the interior with a gradient \n# that transitions from the boundary color to the original color of the object.\n\ndef main(input_grid):\n    # Make a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Determine the background color (assuming it\u0027s black)\n    background_color = Color.BLACK\n\n    # Detect connected components (the colored object)\n    objects = find_connected_components(input_grid, background=background_color, connectivity=4, monochromatic=True)\n    \n    # Assuming there\u0027s only one object for simplicity\n    colored_object = objects[0]\n    \n    # Get the bounding box for the colored object\n    x, y, width, height = bounding_box(colored_object)\n\n    # Get the color of the object\n    object_color = colored_object[x, y]\n\n    # Define the contrasting color (we can use a simple color rotation for contrast)\n    contrasting_color = Color.YELLOW if object_color != Color.YELLOW else Color.RED\n\n    # Trace the boundary of the object\n    for i in range(x, x + width):\n        for j in range(y, y + height):\n            if colored_object[i, j] == object_color:\n                # Check neighbors to find boundary\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    neighbor_x, neighbor_y = i + dx, j + dy\n                    if (0 \u003c= neighbor_x \u003c input_grid.shape[0] and 0 \u003c= neighbor_y \u003c input_grid.shape[1] and\n                        output_grid[neighbor_x, neighbor_y] == background_color):\n                        # Draw the boundary\n                        output_grid[i, j] = contrasting_color\n                        break\n\n    # Fill the interior with a gradient from the boundary color to the object color\n    for i in range(x + 1, x + width - 1):\n        for j in range(y + 1, y + height - 1):\n            if output_grid[i, j] == background_color:\n                # Calculate the gradient based on distance from the boundary\n                dist_from_boundary = min(\n                    min(i - x, (x + width - 1) - i),\n                    min(j - y, (y + height - 1) - j)\n                )\n                # Normalize to get a gradient value\n                gradient_value = dist_from_boundary / (min(width, height) / 2)\n                # Interpolate color based on gradient value\n                new_color = (1 - gradient_value) * object_color + gradient_value * contrasting_color\n                output_grid[i, j] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a black background\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), fill_value=Color.BLACK)\n\n    # Randomly select a color for the object\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Random dimensions for the colored object\n    object_width, object_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    object_sprite = random_sprite(object_width, object_height, color_palette=[object_color], density=1)\n\n    # Place the colored object in the grid\n    x_position, y_position = random_free_location_for_sprite(grid, object_sprite, background=Color.BLACK)\n    blit_sprite(grid, object_sprite, x=x_position, y=y_position, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/68/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/68/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/68/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/68/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/68/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/68/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/68/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/68/images/train_output_2.png"}]}, "index": 68, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, layering, overlapping shapes\n\n# description:\n# In the input grid, you will see several colored circles (or dots) arranged randomly across a black background.\n# The objective is to blend the colors of these overlapping circles, creating a new resultant grid where each overlapping area reflects the blended color of the circles that intersected there.\n\ndef blend_colors(color1, color2):\n    # Function to blend two colors. Here we simply average the color values.\n    return ((color1[0] + color2[0]) // 2, (color1[1] + color2[1]) // 2, (color1[2] + color2[2]) // 2)\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n    \n    # Create a list of colors to map to their RGB values (this is a simplification)\n    color_mapping = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.ORANGE: (255, 165, 0),\n        Color.PINK: (255, 192, 203),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.GREY: (128, 128, 128),\n        Color.BLACK: (0, 0, 0),\n    }\n\n    # Create a new grid to hold blended colors\n    blended_grid = np.full((height, width, 3), 0, dtype=int)  # 3 channels for RGB\n\n    # Loop through each pixel in the input grid\n    for x in range(height):\n        for y in range(width):\n            if input_grid[x, y] in color_mapping:\n                color = color_mapping[input_grid[x, y]]\n                blended_grid[x, y] = color\n\n    # Blend colors where overlaps occur\n    for x in range(height):\n        for y in range(width):\n            if input_grid[x, y] != Color.BLACK:  # If there\u0027s a color present\n                # Check surrounding pixels to blend\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if (dx == 0 and dy == 0) or x + dx \u003c 0 or x + dx \u003e= height or y + dy \u003c 0 or y + dy \u003e= width:\n                            continue\n                        neighbor_color = input_grid[x + dx, y + dy]\n                        if neighbor_color in color_mapping:\n                            # Blend the colors\n                            blended_color = blend_colors(blended_grid[x, y], color_mapping[neighbor_color])\n                            blended_grid[x, y] = blended_color\n\n    # Convert blended colors back to the closest Color enum value\n    for x in range(height):\n        for y in range(width):\n            r, g, b = blended_grid[x, y]\n            # Find the closest color (this is a simplification)\n            closest_color = min(color_mapping.keys(), key=lambda k: (color_mapping[k][0] - r)**2 + (color_mapping[k][1] - g)**2 + (color_mapping[k][2] - b)**2)\n            output_grid[x, y] = closest_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly place a number of colored circles on the grid\n    num_circles = np.random.randint(5, 15)  # Random number of circles\n    for _ in range(num_circles):\n        # Random color for the circle\n        color = np.random.choice(list(Color.NOT_BLACK))\n        radius = np.random.randint(1, 4)  # Random radius between 1 and 3\n        \n        # Random center for the circle\n        center_x = np.random.randint(radius, 20 - radius)\n        center_y = np.random.randint(radius, 20 - radius)\n        \n        # Draw the circle on the grid\n        for x in range(center_x - radius, center_x + radius + 1):\n            for y in range(center_y - radius, center_y + radius + 1):\n                if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:  # Circle equation\n                    input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/69/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/69/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/69/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/69/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/69/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/69/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/69/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/69/images/train_output_2.png"}]}, "index": 69, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal stripes, color mirroring\n\n# description:\n# In the input, you will see a grid with a diagonal stripe pattern of alternating colors. Each diagonal stripe runs from the top left to the bottom right.\n# To make the output, replicate the diagonal stripes symmetrically across the vertical axis of the grid, creating a mirrored effect.\n\ndef main(input_grid):\n    # Create an output grid of the same shape as input\n    output_grid = np.copy(input_grid)\n\n    # Get the number of rows and columns\n    rows, cols = input_grid.shape\n\n    # Mirror the diagonal stripes across the vertical axis\n    for i in range(rows):\n        for j in range(cols):\n            color = input_grid[i, j]\n            if color != Color.BLACK:\n                # Set the mirrored position\n                output_grid[i, cols - j - 1] = color\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid with black background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose colors for the diagonal stripes\n    available_colors = list(Color.NOT_BLACK)\n    colors = np.random.choice(available_colors, size=2, replace=False)\n\n    # Draw diagonal stripes of alternating colors\n    for i in range(min(n, m)):\n        if i % 2 == 0:\n            draw_line(grid, i, 0, length=min(n, m - i), direction=(1, 1), color=colors[0])\n        else:\n            draw_line(grid, i, 0, length=min(n, m - i), direction=(1, 1), color=colors[1])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/70/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/70/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/70/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/70/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/70/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/70/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/70/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/70/images/train_output_2.png"}]}, "index": 70, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, pattern replication\n\n# description:\n# In the input, you will see a 4x4 grid with a pattern in the top left corner. \n# To make the output, rotate the pattern 90 degrees clockwise and then replicate it three more times to fill the entire grid.\n\ndef main(input_grid):\n    # Extract the 2x2 pattern from the top-left corner\n    pattern = input_grid[:2, :2]\n\n    # Rotate the pattern 90 degrees clockwise\n    rotated_pattern = np.array([[pattern[1, 0], pattern[0, 0]],\n                                [pattern[1, 1], pattern[0, 1]]])\n    \n    # Create the output grid by replicating the rotated pattern\n    output_grid = np.tile(rotated_pattern, (2, 2))  # Repeat the pattern 2 times in both dimensions\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 4x4 grid with a black background\n    grid = np.full((4, 4), Color.BLACK)\n\n    # Randomly select a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the top left 2x2 corner with the selected color\n    grid[:2, :2] = [[color, color],\n                    [color, color]]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/71/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/71/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/71/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/71/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/71/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/71/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/71/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/71/images/train_output_2.png"}]}, "index": 71, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color replacement, surrounding\n\n# description:\n# In the input, you will see a grid with a single large colored shape surrounded by random colored pixels. \n# To make the output, create a new grid where the area surrounding the large shape is filled with a contrasting color, \n# while leaving the shape itself unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect the large colored shape\n    # 2. Determine the bounding box of the shape\n    # 3. Fill the area surrounding the shape with a contrasting color, leaving the shape unchanged\n\n    output_grid = np.copy(input_grid)\n\n    # Step 1: Detect the large colored shape (not black)\n    objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=False, connectivity=8)\n    \n    # There should only be one large colored shape\n    assert len(objects) == 1\n    shape = objects[0]\n\n    # Step 2: Determine the bounding box of the shape\n    x, y, width, height = bounding_box(shape)\n\n    # Step 3: Fill the area surrounding the shape with a contrasting color\n    contrasting_color = Color.RED  # Choose a contrasting color (fixed for this puzzle)\n    \n    for i in range(x - 1, x + width + 1):\n        for j in range(y - 1, y + height + 1):\n            if i \u003c 0 or i \u003e= output_grid.shape[0] or j \u003c 0 or j \u003e= output_grid.shape[1]:\n                continue  # Skip out of bounds\n            if output_grid[i, j] == Color.BLACK:  # Only fill black areas around the shape\n                output_grid[i, j] = contrasting_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize a 10x10 grid representing a black background.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the width and height of the shape between 3 and 5.\n    width, height = np.random.randint(3, 6), np.random.randint(3, 6)\n    shape_color = random.choice(Color.NOT_BLACK)  # Ensure it\u0027s not black\n    shape = np.full((width, height), shape_color)\n\n    # Find a free location for this shape and blit it to the grid\n    x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, shape, x, y, background=Color.BLACK)\n\n    # Randomly scatter pixels around the shape\n    density = 0.5  # Density of the surrounding colored pixels\n    grid = random_scatter_points(grid=grid, color=random.choice(Color.NOT_BLACK), density=density, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/72/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/72/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/72/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/72/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/72/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/72/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/72/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/72/images/train_output_2.png"}]}, "index": 72, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern duplication, grid transformation\n\n# description:\n# In the input you will see a grid with a pattern of colored pixels in the center.\n# The output should duplicate this pattern in each quadrant of the output grid while maintaining the original colors.\n# The output grid size should be double the size of the input grid.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    input_height, input_width = input_grid.shape\n    # Create an output grid with double the size\n    output_grid = np.full((input_height * 2, input_width * 2), Color.BLACK)\n\n    # Define the coordinates for the four quadrants\n    quadrants = [\n        (0, 0),  # top-left\n        (0, input_width),  # top-right\n        (input_height, 0),  # bottom-left\n        (input_height, input_width)  # bottom-right\n    ]\n\n    # Blit the original input_grid pattern into each quadrant in the output_grid\n    for x_offset, y_offset in quadrants:\n        output_grid = blit_sprite(grid=output_grid, sprite=input_grid, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a base grid size\n    grid_size = np.random.randint(3, 6)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly create a pattern in the center of the grid\n    pattern_size = np.random.randint(1, grid_size // 2 + 1)\n    start_x = grid_size // 2 - pattern_size // 2\n    start_y = grid_size // 2 - pattern_size // 2\n\n    # Fill the center of the grid with random colors\n    colors = Color.NOT_BLACK\n    for i in range(start_x, start_x + pattern_size):\n        for j in range(start_y, start_y + pattern_size):\n            grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/73/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/73/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/73/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/73/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/73/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/73/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/73/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/73/images/train_output_2.png"}]}, "index": 73, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, frequency extraction\n\n# description:\n# In the input, you will see a grid filled with various colored pixels. \n# To make the output, you should identify the most frequently occurring \n# color in the grid and create a new grid that displays this color \n# in a square pattern, occupying the center of the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Count the frequency of each color in the input grid\n    color_counts = {}\n    for row in input_grid:\n        for color in row:\n            if color != Color.BLACK:  # Ignore the background color\n                if color in color_counts:\n                    color_counts[color] += 1\n                else:\n                    color_counts[color] = 1\n    \n    # Determine the most frequently occurring color\n    most_frequent_color = max(color_counts, key=color_counts.get)\n\n    # Create the output grid, larger than the input grid\n    output_height, output_width = input_grid.shape[0] + 4, input_grid.shape[1] + 4\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Fill the center of the output grid with the most frequent color\n    center_x, center_y = output_height // 2, output_width // 2\n    output_grid[center_x - 2:center_x + 2, center_y - 2:center_y + 2] = most_frequent_color\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random distribution of colors\n    colors = np.random.choice(list(Color.NOT_BLACK), size=(n * m), replace=True)\n\n    # Fill the grid with the chosen colors\n    grid.flat[:len(colors)] = colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/74/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/74/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/74/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/74/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/74/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/74/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/74/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/74/images/train_output_2.png"}]}, "index": 74, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color shift, overlay\n\n# description:\n# In the input, you will see a series of colored square patches arranged in a grid pattern, with some overlapping areas. \n# Each patch can be of any color except black. To produce the output, shift the color of each patch by one position in the color sequence (e.g., red becomes green, green becomes blue, etc.). \n# For overlapping patches, blend their colors by averaging their RGB values.\n\ndef main(input_grid):\n    # Define the color sequence\n    color_sequence = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON, Color.GREY, Color.BLACK]\n    \n    # Create a mapping from current color to the new color\n    color_map = {color: color_sequence[(i + 1) % len(color_sequence)] for i, color in enumerate(color_sequence)}\n    \n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Apply color shift and handle overlaps\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            current_color = input_grid[x, y]\n            if current_color != Color.BLACK:\n                # Shift the color\n                new_color = color_map.get(current_color, current_color)\n\n                # If the output already has a color, blend the colors\n                if output_grid[x, y] != Color.BLACK:\n                    # Blend colors: average the RGB values (since we are assuming colors are represented as simple integers)\n                    existing_color = output_grid[x, y]\n                    blended_color = average_colors(existing_color, new_color)\n                    output_grid[x, y] = blended_color\n                else:\n                    output_grid[x, y] = new_color\n\n    return output_grid\n\ndef average_colors(color1, color2):\n    # A simple averaging function for colors, assuming colors are integers\n    return Color((Color.color_to_rgb(color1) + Color.color_to_rgb(color2)) // 2)\n\ndef generate_input():\n    # Create a random grid with colored patches\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate patches\n    num_patches = np.random.randint(5, 15)\n    for _ in range(num_patches):\n        color = np.random.choice(Color.NOT_BLACK)\n        patch_size = np.random.randint(2, 5)  # size of the square patch\n\n        # Randomly choose a position for the patch\n        x = np.random.randint(0, n - patch_size)\n        y = np.random.randint(0, m - patch_size)\n\n        # Draw the patch in the grid\n        for i in range(patch_size):\n            for j in range(patch_size):\n                grid[x + i, y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/75/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/75/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/75/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/75/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/75/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/75/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/75/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/75/images/train_output_2.png"}]}, "index": 75, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, background matching\n\n# description:\n# In the input, you will see a single colored shape that is scaled down, floating in a grid of black.\n# To make the output, scale the shape up to double its original size while keeping the background pixels unchanged.\n\ndef main(input_grid):\n    # Find the connected component of the non-background pixels\n    shape_components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n    \n    assert len(shape_components) == 1, \"Expected exactly one shape in the input grid.\"\n    original_shape = shape_components[0]\n    \n    # Create an empty output grid filled with the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK, dtype=int)\n    \n    # Get the dimensions of the original shape\n    original_height, original_width = original_shape.shape\n    \n    # Create a new shape that is double the size\n    new_height, new_width = original_height * 2, original_width * 2\n    scaled_shape = np.full((new_height, new_width), Color.BLACK)\n\n    # Scale up the shape by filling each pixel in the original shape with a 2x2 block in the new shape\n    for x in range(original_height):\n        for y in range(original_width):\n            if original_shape[x, y] != Color.BLACK:  # Only scale colored pixels\n                scaled_shape[2*x:2*x+2, 2*y:2*y+2] = original_shape[x, y]\n\n    # Now blit the scaled shape onto the output grid\n    blit_object(output_grid, scaled_shape, background=Color.BLACK)\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a roughly 12x12 input grid\n    n = np.random.randint(8, 15)\n    m = np.random.randint(8, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a small random sprite with shape (2-4)x(2-4)\n    w = np.random.randint(2, 5)\n    h = np.random.randint(2, 5)\n    sprite = random_sprite(w, h, color_palette=[np.random.choice(Color.NOT_BLACK)])\n\n    # Blit the sprite onto a random location on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/76/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/76/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/76/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/76/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/76/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/76/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/76/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/76/images/train_output_2.png"}]}, "index": 76, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color fill, boundary detection, shape transformation\n\n# description:\n# In the input grid, you will see a colored shape surrounded by black pixels. The shape can be any color except black. \n# To create the output grid, detect the boundary of the shape and fill the area inside the boundary with a new color (e.g., pink), \n# while leaving the boundary intact.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = input_grid.copy()\n\n    # Detect the boundary of the shape\n    boundary_mask = object_boundary(input_grid)\n    \n    # Create a mask for the interior of the shape\n    interior_mask = object_interior(input_grid)\n\n    # Fill the interior area with the new color (Pink)\n    for x, y in np.argwhere(interior_mask):\n        output_grid[x, y] = Color.PINK\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid of size between 10x10 to 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random colored shape\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_sprite = random_sprite(np.random.randint(3, 8), np.random.randint(3, 8), color_palette=[shape_color])\n    \n    # Hollow out the interior of the shape\n    interior_mask = object_interior(shape_sprite)\n    boundary_mask = object_boundary(shape_sprite)\n    interior_but_not_edges = interior_mask \u0026 ~boundary_mask\n    shape_sprite[interior_but_not_edges] = Color.BLACK\n\n    # Find a random free location for the shape in the grid\n    x, y = random_free_location_for_sprite(grid, shape_sprite, border_size=1, padding=1)\n    blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/77/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/77/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/77/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/77/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/77/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/77/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/77/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/77/images/train_output_2.png"}]}, "index": 77, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# environmental mapping, gradient transformation\n\n# description:\n# In the input, there is a colored object in the center of the grid surrounded by various colored pixels.\n# To create the output, replace all the surrounding pixels with a gradient that transitions from the color of the object to black as it moves away from the object.\n\ndef main(input_grid):\n    # Get the color of the central object\n    color_of_object = input_grid[1:-1, 1:-1].max()  # Assume the object is surrounded by the background (black)\n    \n    # Initialize the output grid with the input grid\n    output_grid = np.copy(input_grid)\n\n    # Generate the gradient from the color of the object to black\n    height, width = output_grid.shape\n    for i in range(height):\n        for j in range(width):\n            if output_grid[i, j] != Color.BLACK:  # If it\u0027s not the background\n                # Calculate the distance from the object (1, 1) to the current pixel (i, j)\n                distance = max(abs(i - 1), abs(j - 1))  # Using Chebyshev distance\n                # Calculate the gradient color based on distance\n                gradient_color = blend_colors(color_of_object, Color.BLACK, distance / (height + width))\n                output_grid[i, j] = gradient_color\n\n    # Restore the color of the central object in the output grid\n    output_grid[1:-1, 1:-1] = color_of_object\n\n    return output_grid\n\ndef blend_colors(color_a, color_b, ratio):\n    \"\"\"\n    Blends two colors based on a ratio and returns the resulting color.\n    The blending is done linearly, where `ratio` is between 0 and 1.\n    \"\"\"\n    if ratio \u003c 0:\n        return color_a\n    elif ratio \u003e 1:\n        return color_b\n    else:\n        return color_a if ratio \u003c 0.5 else color_b\n\ndef generate_input():\n    # Create a black grid\n    grid_size = np.random.randint(7, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Select a color for the central object\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Draw the object in the center of the grid\n    grid[1:-1, 1:-1] = object_color  # Central object\n\n    # Randomly surround the object with colored pixels\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if grid[i, j] == Color.BLACK and np.random.rand() \u003c 0.3:  # 30% chance to color the surrounding pixels\n                grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/78/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/78/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/78/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/78/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/78/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/78/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/78/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/78/images/train_output_2.png"}]}, "index": 78, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# movement, boundaries, collision detection\n\n# description:\n# In the input, you will see a colored pixel representing a moving object in the center, and several stationary obstacles represented by gray pixels scattered around.\n# To create the output, move the colored pixel toward a target direction (up, down, left, or right), but stop it when it encounters any gray pixel or the edge of the grid.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the position of the colored pixel (the moving object)\n    moving_object_pos = np.argwhere(output_grid != Color.BLACK)\n\n    # We\u0027ll assume there\u0027s only one moving object\n    if moving_object_pos.size == 0:\n        return output_grid  # no moving object found\n\n    x, y = moving_object_pos[0]  # Getting the coordinates of the colored pixel\n\n    # Define the target direction (up, down, left, right)\n    direction = (0, 1)  # Move down for this example; it can be modified as needed\n\n    while True:\n        next_x = x + direction[0]\n        next_y = y + direction[1]\n\n        # Check for boundaries\n        if next_x \u003c 0 or next_x \u003e= output_grid.shape[0] or next_y \u003c 0 or next_y \u003e= output_grid.shape[1]:\n            break  # Stop if we reach the edge of the grid\n\n        # Check if the next position is an obstacle\n        if output_grid[next_x, next_y] == Color.GREY:\n            break  # Stop if we hit a gray pixel\n\n        # Move the object\n        x, y = next_x, next_y\n\n    # Update the position of the moving object in the output grid\n    output_grid[x, y] = output_grid[moving_object_pos[0][0], moving_object_pos[0][1]]\n    output_grid[moving_object_pos[0][0], moving_object_pos[0][1]] = Color.BLACK  # Clear the old position\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 black grid as the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place the moving object in the center\n    center_x, center_y = n // 2, m // 2\n    grid[center_x, center_y] = np.random.choice(list(Color.NOT_BLACK))  # Random color for the moving object\n\n    # Randomly scatter obstacles around, ensuring they don\u0027t overlap with the moving object\n    num_obstacles = np.random.randint(5, 10)\n    for _ in range(num_obstacles):\n        while True:\n            x = np.random.randint(n)\n            y = np.random.randint(m)\n            if (x, y) != (center_x, center_y) and grid[x, y] == Color.BLACK:\n                grid[x, y] = Color.GREY\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/79/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/79/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/79/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/79/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/79/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/79/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/79/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/79/images/train_output_2.png"}]}, "index": 79, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color pattern detection, transformation based on color proximity\n\n# description:\n# In the input, you will see a grid filled with colored pixels. Each pixel can be one of the ten colors.\n# To create the output grid, you should detect clusters of adjacent colored pixels (8-connectivity).\n# Color the pixels in the output grid based on the colors of the largest cluster detected. \n# If two or more clusters are of the same size, use the color of the cluster that appears first (top to bottom, left to right).\n# If the input grid is completely black, output a grid filled with black.\n\ndef main(input_grid):\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # If there are no components, return a black grid\n    if not components:\n        return np.zeros(input_grid.shape, dtype=int)\n\n    # Find the largest component\n    largest_component = max(components, key=lambda x: x.size)\n\n    # Get the color of the largest component\n    color_of_largest = largest_component[0][0]\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Color the pixels of the largest component in the output grid\n    for x, y in np.argwhere(input_grid == color_of_largest):\n        output_grid[x][y] = color_of_largest\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(5, 8), np.random.randint(5, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors, ensuring some connected components\n    num_colors = len(Color.NOT_BLACK)\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.3:  # 30% chance to color the pixel\n                grid[i][j] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/80/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/80/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/80/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/80/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/80/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/80/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/80/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/80/images/train_output_2.png"}]}, "index": 80, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color gradient, spreading, blending\n\n# description:\n# In the input, you will see a grid with a single colored pixel surrounded by black pixels. \n# To create the output, transform this pixel into a color gradient that spreads outwards, blending into black as it reaches the edges of the grid.\n\ndef main(input_grid):\n    # Find the location of the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    colored_x, colored_y = colored_pixel_locations[0]\n\n    # Create the output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Calculate the maximum distance from the colored pixel to the corners of the grid\n    max_distance = np.max([colored_x, colored_y, input_grid.shape[0] - 1 - colored_x, input_grid.shape[1] - 1 - colored_y])\n\n    # Create the gradient by calculating the color intensity based on distance\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # Calculate the Euclidean distance from the colored pixel\n            distance = np.sqrt((x - colored_x) ** 2 + (y - colored_y) ** 2)\n            # Normalize the distance to a value between 0 and 1\n            normalized_distance = distance / max_distance\n            # Determine the color based on the distance\n            if normalized_distance \u003c 1:\n                # Blend towards black based on the normalized distance\n                output_grid[x, y] = blend_color(input_grid[colored_x, colored_y], Color.BLACK, normalized_distance)\n\n    return output_grid\n\ndef blend_color(color_a, color_b, ratio):\n    # Simple blending function between two colors based on a ratio\n    # Assuming colors are represented as strings, we will just return a simple average for demonstration purposes.\n    # In a full implementation, you would handle actual RGB values or a similar representation.\n    return color_a if ratio \u003c 0.5 else color_b\n\ndef generate_input():\n    # Create a random grid size\n    width, height = np.random.randint(3, 30, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Choose a random color for the single colored pixel\n    colored_pixel_color = np.random.choice(Color.NOT_BLACK)\n\n    # Place a colored pixel in a random location not on the edges\n    colored_x = np.random.randint(1, width-1)\n    colored_y = np.random.randint(1, height-1)\n    input_grid[colored_x, colored_y] = colored_pixel_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/81/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/81/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/81/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/81/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/81/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/81/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/81/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/81/images/train_output_2.png"}]}, "index": 81, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, counting, connectivity\n\n# description:\n# In the input grid, you will see colored regions separated by black pixels. \n# To create the output grid, you need to count the number of connected regions for each color\n# and fill those regions with a color corresponding to their size: \n# small regions (1-3 pixels) become red, medium (4-6 pixels) become blue, and large (7+ pixels) become green.\ndef main(input_grid):\n    # Find all connected components in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Iterate through each component\n    for component in components:\n        # Get the color of the current component\n        color = component[0, 0]\n        size = component.size\n\n        # Determine the fill color based on the size of the component\n        if size \u003c= 3:\n            fill_color = Color.RED\n        elif size \u003c= 6:\n            fill_color = Color.BLUE\n        else:\n            fill_color = Color.GREEN\n\n        # Fill the output grid with the determined fill color for this component\n        for x, y in np.argwhere(input_grid == color):\n            output_grid[x, y] = fill_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a square grid with size from 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Randomly scatter colors and create regions separated by black pixels\n    num_colors = np.random.randint(2, 5)  # Use 2 to 4 colors\n    colors = random.sample(Color.NOT_BLACK, num_colors)\n\n    # Random density for the regions\n    for color in colors:\n        density = np.random.uniform(0.1, 0.3)  # Density between 10% to 30%\n        for _ in range(int(n * n * density)):\n            x, y = np.random.randint(0, n), np.random.randint(0, n)\n            if grid[x, y] == Color.BLACK:  # Only fill on black background\n                grid[x, y] = color\n\n    # Create black barriers to separate regions\n    for _ in range(np.random.randint(1, 5)):\n        x1, y1 = np.random.randint(0, n), np.random.randint(0, n)\n        x2, y2 = np.random.randint(0, n), np.random.randint(0, n)\n        draw_line(grid, x1, y1, end_x=x2, end_y=y2, color=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/82/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/82/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/82/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/82/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/82/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/82/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/82/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/82/images/train_output_2.png"}]}, "index": 82, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, resizing, positioning\n\n# description:\n# In the input, you will see a large grid with a complex pattern in the center surrounded by a uniform background color.\n# To make the output, extract the central pattern, resize it to fit a smaller grid, and place the resized pattern in the top-left corner of the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central complex pattern from the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n    \n    # Assuming there\u0027s only one complex central pattern in the input\n    central_pattern = objects[0]\n    \n    # Crop the central pattern from the input grid\n    cropped_pattern = crop(central_pattern, background=Color.BLACK)\n    \n    # Resize the pattern to fit a smaller grid (e.g., 4x4)\n    scaled_pattern = scale_pattern(cropped_pattern, scale_factor=4)\n    \n    # Create a new output grid with a black background\n    output_grid = np.full((8, 8), Color.BLACK, dtype=int)\n    \n    # Place the resized pattern in the top-left corner of the output grid\n    blit_sprite(output_grid, scaled_pattern, x=0, y=0, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a larger grid, for example, 12x12\n    grid_width, grid_height = 12, 12\n    grid = np.zeros((grid_width, grid_height), dtype=int)\n    \n    # Generate a random central pattern size\n    pattern_size = np.random.randint(4, 8)\n    \n    # Generate a random pattern\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n    central_pattern = random_sprite(n=pattern_size, m=pattern_size, color_palette=[pattern_color], density=0.6)\n\n    # Calculate the starting position to center the pattern in the grid\n    start_x = (grid_width - pattern_size) // 2\n    start_y = (grid_height - pattern_size) // 2\n    \n    # Place the central pattern in the grid\n    grid = blit_sprite(grid=grid, sprite=central_pattern, x=start_x, y=start_y)\n    \n    # Fill the borders with the background color\n    grid[:start_y, :] = Color.BLACK\n    grid[start_y + pattern_size:, :] = Color.BLACK\n    grid[:, :start_x] = Color.BLACK\n    grid[:, start_x + pattern_size:] = Color.BLACK\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/83/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/83/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/83/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/83/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/83/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/83/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/83/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/83/images/train_output_2.png"}]}, "index": 83, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel mirroring, symmetry detection\n\n# description:\n# In the input, you will see a grid containing two horizontal colored stripes with a black background.\n# To produce the output, the transformation should identify the top stripe and mirror it onto the bottom of the grid.\n# If there is no top stripe, the output should be the original grid with the bottom stripe replaced by black pixels.\n\ndef main(input_grid):\n    # Get the shape of the grid\n    n, m = input_grid.shape\n    \n    # Find the first horizontal stripe (top stripe)\n    top_stripe = None\n    for i in range(n):\n        if np.any(input_grid[i] != Color.BLACK):  # Found a colored row\n            top_stripe = input_grid[i]\n            break\n    \n    if top_stripe is None:\n        # If there is no top stripe, return the original grid with the bottom stripe replaced by black\n        return np.full((n, m), Color.BLACK)\n    \n    # Find the last horizontal stripe (bottom stripe)\n    bottom_stripe = None\n    for i in range(n-1, -1, -1):\n        if np.any(input_grid[i] != Color.BLACK):  # Found a colored row\n            bottom_stripe = input_grid[i]\n            break\n\n    # Mirror the top stripe to the bottom\n    output_grid = input_grid.copy()\n    if bottom_stripe is not None:\n        output_grid[n - 1] = top_stripe  # Replace the last row with the top stripe\n        # Fill in any other rows below the top stripe with black\n        for i in range(1, n):\n            if output_grid[n - 1 - i, :].any() == False:\n                output_grid[n - 1 - i, :] = Color.BLACK\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid filled with black pixels\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random horizontal stripe in the upper half of the grid\n    top_row = np.random.randint(0, n // 2)\n    stripe_color = np.random.choice(Color.NOT_BLACK)\n    grid[top_row, :] = stripe_color\n\n    # Create a random horizontal stripe in the lower half of the grid\n    bottom_row = np.random.randint(n // 2, n)\n    if bottom_row != top_row:  # Ensure the bottom stripe is not in the same row as the top stripe\n        grid[bottom_row, :] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/84/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/84/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/84/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/84/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/84/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/84/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/84/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/84/images/train_output_2.png"}]}, "index": 84, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# zigzag pattern, path tracing\n\n# description:\n# In the input, you will see a zigzag path of a single color winding through a black grid. To create the output, trace the path by coloring the pixels along the zigzag in a bright hue, while leaving all other pixels unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the zigzag path color (the only color that forms a zigzag)\n    path_color = np.unique(input_grid[input_grid != Color.BLACK])[0]\n\n    # Get the coordinates of the path\n    path_coords = np.argwhere(input_grid == path_color)\n\n    # Trace the path by changing the color of the zigzag pixels to a bright hue\n    for x, y in path_coords:\n        output_grid[x, y] = Color.YELLOW  # Change the color to a bright hue (e.g., yellow)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define a path color\n    path_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a zigzag path\n    for i in range(n):\n        if i % 2 == 0:  # Even rows\n            grid[i, 0:m] = path_color  # Fill the entire row\n        else:  # Odd rows\n            grid[i, 1:m] = path_color  # Fill the row except the first column\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/85/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/85/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/85/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/85/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/85/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/85/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/85/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/85/images/train_output_2.png"}]}, "index": 85, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# spatial symmetry, reflection\n\n# description:\n# In the input, you will see a grid with a colored pattern on the left side and black on the right side.\n# To create the output, reflect the pattern across the vertical centerline of the grid,\n# ensuring that the colors match perfectly on both sides.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n\n    # Determine the vertical centerline\n    center = width // 2\n\n    # Extract the left half of the grid\n    left_pattern = input_grid[:, :center]\n\n    # Reflect the left pattern to create the right half\n    reflected_pattern = left_pattern[:, ::-1]\n\n    # Create the output grid by combining the left pattern and the reflected right pattern\n    output_grid = np.concatenate((left_pattern, reflected_pattern), axis=1)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly decide the dimensions of the grid\n    height = np.random.randint(5, 10)\n    width = np.random.randint(6, 12)  # Ensure width is even for symmetry\n\n    # Create a grid filled with black\n    grid = np.full((height, width), Color.BLACK)\n\n    # Define the width of the colored pattern on the left side\n    pattern_width = width // 2\n\n    # Generate a random pattern on the left side, ensuring it has colors\n    for i in range(height):\n        for j in range(pattern_width):\n            if np.random.rand() \u003c 0.5:  # Randomly decide if a color should be placed\n                grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/86/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/86/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/86/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/86/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/86/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/86/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/86/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/86/images/train_output_2.png"}]}, "index": 86, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pixel filling\n\n# description:\n# In the input, you will see a grid containing a shape that has top-bottom symmetry but is missing some pixels on the bottom half.\n# To create the output, fill in the missing pixels on the bottom half to create a symmetrical shape that mirrors the upper half.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = input_grid.copy()\n    \n    # Determine the height of the grid\n    height, width = output_grid.shape\n\n    # Process the top half and fill the bottom half to create symmetry\n    for x in range(height // 2):\n        for y in range(width):\n            # If the pixel in the top half is colored and the corresponding pixel in the bottom half is black, fill it in\n            if output_grid[x, y] != Color.BLACK and output_grid[height - 1 - x, y] == Color.BLACK:\n                output_grid[height - 1 - x, y] = output_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a symmetric pattern in the top half\n    density = np.random.uniform(0.4, 0.7)\n    sprite = random_sprite(n // 2, m, density=density, symmetry=\"vertical\", color_palette=list(Color.NOT_BLACK))\n\n    # Place the sprite in the top half of the grid\n    grid[:n//2, :] = sprite\n\n    # Randomly remove some pixels from the bottom half\n    for x in range(n // 2, n):\n        for y in range(m):\n            if np.random.random() \u003c 0.5:  # 50% chance to remove the pixel\n                grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/87/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/87/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/87/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/87/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/87/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/87/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/87/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/87/images/train_output_2.png"}]}, "index": 87, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal symmetry, color reflection\n\n# description:\n# In the input, you will see a pattern that is symmetric along the diagonal (top left to bottom right).\n# To make the output, reflect the pattern across the other diagonal (top right to bottom left) and fill the new area with the mirrored colors.\n\ndef main(input_grid):\n    # Take the input pattern\n    pattern = input_grid\n\n    # Create an output grid of the same size\n    output_grid = np.full((pattern.shape[0], pattern.shape[1]), Color.BLACK)\n\n    # Reflect the pattern across the other diagonal (top right to bottom left)\n    for i in range(pattern.shape[0]):\n        for j in range(pattern.shape[1]):\n            output_grid[j, i] = pattern[i, j]  # Swap i and j for reflection\n\n    return output_grid\n\ndef generate_input():\n    # Make a random square pattern of random size and colors\n    n = m = np.random.randint(3, 6)  # Size of the grid\n    grid = random_sprite(n, m, density=1, symmetry=\u0027diagonal\u0027, color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/88/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/88/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/88/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/88/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/88/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/88/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/88/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/88/images/train_output_2.png"}]}, "index": 88, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mixing, proximity\n\n# description:\n# In the input grid, you will see a variety of colored pixels scattered across a black background. \n# To create the output grid, each pixel in the grid should be transformed based on the colors of nearby pixels. \n# If a pixel has neighboring pixels of different colors, it will take on the average color of all nearby pixels. \n# The mixing is determined by proximity, with closer colors contributing more to the average.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Get the dimensions of the grid\n    rows, cols = input_grid.shape\n\n    # Iterate through each pixel in the input grid\n    for x in range(rows):\n        for y in range(cols):\n            # Take the color of the current pixel\n            current_color = input_grid[x, y]\n            if current_color == Color.BLACK:\n                continue  # Skip black pixels\n\n            # Collect nearby colors (considering 8-way connectivity)\n            nearby_colors = []\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    if dx == 0 and dy == 0:\n                        continue  # Skip the current pixel\n                    nx, ny = x + dx, y + dy\n                    # Check for valid indices\n                    if 0 \u003c= nx \u003c rows and 0 \u003c= ny \u003c cols:\n                        neighbor_color = input_grid[nx, ny]\n                        if neighbor_color != Color.BLACK:\n                            nearby_colors.append(neighbor_color)\n\n            # If there are nearby colors, mix them\n            if nearby_colors:\n                # Average the color values (assuming colors are mapped to integers)\n                avg_color = np.mean([color_to_int(c) for c in nearby_colors], dtype=int)\n                output_grid[x, y] = int_to_color(avg_color)\n            else:\n                output_grid[x, y] = current_color  # Retain the current color if no neighbors\n\n    return output_grid\n\ndef color_to_int(color):\n    # Convert color string to a corresponding integer representation for averaging\n    color_dict = {\n        Color.BLUE: 1,\n        Color.RED: 2,\n        Color.GREEN: 3,\n        Color.YELLOW: 4,\n        Color.GREY: 5,\n        Color.PINK: 6,\n        Color.ORANGE: 7,\n        Color.TEAL: 8,\n        Color.MAROON: 9,\n        Color.BLACK: 0,\n    }\n    return color_dict.get(color, 0)\n\ndef int_to_color(value):\n    # Convert integer representation back to color string\n    int_dict = {\n        1: Color.BLUE,\n        2: Color.RED,\n        3: Color.GREEN,\n        4: Color.YELLOW,\n        5: Color.GREY,\n        6: Color.PINK,\n        7: Color.ORANGE,\n        8: Color.TEAL,\n        9: Color.MAROON,\n        0: Color.BLACK,\n    }\n    return int_dict.get(value, Color.BLACK)\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly scatter colored pixels\n    num_pixels = np.random.randint(10, 50)\n    for _ in range(num_pixels):\n        x = np.random.randint(0, 20)\n        y = np.random.randint(0, 20)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/89/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/89/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/89/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/89/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/89/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/89/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/89/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/89/images/train_output_2.png"}]}, "index": 89, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, pattern enhancement\n\n# description:\n# In the input, you will see a half-circular pattern on one side of the grid. \n# To create the output, generate the mirror image of this half-circle pattern on the opposite side of the grid, \n# resulting in a complete circular design that highlights the original half-pattern.\n\ndef main(input_grid):\n    # Extract the half-pattern from the input grid\n    pattern = input_grid\n\n    # Create a mirrored version of the pattern horizontally\n    mirrored_pattern = np.flipud(pattern)\n\n    # Combine the original pattern with the mirrored pattern\n    output_grid = np.concatenate((pattern, mirrored_pattern), axis=0)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random sized grid with black background\n    height = np.random.randint(3, 6)\n    width = np.random.randint(3, 6)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Define the color for the half-circular pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a half-circle pattern on one side of the grid\n    for i in range(height):\n        for j in range(width):\n            if i + j \u003c width:  # Create a half-circle-like pattern\n                grid[i, j] = color if np.random.random() \u003c 0.5 else Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/90/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/90/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/90/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/90/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/90/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/90/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/90/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/90/images/train_output_2.png"}]}, "index": 90, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling gaps, adjacency\n\n# description:\n# The input grid consists of various colored regions separated by gaps of black pixels. \n# To create the output grid, fill in the black gaps with the color of the nearest adjacent colored region. \n# If a gap is equidistant to two colors, choose the color that appears first in the top-down, left-right scan of the grid.\n\ndef main(input_grid):\n    # Create a copy of the input grid to hold the output\n    output_grid = np.copy(input_grid)\n\n    # Get the unique colors in the input grid excluding black\n    unique_colors = set(np.unique(input_grid)) - {Color.BLACK}\n\n    # Loop through each pixel in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # If the current pixel is black, we need to fill it\n            if input_grid[x, y] == Color.BLACK:\n                # Collect colors of adjacent pixels\n                adjacent_colors = set()\n                # Check 4-connected neighbors\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 \u003c= nx \u003c input_grid.shape[0] and 0 \u003c= ny \u003c input_grid.shape[1]:\n                        if input_grid[nx, ny] in unique_colors:\n                            adjacent_colors.add(input_grid[nx, ny])\n                \n                # If there are adjacent colors, choose the first one found in a scan\n                if adjacent_colors:\n                    first_color = min(adjacent_colors, key=lambda color: (np.argwhere(input_grid == color).min(axis=0)))\n                    output_grid[x, y] = first_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size between 10x10 and 20x20\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter some colored regions (non-black) in the grid\n    num_colors = np.random.randint(2, 6)  # Random number of colors\n    colors = random.sample(Color.NOT_BLACK, num_colors)\n    \n    # Scatter colored regions and leave some gaps (black pixels)\n    for color in colors:\n        # Randomly generate the size and position of the colored region\n        region_size = np.random.randint(2, 5)\n        start_x = np.random.randint(0, n - region_size)\n        start_y = np.random.randint(0, m - region_size)\n        \n        # Fill in a colored region\n        for x in range(start_x, start_x + region_size):\n            for y in range(start_y, start_y + region_size):\n                grid[x, y] = color\n\n    # Introduce black gaps randomly within the grid\n    num_gaps = np.random.randint(10, 30)\n    for _ in range(num_gaps):\n        gap_x = np.random.randint(0, n)\n        gap_y = np.random.randint(0, m)\n        grid[gap_x, gap_y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/91/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/91/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/91/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/91/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/91/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/91/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/91/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/91/images/train_output_2.png"}]}, "index": 91, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# masking, color blending, pixel manipulation\n\n# description:\n# In the input, you will see a colorful object partially obscured by a large semi-transparent rectangle. The rectangle is a blend of its color and the background.\n# To create the output, remove the semi-transparent rectangle and reveal the full object, ensuring the colors are preserved.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color by checking for the most common color.\n    # 2. Identify the semi-transparent rectangle and the object.\n    # 3. Replace the area of the rectangle with the color of the object based on the blending rule.\n\n    # Step 1: Identify the background color\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n\n    # Step 2: Find the rectangle and the object\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    rectangle = None\n    for obj in objects:\n        if np.sum(obj != Color.BLACK) \u003c (input_grid.shape[0] * input_grid.shape[1]) // 4:  # Assuming the rectangle is less than 25% of the grid\n            rectangle = obj\n            break\n\n    output_grid = np.copy(input_grid)\n    \n    # Step 3: Remove the rectangle and restore the object\u0027s color\n    rectangle_mask = rectangle != Color.BLACK\n    output_grid[rectangle_mask] = background_color  # Initially set to background\n    object_color = np.unique(input_grid[~rectangle_mask])[0]  # Get the object\u0027s visible color\n\n    # Restore object color where the rectangle was\n    output_grid[rectangle_mask] = object_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a medium sized grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create an object\n    object_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(np.random.randint(3, n-2), np.random.randint(3, m-2), density=0.7, color_palette=[object_color])\n\n    # Place the object in the grid\n    sprite_x, sprite_y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=sprite_x, y=sprite_y)\n\n    # Create a semi-transparent rectangle\n    rectangle_color = np.random.choice(Color.NOT_BLACK)\n    rectangle = np.full((np.random.randint(4, 6), np.random.randint(4, 6)), rectangle_color)\n\n    # Overlay the rectangle on a position that intersects with the object\n    rectangle_x, rectangle_y = random_free_location_for_sprite(grid, rectangle)\n    blit_sprite(grid, rectangle, x=rectangle_x, y=rectangle_y, background=object_color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/92/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/92/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/92/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/92/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/92/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/92/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/92/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/92/images/train_output_2.png"}]}, "index": 92, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# merging shapes, color blending\n\n# description:\n# In the input, you will see two separate colored shapes on a grid, which may overlap. \n# If the shapes overlap, blend them to create a new color based on their combination.\n# The output should show the two shapes merged into one shape with blended color where they overlap.\n\ndef blend_colors(color1, color2):\n    # A simple blending function that combines two colors by averaging their color indices\n    return (color1 + color2) // 2\n\ndef main(input_grid):\n    # Find all connected components (shapes) in the grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    output_grid = np.zeros_like(input_grid)\n    \n    for shape in shapes:\n        # Extract the color of the current shape\n        shape_color = shape[0, 0]\n        # Find the bounding box of the shape\n        x, y, w, h = bounding_box(shape, background=Color.BLACK)\n\n        # Place the shape in the output grid\n        blit_sprite(output_grid, shape, x, y)\n\n        # Check for overlaps with other shapes\n        for other_shape in shapes:\n            if np.array_equal(shape, other_shape):\n                continue  # Don\u0027t compare the shape with itself\n            \n            # Check for overlap\n            overlap_area = np.logical_and(shape != Color.BLACK, other_shape != Color.BLACK)\n            if np.any(overlap_area):  # If there\u0027s any overlap\n                # Calculate the blended color\n                blended_color = blend_colors(shape_color, other_shape[0, 0])\n                output_grid[overlap_area] = blended_color\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random two distinct shapes\n    shape_colors = random.sample(Color.NOT_BLACK, k=2)\n\n    for color in shape_colors:\n        # Create a random shape\n        shape = random_sprite(np.random.randint(3, 7), np.random.randint(3, 7), color_palette=[color])\n        x, y = random_free_location_for_sprite(grid, shape, padding=1)\n        blit_sprite(grid, shape, x, y)\n\n    # Introduce some overlap\n    overlap_shape = random_sprite(np.random.randint(3, 7), np.random.randint(3, 7), color_palette=[shape_colors[0]])\n    x, y = random_free_location_for_sprite(grid, overlap_shape, padding=1)\n    blit_sprite(grid, overlap_shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/93/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/93/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/93/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/93/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/93/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/93/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/93/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/93/images/train_output_2.png"}]}, "index": 93, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, pixel transformation\n\n# description:\n# The input is a grid that contains various colors. To produce the output, you need to transform the grid by applying a specific rule:\n# - If a pixel is red, change it to blue.\n# - If a pixel is blue, change it to green.\n# - If a pixel is green, change it to red.\n# All other colors remain unchanged.\n# The background color is black and should remain black in the output.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Color transformation mapping\n    color_transform = {\n        Color.RED: Color.BLUE,\n        Color.BLUE: Color.GREEN,\n        Color.GREEN: Color.RED\n    }\n\n    # Apply the transformation based on the defined rules\n    for color, new_color in color_transform.items():\n        output_grid[input_grid == color] = new_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black background grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colors including red, blue, and green\n    colors_to_scatter = [Color.RED, Color.BLUE, Color.GREEN]\n    \n    for color in colors_to_scatter:\n        # Randomly scatter a certain number of pixels for each color\n        density = random.uniform(0.1, 0.3)  # Density for scattering\n        num_pixels = int(density * n * m)  # Total number of pixels to scatter\n        \n        # Scatter the specified color\n        for _ in range(num_pixels):\n            empty_cells = np.argwhere(grid == Color.BLACK)\n            if empty_cells.size \u003e 0:\n                x, y = random.choice(empty_cells)\n                grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/94/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/94/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/94/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/94/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/94/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/94/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/94/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/94/images/train_output_2.png"}]}, "index": 94, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel shifting, pattern recognition, overlapping regions\n\n# description:\n# In the input, you will see a series of colored patterns scattered throughout the grid. \n# Each colored pattern can be of varying shape and size. \n# To create the output, shift each colored pattern one pixel to the right and identify any patterns that overlap after the shift. \n# Highlight the overlapping regions in a new color, which is a combination of the two overlapping colors.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Find all connected components (patterns) in the input grid\n    patterns = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n\n    # Iterate over each found pattern\n    for pattern in patterns:\n        # Get the bounding box of the current pattern\n        x, y, width, height = bounding_box(pattern, background=Color.BLACK)\n        \n        # Shift the pattern one pixel to the right\n        shifted_x = x + 1\n        \n        # Create a blank grid\n        shifted_pattern = np.full(pattern.shape, Color.BLACK)\n        \n        # Place the original pattern shifted one pixel to the right\n        shifted_pattern[y:y + height, shifted_x:shifted_x + width] = pattern[y:y + height, x:x + width]\n        \n        # Identify overlapping regions by logical OR operation\n        overlap_mask = (output_grid != Color.BLACK) \u0026 (shifted_pattern != Color.BLACK)\n        \n        # Combine colors in overlapping regions\n        for i in range(output_grid.shape[0]):\n            for j in range(output_grid.shape[1]):\n                if overlap_mask[i, j]:\n                    # Blend the colors by creating a new color (in this case, just use a predefined new color)\n                    output_grid[i, j] = Color.MAROON  # Highlight overlap as maroon\n                    \n        # Update the output grid with the shifted pattern\n        output_grid = np.where(shifted_pattern != Color.BLACK, shifted_pattern, output_grid)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a number of patterns\n    num_patterns = np.random.randint(3, 6)\n    for _ in range(num_patterns):\n        # Choose a random color for the pattern\n        color = np.random.choice(list(Color.NOT_BLACK))\n        # Randomly generate the size of the pattern\n        pattern_height, pattern_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        # Randomly choose a position for the pattern\n        pos_x = np.random.randint(0, n - pattern_height)\n        pos_y = np.random.randint(0, m - pattern_width)\n        # Draw the pattern\n        draw_line(grid, x=pos_x, y=pos_y, length=pattern_width, color=color, direction=(0, 1))\n        draw_line(grid, x=pos_x, y=pos_y, length=pattern_height, color=color, direction=(1, 0))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/95/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/95/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/95/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/95/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/95/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/95/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/95/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/95/images/train_output_2.png"}]}, "index": 95, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color transformation, pixel mapping\n\n# description:\n# In the input, you will see clusters of colored pixels that form distinct shapes. \n# To make the output, identify each distinct shape and color them according to their label:\n# - The first distinct shape should be colored in red.\n# - The second distinct shape should be colored in blue.\n# - The third distinct shape should be colored in green.\n# - Any additional shapes should be colored in yellow.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Find connected components in the input grid\n    connected_components = find_connected_components(input_grid)\n\n    # Assign colors to each distinct shape\n    colors = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]\n    for index, component in enumerate(connected_components):\n        # Get the color for the current shape based on its index\n        color = colors[index] if index \u003c len(colors) else Color.YELLOW\n        \n        # Color the current component with the assigned color\n        output_grid[component == Color.BLACK] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a blank grid with a black background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of shapes (between 3 to 5) in the grid\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        # Create a random sprite for each shape that is non-monochromatic\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), density=0.5, color_palette=Color.NOT_BLACK)\n        \n        # Find a random position to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # Ignore placement failures\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/96/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/96/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/96/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/96/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/96/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/96/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/96/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/96/images/train_output_2.png"}]}, "index": 96, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, color extraction, transparency detection\n\n# description:\n# In the input, you will see a multi-layered grid where some layers are transparent and contain colored pixels beneath them.\n# To create the output, extract the visible colors from the layers and compile them into a new grid,\n# indicating which colors were obscured by the transparent layers.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Check the layers from top to bottom\n    height, width = input_grid.shape\n    for y in range(height):\n        for x in range(width):\n            # If the pixel is not transparent (not black), we keep it and mark the output\n            if input_grid[y, x] != Color.BLACK:\n                output_grid[y, x] = input_grid[y, x]\n            # If the pixel is transparent (black), we continue to check the next layer\n            else:\n                # Check pixels below this layer\n                for below_y in range(y + 1, height):\n                    if input_grid[below_y, x] != Color.BLACK:\n                        output_grid[y, x] = input_grid[below_y, x]\n                        break\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize a grid with a black background (transparent layer).\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the number of layers and their transparency\n    num_layers = np.random.randint(3, 6)\n\n    for layer in range(num_layers):\n        # Randomly create a layer with a mix of colored pixels and transparent (black) pixels\n        for y in range(n):\n            for x in range(m):\n                if np.random.rand() \u003e 0.5:  # 50% chance to place a color or leave it transparent\n                    color = np.random.choice(Color.NOT_BLACK)\n                    grid[y, x] = color\n                else:\n                    grid[y, x] = Color.BLACK  # Transparent pixel\n\n    # To ensure some colors are not completely hidden, we will add some colors explicitly\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(0, m), np.random.randint(0, n)\n        color = np.random.choice(Color.NOT_BLACK)\n        grid[y, x] = color  # Ensure at least some visible colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/97/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/97/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/97/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/97/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/97/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/97/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/97/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/97/images/train_output_2.png"}]}, "index": 97, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color inversion\n\n# description:\n# In the input, you will see a grid that contains a symmetric pattern of colored pixels. \n# To produce the output, if the pattern is symmetric along the vertical axis, invert the colors of the entire grid. \n# If it is not symmetric, leave the grid unchanged.\n\ndef main(input_grid):\n    # Check for vertical symmetry\n    if np.array_equal(input_grid, input_grid[:, ::-1]):\n        # Invert colors if symmetric\n        output_grid = np.where(input_grid == Color.BLACK, Color.GRAY, Color.BLACK)  # Example color inversion\n    else:\n        # If not symmetric, leave unchanged\n        output_grid = input_grid.copy()\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid of size between 5x5 and 7x7\n    n = np.random.randint(5, 8)\n    m = np.random.randint(5, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide if we want a symmetric or non-symmetric pattern\n    has_vertical_symmetry = np.random.choice([True, False])\n\n    # Fill the grid based on symmetry\n    if has_vertical_symmetry:\n        # Generate a symmetric pattern\n        pattern_height = np.random.randint(1, n // 2 + 1)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        for i in range(pattern_height):\n            for j in range(m // 2):\n                grid[i, j] = color\n                grid[i, m - j - 1] = color\n    else:\n        # Generate a non-symmetric pattern\n        density = np.random.random()\n        for i in range(n):\n            for j in range(m):\n                if np.random.random() \u003c density:\n                    grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/98/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/98/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/98/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/98/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/98/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/98/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/98/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/98/images/train_output_2.png"}]}, "index": 98, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pathfinding, color transformation, grid traversal\n\n# description:\n# In the input, you will see a maze-like structure where certain paths are colored green. \n# The task is to trace a path from the top left corner to the bottom right corner, \n# following the green paths and changing any blue pixels encountered along the way to green until reaching the exit.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Start from the top-left corner (0, 0)\n    start = (0, 0)\n    end = (input_grid.shape[0] - 1, input_grid.shape[1] - 1)\n\n    # Check if the start and end are valid (green)\n    if output_grid[start] != Color.GREEN or output_grid[end] != Color.GREEN:\n        return output_grid\n\n    # Initialize a queue for BFS\n    queue = [start]\n    visited = set()\n    visited.add(start)\n\n    while queue:\n        current = queue.pop(0)\n        x, y = current\n\n        # If we reach the end, break\n        if current == end:\n            break\n\n        # Check all four possible directions\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 \u003c= nx \u003c output_grid.shape[0] and 0 \u003c= ny \u003c output_grid.shape[1]:\n                if (nx, ny) not in visited:\n                    if output_grid[nx, ny] == Color.GREEN or output_grid[nx, ny] == Color.BLUE:\n                        # If it\u0027s blue, turn it green\n                        if output_grid[nx, ny] == Color.BLUE:\n                            output_grid[nx, ny] = Color.GREEN\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a maze-like structure using green paths\n    for i in range(n):\n        for j in range(m):\n            # Randomly assign green path or black background\n            if np.random.rand() \u003c 0.2:\n                grid[i, j] = Color.GREEN\n            else:\n                grid[i, j] = Color.BLACK\n\n    # Ensure the start and end points are green\n    grid[0, 0] = Color.GREEN\n    grid[n - 1, m - 1] = Color.GREEN\n\n    # Randomly place blue pixels on the grid\n    for blue_index in range(random.randint(5, 20)):\n        x, y = np.random.randint(1, n - 1), np.random.randint(1, m - 1)\n        grid[x, y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/99/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/99/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/99/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/99/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/99/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/99/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/99/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/99/images/train_output_2.png"}]}, "index": 99, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, overlapping transparency\n\n# description:\n# In the input, you will see a grid with several overlapping colored circles on a transparent background. \n# To create the output, blend the colors of the overlapping circles according to standard color blending rules (e.g., red + blue = orange). \n# The resulting blended colors should be displayed in their respective areas on the output grid.\n\ndef blend_colors(color1, color2):\n    # This is a simple blending function that determines the resulting color when two colors overlap.\n    # It uses predefined blending rules.\n    if color1 == Color.RED and color2 == Color.BLUE:\n        return Color.ORANGE\n    elif color1 == Color.BLUE and color2 == Color.RED:\n        return Color.ORANGE\n    elif color1 == Color.RED and color2 == Color.YELLOW:\n        return Color.ORANGE\n    elif color1 == Color.YELLOW and color2 == Color.RED:\n        return Color.ORANGE\n    elif color1 == Color.BLUE and color2 == Color.YELLOW:\n        return Color.GREEN\n    elif color1 == Color.YELLOW and color2 == Color.BLUE:\n        return Color.GREEN\n    elif color1 == color2:\n        return color1\n    return Color.GREY  # Default blending case for undefined color pairs\n\ndef main(input_grid):\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find and blend colors in overlapping areas\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x][y] != Color.BLACK:\n                # Check for overlapping colors in the surrounding area\n                overlapped_colors = set()\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                            if input_grid[x + dx][y + dy] != Color.BLACK:\n                                overlapped_colors.add(input_grid[x + dx][y + dy])\n                # Blend the colors found in the overlapping area\n                if overlapped_colors:\n                    blended_color = Color.BLACK\n                    for color in overlapped_colors:\n                        blended_color = blend_colors(blended_color, color)\n                    output_grid[x][y] = blended_color\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_circles = np.random.randint(5, 10)\n\n    for _ in range(num_circles):\n        # Create random circles of colors\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.BLACK])\n        radius = np.random.randint(1, 4)\n        center_x, center_y = np.random.randint(radius, n - radius), np.random.randint(radius, m - radius)\n\n        for x in range(-radius, radius + 1):\n            for y in range(-radius, radius + 1):\n                if x**2 + y**2 \u003c= radius**2:  # Inside the circle\n                    if 0 \u003c= center_x + x \u003c n and 0 \u003c= center_y + y \u003c m:\n                        grid[center_x + x, center_y + y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/100/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/100/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/100/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/100/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/100/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/100/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/100/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/100/images/train_output_2.png"}]}, "index": 100, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, rotation, color transformation\n\n# description:\n# In the input, you will see a grid containing a recognizable pattern of colored pixels. \n# To create the output, rotate this pattern 90 degrees clockwise, \n# then replace all pixels in the corners of the output grid with the color of the original pattern\u0027s center pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Identify the central pixel color\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    center_color = input_grid[center_x, center_y]\n\n    # Rotate the input grid 90 degrees clockwise\n    rotated_grid = np.rot90(input_grid, k=-1)\n\n    # Create the output grid with the same dimensions\n    output_grid = np.copy(rotated_grid)\n\n    # Replace the corners with the center color\n    output_grid[0, 0] = center_color\n    output_grid[0, -1] = center_color\n    output_grid[-1, 0] = center_color\n    output_grid[-1, -1] = center_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Random dimensions for the grid\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n\n    # Create a grid filled with black\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the pattern in the center\n    pattern_colors = np.random.choice(list(Color.NOT_BLACK), size=(n, m), replace=True)\n\n    # Fill in the grid with random colors\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = pattern_colors[i, j]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/101/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/101/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/101/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/101/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/101/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/101/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/101/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/101/images/train_output_2.png"}]}, "index": 101, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, boundary detection\n\n# description:\n# In the input grid, you will see a colored shape located in the center of a black grid.\n# To produce the output grid, you must rotate the shape 90 degrees clockwise, ensuring that it remains within the boundaries of the grid.\n\ndef main(input_grid):\n    # Step 1: Identify the bounding box of the colored shape.\n    shape_bbox = crop(input_grid, background=Color.BLACK)\n    \n    # Step 2: Create an empty output grid.\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Step 3: Rotate the cropped shape 90 degrees clockwise.\n    # Shape rotation can be achieved by reversing the order of rows and then transposing.\n    rotated_shape = np.rot90(shape_bbox, k=-1)  # k=-1 for 90 degrees clockwise\n\n    # Step 4: Calculate the center position for the rotated shape.\n    center_x = (output_grid.shape[0] - rotated_shape.shape[0]) // 2\n    center_y = (output_grid.shape[1] - rotated_shape.shape[1]) // 2\n\n    # Step 5: Place the rotated shape back in the output grid.\n    # Blit the rotated shape to the center of the output grid.\n    blit_sprite(output_grid, rotated_shape, x=center_x, y=center_y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 12x12 black grid\n    input_grid = np.full((12, 12), Color.BLACK)\n\n    # Create a random sprite with a size between 2x2 and 6x6\n    width = np.random.randint(2, 7)\n    height = np.random.randint(2, 7)\n    sprite_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(width, height, color_palette=[sprite_color])\n\n    # Place the sprite in the center of the grid\n    x = (input_grid.shape[0] - sprite.shape[0]) // 2\n    y = (input_grid.shape[1] - sprite.shape[1]) // 2\n    blit_sprite(input_grid, sprite, x=x, y=y)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/102/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/102/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/102/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/102/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/102/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/102/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/102/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/102/images/train_output_2.png"}]}, "index": 102, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shadow casting, pixel offset\n\n# description:\n# In the input, you will see a colored object on a light background. \n# To create the output, cast a shadow from the object by offsetting \n# the pixels of the object downward and to the right, coloring the \n# shadow a darker shade of the object\u0027s color.\n\ndef main(input_grid):\n    # Create output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the bounding box of the colored object\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Get the object\u0027s color\n    object_color = input_grid[x, y]\n\n    # Create a darker version of the object\u0027s color\n    if object_color == Color.RED:\n        shadow_color = Color.MAROON\n    elif object_color == Color.GREEN:\n        shadow_color = Color.GREY\n    elif object_color == Color.BLUE:\n        shadow_color = Color.TEAL\n    elif object_color == Color.YELLOW:\n        shadow_color = Color.ORANGE\n    elif object_color == Color.PINK:\n        shadow_color = Color.MAROON\n    elif object_color == Color.TEAL:\n        shadow_color = Color.BLUE\n    elif object_color == Color.GREY:\n        shadow_color = Color.BLACK\n    elif object_color == Color.ORANGE:\n        shadow_color = Color.RED\n    elif object_color == Color.MAROON:\n        shadow_color = Color.PINK\n    else:\n        shadow_color = Color.BLACK  # default case if color is not recognized\n\n    # Offset the pixels of the object to create a shadow\n    for dx in range(width):\n        for dy in range(height):\n            if input_grid[x + dx, y + dy] == object_color:\n                output_grid[x + dx + 1, y + dy + 1] = shadow_color  # downward and to the right\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid for the background\n    n = m = np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the sprite\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a simple square sprite\n    sprite_width, sprite_height = np.random.randint(1, 3), np.random.randint(1, 3)\n    sprite = random_sprite(sprite_width, sprite_height, color_palette=[sprite_color], density=1)\n\n    # Place the sprite in the middle of the grid\n    sprite_x, sprite_y = (n - sprite_width) // 2, (m - sprite_height) // 2\n    blit_sprite(grid, sprite, x=sprite_x, y=sprite_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/103/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/103/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/103/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/103/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/103/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/103/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/103/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/103/images/train_output_2.png"}]}, "index": 103, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object attraction, movement towards center\n\n# description:\n# In the input, you will see two different colored objects on a grid. \n# To create the output, draw a line connecting the centers of the two objects, \n# and alter their positions slightly to be closer together based on the color of the objects. \n# If both colors are warm (red, orange, yellow), move them closer by two cells; \n# if both are cool (blue, teal), move them closer by one cell; \n# if one is warm and the other is cool, move them closer by one cell as well.\n\ndef main(input_grid):\n    # Make a copy of the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components (objects) in the grid\n    objects = find_connected_components(grid=input_grid, monochromatic=False, connectivity=4)\n    \n    # We expect two objects in the input\n    assert len(objects) == 2\n\n    # Get the centers of the two objects\n    centers = []\n    for obj in objects:\n        # Calculate the center of the object\n        y, x = np.argwhere(obj)[0]  # Get the first pixel of the object\n        centers.append((y, x))\n\n    # Extract the colors of the objects\n    colors = [output_grid[y, x] for (y, x) in centers]\n\n    # Determine the attraction distance based on object colors\n    warm_colors = {Color.RED, Color.ORANGE, Color.YELLOW}\n    cool_colors = {Color.BLUE, Color.TEAL}\n    \n    if set(colors).issubset(warm_colors):\n        move_distance = 2\n    elif set(colors).issubset(cool_colors):\n        move_distance = 1\n    else:\n        move_distance = 1\n\n    # Calculate the new positions for the objects\n    def move_towards(a, b, distance):\n        ay, ax = a\n        by, bx = b\n        dy = np.sign(by - ay) * distance\n        dx = np.sign(bx - ax) * distance\n        return (ay + dy, ax + dx)\n\n    new_centers = [move_towards(centers[0], centers[1], move_distance), \n                   move_towards(centers[1], centers[0], move_distance)]\n\n    # Move the objects to their new positions\n    for i, (y, x) in enumerate(centers):\n        new_y, new_x = new_centers[i]\n        translated_object = translate(objects[i], new_x - x, new_y - y, background=Color.BLACK)\n        output_grid = blit_object(output_grid, translated_object, background=Color.BLACK)\n\n    # Draw a line connecting the two new centers\n    draw_line(output_grid, new_centers[0][0], new_centers[0][1], new_centers[1][0], new_centers[1][1], color=Color.RED)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define two colors for the objects\n    colors = [Color.RED, Color.BLUE]  # One warm, one cool\n\n    # Generate two random positions for the objects ensuring they do not overlap\n    for color in colors:\n        while True:\n            y, x = np.random.randint(1, n-1), np.random.randint(1, m-1)\n            if grid[y, x] == Color.BLACK:\n                # Create a small object (e.g., 2x2 square)\n                obj = np.full((2, 2), color)\n                blit_sprite(grid, obj, x, y, background=Color.BLACK)\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/104/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/104/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/104/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/104/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/104/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/104/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/104/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/104/images/train_output_2.png"}]}, "index": 104, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color filling, pattern completion\n\n# description:\n# In the input, you will see a grid with a pattern that is symmetric about both axes, but with one color missing in the center. \n# To create the output, find the missing color and fill in the center pixel to complete the symmetry.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Calculate the center pixel coordinates\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n\n    # Get the colors surrounding the center pixel\n    surrounding_colors = [\n        output_grid[center_x - 1, center_y],\n        output_grid[center_x + 1, center_y],\n        output_grid[center_x, center_y - 1],\n        output_grid[center_x, center_y + 1]\n    ]\n\n    # Find the unique colors surrounding the center; ignore black\n    unique_colors = set(surrounding_colors) - {Color.BLACK}\n\n    # If there\u0027s one unique color, fill the center pixel with that color\n    if len(unique_colors) == 1:\n        output_grid[center_x, center_y] = unique_colors.pop()\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the pattern \n    n, m = random.randint(5, 9), random.randint(5, 9)\n\n    # Generate a random symmetric pattern (without the center color)\n    pattern = random_sprite(n, m, density=0.5, symmetry=\u0027horizontal\u0027, color_palette=list(Color.NOT_BLACK))\n\n    # Set the center pixel to black to simulate the missing color\n    center_x, center_y = n // 2, m // 2\n    pattern[center_x, center_y] = Color.BLACK\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/105/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/105/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/105/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/105/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/105/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/105/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/105/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/105/images/train_output_2.png"}]}, "index": 105, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel expansion, pattern generation\n\n# description:\n# In the input, you will see a small colored shape on a black background.\n# To produce the output, grow the shape outward by expanding each pixel into a 5x5 block of the same color,\n# while maintaining the center pixel of the original shape as the main color and filling the surrounding area with a secondary color.\n\ndef main(input_grid):\n    # Retrieve the connected components, which should contain our colored shape\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    \n    # Prepare an output grid, initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    for obj in objects:\n        # Get the bounding box of the shape\n        x, y, w, h = bounding_box(obj)\n\n        # Use the color of the center pixel as the main color\n        center_x, center_y = x + w // 2, y + h // 2\n        main_color = obj[center_x, center_y]\n\n        # Use the first non-black color found in the shape as the secondary color\n        secondary_color = obj[obj != Color.BLACK][0]\n\n        # Expand the shape into a 5x5 block\n        for i in range(-2, 3):\n            for j in range(-2, 3):\n                # Determine the output coordinates\n                output_x = center_x + i\n                output_y = center_y + j\n\n                # Set the colors according to the conditions\n                if (i == 0 and j == 0):\n                    # Center pixel gets the main color\n                    output_grid[output_x, output_y] = main_color\n                else:\n                    # Surrounding pixels get the secondary color\n                    output_grid[output_x, output_y] = secondary_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 12x12 input grid\n    grid = np.zeros((12, 12), dtype=int)\n\n    # Create a random shape (2-4 pixels in width and height)\n    w = np.random.randint(2, 5)\n    h = np.random.randint(2, 5)\n    sprite = random_sprite(w, h, color_palette=list(Color.NOT_BLACK))\n\n    # Find a random free location for the sprite\n    x, y = random_free_location_for_sprite(grid, sprite)\n\n    # Blit the sprite onto the input grid\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/106/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/106/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/106/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/106/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/106/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/106/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/106/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/106/images/train_output_2.png"}]}, "index": 106, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, grid manipulation\n\n# description:\n# In the input, you will see a grid containing a colorful shape on a black background. The shape will consist of several connected colored pixels. \n# To make the output, convert every color in the shape to its complementary color, while keeping the shape\u0027s structure intact.\n\ndef main(input_grid):\n    # Initialize output grid with the same dimensions as input\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Define a function to find the complementary color\n    def complement_color(color):\n        color_map = {\n            Color.BLACK: Color.BLACK,\n            Color.BLUE: Color.YELLOW,\n            Color.RED: Color.GREEN,\n            Color.GREEN: Color.RED,\n            Color.YELLOW: Color.BLUE,\n            Color.GREY: Color.GREY,\n            Color.PINK: Color.MAROON,\n            Color.ORANGE: Color.TEAL,\n            Color.TEAL: Color.ORANGE,\n            Color.MAROON: Color.PINK\n        }\n        return color_map[color]\n\n    # Iterate through the input grid and apply the color transformation\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            current_color = input_grid[i, j]\n            if current_color != Color.BLACK:  # Only change non-black colors\n                output_grid[i, j] = complement_color(current_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size between 10x10 and 15x15\n    n = np.random.randint(10, 16)\n    m = np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a random sprite of size (2-7)x(2-7)\n    w = np.random.randint(2, 8)\n    h = np.random.randint(2, 8)\n    sprite = random_sprite(w, h, density=0.5, color_palette=Color.NOT_BLACK)\n\n    # Place the sprite onto a random location on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/107/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/107/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/107/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/107/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/107/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/107/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/107/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/107/images/train_output_2.png"}]}, "index": 107, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel rotation, symmetry\n\n# description:\n# In the input, you will see a grid with a symmetrical pattern of colored pixels.\n# To create the output, rotate the entire pattern by 90 degrees clockwise, maintaining the colors and positions of the pixels.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid with the dimensions swapped\n    output_grid = np.full((m, n), Color.BLACK)\n    \n    # Rotate the input grid 90 degrees clockwise\n    for i in range(n):\n        for j in range(m):\n            output_grid[j, n - 1 - i] = input_grid[i, j]\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a symmetrical pattern\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n    \n    # Create a grid with a black background\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Create a color for the symmetrical pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Randomly choose a point for the center of a symmetrical pattern\n    center_x = np.random.randint(0, n)\n    center_y = np.random.randint(0, m)\n    \n    # Draw a symmetrical pattern around the center\n    for dx in range(-1, 2):  # -1, 0, 1\n        for dy in range(-1, 2):  # -1, 0, 1\n            if (dx, dy) != (0, 0):  # Skip the center point\n                grid[center_x + dx, center_y + dy] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/108/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/108/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/108/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/108/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/108/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/108/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/108/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/108/images/train_output_2.png"}]}, "index": 108, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel reflection, dual symmetry, color filling\n\n# description:\n# In the input, you will see a symmetric shape along both the horizontal and vertical axes, consisting of a specific color on a black background. \n# To make the output, reflect the shape across both axes and fill the gaps with the same color as the original shape to create a larger symmetric pattern.\n\ndef main(input_grid):\n    # Find the bounding box of the symmetric shape\n    x, y, width, height = bounding_box(input_grid)\n    \n    # Extract the original shape\n    original_shape = input_grid[x:x + height, y:y + width]\n    \n    # Reflect the shape horizontally and vertically\n    reflected_shape_h = original_shape[::-1, :]\n    reflected_shape_v = original_shape[:, ::-1]\n    \n    # Create the output grid which is large enough to hold the original and its reflections\n    output_grid_height = height * 2\n    output_grid_width = width * 2\n    output_grid = np.full((output_grid_height, output_grid_width), Color.BLACK)\n    \n    # Place the original shape and its reflections into the output grid\n    output_grid[0:height, 0:width] = original_shape\n    output_grid[0:height, width:output_grid_width] = reflected_shape_v\n    output_grid[height:output_grid_height, 0:width] = reflected_shape_h\n    output_grid[height:output_grid_height, width:output_grid_width] = original_shape[::-1, ::-1]\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium-sized grid for the symmetric shape\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random symmetric shape\n    sprite = random_sprite(np.random.randint(3, n), np.random.randint(3, m), density=0.5, symmetry=\"horizontal\", color_palette=Color.NOT_BLACK)\n\n    # Place the sprite in the grid at a random location\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=x, y=y)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/109/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/109/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/109/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/109/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/109/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/109/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/109/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/109/images/train_output_2.png"}]}, "index": 109, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel clustering, radial symmetry\n\n# description:\n# In the input, you will see a cluster of colored pixels arranged in a circular pattern around a central pixel. \n# To create the output, identify the central pixel (the one with the lowest brightness) and then draw lines outward from this central pixel to fill the surrounding pixels with the color of that pixel, \n# creating a radial effect. The lines will extend outward in all directions until they hit the edge of the grid or a non-background pixel.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Find the central pixel: the one with the lowest brightness (or lowest index in this case)\n    central_pixel_position = np.unravel_index(np.argmin(input_grid), input_grid.shape)\n    central_color = input_grid[central_pixel_position]\n\n    # Draw lines outward from the central pixel in all directions until we hit the edge of the grid\n    for angle in np.linspace(0, 2 * np.pi, num=8, endpoint=False):\n        direction = (int(np.round(np.cos(angle))), int(np.round(np.sin(angle))))\n        x, y = central_pixel_position\n\n        # Extend the line in the chosen direction\n        while 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:\n            output_grid[x, y] = central_color\n            x += direction[0]\n            y += direction[1]\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly choose a pixel to be the central pixel\n    center_x, center_y = np.random.randint(1, 19), np.random.randint(1, 19)\n    central_color = np.random.choice(Color.NOT_BLACK)\n\n    # Set the central pixel\n    input_grid[center_x, center_y] = central_color\n\n    # Create a circular pattern around the central pixel\n    for angle in np.linspace(0, 2 * np.pi, num=12, endpoint=False):\n        radius = 3\n        x = int(center_x + radius * np.cos(angle))\n        y = int(center_y + radius * np.sin(angle))\n        \n        if 0 \u003c= x \u003c 20 and 0 \u003c= y \u003c 20:\n            input_grid[x, y] = central_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/110/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/110/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/110/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/110/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/110/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/110/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/110/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/110/images/train_output_2.png"}]}, "index": 110, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel connection, obstacle avoidance\n\n# description:\n# In the input, you will see a grid with several yellow pixels and gray obstacles scattered throughout the grid. \n# The task is to connect each yellow pixel to the nearest yellow pixel using a continuous line of blue pixels, \n# avoiding any gray obstacles in the path. The output should show these blue connections between the yellow pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    yellow_pixels = np.argwhere(input_grid == Color.YELLOW)\n\n    # A function to find the nearest yellow pixel and draw a line to it\n    def draw_connection(start_pos):\n        start_x, start_y = start_pos\n        nearest_dist = float(\u0027inf\u0027)\n        nearest_pos = None\n\n        for target_pos in yellow_pixels:\n            target_x, target_y = target_pos\n            if (start_x, start_y) != (target_x, target_y):\n                distance = abs(start_x - target_x) + abs(start_y - target_y)  # Manhattan distance\n                if distance \u003c nearest_dist:\n                    nearest_dist = distance\n                    nearest_pos = target_pos\n\n        if nearest_pos is not None:\n            # Draw a blue line from start_pos to nearest_pos\n            end_x, end_y = nearest_pos\n            draw_line(output_grid, start_x, start_y, end_x=end_x, end_y=end_y, color=Color.BLUE, stop_at_color=[Color.GRAY])\n\n    # Iterate over each yellow pixel and connect them\n    for yellow_pixel in yellow_pixels:\n        draw_connection(tuple(yellow_pixel))\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter yellow pixels\n    num_yellow = np.random.randint(3, 7)\n    yellow_positions = set()\n\n    while len(yellow_positions) \u003c num_yellow:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        yellow_positions.add((x, y))\n    \n    for pos in yellow_positions:\n        grid[pos] = Color.YELLOW\n\n    # Randomly scatter gray obstacles\n    num_gray = np.random.randint(5, 15)\n    for _ in range(num_gray):\n        while True:\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            if grid[x, y] == Color.BLACK:  # Ensure we don\u0027t overwrite yellow pixels\n                grid[x, y] = Color.GRAY\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/111/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/111/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/111/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/111/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/111/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/111/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/111/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/111/images/train_output_2.png"}]}, "index": 111, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color filling\n\n# description:\n# In the input, you will see a grid with a pattern that is horizontally symmetric, but one half is missing some pixels. \n# To make the output, fill in the missing pixels on one side to complete the horizontal symmetry, using the colors from the opposite side.\n\ndef main(input_grid):\n    # Get the number of rows and columns in the grid\n    n, m = input_grid.shape\n    \n    # Create an output grid initialized to black\n    output_grid = np.full((n, m), Color.BLACK)\n    \n    # Fill the output grid with the colors from the input grid, copying left to right\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] != Color.BLACK:\n                output_grid[i, j] = input_grid[i, j]\n                \n            # Check for horizontal symmetry and fill in the missing pixels\n            if input_grid[i, j] == Color.BLACK:\n                opposite_index = m - j - 1\n                if input_grid[i, opposite_index] != Color.BLACK:\n                    output_grid[i, j] = input_grid[i, opposite_index]\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n = np.random.randint(5, 8)\n    m = np.random.randint(5, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color for the patterns\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the left half of the grid with a random pattern\n    for i in range(n):\n        for j in range(m // 2):\n            grid[i, j] = np.random.choice([color, Color.BLACK])\n\n    # Create symmetry by copying the left half to the right, but some pixels are blacked out\n    for i in range(n):\n        for j in range(m // 2, m):\n            if np.random.rand() \u003e 0.5:  # Randomly decide if this pixel is blacked out\n                grid[i, j] = Color.BLACK\n            else:\n                grid[i, j] = grid[i, m - j - 1]  # Copy from the left half\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/112/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/112/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/112/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/112/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/112/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/112/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/112/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/112/images/train_output_2.png"}]}, "index": 112, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, occlusion, color detection\n\n# description:\n# In the input, you will see a grid with multiple layers of colored objects, some of which are partially occluded.\n# To create the output, remove the occluding layers to reveal the bottom layers and color them according to their original color.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all colored objects (non-background) in the input grid.\n    # 2. Create an output grid initialized to the background color.\n    # 3. Iterate through the detected objects from top to bottom to reveal the original colors of the bottom layers.\n\n    # Detect connected components (objects) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Prepare an output grid initialized to the background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Process each detected object\n    for obj in objects:\n        # Crop the object to get its actual shape\n        cropped_obj = crop(obj, background=Color.BLACK)\n\n        # Get the color of the object\n        unique_colors = np.unique(cropped_obj[cropped_obj != Color.BLACK])\n        \n        # If there are colors in the object, we want to place it in the output grid\n        if len(unique_colors) \u003e 0:\n            # Find the position to place the object (bottom-most available position)\n            y_offset = np.where((output_grid == Color.BLACK).any(axis=1))[0][0]\n            x_offset = (output_grid.shape[1] - cropped_obj.shape[1]) // 2  # Center the object\n\n            # Check for collision and blit the object if no color matches\n            if collision(object1=output_grid, object2=cropped_obj, x2=x_offset, y2=y_offset):\n                # Only place the object if it doesn\u0027t collide with already placed objects\n                continue\n            \n            # Blit the object into the output grid\n            blit_sprite(output_grid, cropped_obj, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a larger canvas to place multiple layers of objects\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly determine the number of layers and their colors\n    num_layers = np.random.randint(3, 5)\n    layers = []\n    \n    for _ in range(num_layers):\n        # Create a random sprite\n        layer_color = np.random.choice(list(Color.NOT_BLACK))\n        layer_sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.5, color_palette=[layer_color])\n        \n        # Find a random location for this layer\n        x, y = random_free_location_for_sprite(grid, layer_sprite, background=Color.BLACK, padding=1)\n        \n        # Blit the layer onto the grid\n        blit_sprite(grid, layer_sprite, x=x, y=y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/113/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/113/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/113/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/113/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/113/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/113/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/113/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/113/images/train_output_2.png"}]}, "index": 113, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, counting regions\n\n# description:\n# In the input grid, you will see several regions of colors where each region is surrounded by black pixels. \n# The goal is to replace each distinct color region (except black) with a new color. The first detected region should be colored red, \n# the second blue, the third green, and so on until all regions are mapped to colors. \n# If there are more regions than available colors, the additional regions will remain unchanged.\n\ndef main(input_grid):\n    # Create an output grid to copy the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find all connected regions excluding black\n    regions = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Define the colors to use for coloring regions\n    colors = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.ORANGE, Color.TEAL, Color.PINK, Color.MAROON, Color.GREY]\n\n    # Color each region with a corresponding color\n    for i, region in enumerate(regions):\n        if i \u003c len(colors):\n            # Get a representative pixel of the region to fill\n            x, y = np.where(region == region[0, 0])\n            flood_fill(output_grid, x[0], y[0], colors[i])\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid with random dimensions between 10 and 20\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of colored regions\n    num_regions = np.random.randint(3, 8)\n\n    for _ in range(num_regions):\n        # Generate random sprite parameters for regions\n        region_width = np.random.randint(3, 6)\n        region_height = np.random.randint(3, 6)\n        color = np.random.choice(list(Color.NOT_BLACK))  # Choose a random color excluding black\n        sprite = random_sprite(region_height, region_width, color_palette=[color], connectivity=4)\n\n        # Find a random free location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except:\n            continue  # Continue to the next region if no free space is found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/114/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/114/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/114/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/114/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/114/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/114/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/114/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/114/images/train_output_2.png"}]}, "index": 114, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color separation, pattern extraction, color transformation\n\n# description:\n# In the input, you will see a grid filled with a mixture of two colors: blue and yellow. \n# The blue pixels represent a shape that is surrounded by yellow pixels. \n# To make the output, extract the blue shape and fill the area surrounding it with orange pixels, \n# while keeping the blue shape unchanged.\n\ndef main(input_grid):\n    # Detect the blue object in the input grid\n    blue_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=False)\n\n    # Create an output grid with the same dimensions as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Fill the output grid with orange color\n    output_grid.fill(Color.ORANGE)\n\n    # For each detected blue object, overlay it onto the output grid\n    for blue_object in blue_objects:\n        cropped_blue = crop(grid=blue_object, background=Color.YELLOW)  # Crop the blue object\n        x, y, _, _ = bounding_box(grid=blue_object, background=Color.YELLOW)  # Get bounding box\n        blit_sprite(output_grid, cropped_blue, x, y, background=Color.ORANGE)  # Place blue object\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a size ranging from 6x6 to 10x10\n    n = np.random.randint(6, 11)\n    m = np.random.randint(6, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a blue shape surrounded by yellow\n    # Randomly generate a shape size\n    shape_height = np.random.randint(2, 5)\n    shape_width = np.random.randint(2, 5)\n\n    # Randomly determine starting position for the shape\n    start_x = np.random.randint(1, n - shape_height - 1)\n    start_y = np.random.randint(1, m - shape_width - 1)\n\n    # Fill the shape with blue\n    for i in range(shape_height):\n        for j in range(shape_width):\n            grid[start_x + i, start_y + j] = Color.BLUE\n            \n    # Surround the blue shape with yellow\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.BLUE:\n                continue\n            # Set all other pixels to yellow\n            grid[i, j] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/115/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/115/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/115/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/115/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/115/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/115/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/115/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/115/images/train_output_2.png"}]}, "index": 115, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pathfinding, connectivity, color transformation\n\n# description:\n# In the input, you will see a grid consisting of a winding path formed by a specific color, surrounded by a background color. \n# To create the output, trace the path of the specific color and fill it with a new color while leaving the background and other colors unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Define the path color (the color to be transformed)\n    path_color = np.unique(input_grid)[1]  # Assume the second unique color is the path color\n\n    # Find the connected components of the path\n    path_components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n    \n    # Define the new color to fill the path\n    new_color = Color.RED  # You can choose any color here\n\n    # Fill the path components with the new color in the output grid\n    for component in path_components:\n        if path_color in component:  # Only fill components that contain the path color\n            indices = np.argwhere(input_grid == path_color)\n            for x, y in indices:\n                output_grid[x, y] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a specified size\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Randomly select a color for the path\n    path_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a winding path using random movements\n    x, y = np.random.randint(1, n-1), np.random.randint(1, m-1)  # Start somewhere in the grid\n    grid[x, y] = path_color\n\n    for _ in range(np.random.randint(10, 20)):  # Randomly create a winding path\n        direction = np.random.choice([\u0027up\u0027, \u0027down\u0027, \u0027left\u0027, \u0027right\u0027])\n        if direction == \u0027up\u0027 and x \u003e 0:\n            x -= 1\n        elif direction == \u0027down\u0027 and x \u003c n - 1:\n            x += 1\n        elif direction == \u0027left\u0027 and y \u003e 0:\n            y -= 1\n        elif direction == \u0027right\u0027 and y \u003c m - 1:\n            y += 1\n        grid[x, y] = path_color  # Mark the new position as part of the path\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/116/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/116/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/116/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/116/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/116/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/116/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/116/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/116/images/train_output_2.png"}]}, "index": 116, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel counting, filling, color mapping\n\n# description:\n# In the input grid, you will see clusters of colored pixels scattered throughout a black background.\n# To create the output, count the number of pixels in each cluster and fill a new grid with colored squares corresponding to the size of each cluster, \n# starting from the largest to the smallest. Each unique cluster\u0027s size will be represented by a different color in the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find connected components in the input grid\n    clusters = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Count the number of pixels in each cluster and map them to their sizes\n    cluster_sizes = [(np.sum(cluster == cluster[0]), cluster) for cluster in clusters]\n\n    # Sort clusters by size, largest first\n    cluster_sizes.sort(key=lambda x: x[0], reverse=True)\n\n    # Create output grid based on sizes\n    output_grid = np.zeros_like(input_grid)\n    \n    # Color mapping for sizes\n    colors_for_sizes = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.ORANGE, Color.PINK, Color.TEAL, Color.GREY, Color.MAROON, Color.GRAY]\n    \n    for index, (size, cluster) in enumerate(cluster_sizes):\n        # Check if the size is larger than the colors available\n        if index \u003c len(colors_for_sizes):\n            fill_color = colors_for_sizes[index]\n            output_grid[cluster == cluster[0]] = fill_color  # Fill the cluster in the output grid with the corresponding color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid for the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the number of clusters and their maximum size\n    num_clusters = np.random.randint(3, 6)  # Create between 3 and 5 clusters\n    max_cluster_size = 6\n\n    for _ in range(num_clusters):\n        # Randomly generate a cluster size between 1 and max_cluster_size\n        cluster_size = np.random.randint(1, max_cluster_size + 1)\n\n        # Create a random sprite for the cluster\n        sprite = random_sprite(cluster_size, cluster_size, density=1, color_palette=[Color.RED])  # All pixels will be the same color\n\n        # Find a random location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            continue  # If there is no space, we skip placing this cluster\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/117/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/117/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/117/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/117/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/117/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/117/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/117/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/117/images/train_output_2.png"}]}, "index": 117, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color proximity, gradient blending\n\n# description:\n# In the input, you will see a cluster of colored pixels on a black background. \n# To create the output, identify the closest colored pixel to each other and create a gradient transition between these pixels, \n# fading from one color to another as the distance decreases.\n\ndef main(input_grid):\n    # Make output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the non-background colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # If there are fewer than two colored pixels, return the original grid\n    if len(colored_pixels) \u003c 2:\n        return output_grid\n\n    # Calculate distances between all pairs of colored pixels\n    colors = [input_grid[x, y] for x, y in colored_pixels]\n    distances = np.zeros((len(colored_pixels), len(colored_pixels)))\n\n    for i, (x1, y1) in enumerate(colored_pixels):\n        for j, (x2, y2) in enumerate(colored_pixels):\n            distances[i, j] = np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    # For each pixel, find the closest colored pixel and blend colors\n    for i, (x, y) in enumerate(colored_pixels):\n        closest_color_idx = np.argmin(distances[i][distances[i] \u003e 0])  # Ignore distance to itself\n        closest_color = colors[closest_color_idx]\n\n        # Create a gradient between the pixel\u0027s color and the closest pixel\u0027s color\n        blend_color = blend(colors[i], closest_color, 0.5)  # Simple averaging for the gradient\n        output_grid[x, y] = blend_color\n\n    return output_grid\n\ndef blend(color1, color2, fraction):\n    # Simple linear interpolation to blend two colors\n    return Color.RED if fraction \u003c 0.5 else Color.BLUE  # Placeholder for blending; replace with actual color blending logic\n\ndef generate_input():\n    # Create a black grid as the background\n    n = m = np.random.randint(5, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place a number of colored pixels\n    num_pixels = np.random.randint(5, 15)\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/118/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/118/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/118/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/118/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/118/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/118/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/118/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/118/images/train_output_2.png"}]}, "index": 118, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# circular patterns, rotation\n\n# description:\n# In the input, you will see a set of colored dots arranged in a circular pattern.\n# To create the output, rotate the entire pattern by a specific angle (90 degrees clockwise) and draw the new positions of the dots while maintaining their relative distances.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid of the same size, initialized to black\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # Find the center of the grid\n    center_x, center_y = n // 2, m // 2\n    \n    # Find the positions of all colored pixels\n    colored_positions = np.argwhere(input_grid != Color.BLACK)\n    \n    # Rotate each colored position around the center point\n    for x, y in colored_positions:\n        # Translate to origin (center of rotation)\n        translated_x = x - center_x\n        translated_y = y - center_y\n        \n        # Apply rotation (90 degrees clockwise)\n        new_x = translated_y + center_x\n        new_y = -translated_x + center_y\n        \n        # Place the colored pixel in the new position\n        if 0 \u003c= new_x \u003c n and 0 \u003c= new_y \u003c m:  # Ensure it\u0027s within bounds\n            output_grid[new_x, new_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a circular pattern of colored dots\n    n, m = 7, 7  # Fixed size for simplicity\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the center of the circular pattern\n    center_x, center_y = n // 2, m // 2\n    num_dots = 8  # Number of dots to place\n\n    # Place dots at equal angles around the center\n    angles = np.linspace(0, 2 * np.pi, num_dots, endpoint=False)\n    for angle in angles:\n        dot_x = int(center_x + 2 * np.cos(angle))  # Radius of 2\n        dot_y = int(center_y + 2 * np.sin(angle))\n        grid[dot_x, dot_y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/119/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/119/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/119/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/119/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/119/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/119/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/119/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/119/images/train_output_2.png"}]}, "index": 119, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, pixel grouping\n\n# description:\n# In the input, you will see a grid filled with colored pixels. \n# To make the output, first, group adjacent pixels of the same color into larger blocks and then map each block\u0027s color to a new color based on the following mapping:\n# red -\u003e blue, green -\u003e yellow, blue -\u003e pink, yellow -\u003e teal, pink -\u003e maroon, teal -\u003e red.\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Create a mapping for the colors\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.PINK,\n        Color.YELLOW: Color.TEAL,\n        Color.PINK: Color.MAROON,\n        Color.TEAL: Color.RED\n    }\n\n    # Create a mask to track seen pixels\n    seen = np.zeros_like(input_grid, dtype=bool)\n\n    # Iterate through each pixel in the input grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if seen[x, y]:\n                continue\n\n            # Get the color of the current pixel\n            color = input_grid[x, y]\n            if color == Color.BLACK:\n                continue  # Skip black pixels\n\n            # Group adjacent pixels of the same color\n            block = []\n            to_visit = [(x, y)]\n            while to_visit:\n                cx, cy = to_visit.pop()\n                if 0 \u003c= cx \u003c input_grid.shape[0] and 0 \u003c= cy \u003c input_grid.shape[1] and not seen[cx, cy]:\n                    if input_grid[cx, cy] == color:\n                        seen[cx, cy] = True\n                        block.append((cx, cy))\n                        # Check all 4 neighboring pixels\n                        to_visit.extend([(cx + 1, cy), (cx - 1, cy), (cx, cy + 1), (cx, cy - 1)])\n\n            # Now we have a block of the same color\n            if block:\n                # Map the block\u0027s color to the new color\n                new_color = color_map.get(color, color)\n                for bx, by in block:\n                    output_grid[bx, by] = new_color\n\n    return output_grid\n\n\ndef generate_input():\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place colored pixels while forming blocks\n    colors = list(Color.NOT_BLACK)\n    for color in colors:\n        # Randomly choose the top-left corner of the block\n        x_start = np.random.randint(0, n)\n        y_start = np.random.randint(0, m)\n        block_height = np.random.randint(1, 3)\n        block_width = np.random.randint(1, 3)\n\n        # Fill the block with color\n        for x in range(x_start, min(x_start + block_height, n)):\n            for y in range(y_start, min(y_start + block_width, m)):\n                grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/120/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/120/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/120/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/120/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/120/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/120/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/120/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/120/images/train_output_2.png"}]}, "index": 120, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape merging, proximity detection, color expansion\n\n# description:\n# In the input grid, you will see various colored shapes on a black background. Each shape consists of connected colored pixels.\n# To produce the output grid, expand each colored shape outward until it either touches another shape of the same color or hits a shape of a different color. \n# The expanded regions should be filled with the same color as the original shape.\n\ndef main(input_grid):\n    # 1. Identify all connected components in the input grid\n    components = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    output_grid = np.copy(input_grid)\n\n    for component in components:\n        # Get the color of the current component\n        color = component[component != Color.BLACK][0]\n        \n        # Create a mask for the current component\u0027s pixels\n        mask = (component == color)\n\n        # Expand the shape in all directions\n        for dx in range(-1, 2):  # -1, 0, 1 for x direction\n            for dy in range(-1, 2):  # -1, 0, 1 for y direction\n                if abs(dx) + abs(dy) == 1:  # Only consider cardinal directions\n                    for x, y in np.argwhere(mask):\n                        # Move in the (dx, dy) direction\n                        nx, ny = x + dx, y + dy\n                        if 0 \u003c= nx \u003c input_grid.shape[0] and 0 \u003c= ny \u003c input_grid.shape[1]:\n                            # Check for collision with the same color or stop at a different color\n                            if output_grid[nx, ny] == Color.BLACK:\n                                output_grid[nx, ny] = color\n                            elif output_grid[nx, ny] != color:\n                                continue\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a black grid\n    # 2. Randomly generate multiple colored shapes\n    # 3. Ensure shapes are connected and do not overlap\n\n    n, m = np.random.randint(15, 21), np.random.randint(15, 21)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of shapes\n    n_shapes = np.random.randint(3, 7)\n\n    for _ in range(n_shapes):\n        color = np.random.choice(Color.NOT_BLACK)\n        # Random size for the shape\n        width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n        \n        # Create a random shape sprite\n        sprite = random_sprite(width, height, density=0.7, color_palette=[color])\n\n        # Find a random position to place the shape where it won\u0027t overlap with existing shapes\n        x, y = random_free_location_for_sprite(input_grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n        blit_sprite(input_grid, sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/121/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/121/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/121/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/121/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/121/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/121/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/121/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/121/images/train_output_2.png"}]}, "index": 121, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alternating patterns, boundary detection\n\n# description:\n# In the input, you will see a grid with a checkerboard pattern of two colors (e.g., black and white).\n# To make the output, detect the boundaries of the colored squares and fill in the borders with a contrasting color (e.g., red),\n# while maintaining the checkerboard pattern inside.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    # Detect connected components to identify the checkerboard squares\n    squares = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # For each square, detect its bounding box and draw a border around it\n    for square in squares:\n        x, y, width, height = bounding_box(square)\n        # Fill the border with red\n        draw_line(output_grid, x, y, length=width, direction=(1, 0), color=Color.RED)  # Top\n        draw_line(output_grid, x, y + height - 1, length=width, direction=(1, 0), color=Color.RED)  # Bottom\n        draw_line(output_grid, x, y, length=height, direction=(0, 1), color=Color.RED)  # Left\n        draw_line(output_grid, x + width - 1, y, length=height, direction=(0, 1), color=Color.RED)  # Right\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid size between 8x8 and 16x16\n    n, m = np.random.randint(8, 17), np.random.randint(8, 17)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Random colors for the checkerboard pattern\n    color1, color2 = random.sample(Color.NOT_BLACK, 2)\n\n    # Fill the grid with a checkerboard pattern\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 2 == 0:\n                grid[i, j] = color1\n            else:\n                grid[i, j] = color2\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/122/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/122/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/122/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/122/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/122/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/122/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/122/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/122/images/train_output_2.png"}]}, "index": 122, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape merging, color majority\n\n# description:\n# In the input, you will see various colored shapes on a grid, some overlapping. Each shape is a solid color, and they might touch each other at the edges or corners. \n# The output grid should merge overlapping shapes of the same color into a single shape, and the color of the merged shape should be determined by the majority color of the overlapping areas.\n\ndef main(input_grid):\n    # Find all the connected components in the grid\n    components = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n    \n    # Create a grid to store the output\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # For each component, determine its color and merge accordingly\n    for component in components:\n        # Get the colors present in the connected component\n        colors = np.unique(component[component != Color.BLACK])\n        \n        # Count the occurrences of each color\n        color_count = {color: np.sum(component == color) for color in colors}\n        \n        # Determine the majority color (if there\u0027s a tie, select the first one)\n        majority_color = max(color_count, key=color_count.get)\n        \n        # Create the bounding box for this component\n        x, y, w, h = bounding_box(component, background=Color.BLACK)\n        \n        # Fill the output grid with the majority color in the bounding box area\n        output_grid[x:x+w, y:y+h] = majority_color\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random dimensions\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter a random number of colored shapes on the grid\n    shape_count = np.random.randint(5, 15)\n    colors_used = set()\n    \n    for _ in range(shape_count):\n        # Choose a random color (not black)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        colors_used.add(color)\n\n        # Generate a random sprite shape\n        shape_height = np.random.randint(2, 5)\n        shape_width = np.random.randint(2, 5)\n        sprite = random_sprite(shape_height, shape_width, density=0.8, color_palette=[color])\n\n        # Place the shape randomly on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/123/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/123/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/123/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/123/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/123/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/123/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/123/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/123/images/train_output_2.png"}]}, "index": 123, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color isolation, frequency counting\n\n# description:\n# In the input, you will see a grid filled with colored pixels. The task is to identify the most frequent color in the grid and change all other colors to pink, leaving only the most frequent color visible.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a blank new canvas filled with pink (Color.PINK).\n    # 2. Identify the most frequent color in the input grid.\n    # 3. Copy the most frequent color onto the output grid, leaving other areas pink.\n\n    output_grid = np.full_like(input_grid, Color.PINK)\n\n    # 2. Identify the most frequent color\n    color_counts = {color: np.count_nonzero(input_grid == color) for color in Color.NOT_BLACK}\n    most_frequent_color = max(color_counts, key=color_counts.get)\n\n    # 3. Copy the most frequent color onto the output grid\n    output_grid[input_grid == most_frequent_color] = most_frequent_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid with a mixture of colors.\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)  # Random grid size\n    grid = np.full((n, m), Color.PINK)  # Start with a pink grid (background)\n\n    # Randomly scatter colors on the grid, ensuring that at least one color is frequent.\n    num_colors = np.random.randint(2, 10)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=num_colors, replace=False)\n\n    for color in colors:\n        # For each color, randomly determine its frequency but keep it at least 3 to ensure it\u0027s frequent\n        frequency = np.random.randint(3, n * m // num_colors)\n        \n        for _ in range(frequency):\n            empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.PINK]\n            if empty_cells:  # If there are still empty cells to fill\n                x, y = random.choice(empty_cells)\n                grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/124/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/124/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/124/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/124/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/124/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/124/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/124/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/124/images/train_output_2.png"}]}, "index": 124, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, radial gradient\n\n# description:\n# In the input grid, you will see a single pixel of one color in the center of the grid. The rest of the grid is filled with another color. \n# To create the output grid, generate a radial gradient that blends from the center color to the background color, \n# filling the entire grid with this gradient based on the distance from the center pixel.\n\ndef main(input_grid):\n    # Get the dimensions of the grid\n    height, width = input_grid.shape\n    center_color = input_grid[height // 2, width // 2]\n    background_color = Color.BLACK if center_color != Color.BLACK else Color.RED  # Avoid blending to the same color\n    \n    output_grid = np.full((height, width), background_color)\n\n    # Calculate the maximum distance from the center to the corners\n    max_distance = np.sqrt((height // 2) ** 2 + (width // 2) ** 2)\n\n    for x in range(height):\n        for y in range(width):\n            # Calculate the distance from the center pixel\n            distance = np.sqrt((x - height // 2) ** 2 + (y - width // 2) ** 2)\n            # Calculate the blending factor based on the distance\n            blend_factor = distance / max_distance\n            # Determine the color based on the blend factor\n            if blend_factor \u003c 1:\n                # Blend proportionally\n                output_grid[x, y] = blend_colors(center_color, background_color, blend_factor)\n            else:\n                output_grid[x, y] = background_color\n\n    return output_grid\n\ndef blend_colors(color1, color2, factor):\n    # Simple function to blend two colors\n    return color1 if factor \u003c 0.5 else color2  # This basic blending assumes two colors\n\ndef generate_input():\n    # Create a 20x20 grid filled with a background color\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Choose a center color\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Set the center pixel to the selected color\n    input_grid[10, 10] = center_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/125/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/125/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/125/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/125/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/125/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/125/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/125/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/125/images/train_output_2.png"}]}, "index": 125, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel aggregation, pixel counting\n\n# description:\n# In the input, you will see a grid filled with colored pixels. The challenge is to count how many times each color appears in the grid.\n# To make the output grid, represent the counts of the colors in a 1xN grid where N is the number of unique colors,\n# with each cell filled with the respective color, filled from left to right based on the count.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Count the occurrence of each color\n    color_counts = {}\n    \n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color != Color.BLACK:  # Ignore the background color\n                if color in color_counts:\n                    color_counts[color] += 1\n                else:\n                    color_counts[color] = 1\n\n    # Create the output grid with a height of 1 and width equal to the number of unique colors\n    unique_colors = list(color_counts.keys())\n    output_grid = np.zeros((1, len(unique_colors)), dtype=int)\n\n    # Fill the output grid with the respective colors based on their counts\n    for index, color in enumerate(unique_colors):\n        count = color_counts[color]\n        output_grid[0, index] = color  # Fill the color in the output grid\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid with colored pixels\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels in the grid\n    total_pixels = np.random.randint(10, 50)  # Total colored pixels to scatter\n\n    for _ in range(total_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(Color.NOT_BLACK)  # Choose a random color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/126/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/126/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/126/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/126/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/126/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/126/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/126/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/126/images/train_output_2.png"}]}, "index": 126, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, overlapping shapes\n\n# description:\n# In the input, you will see two overlapping shapes, one blue and one yellow. \n# The output should blend the overlapping area to create a green section while keeping the non-overlapping parts blue and yellow.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n    \n    # Find the coordinates of the blue and yellow shapes\n    blue_coords = np.where(input_grid == Color.BLUE)\n    yellow_coords = np.where(input_grid == Color.YELLOW)\n    \n    # Create a mask for the overlapping area\n    overlap_mask = np.zeros_like(input_grid, dtype=bool)\n    overlap_mask[blue_coords] = True\n    overlap_mask[yellow_coords] = True\n    \n    # Blend the overlapping area to green\n    output_grid[overlap_mask] = Color.GREEN\n    \n    return output_grid\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a black background.\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Randomly determine the size and position of the blue shape\n    blue_width, blue_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    blue_sprite = random_sprite(blue_width, blue_height, density=0.7, color_palette=[Color.BLUE])\n    \n    # Randomly determine the size and position of the yellow shape\n    yellow_width, yellow_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    yellow_sprite = random_sprite(yellow_width, yellow_height, density=0.7, color_palette=[Color.YELLOW])\n    \n    # Place the blue sprite in a random location\n    x_blue, y_blue = random_free_location_for_sprite(grid, blue_sprite)\n    blit_sprite(grid, blue_sprite, x=x_blue, y=y_blue)\n\n    # Place the yellow sprite in a random location, ensuring it overlaps with the blue sprite\n    # First, get the bounding box of the blue sprite\n    blue_x_min, blue_y_min = x_blue, y_blue\n    blue_x_max = x_blue + blue_width\n    blue_y_max = y_blue + blue_height\n    \n    # Calculate overlapping area for yellow shape placement\n    overlap_x = np.random.randint(blue_x_min, min(blue_x_max, n))\n    overlap_y = np.random.randint(blue_y_min, min(blue_y_max, m))\n\n    # Place the yellow sprite with a guaranteed overlap\n    x_yellow = overlap_x - yellow_width // 2\n    y_yellow = overlap_y - yellow_height // 2\n    blit_sprite(grid, yellow_sprite, x=x_yellow, y=y_yellow)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/127/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/127/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/127/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/127/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/127/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/127/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/127/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/127/images/train_output_2.png"}]}, "index": 127, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color layering\n\n# description:\n# In the input, you will see a grid with several colored shapes. Each shape is either filled or outlined. Outlined shapes have a color that is different from the background, while filled shapes have the same color as the shape\u0027s outline. \n# To create the output grid, you should convert all outlined shapes to a different color (for example, from red to green) while leaving the filled shapes unchanged.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    # Detect all unique colors in the grid, excluding the background color\n    unique_colors = set(np.unique(input_grid)) - {Color.BLACK}\n    \n    for color in unique_colors:\n        # Find the outlined shapes (those that are adjacent to the background)\n        outlined_shapes = find_connected_components(input_grid == color, background=Color.BLACK)\n        \n        for shape in outlined_shapes:\n            # Check if the shape is outlined (i.e., has any background pixels adjacent)\n            if np.any(np.isin(np.roll(shape, 1, axis=0), Color.BLACK)) or np.any(np.isin(np.roll(shape, -1, axis=0), Color.BLACK)) or \\\n               np.any(np.isin(np.roll(shape, 1, axis=1), Color.BLACK)) or np.any(np.isin(np.roll(shape, -1, axis=1), Color.BLACK)):\n                # Change the color to a different one (e.g., from red to green)\n                output_grid[shape != Color.BLACK] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create filled and outlined shapes in the grid\n    colors = [Color.RED, Color.BLUE, Color.YELLOW]\n\n    for color in colors:\n        # Create a filled shape\n        shape_height, shape_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        filled_shape = random_sprite(shape_height, shape_width, density=1.0, color_palette=[color])\n        x, y = random_free_location_for_sprite(input_grid, filled_shape, background=Color.BLACK)\n        blit_sprite(input_grid, filled_shape, x, y)\n\n        # Create an outlined shape\n        outline_height, outline_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        outlined_shape = random_sprite(outline_height, outline_width, density=0.3, color_palette=[color])\n        x, y = random_free_location_for_sprite(input_grid, outlined_shape, background=Color.BLACK)\n        blit_sprite(input_grid, outlined_shape, x, y)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/128/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/128/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/128/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/128/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/128/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/128/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/128/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/128/images/train_output_2.png"}]}, "index": 128, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color rotation, circular pattern\n\n# description:\n# In the input, you will see a grid containing pixels of four different colors arranged in a circular pattern. \n# To make the output grid, you should rotate the colors in the grid by one position clockwise, \n# so that the pixel colors shift their positions accordingly.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid of the same shape\n    output_grid = np.zeros_like(input_grid)\n\n    # Iterate through the grid and perform the rotation\n    for x in range(n):\n        for y in range(m):\n            # Calculate the new position for the rotation\n            new_x = x\n            new_y = (y + 1) % m  # Move to the right (clockwise)\n            output_grid[new_x, new_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with a size of n x m.\n    n, m = random.randint(5, 10), random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define four colors to use in the circular pattern\n    colors = random.sample(list(Color.NOT_BLACK), k=4)\n\n    # Create a circular pattern with the four colors\n    center_x, center_y = n // 2, m // 2\n\n    # Assign colors in a circular fashion around the center\n    radius = 2  # Fixed radius for the circular pattern\n    for angle in range(0, 360, 90):  # 90-degree increments for four colors\n        rad = np.deg2rad(angle)\n        x = int(center_x + radius * np.cos(rad))\n        y = int(center_y + radius * np.sin(rad))\n        if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m:\n            grid[x, y] = colors[angle // 90]  # Assign a color based on the angle\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/129/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/129/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/129/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/129/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/129/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/129/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/129/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/129/images/train_output_2.png"}]}, "index": 129, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, scaling, color transformation\n\n# description:\n# In the input, you will see a grid with a central pattern of colored pixels surrounded by a border of a different color.\n# The border can be of any width but must be uniform. To make the output, extract the central pattern by removing the border,\n# and scale the central pattern by a factor of 3, filling the background with black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Crop the grid to remove the border\n    central_pattern = crop(input_grid, background=Color.BLACK)\n    \n    # Scale the central pattern by a factor of 3\n    scaled_pattern = scale_pattern(pattern=central_pattern, scale_factor=3)\n    \n    # Create an output grid with a black background\n    output_grid = np.full((scaled_pattern.shape[0], scaled_pattern.shape[1]), Color.BLACK, dtype=int)\n    \n    # Place the scaled pattern in the output grid\n    output_grid = blit_sprite(grid=output_grid, sprite=scaled_pattern, x=0, y=0)\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the grid\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK, dtype=int)\n\n    # Define the size of the border\n    border_size = np.random.randint(1, 4)\n\n    # Generate a random central pattern size\n    pattern_height = np.random.randint(3, grid_size - 2 * border_size)\n    pattern_width = np.random.randint(3, grid_size - 2 * border_size)\n\n    # Create a random central pattern\n    central_pattern = random_sprite(n=pattern_height, m=pattern_width, density=0.6, color_palette=list(Color.NOT_BLACK))\n\n    # Blit the central pattern onto the grid with a border of a different color\n    border_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Create the grid with a border\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if (i \u003c border_size) or (i \u003e= grid_size - border_size) or (j \u003c border_size) or (j \u003e= grid_size - border_size):\n                grid[i, j] = border_color\n\n    # Place the central pattern in the middle of the grid\n    x_start = border_size\n    y_start = border_size\n    grid = blit_sprite(grid=grid, sprite=central_pattern, x=x_start, y=y_start, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/130/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/130/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/130/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/130/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/130/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/130/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/130/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/130/images/train_output_2.png"}]}, "index": 130, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color transformation, spatial arrangement\n\n# description:\n# In the input, you will see a grid filled with various patterns of colored pixels. \n# To create the output, identify and extract the most common pattern in the grid \n# and replicate it in a new area of the grid while changing its color to a specified new color.\n\ndef main(input_grid):\n    # Step 1: Identify connected components in the grid.\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Step 2: Count the occurrences of each unique pattern.\n    pattern_counts = {}\n    for component in components:\n        # Convert the component to a tuple for hashing\n        pattern_tuple = tuple(component.flatten())\n        if pattern_tuple in pattern_counts:\n            pattern_counts[pattern_tuple] += 1\n        else:\n            pattern_counts[pattern_tuple] = 1\n\n    # Step 3: Find the most common pattern.\n    most_common_pattern = max(pattern_counts, key=pattern_counts.get)\n\n    # Step 4: Convert the tuple back to a numpy array\n    pattern_shape = (int(np.sqrt(len(most_common_pattern))),) * 2  # Assuming square patterns for simplicity\n    pattern_array = np.array(most_common_pattern).reshape(pattern_shape)\n\n    # Step 5: Create the grid for output.\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 6: Find a free location in the output grid to place the pattern\n    x, y = random_free_location_for_sprite(output_grid, pattern_array, background=Color.BLACK)\n\n    # Step 7: Blit the most common pattern onto the output grid\n    output_grid = blit_sprite(output_grid, pattern_array, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with random colors and patterns\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)  # Random size for the grid\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter some random colors in the grid\n    available_colors = list(Color.NOT_BLACK)\n    for _ in range(np.random.randint(5, 15)):  # Random number of colored pixels\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice(available_colors)\n        grid[x, y] = color\n\n    # Introduce some patterns in the grid\n    for _ in range(np.random.randint(2, 5)):  # Random number of patterns\n        pattern_size = np.random.randint(2, 4)\n        pattern = random_sprite(pattern_size, pattern_size, density=0.5, color_palette=available_colors)\n        x, y = random_free_location_for_sprite(grid, pattern, background=Color.BLACK)\n        grid = blit_sprite(grid, pattern, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/131/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/131/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/131/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/131/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/131/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/131/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/131/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/131/images/train_output_2.png"}]}, "index": 131, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern scaling, pattern mirroring, placing\n\n# description:\n# In the input, you will see a single square pattern in the center of the grid.\n# To make the output grid, you should scale this pattern by a factor of 2 in both dimensions,\n# and then place the original pattern in the top-left corner and the scaled pattern in the bottom-right corner of the output grid.\n\ndef main(input_grid):\n    # Step 1: Detect the pattern in the input grid\n    pattern_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=8)\n\n    # Assuming only one pattern is present, extract it\n    original_pattern = pattern_objects[0]\n    original_sprite = crop(original_pattern, background=Color.BLACK)\n\n    # Step 2: Scale the original pattern by a factor of 2\n    scaled_pattern = scale_pattern(original_sprite, scale_factor=2)\n\n    # Step 3: Create the output grid\n    output_height = max(original_sprite.shape[0], scaled_pattern.shape[0])\n    output_width = original_sprite.shape[1] + scaled_pattern.shape[1]\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Step 4: Place the original pattern in the top-left corner\n    output_grid = blit_sprite(output_grid, original_sprite, x=0, y=0, background=Color.BLACK)\n\n    # Step 5: Place the scaled pattern in the bottom-right corner\n    output_grid = blit_sprite(output_grid, scaled_pattern, x=original_sprite.shape[1], y=0, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a single centered pattern\n    grid_size = 10\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Define the size of the pattern\n    pattern_size = 3\n    start_x = (grid_size - pattern_size) // 2\n    start_y = (grid_size - pattern_size) // 2\n\n    # Fill the pattern with a random color and leave the rest as black\n    random_color = np.random.choice(list(Color.NOT_BLACK))\n    pattern = np.full((pattern_size, pattern_size), random_color)\n    grid[start_x:start_x + pattern_size, start_y:start_y + pattern_size] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/132/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/132/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/132/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/132/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/132/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/132/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/132/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/132/images/train_output_2.png"}]}, "index": 132, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object mirroring, color fill\n\n# description:\n# In the input, you will see a colored shape on a black background. \n# To make the output, create a mirrored version of the shape on the opposite side of the grid and fill it with a gradient that transitions from the original color to black.\n\ndef main(input_grid):\n    # Create output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the colored shape\n    shape_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Assuming there\u0027s only one shape in the grid; select the first found\n    original_shape = shape_objects[0]\n\n    # Get the color of the original shape\n    color = np.unique(original_shape[original_shape != Color.BLACK])[0]\n\n    # Get the bounding box of the original shape\n    x, y, width, height = bounding_box(original_shape)\n\n    # Determine the position for the mirrored shape\n    mirrored_x = output_grid.shape[0] - (x + width)\n    mirrored_y = y\n\n    # Create a mirrored version of the shape\n    mirrored_shape = np.copy(original_shape)\n\n    # Translate mirrored_shape to the appropriate position\n    mirrored_shape = translate(mirrored_shape, mirrored_x - x, mirrored_y - y, background=Color.BLACK)\n\n    # Fill the mirrored shape with a gradient from the original color to black\n    for i in range(mirrored_shape.shape[0]):\n        for j in range(mirrored_shape.shape[1]):\n            if mirrored_shape[i, j] != Color.BLACK:\n                # Calculate gradient color (for simplicity, we can average the color with black)\n                output_grid[mirrored_x + i, mirrored_y + j] = color # Fill with original color first\n                # Additional logic could be added here for a more complex gradient effect\n\n    # Place the mirrored shape into the output grid\n    output_grid = np.where(mirrored_shape != Color.BLACK, mirrored_shape, output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random dimensions\n    n = np.random.randint(7, 15)\n    m = np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a color for the shape\n    shape_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random shape in the grid\n    shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=1)\n\n    # Find a random free location for the shape\n    x, y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/133/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/133/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/133/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/133/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/133/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/133/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/133/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/133/images/train_output_2.png"}]}, "index": 133, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color filling, center point\n\n# description:\n# In the input, you will see a colored pixel on a black background. To create the output, fill in the symmetrical positions around \n# the colored pixel with the same color, creating a symmetrical pattern across both axes (horizontal and vertical) through the \n# center point of the colored pixel.\n\ndef main(input_grid):\n    # Create an output grid and copy the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the coordinates of the colored pixel\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n\n        # Calculate symmetrical positions\n        output_grid[x, y] = color\n        output_grid[x, -y + (input_grid.shape[1] - 1)] = color  # Symmetrical about the vertical axis\n        output_grid[-x + (input_grid.shape[0] - 1), y] = color  # Symmetrical about the horizontal axis\n        output_grid[-x + (input_grid.shape[0] - 1), -y + (input_grid.shape[1] - 1)] = color  # Symmetrical about both axes\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid for the background\n    width, height = np.random.randint(5, 15, size=2)\n    input_grid = np.full((width, height), fill_value=Color.BLACK)\n\n    # Place a single randomly colored pixel in the grid\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/134/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/134/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/134/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/134/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/134/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/134/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/134/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/134/images/train_output_2.png"}]}, "index": 134, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity sensing, color blending\n\n# description:\n# In the input, you will see several colored pixels scattered across a grid. \n# To create the output, for each pixel, calculate the average color of the surrounding pixels within a specific radius \n# and fill in the pixel with that average color to create a blended effect.\n\ndef main(input_grid: np.ndarray, radius: int = 1) -\u003e np.ndarray:\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Get the dimensions of the input grid\n    rows, cols = input_grid.shape\n\n    # Iterate over each pixel in the input grid\n    for x in range(rows):\n        for y in range(cols):\n            # Gather colors of surrounding pixels within the specified radius\n            surrounding_colors = []\n\n            for dx in range(-radius, radius + 1):\n                for dy in range(-radius, radius + 1):\n                    if abs(dx) + abs(dy) \u003c= radius:  # Check Manhattan distance\n                        nx, ny = x + dx, y + dy\n                        if 0 \u003c= nx \u003c rows and 0 \u003c= ny \u003c cols and input_grid[nx, ny] != Color.BLACK:\n                            surrounding_colors.append(input_grid[nx, ny])\n\n            if surrounding_colors:\n                # Calculate the average color (by counting occurrences of each color)\n                color_count = {}\n                for color in surrounding_colors:\n                    if color in color_count:\n                        color_count[color] += 1\n                    else:\n                        color_count[color] = 1\n\n                # Find the color with the maximum count (mode)\n                avg_color = max(color_count.items(), key=lambda item: item[1])[0]\n                output_grid[x, y] = avg_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid with scattered colored pixels\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly decide on a number of colored pixels to place\n    num_pixels = np.random.randint(10, 30)\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/135/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/135/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/135/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/135/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/135/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/135/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/135/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/135/images/train_output_2.png"}]}, "index": 135, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, filling, color transformation\n\n# description:\n# In the input, you will see a grid containing a repeated pattern of colors, but some parts are obscured by black pixels. \n# To create the output, recognize the original pattern and fill in the obscured areas to restore the complete pattern.\n\ndef main(input_grid):\n    # Detect the connected components in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # If there are no components, return a blank grid\n    if not components:\n        return np.zeros(input_grid.shape, dtype=int)\n\n    # Extract the first component to determine the original pattern\n    original_pattern = crop(components[0], background=Color.BLACK)\n    pattern_color = np.unique(original_pattern[original_pattern != Color.BLACK])[0]\n\n    # Create an output grid filled with the original pattern\n    output_grid = np.copy(input_grid)\n\n    # Fill obscured areas with the color of the original pattern\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            if output_grid[x, y] == Color.BLACK:\n                output_grid[x, y] = pattern_color\n\n    return output_grid\n\ndef generate_input():\n    # Randomly generate the size of the grid\n    n, m = random.randint(8, 15), random.randint(8, 15)\n\n    # Generate the base grid with black background\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the pattern size and colors\n    pattern_size = random.randint(3, 5)\n    available_colors = random.sample(Color.NOT_BLACK, 1)  # Just one color for the pattern\n    pattern_color = available_colors[0]\n\n    # Create the original pattern\n    pattern = random_sprite(pattern_size, pattern_size, color_palette=[pattern_color], density=0.5)\n\n    # Place the pattern in the grid but leave some areas black (obscured)\n    for i in range(0, n, pattern_size + 1):  # add spacing\n        for j in range(0, m, pattern_size + 1):\n            # Only draw the pattern if it fits in the grid\n            if i + pattern_size \u003c= n and j + pattern_size \u003c= m:\n                # Randomly decide to obscure some parts\n                if random.random() \u003c 0.5:  # 50% chance to obscure\n                    obscured_pattern = np.where(pattern == pattern_color, Color.BLACK, pattern_color)\n                else:\n                    obscured_pattern = pattern\n\n                grid[i:i + pattern_size, j:j + pattern_size] = obscured_pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/136/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/136/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/136/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/136/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/136/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/136/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/136/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/136/images/train_output_2.png"}]}, "index": 136, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, outline drawing\n\n# description:\n# In the input, you will see a grid filled with colored shapes on a black background. \n# To create the output, detect the boundaries of each shape and create a new grid that outlines \n# each shape with a contrasting color, leaving the interior of the shapes transparent.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all connected components (shapes) in the input grid\n    shapes = find_connected_components(grid=input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n\n    # For each shape found, draw its boundary with a contrasting color\n    for shape in shapes:\n        # Get the bounding box of the shape\n        x, y, width, height = bounding_box(shape, background=Color.BLACK)\n\n        # Loop through the bounding box to find the outline\n        for i in range(x, x + width):\n            for j in range(y, y + height):\n                # Check if the current pixel is part of the shape\n                if shape[i - x, j - y] != Color.BLACK:\n                    # Check its neighbors to see if it\u0027s on the edge\n                    is_edge = (i == 0 or input_grid[i - 1, j] == Color.BLACK) or \\\n                              (i == input_grid.shape[0] - 1 or input_grid[i + 1, j] == Color.BLACK) or \\\n                              (j == 0 or input_grid[i, j - 1] == Color.BLACK) or \\\n                              (j == input_grid.shape[1] - 1 or input_grid[i, j + 1] == Color.BLACK)\n                    if is_edge:\n                        # Outline this pixel in the output grid with a contrasting color\n                        output_grid[i, j] = Color.RED  # Using RED as the outline color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid of random size\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Randomly generate a number of colored shapes\n    num_shapes = np.random.randint(1, 5)\n    for _ in range(num_shapes):\n        # Randomly determine the shape size\n        shape_width = np.random.randint(2, 6)\n        shape_height = np.random.randint(2, 6)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a random shape (sprite)\n        shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color])\n\n        # Find a random free location to place the shape in the grid\n        x, y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK)\n        blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/137/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/137/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/137/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/137/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/137/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/137/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/137/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/137/images/train_output_2.png"}]}, "index": 137, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, centering, color retention\n\n# description:\n# In the input, you will see a colored shape that is not centered on the canvas. \n# To make the output, rotate the shape 90 degrees clockwise and center it on the canvas while keeping its color intact.\n\ndef main(input_grid):\n    # Step 1: Detect the object(s) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # There should be only one object\n    assert len(objects) == 1\n    original_shape = objects[0]\n\n    # Step 2: Rotate the shape 90 degrees clockwise\n    rotated_shape = np.rot90(original_shape, k=-1)  # k=-1 for clockwise rotation\n\n    # Step 3: Create an output grid with a black background\n    output_grid = np.zeros_like(input_grid)\n\n    # Step 4: Center the rotated shape in the output grid\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n    shape_height, shape_width = rotated_shape.shape\n\n    # Calculate the top-left corner to place the rotated shape centered\n    start_x = center_x - shape_height // 2\n    start_y = center_y - shape_width // 2\n\n    # Blit the rotated shape onto the output grid\n    blit_object(output_grid, rotated_shape, background=Color.BLACK)  # draw the rotated shape on black background\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of a random size with a black background\n    n, m = np.random.randint(5, 10, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random color for the sprite\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random sprite shape that is not symmetric and place it in a random location\n    sprite_shape = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), density=1, symmetry=\"not_symmetric\", color_palette=[sprite_color])\n    \n    # Find a random free location for the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, sprite_shape, background=Color.BLACK)\n    \n    # Blit the sprite onto the grid\n    blit_sprite(grid, sprite_shape, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/138/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/138/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/138/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/138/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/138/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/138/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/138/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/138/images/train_output_2.png"}]}, "index": 138, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color pattern detection, block merging, grid transformation\n\n# description:\n# In the input you will see a grid with multiple 2x2 blocks of various colors scattered across it.\n# To create the output grid, identify the distinct colors of the blocks and replace each 2x2 block\n# with a 4x4 block of the same color. The output grid should be larger than the input grid to accommodate\n# the enlarged blocks.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all the 2x2 colored blocks in the input grid.\n    # 2. For each detected block, replace it with a 4x4 block of the same color in the output grid.\n\n    output_grid = np.full((input_grid.shape[0] * 2, input_grid.shape[1] * 2), Color.BLACK)\n\n    for x in range(input_grid.shape[0] - 1):\n        for y in range(input_grid.shape[1] - 1):\n            if (input_grid[x, y] == input_grid[x + 1, y] == \n                input_grid[x, y + 1] == input_grid[x + 1, y + 1]):\n                # If we find a 2x2 block, get its color\n                block_color = input_grid[x, y]\n                # Place a 4x4 block of that color in the output grid\n                output_grid[x*2:x*2 + 4, y*2:y*2 + 4] = block_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random 2x2 colored blocks.\n    n, m = 10, 10  # Size of the grid\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n\n    # Randomly create a number of 2x2 colored blocks\n    num_blocks = np.random.randint(1, 6)  # Random number of blocks to place\n\n    for _ in range(num_blocks):\n        # Choose a random color for the block\n        color = np.random.choice(Color.NOT_BLACK)\n        # Create a 2x2 block of that color\n        block = np.full((2, 2), color)\n        # Find a random free location for the block\n        try:\n            x, y = random_free_location_for_sprite(grid, block, background=Color.BLACK)\n            # Blit the block onto the grid\n            grid = blit_sprite(grid, block, x, y, background=Color.BLACK)\n        except:\n            continue  # If no space is found, continue with the next block\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/139/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/139/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/139/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/139/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/139/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/139/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/139/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/139/images/train_output_2.png"}]}, "index": 139, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel expansion, contour filling, color detection\n\n# description:\n# In the input, you will see a shape defined by a colored contour on a black background. \n# To make the output, expand the contour outward by one pixel, filling the newly created space with the same color as the contour.\n\ndef main(input_grid):\n    # Create output grid\n    output_grid = np.copy(input_grid)\n    \n    # Find all components in the grid\n    contours = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n    \n    for contour in contours:\n        # Get the color of the contour\n        color = contour[contour != Color.BLACK][0]\n        \n        # Get the coordinates of the contour\n        contour_coords = np.argwhere(contour != Color.BLACK)\n        \n        # For each coordinate in the contour, fill the surrounding pixels with the same color\n        for x, y in contour_coords:\n            # Check all 8 surrounding pixels to expand the contour\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    if dx == 0 and dy == 0:\n                        continue  # Skip the center pixel\n                    nx, ny = x + dx, y + dy\n                    # Ensure within bounds and fill if it\u0027s a black pixel\n                    if 0 \u003c= nx \u003c input_grid.shape[0] and 0 \u003c= ny \u003c input_grid.shape[1]:\n                        if output_grid[nx, ny] == Color.BLACK:\n                            output_grid[nx, ny] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a contour color\n    contour_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly generate a shape (contour) in the grid\n    shape_size = np.random.randint(3, 6)\n    start_x, start_y = np.random.randint(0, n - shape_size), np.random.randint(0, m - shape_size)\n    \n    # Draw a simple square contour\n    for i in range(shape_size):\n        grid[start_x, start_y + i] = contour_color  # Left vertical\n        grid[start_x + shape_size - 1, start_y + i] = contour_color  # Right vertical\n        grid[start_x + i, start_y] = contour_color  # Top horizontal\n        grid[start_x + i, start_y + shape_size - 1] = contour_color  # Bottom horizontal\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/140/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/140/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/140/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/140/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/140/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/140/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/140/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/140/images/train_output_2.png"}]}, "index": 140, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change, scaling\n\n# description:\n# In the input, you will see several colorful objects on a black background. Each object has a distinct color and varies in size. \n# To create the output, identify the smallest object and change its color to red. \n# All other objects should be scaled down to half their size while maintaining their original colors, and they should be positioned in the same location as before.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False)\n\n    # Identify the smallest object\n    smallest_object = min(objects, key=lambda obj: np.count_nonzero(obj != Color.BLACK))\n\n    # Change the color of the smallest object to red\n    output_grid[smallest_object != Color.BLACK] = Color.RED\n\n    # Scale down all other objects to half their size\n    for obj in objects:\n        if np.array_equal(obj, smallest_object):\n            continue\n        # Crop the object to get its sprite\n        sprite = crop(obj)\n        # Scale down the sprite\n        scaled_sprite = sprite[::2, ::2]  # Take every second pixel to reduce size by half\n        # Find the original position of the object in the output grid\n        x, y = np.where(output_grid == obj[0,0])  # Assuming single color per object\n        if len(x) \u003e 0 and len(y) \u003e 0:\n            blit_sprite(output_grid, scaled_sprite, x[0], y[0], background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random number of objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Generate a random sprite with a random color\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=Color.NOT_BLACK)\n        # Ensure the object is not too large to fit in the grid\n        while sprite.shape[0] \u003e n or sprite.shape[1] \u003e m:\n            sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=Color.NOT_BLACK)\n        # Find a random location to place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/141/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/141/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/141/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/141/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/141/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/141/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/141/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/141/images/train_output_2.png"}]}, "index": 141, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# texture mapping, pattern recognition\n\n# description:\n# In the input, you will see a grid with a textured pattern. To create the output, \n# identify and extract a 3x3 section of the pattern, then repeat that section \n# across the entire grid to create a consistent texture throughout.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract a 3x3 section from the input grid\n    pattern_section = input_grid[1:4, 1:4]  # Extracting the center 3x3 section\n\n    # Create the output grid with the same shape as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Fill the output grid with the extracted pattern section\n    for i in range(0, output_grid.shape[0], 3):\n        for j in range(0, output_grid.shape[1], 3):\n            output_grid[i:i + 3, j:j + 3] = pattern_section\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    \n    # Create a random grid with a textured pattern\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define a color palette\n    color_palette = list(Color.NOT_BLACK)\n\n    # Fill the grid with random colors\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(color_palette)\n\n    # Ensure there is a 3x3 section in the middle of the grid\n    # that can be easily extracted\n    center_x, center_y = n // 2, m // 2\n    for i in range(center_x - 1, center_x + 2):\n        for j in range(center_y - 1, center_y + 2):\n            grid[i, j] = np.random.choice(color_palette)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/142/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/142/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/142/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/142/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/142/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/142/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/142/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/142/images/train_output_2.png"}]}, "index": 142, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, edge detection, neighbor influence\n\n# description:\n# In the input, you will see a grid filled with colored pixels. The outermost pixels of the grid are special and will influence the colors of the inner pixels.\n# To make the output, for each inner pixel, if it is adjacent to any outer pixel that is a certain color, change its color to that color. \n# The outer colors that influence the inner pixels are red and blue. If an inner pixel is adjacent to both a red and a blue pixel, it should change to purple.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Define the special colors\n    outer_colors = {Color.RED, Color.BLUE}\n    purple_color = Color.MAROON  # Assume maroon is a representation of purple\n\n    # Iterate through the inner pixels (not the outermost rows and columns)\n    for x in range(1, input_grid.shape[0] - 1):\n        for y in range(1, input_grid.shape[1] - 1):\n            adjacent_colors = set()\n\n            # Check neighbors: up, down, left, right\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                neighbor_color = input_grid[x + dx, y + dy]\n                if neighbor_color in outer_colors:\n                    adjacent_colors.add(neighbor_color)\n\n            # Determine the new color based on adjacent outer colors\n            if Color.RED in adjacent_colors and Color.BLUE in adjacent_colors:\n                output_grid[x, y] = purple_color\n            elif adjacent_colors:\n                output_grid[x, y] = adjacent_colors.pop()  # Take one of the adjacent colors\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size with a black background\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place red and blue pixels on the boundary\n    for i in range(n):\n        if np.random.rand() \u003c 0.5:  # Randomly choose to place red or blue on the top and bottom edges\n            grid[i, 0] = np.random.choice([Color.RED, Color.BLUE])\n            grid[i, m - 1] = np.random.choice([Color.RED, Color.BLUE])\n\n    for j in range(m):\n        if np.random.rand() \u003c 0.5:  # Randomly choose to place red or blue on the left and right edges\n            grid[0, j] = np.random.choice([Color.RED, Color.BLUE])\n            grid[n - 1, j] = np.random.choice([Color.RED, Color.BLUE])\n\n    # Randomly fill inner pixels with colors (not red or blue)\n    for x in range(1, n - 1):\n        for y in range(1, m - 1):\n            grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color not in [Color.RED, Color.BLUE]])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/143/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/143/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/143/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/143/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/143/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/143/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/143/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/143/images/train_output_2.png"}]}, "index": 143, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shifting, color transformation, bounding box\n\n# description:\n# In the input grid, you will see a colored square and a colored rectangle. The square is in the center of the grid, while the rectangle is overlapping with the square on one side. \n# The output grid will involve shifting the rectangle horizontally until it no longer overlaps with the square, and changing its color to match the color of the square.\n\ndef main(input_grid):\n    # Step 1: Detect the square and rectangle in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=True, connectivity=4)\n    \n    # Identify the square and rectangle based on their size\n    square = max(objects, key=lambda o: np.count_nonzero(o) if o.shape[0] == o.shape[1] else -1)\n    rectangle = min(objects, key=lambda o: np.count_nonzero(o) if o.shape[0] != o.shape[1] else float(\u0027inf\u0027))\n\n    square_color = square[square != Color.BLACK][0]\n    \n    # Step 2: Determine the bounding boxes for the square and rectangle\n    square_coords = np.argwhere(input_grid == square_color)\n    rectangle_coords = np.argwhere(input_grid != Color.BLACK)\n\n    min_x_square, min_y_square = square_coords.min(axis=0)\n    max_x_square, max_y_square = square_coords.max(axis=0)\n\n    min_x_rectangle, min_y_rectangle = rectangle_coords.min(axis=0)\n    max_x_rectangle, max_y_rectangle = rectangle_coords.max(axis=0)\n\n    # Step 3: Shift the rectangle to the right until there is no overlap\n    while collision(object1=input_grid, object2=rectangle, x1=min_x_rectangle, y1=min_y_rectangle, x2=max_x_square + 1, y2=min_y_square):\n        # Shift rectangle to the right\n        min_x_rectangle += 1\n        max_x_rectangle += 1\n\n    # Step 4: Change the rectangle\u0027s color to match the square\u0027s color\n    output_grid = np.copy(input_grid)\n    output_grid[min_x_rectangle:max_x_rectangle + 1, min_y_rectangle:max_y_rectangle + 1] = square_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid of size 10x10\n    grid_size = 10\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Create a square of random size between 2 and 4\n    square_size = np.random.randint(2, 5)\n    square_color = np.random.choice(Color.NOT_BLACK)\n    square = np.full((square_size, square_size), square_color)\n\n    # Place the square in the center of the grid\n    center_x = grid_size // 2 - square_size // 2\n    center_y = grid_size // 2 - square_size // 2\n    blit_sprite(grid, square, center_x, center_y)\n\n    # Create a rectangle of random width and height but ensure it overlaps\n    rect_width = np.random.randint(1, 5)\n    rect_height = np.random.randint(1, 5)\n    rect_color = np.random.choice([c for c in Color.NOT_BLACK if c != square_color])\n    rectangle = np.full((rect_height, rect_width), rect_color)\n\n    # Position the rectangle to ensure it overlaps with the square\n    rect_x = center_x + square_size - 1\n    rect_y = center_y + np.random.randint(0, square_size)\n    blit_sprite(grid, rectangle, rect_x, rect_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/144/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/144/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/144/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/144/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/144/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/144/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/144/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/144/images/train_output_2.png"}]}, "index": 144, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# wave propagation, color mapping\n\n# description:\n# In the input, you will see a row of colored pixels (dots) on a black background, with additional colored pixels scattered around.\n# To create the output, generate a wave effect that propagates from each colored dot horizontally, creating horizontal lines of the same color extending to the left and the right until they reach the edge of the grid or another colored dot.\n\ndef main(input_grid):\n    # Create a copy of the input grid to work on\n    output_grid = np.copy(input_grid)\n\n    # Find the row index that contains the colored dots\n    row_index = np.where(np.any(input_grid != Color.BLACK, axis=0))[0]\n    if len(row_index) == 0:\n        return output_grid  # If no colored pixels, return the original grid\n\n    target_row = min(row_index)\n\n    # Get the colored pixels in the target row\n    colored_pixels = np.where(output_grid[target_row] != Color.BLACK)[0]\n\n    # For each colored pixel, draw horizontal lines to the left and right\n    for col in colored_pixels:\n        color = output_grid[target_row, col]\n        # Draw left\n        draw_line(output_grid, x=target_row, y=col, direction=(0, -1), color=color)\n        # Draw right\n        draw_line(output_grid, x=target_row, y=col, direction=(0, 1), color=color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly choose a row for the colored dots\n    target_row = np.random.randint(0, 20)\n\n    # Randomly generate colored dots in the target row\n    n_dots = np.random.randint(3, 8)\n    columns = np.random.choice(np.arange(20), size=n_dots, replace=False)\n    \n    for col in columns:\n        color = np.random.choice(Color.NOT_BLACK)\n        input_grid[target_row, col] = color\n\n    # Optionally scatter some additional colored pixels around, not in the target row\n    n_extra_pixels = np.random.randint(10, 20)\n    for _ in range(n_extra_pixels):\n        while True:\n            x, y = np.random.randint(0, 20), np.random.randint(0, 20)\n            if x != target_row and input_grid[x, y] == Color.BLACK:  # Ensure we don\u0027t overlap\n                input_grid[x, y] = np.random.choice(Color.NOT_BLACK)\n                break\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/145/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/145/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/145/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/145/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/145/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/145/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/145/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/145/images/train_output_2.png"}]}, "index": 145, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# clustering, counting, color mapping\n\n# description:\n# In the input, you will see a grid with colored pixels scattered throughout. \n# To create the output, identify clusters of the same color that are adjacent to each other, \n# count the number of pixels in each cluster, and represent each cluster\u0027s size with a corresponding color:\n# 1 pixel: BLUE\n# 2 pixels: GREEN\n# 3 pixels: YELLOW\n# 4 or more pixels: RED\n# Any uncolored pixels will be black in the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Find connected components (clusters) in the grid\n    clusters = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Color the output grid based on the size of each cluster\n    for cluster in clusters:\n        num_pixels = np.sum(cluster != Color.BLACK)\n\n        # Determine color based on the cluster size\n        if num_pixels == 1:\n            color = Color.BLUE\n        elif num_pixels == 2:\n            color = Color.GREEN\n        elif num_pixels == 3:\n            color = Color.YELLOW\n        else:\n            color = Color.RED\n        \n        # Assign the determined color to the corresponding pixels in the output grid\n        output_grid[cluster != Color.BLACK] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the size of the grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the number of clusters to create\n    num_clusters = np.random.randint(3, 7)\n\n    for _ in range(num_clusters):\n        # Create a random cluster size (between 1 and 5)\n        cluster_size = np.random.randint(1, 6)\n        # Choose a random position to start the cluster\n        start_x, start_y = np.random.randint(1, n - 1), np.random.randint(1, m - 1)\n\n        # Draw the cluster\n        for _ in range(cluster_size):\n            # Randomly choose a position around the starting point to create a cluster\n            dx, dy = np.random.choice([-1, 0, 1]), np.random.choice([-1, 0, 1])\n            new_x, new_y = start_x + dx, start_y + dy\n            \n            # Ensure we stay within bounds\n            if 0 \u003c= new_x \u003c n and 0 \u003c= new_y \u003c m:\n                grid[new_x, new_y] = Color.GREEN  # Use green for cluster pixels initially\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/146/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/146/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/146/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/146/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/146/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/146/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/146/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/146/images/train_output_2.png"}]}, "index": 146, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contour detection, edge highlighting\n\n# description:\n# In the input, you will see a grid filled with various colors on a black background.\n# To create the output, detect the contours of each colored object and draw a thick maroon outline around them,\n# effectively highlighting the edges of the objects.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (colored objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4)\n\n    # Iterate through each detected object\n    for obj in objects:\n        # Get the bounding box of the current object\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n        # Draw a thick maroon outline around the detected object\n        for dx in range(-1, 2):   # This will create a 3-pixel wide outline\n            for dy in range(-1, 2):  # This will create a 3-pixel high outline\n                if abs(dx) + abs(dy) == 1:  # Only draw on the outer edge\n                    draw_line(output_grid, x + dx, y, direction=(0, 1), color=Color.MAROON)  # Vertical edges\n                    draw_line(output_grid, x + width + dx - 1, y, direction=(0, 1), color=Color.MAROON)  # Right edge\n                    draw_line(output_grid, x, y + dy, direction=(1, 0), color=Color.MAROON)  # Horizontal edges\n                    draw_line(output_grid, x, y + height + dy - 1, direction=(1, 0), color=Color.MAROON)  # Bottom edge\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid filled with a black background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of colored sprites\n    num_sprites = np.random.randint(3, 7)\n    for _ in range(num_sprites):\n        # Create a random sprite with colors (not black)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), color_palette=[color])\n\n        # Attempt to place the sprite in a random free location on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except:\n            pass  # If placement fails, just skip to the next sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/147/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/147/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/147/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/147/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/147/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/147/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/147/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/147/images/train_output_2.png"}]}, "index": 147, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, background removal\n\n# description:\n# In the input, you will see several shapes of different colors against a complex background. \n# To create the output, isolate the shapes by removing the background, leaving only the shapes visible on a blue canvas.\n\ndef main(input_grid):\n    # Step 1: Determine the background color (the most common color that\u0027s not black)\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n\n    # Step 2: Create an output grid initialized with blue color (Color.BLUE)\n    output_grid = np.full(input_grid.shape, Color.BLUE)\n\n    # Step 3: Find connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Step 4: For each shape, replace the corresponding area in the output grid with the shape\u0027s color\n    for shape in shapes:\n        if np.sum(shape != Color.BLACK) \u003e 0:  # Make sure it\u0027s not the background\n            color = np.argmax(np.bincount(shape[shape != Color.BLACK]))  # Get the shape\u0027s color\n            output_grid[shape == color] = color  # Assign that color to the output grid\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(15, 30, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose a number of random shapes (2-5)\n    num_shapes = np.random.randint(2, 6)\n\n    for _ in range(num_shapes):\n        # Create a random shape (2-7)x(2-7) in a random color\n        w, h = np.random.randint(2, 8), np.random.randint(2, 8)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n        shape = random_sprite(w, h, color_palette=[shape_color])\n\n        # Blit the shape onto a random location on the grid\n        x, y = random_free_location_for_sprite(grid, shape)\n        blit_sprite(grid, shape, x, y)\n\n    # Randomly add background noise (pixels) of a different color\n    noise_color = np.random.choice([color for color in Color.NOT_BLACK if color != shape_color])\n    num_noise_pixels = np.random.randint(10, 30)\n    for _ in range(num_noise_pixels):\n        x, y = np.random.randint(n), np.random.randint(m)\n        grid[x, y] = noise_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/148/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/148/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/148/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/148/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/148/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/148/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/148/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/148/images/train_output_2.png"}]}, "index": 148, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, quadrant mapping\n\n# description:\n# In the input, you will see a grid divided into four quadrants, each filled with a different color.\n# To produce the output, transform the colors in each quadrant according to the following mapping:\n# red -\u003e yellow, green -\u003e blue, blue -\u003e red, yellow -\u003e green.\n# Finally, merge the quadrants into one cohesive grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the input grid\n    rows, cols = input_grid.shape\n    \n    # Determine the midpoints for splitting the grid into quadrants\n    mid_row, mid_col = rows // 2, cols // 2\n    \n    # Define the color mapping\n    color_map = {\n        Color.RED: Color.YELLOW,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN\n    }\n    \n    # Create the output grid\n    output_grid = np.empty_like(input_grid)\n\n    # Transform each quadrant\n    # Top-left quadrant\n    output_grid[:mid_row, :mid_col] = np.vectorize(lambda color: color_map.get(color, color))(input_grid[:mid_row, :mid_col])\n    \n    # Top-right quadrant\n    output_grid[:mid_row, mid_col:] = np.vectorize(lambda color: color_map.get(color, color))(input_grid[:mid_row, mid_col:])\n    \n    # Bottom-left quadrant\n    output_grid[mid_row:, :mid_col] = np.vectorize(lambda color: color_map.get(color, color))(input_grid[mid_row:, :mid_col])\n    \n    # Bottom-right quadrant\n    output_grid[mid_row:, mid_col:] = np.vectorize(lambda color: color_map.get(color, color))(input_grid[mid_row:, mid_col:])\n\n    return output_grid\n    \ndef generate_input() -\u003e np.ndarray:\n    # Step 1: Create a grid with random sizes\n    n, m = np.random.randint(8, 16), np.random.randint(8, 16)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Step 2: Determine midpoints to form quadrants\n    mid_row, mid_col = n // 2, m // 2\n\n    # Step 3: Fill each quadrant with a different color\n    unique_colors = list(Color.NOT_BLACK)  # All colors except black\n    np.random.shuffle(unique_colors)  # Shuffle to select unique colors for quadrants\n\n    # Fill top-left quadrant\n    grid[:mid_row, :mid_col] = unique_colors[0]\n    # Fill top-right quadrant\n    grid[:mid_row, mid_col:] = unique_colors[1]\n    # Fill bottom-left quadrant\n    grid[mid_row:, :mid_col] = unique_colors[2]\n    # Fill bottom-right quadrant\n    grid[mid_row:, mid_col:] = unique_colors[3]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/149/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/149/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/149/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/149/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/149/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/149/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/149/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/149/images/train_output_2.png"}]}, "index": 149, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, filling, transformation\n\n# description:\n# In the input, you will see a grid with various colored shapes on a black background.\n# To make the output grid, you should detect the largest shape (in terms of pixel count) \n# and fill its interior with a new color while leaving the border of the shape unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Detect all colored objects in the grid that are not black\n    shapes = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=False, connectivity=8)\n\n    # Find the largest shape based on the number of pixels\n    largest_shape = max(shapes, key=lambda shape: np.sum(shape != Color.BLACK))\n    \n    # Create a mask for the largest shape\n    mask = (largest_shape != Color.BLACK)\n    \n    # Get the color of the largest shape\u0027s border\n    border_color = largest_shape[mask][0]\n    \n    # Fill the interior of the largest shape with a new color (for example, Color.YELLOW)\n    fill_color = Color.YELLOW\n    output_grid[mask] = fill_color\n    output_grid[largest_shape == border_color] = border_color  # Restore the border color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random shapes in the grid\n    for _ in range(np.random.randint(5, 10)):\n        shape_color = np.random.choice(Color.NOT_BLACK)\n        shape_height, shape_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape = random_sprite(shape_height, shape_width, color_palette=[shape_color], density=0.5)\n        \n        # Find a random location to place the shape\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n        blit_sprite(grid, shape, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/150/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/150/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/150/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/150/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/150/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/150/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/150/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/150/images/train_output_2.png"}]}, "index": 150, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape recognition, color transformation\n\n# description:\n# The input grid consists of various colored shapes that are separated by a black background. \n# Each of the shapes has a unique color. The output grid should be generated by transforming \n# the colors of each shape based on a specific rule: \n# if a shape is red, it should be transformed to blue, if it is blue, transform it to green, \n# and if it is green, transform it to red. All other colors should remain unchanged.\n\ndef main(input_grid):\n    # Create an output grid initialized to the same values as the input grid\n    output_grid = input_grid.copy()\n\n    # Define a mapping for color transformations\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.BLUE: Color.GREEN,\n        Color.GREEN: Color.RED\n    }\n\n    # Iterate through each color in the color map and apply the transformation\n    for original_color, new_color in color_map.items():\n        output_grid[output_grid == original_color] = new_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a black grid with random dimensions\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide how many shapes to create (1 to 5 shapes)\n    num_shapes = np.random.randint(1, 6)\n\n    # Generate random color palette including red, blue, and green\n    shape_colors = [Color.RED, Color.BLUE, Color.GREEN]\n    \n    for _ in range(num_shapes):\n        # Generate a random sprite shape\n        sprite_width = np.random.randint(2, 5)\n        sprite_height = np.random.randint(2, 5)\n        sprite = random_sprite(sprite_height, sprite_width, color_palette=shape_colors, connectivity=4)\n\n        # Find a random free location to blit the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except:\n            # If failed to find a location, skip this shape\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/151/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/151/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/151/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/151/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/151/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/151/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/151/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/151/images/train_output_2.png"}]}, "index": 151, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, shape isolation, color transformation\n\n# description:\n# In the input, you will see a 10x10 grid containing a random shape made of various colored pixels surrounded by black pixels. To make the output, isolate the shape and change its colors to green while preserving the shape\u0027s structure.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect the boundaries of the shape (non-black pixels).\n    # 2. Create a new grid and fill it with black.\n    # 3. Change the color of the detected shape\u0027s pixels to green in the new grid.\n\n    # 1. Detect the shape by finding the bounding box of non-black pixels\n    bounding_box_coords = bounding_box(input_grid, background=Color.BLACK)\n    x, y, width, height = bounding_box_coords\n\n    # 2. Create the output grid, which is all black\n    output_grid = np.zeros_like(input_grid)\n\n    # 3. Change the color of the detected shape\u0027s pixels to green\n    for i in range(x, x + width):\n        for j in range(y, y + height):\n            if input_grid[i, j] != Color.BLACK:\n                output_grid[i, j] = Color.GREEN\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    \n    # First, create a 10x10 black grid as the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels to create a random shape\n    colors = list(Color.NOT_BLACK)\n    shape_color = np.random.choice(colors)\n    \n    # Use random_scatter_points to create the shape\n    grid = random_scatter_points(grid=grid, color=shape_color, density=0.5, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/152/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/152/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/152/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/152/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/152/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/152/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/152/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/152/images/train_output_2.png"}]}, "index": 152, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, shape transformation\n\n# description:\n# In the input grid, you will see a circular shape of colored pixels surrounded by black pixels.\n# To create the output grid, you should transform the circular shape into a square shape \n# and map its colors to a new set: red to blue, green to yellow, and blue to green.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Detect the circular shape in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    circular_shape = max(objects, key=lambda o: np.count_nonzero(o))\n\n    # Create an output grid that is the same size as the input grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Define the color mapping\n    color_mapping = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.GREEN\n    }\n\n    # Get the bounding box of the circular shape\n    x, y, width, height = bounding_box(circular_shape, background=Color.BLACK)\n\n    # Calculate the center of the circular shape\n    center_x = x + width // 2\n    center_y = y + height // 2\n\n    # Create the square shape in the output grid\n    square_size = max(width, height)\n    square_top_left_x = center_x - square_size // 2\n    square_top_left_y = center_y - square_size // 2\n\n    for i in range(square_size):\n        for j in range(square_size):\n            # Calculate the corresponding position in the circular shape\n            circular_x = x + i * (width // square_size)\n            circular_y = y + j * (height // square_size)\n\n            # Check if the circular shape has a color\n            if 0 \u003c= circular_x \u003c input_grid.shape[0] and 0 \u003c= circular_y \u003c input_grid.shape[1]:\n                current_color = input_grid[circular_x, circular_y]\n                if current_color in color_mapping:\n                    output_grid[square_top_left_x + i, square_top_left_y + j] = color_mapping[current_color]\n                else:\n                    output_grid[square_top_left_x + i, square_top_left_y + j] = current_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 20x20 black grid\n    grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly choose a center for the circular shape\n    center_x, center_y = np.random.randint(5, 15), np.random.randint(5, 15)\n\n    # Define the radius of the circular shape\n    radius = np.random.randint(3, 6)\n\n    # Randomly assign colors to the circular shape\n    colors = [Color.RED, Color.GREEN, Color.BLUE]\n    for angle in np.linspace(0, 2 * np.pi, 100):\n        x = int(center_x + radius * np.cos(angle))\n        y = int(center_y + radius * np.sin(angle))\n        if 0 \u003c= x \u003c 20 and 0 \u003c= y \u003c 20:\n            grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/153/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/153/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/153/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/153/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/153/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/153/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/153/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/153/images/train_output_2.png"}]}, "index": 153, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color gradient, pixel expansion\n\n# description:\n# In the input, you will see a single pixel of one color surrounded by a maroon background. \n# To make the output grid, expand the pixel into a gradient that transitions from the original color to maroon, \n# filling a 5x5 area around the pixel with the gradient.\n\ndef main(input_grid):\n    # Find the location of the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.MAROON)\n    assert len(colored_pixel_locations) == 1, \"There should be exactly one colored pixel.\"\n    colored_pixel_location = colored_pixel_locations[0]\n    colored_x, colored_y = colored_pixel_location\n\n    # Get the color of the pixel\n    pixel_color = input_grid[colored_x, colored_y]\n\n    # Create output grid and fill it with maroon\n    output_grid = np.full_like(input_grid, Color.MAROON)\n\n    # Fill the 5x5 area with the gradient\n    for dx in range(-2, 3):\n        for dy in range(-2, 3):\n            # Calculate distance from the original pixel\n            distance = max(abs(dx), abs(dy))\n            # Calculate the gradient color based on distance\n            gradient_color = blend_colors(pixel_color, Color.MAROON, distance / 2.0)\n            output_grid[colored_x + dx, colored_y + dy] = gradient_color\n\n    return output_grid\n\ndef blend_colors(color1, color2, ratio):\n    \"\"\" Blend two colors based on a ratio. Color ratio is from 0 to 1. \"\"\"\n    # For simplicity, we will simply return color1 if ratio is 0 and color2 if ratio is 1.\n    if ratio \u003c= 0:\n        return color1\n    elif ratio \u003e= 1:\n        return color2\n    else:\n        return color1  # In a real implementation, we would blend the colors, but for this example we just return the original color.\n\ndef generate_input():\n    # Create a grid of random dimensions\n    width, height = np.random.randint(5, 20, size=2)\n    input_grid = np.full((width, height), Color.MAROON)\n\n    # Place a single pixel of a random color in the grid\n    random_color = np.random.choice(Color.NOT_BLACK)\n    input_grid[width // 2, height // 2] = random_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/154/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/154/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/154/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/154/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/154/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/154/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/154/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/154/images/train_output_2.png"}]}, "index": 154, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# overlapping patterns, blending\n\n# description:\n# In the input, you will see multiple overlapping patterns in different colors. \n# To create the output, blend the colors in the overlapping regions to create new colors based on the blending mode (e.g., additive or subtractive blending).\n\ndef blend_colors(color1, color2):\n    # Simple additive blending: \n    # Assuming colors are represented numerically, this function sums the RGB values and clamps to maximum color value.\n    return min(color1 + color2, 255)  # Assuming color values range from 0 to 255\n\ndef main(input_grid):\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all connected components that are not the background\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    for component in components:\n        # Identify the bounding box of the component\n        x, y, width, height = bounding_box(component, background=Color.BLACK)\n\n        # Place the component in the output grid\n        for i in range(height):\n            for j in range(width):\n                if component[i, j] != Color.BLACK:\n                    if output_grid[y + i, x + j] == Color.BLACK:\n                        output_grid[y + i, x + j] = component[i, j]\n                    else:\n                        # Blend the existing color with the new color\n                        blended_color = blend_colors(output_grid[y + i, x + j], component[i, j])\n                        output_grid[y + i, x + j] = blended_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random overlapping patterns\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random number of patterns\n    num_patterns = np.random.randint(3, 6)\n    for _ in range(num_patterns):\n        # Create a random colored pattern\n        sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=Color.NOT_BLACK, density=0.5)\n        # Find a random location to place this sprite\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/155/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/155/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/155/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/155/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/155/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/155/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/155/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/155/images/train_output_2.png"}]}, "index": 155, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connectivity, color merging, adjacency\n\n# description:\n# In the input, you will see several colored pixels scattered across the grid. To create the output, \n# identify all connected components of the same color and merge them into one single pixel of that color, \n# while ensuring that the adjacent pixels are merged into a single color as well.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an empty output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Find connected components\n    components = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Assign each component a unique position in the output grid\n    for component in components:\n        # Get the color of the current component\n        color = component[0, 0]\n        \n        # Get the coordinates of the component\n        coords = np.argwhere(input_grid == color)\n        if len(coords) \u003e 0:\n            # Merge the component by placing a single pixel of its color\n            # Calculate the center of mass to place the merged color\n            center_x = int(np.mean(coords[:, 0]))\n            center_y = int(np.mean(coords[:, 1]))\n            \n            # Place the merged color in the output grid\n            output_grid[center_x, center_y] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a number of colors to use\n    colors_to_use = np.random.choice(Color.NOT_BLACK, size=np.random.randint(2, 6), replace=False)\n\n    # Randomly scatter pixels of each selected color across the grid\n    for color in colors_to_use:\n        grid = random_scatter_points(grid=grid, color=color, density=0.3)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/156/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/156/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/156/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/156/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/156/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/156/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/156/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/156/images/train_output_2.png"}]}, "index": 156, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel rotation, mirroring\n\n# description:\n# In the input, you will see a small object represented by colored pixels. \n# To make the output, rotate the object by 90 degrees clockwise and place it in the center \n# of a larger empty grid, while mirroring its color pattern in the opposite quadrant.\n\ndef main(input_grid):\n    # Rotate the input object 90 degrees clockwise\n    rotated_object = np.rot90(input_grid, k=-1)  # k=-1 for clockwise rotation\n\n    # Create an output grid that is larger than the input grid\n    output_size = max(rotated_object.shape) * 2\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # Calculate the center position for the rotated object\n    center_x, center_y = output_size // 2, output_size // 2\n\n    # Blit the rotated object to the center\n    blit_sprite(output_grid, rotated_object, center_x - rotated_object.shape[0] // 2, center_y - rotated_object.shape[1] // 2)\n\n    # Mirror the rotated object across the center into the opposite quadrant\n    mirrored_object = np.flipud(rotated_object)\n    blit_sprite(output_grid, mirrored_object, center_x - rotated_object.shape[0] // 2, center_y - rotated_object.shape[1] // 2 + rotated_object.shape[1])\n\n    return output_grid\n\ndef generate_input():\n    # Create a random small object with colors (not black)\n    n, m = np.random.randint(2, 5), np.random.randint(2, 5)  # Small object size\n    grid = random_sprite(n, m, density=0.8, color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/157/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/157/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/157/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/157/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/157/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/157/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/157/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/157/images/train_output_2.png"}]}, "index": 157, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# radial symmetry, pattern creation\n\n# description:\n# In the input, you will see a central colored pixel on a white background.\n# To create the output, generate a radial pattern of the same color that extends outward in all directions\n# from the central pixel, forming a circular design.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Locate the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1  # Ensure there is exactly one colored pixel\n    colored_x, colored_y = colored_pixel_locations[0]\n\n    # Get the color of the central pixel\n    color = input_grid[colored_x, colored_y]\n\n    # Draw a circular pattern centered at the colored pixel\n    radius = 5  # You can adjust the radius or make it dynamic\n    for angle in range(0, 360, 10):  # Draw lines in 10-degree increments\n        rad = np.radians(angle)\n        for r in range(1, radius + 1):\n            x = int(colored_x + r * np.cos(rad))\n            y = int(colored_y + r * np.sin(rad))\n            if 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:\n                output_grid[x, y] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid with a white background\n    grid_size = random.randint(7, 15)\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly select a position for the colored pixel\n    x, y = random.randint(1, grid_size - 2), random.randint(1, grid_size - 2)\n    color = random.choice(list(Color.NOT_BLACK))\n    input_grid[x, y] = color\n    \n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/158/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/158/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/158/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/158/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/158/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/158/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/158/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/158/images/train_output_2.png"}]}, "index": 158, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern replication, boundary detection, color filling\n\n# description:\n# In the input, you will see a pattern located in the center of a grid. \n# To create the output, replicate the pattern in each corner of the grid, \n# ensuring that it touches the edges of the grid. If the pattern has any \n# transparent pixel (black), those pixels should be filled with a default color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the bounding box of the non-background pixels in the input grid\n    pattern_bbox = bounding_box(input_grid, background=Color.BLACK)\n    pattern_x, pattern_y, pattern_width, pattern_height = pattern_bbox\n    \n    # Crop the pattern from the input grid\n    pattern = crop(input_grid, background=Color.BLACK)\n\n    # Determine the size of the output grid\n    output_width = max(pattern_width + 2, pattern_height + 2)\n    output_height = output_width\n\n    # Create the output grid with a black background\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Define the coordinates for the corners of the output grid\n    corners = [\n        (0, 0),  # Top-left\n        (0, output_width - pattern_width),  # Top-right\n        (output_height - pattern_height, 0),  # Bottom-left\n        (output_height - pattern_height, output_width - pattern_width)  # Bottom-right\n    ]\n\n    # Place the pattern in each corner of the output grid\n    for x, y in corners:\n        blit_sprite(output_grid, pattern, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random sized grid with a black background\n    n = np.random.randint(5, 10)\n    m = np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random pattern in the center of the grid\n    pattern_size = np.random.randint(2, min(n, m) - 1)\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Set the pattern in the center of the grid\n    start_x = (n - pattern_size) // 2\n    start_y = (m - pattern_size) // 2\n\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[start_x + i, start_y + j] = np.random.choice([pattern_color, Color.BLACK])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/159/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/159/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/159/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/159/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/159/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/159/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/159/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/159/images/train_output_2.png"}]}, "index": 159, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, rotation\n\n# description:\n# In the input, you will see a colored shape on a grid. To make the output, create a rotated version of the shape that is symmetrical about the center of the grid. The rotation should be clockwise by 90 degrees, and the output should maintain the same color as the original shape.\n\ndef main(input_grid):\n    # Crop the input grid to get the shape\n    shape = crop(input_grid)\n\n    # Rotate the shape clockwise by 90 degrees\n    rotated_shape = np.rot90(shape, k=-1)  # k=-1 for clockwise rotation\n\n    # Create an output grid the same size as the input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find the center of the original shape\n    shape_height, shape_width = shape.shape\n    center_x, center_y = shape_height // 2, shape_width // 2\n\n    # Calculate the position to place the rotated shape back into the output grid\n    start_x = (input_grid.shape[0] - rotated_shape.shape[0]) // 2\n    start_y = (input_grid.shape[1] - rotated_shape.shape[1]) // 2\n\n    # Blit the rotated shape into the output grid\n    blit_sprite(output_grid, rotated_shape, start_x, start_y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random shape of random size\n    n = np.random.randint(3, 7)  # Height of the shape\n    m = np.random.randint(3, 7)  # Width of the shape\n    shape = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    # Create an output grid to place the shape\n    grid = np.full((10, 10), Color.BLACK)  # A larger grid to allow for placement\n\n    # Find a random free location to place the shape in the grid\n    x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n\n    # Blit the shape into the grid\n    blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/160/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/160/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/160/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/160/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/160/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/160/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/160/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/160/images/train_output_2.png"}]}, "index": 160, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, color gradient filling\n\n# description:\n# In the input grid, you will see a shape that is radially symmetric around a central point on a black background. Each pixel of the shape has a single color. To create the output grid, fill the shape with a gradient that radiates outward from the central point, transitioning colors smoothly from the center to the edges of the shape.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the center of the shape.\n    # 2. Compute the distance of each pixel in the shape from the center.\n    # 3. Map these distances to a gradient of colors based on their distance from the center.\n    \n    # Find connected components (the shape) in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    assert len(components) == 1  # We expect only one radially symmetric shape\n    shape = components[0]\n\n    # Get the coordinates of the shape pixels\n    shape_coords = np.argwhere(shape != Color.BLACK)\n    center_y, center_x = np.mean(shape_coords, axis=0).astype(int)\n\n    # Calculate the maximum distance from the center to the edge of the shape\n    max_distance = np.max(np.sqrt((shape_coords[:, 0] - center_y) ** 2 + (shape_coords[:, 1] - center_x) ** 2))\n\n    # Create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Fill the gradient\n    for y, x in shape_coords:\n        distance = np.sqrt((y - center_y) ** 2 + (x - center_x) ** 2)\n        # Normalize the distance to get a value between 0 and 1\n        normalized_distance = distance / max_distance\n        # Choose a color based on the distance; here we map it to a color palette\n        gradient_color = interpolate_color(Color.RED, Color.BLUE, normalized_distance)  # Interpolating between two colors\n        output_grid[y, x] = gradient_color\n\n    return output_grid\n\ndef interpolate_color(color1, color2, t):\n    \"\"\" Interpolates between two colors based on a parameter t (0 \u003c= t \u003c= 1). \"\"\"\n    # Extract RGB values from colors\n    r1, g1, b1 = color_to_rgb(color1)\n    r2, g2, b2 = color_to_rgb(color2)\n\n    # Interpolate RGB values\n    r = int(r1 + (r2 - r1) * t)\n    g = int(g1 + (g2 - g1) * t)\n    b = int(b1 + (b2 - b1) * t)\n\n    # Convert back to a color representation (assuming colors are represented as strings)\n    return rgb_to_color(r, g, b)\n\ndef color_to_rgb(color):\n    \"\"\" Converts a color string to an RGB tuple. \"\"\"\n    color_mapping = {\n        Color.RED: (255, 0, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.GREEN: (0, 255, 0),\n        Color.YELLOW: (255, 255, 0),\n        Color.GREY: (128, 128, 128),\n        Color.PINK: (255, 192, 203),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.BLACK: (0, 0, 0)\n    }\n    return color_mapping[color]\n\ndef rgb_to_color(r, g, b):\n    \"\"\" Converts RGB values to a color string. \"\"\"\n    if r == 255 and g == 0 and b == 0:\n        return Color.RED\n    elif r == 0 and g == 0 and b == 255:\n        return Color.BLUE\n    elif r == 0 and g == 255 and b == 0:\n        return Color.GREEN\n    elif r == 255 and g == 255 and b == 0:\n        return Color.YELLOW\n    elif r == 128 and g == 128 and b == 128:\n        return Color.GREY\n    elif r == 255 and g == 192 and b == 203:\n        return Color.PINK\n    elif r == 255 and g == 165 and b == 0:\n        return Color.ORANGE\n    elif r == 0 and g == 128 and b == 128:\n        return Color.TEAL\n    elif r == 128 and g == 0 and b == 0:\n        return Color.MAROON\n    else:\n        return Color.BLACK  # Default fallback\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Choose a random color for the shape\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a random radial shape\n    radius = np.random.randint(5, 10)\n    center_x = np.random.randint(radius, 20 - radius)\n    center_y = np.random.randint(radius, 20 - radius)\n\n    # Fill in the radial shape\n    for y in range(20):\n        for x in range(20):\n            if np.sqrt((y - center_y) ** 2 + (x - center_x) ** 2) \u003c radius:\n                input_grid[y, x] = shape_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/161/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/161/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/161/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/161/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/161/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/161/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/161/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/161/images/train_output_2.png"}]}, "index": 161, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, symmetry detection, color filling\n\n# description:\n# In the input, you will see a grid with a symmetrical pattern composed of colored pixels in the center. \n# Surrounding this pattern are random colors. \n# To create the output, extract the symmetrical pattern, mirror it in the output grid, \n# and fill the outer areas with a uniform color that is different from the pattern\u0027s colors.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the connected components in the grid\n    components = find_connected_components(input_grid, monochromatic=False)\n\n    # Identify the symmetrical pattern (assuming there\u0027s only one)\n    pattern = components[0]  # For simplicity, we assume there\u0027s only one pattern\n    bounding_box_coords = bounding_box(pattern)\n\n    # Crop the pattern\n    cropped_pattern = crop(pattern)\n\n    # Create an output grid with a uniform color for the background\n    output_color = Color.BLUE  # Choose a uniform color for the output\n    output_grid = np.full((input_grid.shape[0], input_grid.shape[1]), output_color)\n\n    # Mirror the cropped pattern and place it in the center of the output grid\n    mirrored_pattern = np.copy(cropped_pattern)\n    mirrored_pattern = mirrored_pattern[:, ::-1]  # Reflect horizontally\n\n    # Calculate the center position to place the mirrored pattern\n    center_x = (output_grid.shape[0] - mirrored_pattern.shape[0]) // 2\n    center_y = (output_grid.shape[1] - mirrored_pattern.shape[1]) // 2\n\n    # Place the mirrored pattern in the output grid\n    blit_sprite(output_grid, mirrored_pattern, x=center_x, y=center_y, background=output_color)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid size\n    n, m = np.random.randint(6, 10), np.random.randint(6, 10)\n    \n    # Generate a central symmetrical pattern\n    pattern_size = np.random.randint(3, 5)\n    central_pattern = random_sprite(pattern_size, pattern_size, density=1, symmetry=\u0027horizontal\u0027, color_palette=Color.NOT_BLACK)\n\n    # Create an empty grid with a black background\n    grid = np.full((n, m), Color.BLACK)\n\n    # Place the central symmetrical pattern in the grid\n    x_offset = (n - pattern_size) // 2\n    y_offset = (m - pattern_size) // 2\n    grid = blit_sprite(grid, central_pattern, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    # Fill surrounding areas with random colors\n    colors = np.random.choice(list(Color.NOT_BLACK), size=(n, m), replace=True)\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.BLACK:\n                grid[i, j] = colors[i, j]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/162/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/162/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/162/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/162/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/162/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/162/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/162/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/162/images/train_output_2.png"}]}, "index": 162, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, connectivity\n\n# description:\n# In the input grid, you will see a mix of colored pixels, with certain pixels designated as \"targets\" (marked in red).\n# Your task is to create an output grid where you connect all target pixels with the minimum number of lines\n# while avoiding black pixels. The connections should be made using green lines, and if any target pixel is isolated (not connected),\n# it should remain unchanged in the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Find all target pixels (red)\n    target_pixels = np.argwhere(input_grid == Color.RED)\n    \n    # If no targets, return input as output\n    if not target_pixels.size:\n        return output_grid\n\n    # Create a list to track connected components\n    connected_components = []\n\n    # A function to perform DFS and find connected targets\n    def dfs(x, y, component):\n        if (x, y) in component or input_grid[x, y] != Color.RED:\n            return\n        component.add((x, y))\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Up, Down, Left, Right\n            if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                dfs(x + dx, y + dy, component)\n\n    # Find connected components of target pixels\n    for px, py in target_pixels:\n        component = set()\n        dfs(px, py, component)\n        if component:\n            connected_components.append(component)\n\n    # Draw lines between connected components\n    for component in connected_components:\n        points = list(component)\n        # Draw lines between the first point and each subsequent point\n        for i in range(1, len(points)):\n            x1, y1 = points[i - 1]\n            x2, y2 = points[i]\n            draw_line(output_grid, x1, y1, end_x=x2, end_y=y2, color=Color.GREEN)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    num_targets = np.random.randint(1, 10)  # Random number of target pixels\n    for _ in range(num_targets):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.RED  # Place target pixels\n\n    # Scatter other colors in the grid while ensuring black pixels exist to avoid\n    num_other_colors = np.random.randint(5, 20)\n    for _ in range(num_other_colors):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color != Color.RED])\n\n    # Randomly place some black pixels to create obstacles\n    num_black_pixels = np.random.randint(5, 20)\n    for _ in range(num_black_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/163/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/163/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/163/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/163/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/163/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/163/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/163/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/163/images/train_output_2.png"}]}, "index": 163, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, repositioning\n\n# description:\n# In the input, you will see several colored squares (of size 2x2) arranged on a grid. Each square is a different color and is positioned randomly. To produce the output, rotate each square 90 degrees clockwise and reposition them so that they are centered within their original positions.\n\ndef main(input_grid):\n    # Step 1: Detect all the 2x2 colored squares in the input grid\n    square_objects = detect_objects(input_grid, background=Color.BLACK, allowed_dimensions=[(2, 2)],\n                                    monochromatic=False, connectivity=4)\n\n    # Step 2: Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    for square in square_objects:\n        # Step 3: Crop the square from the input grid\n        cropped_square = crop(square, background=Color.BLACK)\n\n        # Step 4: Rotate the square 90 degrees clockwise\n        rotated_square = np.rot90(cropped_square, k=-1)  # k=-1 for 90 degrees clockwise\n\n        # Get original position of the square in input grid\n        x, y = object_position(square, background=Color.BLACK, anchor=\"upper left\")\n\n        # Step 5: Calculate the new position for the rotated square\n        new_x = x + 1  # Center within the 2x2 block (the new top-left corner)\n        new_y = y + 1\n\n        # Step 6: Blit the rotated square back to the output grid\n        blit_sprite(output_grid, rotated_square, x=new_x, y=new_y)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a sufficiently large grid to accommodate the squares\n    grid_size = np.random.randint(6, 12)\n    grid = np.full((grid_size, grid_size), Color.BLACK, dtype=int)\n\n    # Randomly place 4 colored squares of size 2x2\n    colors = list(Color.NOT_BLACK)\n    for _ in range(4):\n        # Create a random color for the square\n        color = np.random.choice(colors)\n        \n        # Create a 2x2 sprite of that color\n        square = np.full((2, 2), color)\n        \n        # Find a random free location for the square in the grid\n        x, y = random_free_location_for_sprite(grid, square, border_size=1)\n        blit_sprite(grid, square, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/164/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/164/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/164/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/164/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/164/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/164/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/164/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/164/images/train_output_2.png"}]}, "index": 164, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape transformation, reflection\n\n# description:\n# In the input, you will see a colored shape that has been reflected vertically.\n# To make the output, create a new shape that is a horizontal reflection of the input shape,\n# effectively mirroring it across the horizontal axis.\n\ndef main(input_grid):\n    # Get the bounding box of the input shape\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Extract the shape from the input grid\n    shape = input_grid[x:x + width, y:y + height]\n\n    # Reflect the shape horizontally\n    reflected_shape = shape[::-1, :]\n\n    # Create an output grid that is large enough to hold the original and the reflected shape\n    output_height = height * 2\n    output_grid = np.full((width, output_height), Color.BLACK)\n\n    # Place the original shape on the top half of the output grid\n    output_grid[x:x + width, y:y + height] = shape\n\n    # Place the reflected shape on the bottom half of the output grid\n    output_grid[x:x + width, y + height:y + output_height] = reflected_shape\n\n    return output_grid\n\ndef generate_input():\n    # Create a random colored shape that will be reflected vertically in the output\n    # Define random dimensions for the sprite\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n\n    # Generate a random shape with colors (not symmetric)\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    # Reflect the shape vertically to create the input grid\n    reflected_grid = np.copy(grid[:, ::-1])\n\n    # Create a final input grid that contains the original shape and its vertical reflection\n    input_grid = np.full((n, m * 2), Color.BLACK)\n    input_grid[:, :m] = grid\n    input_grid[:, m:] = reflected_grid\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/165/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/165/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/165/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/165/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/165/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/165/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/165/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/165/images/train_output_2.png"}]}, "index": 165, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color subtraction, pixel masking, overlap detection\n\n# description:\n# In the input, you will see a grid containing several colored polygons on a black background. Each polygon is made up of colored pixels, with no overlaps except for the black background.\n# To make the output, remove all the pixels from the polygons that overlap with a predefined mask, which is a cross shape centered in the grid. The remaining pixels should be the output.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Create a mask in the shape of a cross centered in the grid.\n    # 2. For each colored pixel in the input grid, check if it overlaps with the mask.\n    # 3. If it overlaps, set that pixel in the output grid to black (remove it), otherwise retain its color.\n\n    output_grid = np.copy(input_grid)\n\n    # Create a cross mask in the center of the grid\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n    mask_size = 1  # The size of the cross\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            if i == center_x or j == center_y:\n                output_grid[i, j] = Color.BLACK  # Set the mask area to black (removal)\n\n    # Remove pixels that overlap with the mask\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            if output_grid[i, j] == Color.BLACK and input_grid[i, j] != Color.BLACK:\n                # If the input has a color but the output is black, remove it by setting to black\n                output_grid[i, j] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    # Initialize a grid with a black background of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate colored polygons on the grid\n    num_polygons = np.random.randint(2, 5)  # Random number of polygons\n    for _ in range(num_polygons):\n        # Create a random polygon (a small cluster of colored pixels)\n        polygon_width, polygon_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        color = random.choice(Color.NOT_BLACK)  # Pick a random color\n        polygon = random_sprite(polygon_width, polygon_height, density=1.0, color_palette=[color])\n\n        # Place the polygon in a random free location on the grid\n        x, y = random_free_location_for_sprite(grid, polygon, background=Color.BLACK, padding=1)\n        blit_sprite(grid, polygon, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/166/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/166/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/166/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/166/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/166/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/166/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/166/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/166/images/train_output_2.png"}]}, "index": 166, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alternating patterns, layering, color repetition\n\n# description:\n# In the input, you will see rows of colored pixels that alternate between two colors. \n# To create the output, layer the alternating patterns on top of each other, ensuring that the colors alternate correctly across the entire grid. \n# The output grid should reflect the layered colors from the input while maintaining the alternating structure.\n\ndef main(input_grid):\n    # Initialize the output grid with the same shape as input\n    output_grid = np.copy(input_grid)\n\n    # Get the number of rows and columns in the input grid\n    rows, cols = input_grid.shape\n\n    # Iterate through each row\n    for row in range(rows):\n        # Determine the base color from the first pixel of the current row\n        base_color = input_grid[row, 0]\n\n        # Layer the colors in the output grid\n        for col in range(cols):\n            # Check if the current column is even or odd\n            if col % 2 == 0:\n                output_grid[row, col] = base_color  # Even columns take the base color\n            else:\n                # Find the color that is not the base color\n                alternate_color = Color.RED if base_color != Color.RED else Color.BLUE\n                output_grid[row, col] = alternate_color  # Odd columns take the alternate color\n\n    return output_grid\n\ndef generate_input():\n    # Randomly choose two colors for the alternating pattern\n    colors = np.random.choice(list(Color.NOT_BLACK), 2, replace=False)\n    \n    # Decide the size of the grid\n    rows, cols = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((rows, cols), dtype=int)\n    \n    # Fill the grid with alternating colors\n    for row in range(rows):\n        for col in range(cols):\n            grid[row, col] = colors[col % 2]  # Alternating colors across columns\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/167/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/167/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/167/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/167/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/167/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/167/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/167/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/167/images/train_output_2.png"}]}, "index": 167, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# masking, surrounding, color filling\n\n# description:\n# In the input, you will see a grid filled with a background color and a few scattered colored pixels.\n# To produce the output, create a mask using the scattered colored pixels, and change the colors of the pixels \n# surrounding them (in 8 directions) to a specified highlight color, while keeping the scattered pixels unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    background_color = np.min(output_grid)  # Assume the background is the minimum color value (0)\n    \n    # Get coordinates of scattered colored pixels\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] != background_color:  # If it\u0027s not the background\n                # Highlight surrounding pixels\n                for dx in range(-1, 2):  # -1, 0, 1\n                    for dy in range(-1, 2):  # -1, 0, 1\n                        if dx == 0 and dy == 0:\n                            continue  # Skip the pixel itself\n                        nx, ny = x + dx, y + dy\n                        # Check if the new coordinates are within bounds\n                        if 0 \u003c= nx \u003c input_grid.shape[0] and 0 \u003c= ny \u003c input_grid.shape[1]:\n                            output_grid[nx, ny] = Color.YELLOW  # Change the surrounding pixel to highlight color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid with a black background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter some colored pixels\n    num_scattered_pixels = np.random.randint(5, 15)\n    for _ in range(num_scattered_pixels):\n        x, y = random.randint(0, n-1), random.randint(0, m-1)\n        color = random.choice(Color.NOT_BLACK)  # Pick a non-black color\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/168/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/168/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/168/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/168/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/168/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/168/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/168/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/168/images/train_output_2.png"}]}, "index": 168, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color extraction\n\n# description:\n# In the input grid, you will see various shapes made up of colored pixels on a black background. \n# Create the output by extracting the color of the shape that occupies the largest area, and fill the entire grid with that color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find all connected components (shapes) in the grid.\n    # 2. For each component, calculate its area (number of pixels).\n    # 3. Identify the color of the largest component.\n    # 4. Create an output grid filled with that color.\n\n    # 1. Find all connected components\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK, connectivity=8)\n    \n    max_area = 0\n    max_color = Color.BLACK\n\n    # 2. For each component, calculate its area\n    for obj in objects:\n        current_area = np.count_nonzero(obj)\n        if current_area \u003e max_area:\n            max_area = current_area\n            # Get the color of the current largest component\n            color_mask = obj != Color.BLACK\n            # Assuming the component is monochromatic, get its color\n            max_color = obj[color_mask][0] if color_mask.any() else Color.BLACK\n    \n    # 4. Create an output grid filled with that color\n    output_grid = np.full_like(input_grid, max_color)  # Fill the entire grid with the largest color\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with a black background and random colored shapes\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create random colored sprites and place them on the grid\n    num_shapes = np.random.randint(1, 5)\n    for _ in range(num_shapes):\n        # Random size for the shape\n        w, h = np.random.randint(2, 6), np.random.randint(2, 6)\n        color = np.random.choice(Color.NOT_BLACK)  # Choose a random color\n        sprite = random_sprite(w, h, color_palette=[color])  # Create a colored sprite\n\n        # Place the shape at a random position in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except:\n            continue  # If we can\u0027t place the sprite, skip to the next\n        \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/169/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/169/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/169/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/169/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/169/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/169/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/169/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/169/images/train_output_2.png"}]}, "index": 169, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection, lines\n\n# description:\n# In the input, you will see a colored shape on a black background. To create the output, reflect the shape across the central vertical axis of the grid, coloring the reflected pixels the same color as the original shape.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color (black)\n    output_grid = np.zeros_like(input_grid)\n\n    # Determine the width and height of the grid\n    height, width = input_grid.shape\n\n    # Find the bounding box of the colored object\n    x, y, obj_width, obj_height = bounding_box(input_grid != Color.BLACK)\n\n    # Reflect the shape across the central vertical axis\n    for i in range(obj_width):\n        for j in range(obj_height):\n            if input_grid[x + i, y + j] != Color.BLACK:  # Check if the pixel is part of the shape\n                # Calculate the corresponding x-coordinate for reflection\n                reflected_x = width - 1 - (x + i)\n                output_grid[reflected_x, y + j] = input_grid[x + i, y + j]\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random colored shape while ensuring it is centered\n    color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Randomly choose the size of the shape\n    shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n\n    # Random position ensuring it fits in the grid\n    start_x = np.random.randint(0, n - shape_width)\n    start_y = np.random.randint(0, m - shape_height)\n\n    # Draw the shape in the grid\n    for i in range(shape_width):\n        for j in range(shape_height):\n            grid[start_x + i, start_y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/170/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/170/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/170/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/170/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/170/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/170/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/170/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/170/images/train_output_2.png"}]}, "index": 170, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, boundary detection\n\n# description:\n# In the input grid, you will see a black background with a single colored shape that may be irregular. \n# To create the output grid, you will transform the shape into a rectangular boundary of the same color, \n# and fill the area inside this boundary with a different color (e.g., yellow). \n# If the shape is already a rectangle, the output should simply be a solid fill of the new color inside that rectangle.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect the connected component which is the colored shape.\n    # 2. Determine the bounding box of that shape.\n    # 3. Create the output grid, filling the bounding box with the new color (yellow) and drawing the original color as a border.\n\n    # Step 1: Find the colored object\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one colored shape in the input grid\"\n    colored_shape = objects[0]\n\n    # Step 2: Get bounding box of the colored object\n    x, y, width, height = bounding_box(colored_shape, background=Color.BLACK)\n\n    # Step 3: Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK, dtype=int)\n\n    # Fill the area inside the bounding box with yellow\n    output_grid[x+1:x+height-1, y+1:y+width-1] = Color.YELLOW\n    \n    # Draw the original color as a border\n    for i in range(height):\n        for j in range(width):\n            if (i == 0 or i == height - 1) or (j == 0 or j == width - 1):\n                output_grid[x + i, y + j] = input_grid[x + i, y + j]\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # 1. Create a black grid of size 20x20.\n    n, m = 20, 20\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # 2. Define a random color for the shape (not black), and choose a random size and position.\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Random width and height for the shape\n    width = np.random.randint(3, 10)\n    height = np.random.randint(3, 10)\n\n    # Random position ensuring the shape fits in the grid\n    x = np.random.randint(0, n - height)\n    y = np.random.randint(0, m - width)\n\n    # 3. Create the shape in the grid\n    for i in range(height):\n        for j in range(width):\n            input_grid[x + i, y + j] = color\n\n    # Optionally add some irregularity by clearing out random cells in the shape\n    for _ in range(np.random.randint(0, width * height // 4)):  # Clear some cells but not too many\n        clear_x = np.random.randint(x, x + height)\n        clear_y = np.random.randint(y, y + width)\n        input_grid[clear_x, clear_y] = Color.BLACK\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/171/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/171/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/171/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/171/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/171/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/171/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/171/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/171/images/train_output_2.png"}]}, "index": 171, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, transparency, blending\n\n# description:\n# In the input, you will see multiple layers of colored shapes with varying degrees of transparency. \n# To make the output, blend these layers together according to their transparency levels, producing a single image \n# that reflects the combined colors of all layers.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Extract connected components from the input grid\n    layers = find_connected_components(input_grid, monochromatic=False)\n\n    # Blend each layer based on its transparency (assumed to be represented by the color)\n    for layer in layers:\n        # Get the color of the current layer\n        layer_color = layer[layer != Color.BLACK][0]\n\n        # Assume transparency is determined by the brightness of the color (simplified for this example)\n        # Here we define a simple rule: if the color is bright (here we assume any non-black color), \n        # it adds to the output grid, else it doesn\u0027t.\n        if layer_color != Color.BLACK:\n            # Blend the layer with the output grid: \n            # We treat each color as having a \"weight\" based on its brightness.\n            blend_color = np.where(output_grid == Color.BLACK, layer_color, output_grid)\n\n            # Update the output grid\n            output_grid = np.where(blend_color == Color.BLACK, output_grid, blend_color)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Random number of layers\n    num_layers = np.random.randint(1, 5)\n\n    for _ in range(num_layers):\n        # Create a random sprite for the layer\n        layer_color = random.choice(list(Color.NOT_BLACK))\n        layer = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.7, color_palette=[layer_color])\n        \n        # Random position to place the layer in the grid\n        x, y = random_free_location_for_sprite(grid, layer, padding=1, background=Color.BLACK)\n        blit_sprite(grid, layer, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/172/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/172/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/172/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/172/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/172/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/172/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/172/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/172/images/train_output_2.png"}]}, "index": 172, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, color pattern generation\n\n# description:\n# In the input, you will see a central colored pixel on a white background. \n# To generate the output, create a pattern of colored pixels around the central pixel, \n# creating a radial symmetry effect where colors alternate in a concentric manner outward from the center.\n\ndef main(input_grid):\n    # Extract the position and color of the central pixel\n    central_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, allowed_dimensions=[(1, 1)], monochromatic=True)\n    \n    assert len(central_objects) == 1  # Ensure there is exactly one central pixel\n    central_pixel = central_objects[0]\n    central_x, central_y = object_position(central_pixel, background=Color.BLACK, anchor=\u0027upper left\u0027)\n    central_color = central_pixel[0, 0]\n\n    # Create the output grid with a size that allows for radial expansion\n    output_size = 7  # Fixed size for demonstration (can be adjusted)\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # Define the colors to use in the radial pattern\n    colors = [central_color, Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.TEAL, Color.PINK, Color.ORANGE]\n    \n    # Generate the radial pattern\n    for layer in range((output_size - 1) // 2 + 1):  # Number of layers\n        color_index = layer % len(colors)  # Alternate colors\n        # Fill the layer with the current color\n        for x in range(-layer, layer + 1):\n            for y in range(-layer, layer + 1):\n                if max(abs(x), abs(y)) == layer:  # Only fill the border of the current layer\n                    output_grid[central_y + y, central_x + x] = colors[color_index]\n\n    return output_grid\n\ndef generate_input():\n    # Create a simple grid with a single colored pixel in the center\n    size = 5  # Fixed grid size\n    grid = np.full((size, size), Color.BLACK)\n    central_x, central_y = size // 2, size // 2\n    \n    # Randomly choose a color for the central pixel\n    grid[central_y, central_x] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/173/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/173/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/173/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/173/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/173/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/173/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/173/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/173/images/train_output_2.png"}]}, "index": 173, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change, fill pattern\n\n# description:\n# In the input, you will see a cluster of colored objects on a yellow background. Each object has a unique color.\n# To create the output, replace all colors of the objects that are connected to the background with a uniform color (e.g., light blue).\n# The objects that are not connected to the background will remain unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Define the background color (yellow in this case)\n    background_color = Color.YELLOW\n\n    # Detect connected components starting from the background color\n    background_objects = find_connected_components(input_grid, background=background_color)\n\n    # Process each background object, changing its color to light blue\n    for obj in background_objects:\n        # Change the color of each pixel in the object to light blue\n        output_grid[obj == background_color] = Color.PINK\n\n    return output_grid\n\ndef generate_input():\n    # Create a yellow 10x10 grid as the background\n    n, m = 10, 10\n    grid = np.full((n, m), Color.YELLOW)\n\n    # Randomly generate a number of colored objects\n    num_objects = np.random.randint(3, 8)\n    colors_used = []\n    \n    for _ in range(num_objects):\n        # Create a random object with a unique color\n        color = np.random.choice([c for c in Color.NOT_BLACK if c not in colors_used])\n        colors_used.append(color)\n        \n        # Random dimensions for the object\n        height, width = np.random.randint(1, 4), np.random.randint(1, 4)\n        object_sprite = random_sprite(height, width, color_palette=[color], density=1)\n\n        # Find a free location for the object in the grid\n        x, y = random_free_location_for_sprite(grid, object_sprite, background=Color.YELLOW)\n        blit_sprite(grid, object_sprite, x=x, y=y, background=Color.YELLOW)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/174/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/174/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/174/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/174/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/174/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/174/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/174/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/174/images/train_output_2.png"}]}, "index": 174, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# ripple effect, color transition\n\n# description:\n# In the input, you will see a single colored pixel on a black background. \n# To make the output, create a ripple effect by expanding the color outward in concentric circles, \n# changing the color to a lighter shade with each layer until it reaches the edge of the grid.\n\ndef main(input_grid):\n    # Create a copy of the input grid to draw the output\n    output_grid = input_grid.copy()\n\n    # Find the coordinates of the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1  # There should be exactly one colored pixel\n    center_x, center_y = colored_pixel_locations[0]\n\n    # Define the color shades for the ripple effect\n    color_shades = {\n        0: Color.BLACK,\n        1: Color.BLUE,\n        2: Color.GREEN,\n        3: Color.YELLOW,\n        4: Color.GREY,\n        5: Color.PINK,\n        6: Color.ORANGE,\n        7: Color.TEAL,\n        8: Color.MAROON,\n        9: Color.RED,\n    }\n\n    # Start spreading the colors from the center\n    max_radius = max(output_grid.shape) // 2  # Maximum radius to spread\n    for radius in range(max_radius + 1):\n        # Determine the current color shade\n        current_color = color_shades[min(radius, len(color_shades) - 1)]\n        # Iterate through the perimeter of the circle defined by the current radius\n        for angle in np.linspace(0, 2 * np.pi, num=360):\n            x = int(center_x + radius * np.cos(angle))\n            y = int(center_y + radius * np.sin(angle))\n            # Check if the coordinates are within the bounds of the grid\n            if 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:\n                output_grid[x, y] = current_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly choose a color for the single pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the colored pixel at a random location in the grid\n    x, y = np.random.randint(0, 20), np.random.randint(0, 20)\n    input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/175/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/175/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/175/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/175/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/175/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/175/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/175/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/175/images/train_output_2.png"}]}, "index": 175, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color replacement\n\n# description:\n# In the input, you will see a shape that has vertical mirror symmetry. \n# To make the output, replace the color of the right half of the shape with a new color while keeping the left half unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = input_grid.copy()\n    \n    # Detect vertical mirror symmetries\n    mirrors = detect_mirror_symmetry(input_grid)\n    \n    # Check the color of the left half and prepare to replace the right half\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # We only need to check the right half of the grid\n            if y \u003e= input_grid.shape[1] // 2:\n                # Get the corresponding left side coordinate\n                left_x, left_y = x, input_grid.shape[1] - 1 - y\n                \n                # If the left side has a color, replace the right side\u0027s color\n                if input_grid[left_x, left_y] != Color.BLACK:\n                    # Replace the right half color with a new color, for example, Color.RED\n                    output_grid[x, y] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a left-right symmetric sprite\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n    sprite = random_sprite(np.random.randint(5, n-2), np.random.randint(5, m-2), density=0.5, symmetry=\"vertical\", color_palette=[sprite_color])\n\n    # Place the symmetric sprite in the center of the grid\n    sprite_x, sprite_y = (n - sprite.shape[0]) // 2, (m - sprite.shape[1]) // 2\n    blit_sprite(grid, sprite, x=sprite_x, y=sprite_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/176/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/176/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/176/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/176/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/176/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/176/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/176/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/176/images/train_output_2.png"}]}, "index": 176, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, scaling\n\n# description:\n# In the input, you will see a grid containing a central pattern surrounded by a border of a different color.\n# To create the output, you should extract the central pattern, scale it up by a factor of 2, \n# and place it in the center of a new grid that has a black background.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central pattern by cropping the grid\n    central_pattern = crop(input_grid, background=Color.BLACK)\n\n    # Scale the pattern by a factor of 2\n    scaled_pattern = scale_pattern(central_pattern, scale_factor=2)\n\n    # Prepare the output grid, it should be larger to accommodate the scaled pattern\n    output_size = scaled_pattern.shape[0] + 4  # Adding space for black border\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # Place the scaled pattern in the center of the output grid\n    start_x = (output_size - scaled_pattern.shape[0]) // 2\n    start_y = (output_size - scaled_pattern.shape[1]) // 2\n    output_grid[start_x:start_x + scaled_pattern.shape[0], start_y:start_y + scaled_pattern.shape[1]] = scaled_pattern\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate random size for the central pattern\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n\n    # Create a random central pattern\n    central_pattern = random_sprite(n, m, density=0.5, symmetry=None, color_palette=Color.NOT_BLACK)\n\n    # Create a border color that is different from the central pattern\u0027s colors\n    border_color = np.random.choice([color for color in Color.NOT_BLACK if color not in central_pattern])\n\n    # Create the grid with a border\n    border_size = 1\n    output_grid = np.full((n + 2 * border_size, m + 2 * border_size), Color.BLACK)\n\n    # Set the border color\n    output_grid[0, :] = border_color\n    output_grid[-1, :] = border_color\n    output_grid[:, 0] = border_color\n    output_grid[:, -1] = border_color\n\n    # Place the central pattern in the middle of the grid\n    output_grid[border_size:border_size + n, border_size:border_size + m] = central_pattern\n\n    return output_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/177/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/177/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/177/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/177/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/177/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/177/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/177/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/177/images/train_output_2.png"}]}, "index": 177, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color transformation\n\n# description:\n# In the input grid, you will see a pattern that exhibits horizontal symmetry. \n# To create the output, you should transform the colors of the pixels in the top half of the grid \n# to match the colors of their corresponding pixels in the bottom half, effectively mirroring the colors \n# across the horizontal axis. The bottom half should remain unchanged.\n\ndef main(input_grid):\n    # Get the number of rows in the grid\n    n_rows = input_grid.shape[0]\n    \n    # Define the middle row (for even rows, it will be the row above the center)\n    middle_row = n_rows // 2\n\n    # Mirror the colors from the top half to the bottom half\n    input_grid[middle_row:n_rows, :] = input_grid[middle_row-1::-1, :]\n\n    return input_grid\n\ndef generate_input():\n    n, m = 6, 6  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate colors for the top half of the grid\n    color_palette = Color.NOT_BLACK  # Exclude black from palette\n    for i in range(n // 2):\n        for j in range(m):\n            grid[i, j] = np.random.choice(color_palette)\n\n    # Fill the bottom half with black pixels\n    grid[n // 2:, :] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/178/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/178/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/178/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/178/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/178/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/178/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/178/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/178/images/train_output_2.png"}]}, "index": 178, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# silhouette extraction, background filling, color mapping\n\n# description:\n# In the input, you will see a collection of colorful objects on a pink background. \n# To create the output, extract the silhouettes of the objects by filling in the negative space around them with a single color (for example, black). \n# The silhouettes should be the same shape as the original colored objects, but they should be filled with the specified silhouette color, while the background remains pink.\n\ndef main(input_grid):\n    # Step 1: Identify the background color (assumed to be pink for this puzzle)\n    background_color = Color.PINK\n    \n    # Prepare an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, background_color)\n\n    # Step 2: Find all connected components (objects) in the grid\n    objects = find_connected_components(input_grid, background=background_color)\n\n    # Step 3: For each object, fill the corresponding area in the output grid with black (or silhouette color)\n    for obj in objects:\n        # Get the bounding box of the object\n        cropped_object = crop(obj, background=background_color)\n        # Fill the output grid at the same location as the object with black color\n        output_grid[obj != background_color] = Color.BLACK\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size within reasonable limits\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.PINK)  # Start with a pink background\n\n    # Number of objects to create\n    num_objects = np.random.randint(2, 5)\n    \n    for _ in range(num_objects):\n        # Generate random sprites (objects)\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), density=0.5, color_palette=list(Color.NOT_BLACK))\n\n        # Find a free location to place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.PINK)\n        blit_sprite(grid, sprite, x, y, background=Color.PINK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/179/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/179/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/179/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/179/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/179/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/179/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/179/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/179/images/train_output_2.png"}]}, "index": 179, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, filling, mirroring\n\n# description:\n# In the input, you will see a grid with a symmetrical pattern made of colored pixels only on one side. \n# The pattern will be in the left half of the grid, and the right half will be a black background. \n# To create the output, replicate the pattern on the opposite side to achieve full symmetry, \n# filling in the missing pixels to complete the mirrored design.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n    \n    # Create an output grid filled with black\n    output_grid = np.full((height, width), Color.BLACK)\n    \n    # Copy the left half of the input grid to the output grid, mirrored on the right side\n    for y in range(height):\n        for x in range(width // 2):\n            output_grid[y, x] = input_grid[y, x]  # Copy left side\n            output_grid[y, width - x - 1] = input_grid[y, x]  # Mirror to right side\n    \n    return output_grid\n\ndef generate_input():\n    # Determine the size of the grid\n    height = np.random.randint(5, 8)\n    width = np.random.randint(5, 10)  # Ensure there\u0027s an odd width to have a clear left and right half\n    grid = np.zeros((height, width), dtype=int)\n\n    # Select a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the left half of the grid with the selected color randomly\n    for y in range(height):\n        for x in range(width // 2):\n            grid[y, x] = np.random.choice([color, Color.BLACK])  # Randomly choose the color or black\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/180/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/180/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/180/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/180/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/180/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/180/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/180/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/180/images/train_output_2.png"}]}, "index": 180, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color mapping, diagonal filling\n\n# description:\n# In the input, you will see several diagonal stripes of different colors filling a grid.\n# To make the output, fill each empty space with the color of the nearest diagonal stripe, \n# following the direction of the stripes. If two stripes are equidistant, the color of the \n# stripe that appears first in the reading order (top-left to bottom-right) will be used.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    rows, cols = input_grid.shape\n    \n    # Iterate through each pixel in the grid\n    for x in range(rows):\n        for y in range(cols):\n            if input_grid[x, y] == Color.BLACK:  # Only fill the empty spaces\n                # Find the nearest diagonal stripe color\n                nearest_color = None\n                nearest_distance = float(\u0027inf\u0027)\n                \n                # Check each diagonal stripe\n                for dx in range(-rows, rows):\n                    for dy in range(-cols, cols):\n                        if abs(dx) == abs(dy):  # Check only diagonal directions\n                            x_check = x + dx\n                            y_check = y + dy\n                            if 0 \u003c= x_check \u003c rows and 0 \u003c= y_check \u003c cols:\n                                current_color = input_grid[x_check, y_check]\n                                if current_color != Color.BLACK:\n                                    distance = abs(dx)  # Distance is based on diagonal steps\n                                    if distance \u003c nearest_distance:\n                                        nearest_distance = distance\n                                        nearest_color = current_color\n                \n                if nearest_color:\n                    output_grid[x, y] = nearest_color  # Fill with the nearest stripe color\n    \n    return output_grid\n\ndef generate_input():\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly draw diagonal stripes\n    num_stripes = np.random.randint(3, 6)\n    colors = random.sample(Color.NOT_BLACK, num_stripes)\n\n    for i, color in enumerate(colors):\n        # Draw a diagonal line from the top-left to bottom-right\n        start_x = np.random.randint(0, grid_size)\n        start_y = np.random.randint(0, grid_size)\n        \n        # Draw the diagonal stripe\n        for offset in range(grid_size):\n            x = start_x + offset\n            y = start_y + offset\n            if 0 \u003c= x \u003c grid_size and 0 \u003c= y \u003c grid_size:\n                grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/181/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/181/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/181/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/181/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/181/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/181/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/181/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/181/images/train_output_2.png"}]}, "index": 181, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, filling, color isolation\n\n# description:\n# In the input, you will see several colored shapes, some of which may touch each other. \n# To create the output, identify the outer boundaries of each shape. Then, fill the areas inside the boundaries with a distinctive color (e.g., light green), while keeping the original colors of the shapes intact.\n\ndef main(input_grid):\n    # Find all connected components (shapes) in the grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    output_grid = input_grid.copy()\n    \n    for shape in shapes:\n        # Create a mask for the shape\u0027s interior\n        interior_mask = object_interior(shape, background=Color.BLACK)\n        \n        # Fill the interior of the shape with light green\n        output_grid[interior_mask] = Color.PINK\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a black background\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly determine the number of shapes to create\n    num_shapes = np.random.randint(3, 6)\n\n    for _ in range(num_shapes):\n        # Randomly decide the size of the shape\n        width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape = np.full((width, height), Color.BLUE)\n        # Create a hollow shape by filling the interior with black\n        shape[1:-1, 1:-1] = Color.BLACK\n\n        # Find a random free location for the shape\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n        blit_sprite(grid, shape, x=x, y=y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/182/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/182/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/182/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/182/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/182/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/182/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/182/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/182/images/train_output_2.png"}]}, "index": 182, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transition, gradient blending\n\n# description:\n# In the input, you will see a vertical gradient of colors from top to bottom. \n# To make the output, horizontally flip the gradient to create a mirror image, \n# then blend the two gradients together in the center to create a smooth transition effect across the entire grid.\n\ndef main(input_grid):\n    # Create the output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the number of rows and columns\n    n, m = input_grid.shape\n\n    # Reflect the input grid horizontally\n    reflected_gradient = input_grid[:, ::-1]\n\n    # Blend the two gradients in the center\n    for i in range(n):\n        for j in range(m):\n            # Calculate the blending factor\n            blend_factor = j / (m - 1)  # from 0 to 1 from left to right\n            \n            # Get the colors from both gradients\n            top_color = input_grid[i, j]\n            bottom_color = reflected_gradient[i, j]\n\n            # Blend the colors based on the blend factor\n            output_grid[i, j] = top_color if blend_factor \u003c 0.5 else bottom_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a vertical gradient of random colors\n    n = np.random.randint(5, 10)  # height of the grid\n    m = 3  # single column for gradient\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose random colors to create a gradient from top to bottom\n    colors = np.random.choice(list(Color.NOT_BLACK), n, replace=False)\n    \n    # Fill the grid with a vertical gradient\n    for i in range(n):\n        grid[i, 0] = colors[i]\n\n    # Convert the single column into a vertical gradient by repeating the column\n    grid = np.repeat(grid, 3, axis=1)  # replicate to have enough columns for blending\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/183/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/183/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/183/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/183/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/183/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/183/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/183/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/183/images/train_output_2.png"}]}, "index": 183, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color shifting, edge detection, pattern formation\n\n# description:\n# In the input grid, you will see two colors forming a border around the grid and a central area filled with black pixels. \n# The outer border is composed of two different colors, one on each edge (top-bottom and left-right). \n# To create the output, shift the colors of the top and bottom edges inward by one cell, \n# and shift the colors of the left and right edges inward by one cell. \n# The central black pixels should remain unchanged.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    n, m = output_grid.shape\n\n    # Shift top edge color down into the second row\n    output_grid[1, :] = output_grid[0, :]\n\n    # Shift bottom edge color up into the second-to-last row\n    output_grid[-2, :] = output_grid[-1, :]\n\n    # Shift left edge color right into the second column\n    output_grid[:, 1] = output_grid[:, 0]\n\n    # Shift right edge color left into the second-to-last column\n    output_grid[:, -2] = output_grid[:, -1]\n\n    # Set the edges to black to represent the new inner edge\n    output_grid[0, :] = Color.BLACK\n    output_grid[-1, :] = Color.BLACK\n    output_grid[:, 0] = Color.BLACK\n    output_grid[:, -1] = Color.BLACK\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with black background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the border\n    color1, color2 = np.random.choice(list(Color.NOT_BLACK), size=2, replace=False)\n\n    # Draw top and bottom borders\n    grid[0, :] = color1\n    grid[-1, :] = color2\n\n    # Draw left and right borders\n    grid[:, 0] = color1\n    grid[:, -1] = color2\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/184/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/184/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/184/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/184/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/184/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/184/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/184/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/184/images/train_output_2.png"}]}, "index": 184, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, depth perception, transparency\n\n# description:\n# In the input, multiple layers of colored shapes are stacked on top of each other. The top layers may have transparent pixels, allowing the colors of the layers below to show through.\n# To create the output, display the layers such that the bottom layers are partially visible through the transparent areas of the top layers, creating a sense of depth.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Detect connected components in the input grid\n    layers = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    \n    # Sort layers by their vertical position (y-coordinate) to apply depth effect\n    layers.sort(key=lambda layer: np.min(np.argwhere(layer != Color.BLACK)[:, 0]))\n\n    # Process each layer from top to bottom\n    for layer in layers:\n        # Get the bounding box of the current layer\n        x, y, w, h = bounding_box(layer)\n        \n        # Overlay the current layer onto the output grid\n        for i in range(h):\n            for j in range(w):\n                if layer[i, j] != Color.BLACK:  # Only consider non-transparent pixels\n                    # If the output grid pixel is already colored, keep it (simulating transparency)\n                    if output_grid[y + i, x + j] == Color.BLACK:\n                        output_grid[y + i, x + j] = layer[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the number of layers (shapes)\n    num_layers = np.random.randint(3, 6)\n\n    for _ in range(num_layers):\n        # Create a random sprite\n        layer_sprite = random_sprite(np.random.randint(3, 8), np.random.randint(3, 8), density=0.7, color_palette=Color.NOT_BLACK)\n        \n        # Randomly position the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, layer_sprite, padding=1)\n        blit_sprite(grid, layer_sprite, x, y, background=Color.BLACK)\n\n    # Randomly make some pixels transparent (set to black) in each layer\n    for _ in range(num_layers):\n        # Choose a random layer to modify\n        layer_index = np.random.randint(0, num_layers)\n        layer_bounds = find_connected_components(grid, monochromatic=False, connectivity=8)[layer_index]\n        x, y, w, h = bounding_box(layer_bounds)\n\n        # Randomly decide the number of transparent pixels to create in this layer\n        num_transparent_pixels = np.random.randint(1, 5)\n        for _ in range(num_transparent_pixels):\n            px, py = np.random.randint(y, y + h), np.random.randint(x, x + w)\n            if layer_bounds[px, py] != Color.BLACK:  # Only make non-black pixels transparent\n                layer_bounds[px, py] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/185/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/185/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/185/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/185/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/185/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/185/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/185/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/185/images/train_output_2.png"}]}, "index": 185, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern expansion, quadrant filling\n\n# description:\n# In the input you will see a grid with a specific pattern located in the center with distinct colors.\n# To make the output grid, you should copy the center pattern into each of the four quadrants of the output grid, \n# replacing the original colors with the corresponding colors from the center pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the size of the input grid\n    n, m = input_grid.shape\n\n    # Calculate the center of the grid\n    center_x, center_y = n // 2, m // 2\n\n    # Determine the size of the center pattern\n    # Assuming the pattern is a square pattern located at the center\n    pattern_size = min(center_x, center_y)\n\n    # Extract the center pattern\n    center_pattern = input_grid[center_x - pattern_size: center_x + pattern_size, \n                                center_y - pattern_size: center_y + pattern_size]\n\n    # Create the output grid, with the same dimensions as the input grid\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # Fill in the four quadrants with the center pattern\n    output_grid[:pattern_size * 2, :pattern_size * 2] = center_pattern  # Top-left\n    output_grid[:pattern_size * 2, m - pattern_size * 2:] = center_pattern  # Top-right\n    output_grid[n - pattern_size * 2:, :pattern_size * 2] = center_pattern  # Bottom-left\n    output_grid[n - pattern_size * 2:, m - pattern_size * 2:] = center_pattern  # Bottom-right\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size that is at least 6x6 to ensure a center pattern can fit\n    n, m = np.random.randint(6, 12), np.random.randint(6, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Determine the size of the center pattern\n    pattern_size = np.random.randint(2, min(n, m) // 2)\n\n    # Create a center pattern with random colors\n    center_pattern = random_sprite(pattern_size, pattern_size, density=0.5, color_palette=list(Color.NOT_BLACK))\n\n    # Place the center pattern in the middle of the grid\n    start_x = n // 2 - pattern_size // 2\n    start_y = m // 2 - pattern_size // 2\n    grid[start_x:start_x + pattern_size, start_y:start_y + pattern_size] = center_pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/186/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/186/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/186/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/186/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/186/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/186/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/186/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/186/images/train_output_2.png"}]}, "index": 186, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color spreading, diffusion\n\n# description:\n# In the input you will see a grid where each pixel is colored. Some pixels are designated as \"source\" pixels of specific colors. \n# To create the output, spread the color of each source pixel to its adjacent (up, down, left, right) pixels, replacing their colors with the \n# source color if they are currently black. The spreading will stop once all adjacent pixels have either been filled or are no longer black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Identify source colors (non-black pixels)\n    source_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    for x, y in source_pixels:\n        color = input_grid[x, y]\n        # Spread the color to adjacent pixels\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:  # right, left, down, up\n            nx, ny = x + dx, y + dy\n            if 0 \u003c= nx \u003c input_grid.shape[0] and 0 \u003c= ny \u003c input_grid.shape[1]:\n                if output_grid[nx, ny] == Color.BLACK:  # Only spread to black pixels\n                    output_grid[nx, ny] = color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose a random number of source pixels\n    num_sources = np.random.randint(3, 10)\n    for _ in range(num_sources):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice([c for c in Color.NOT_BLACK])  # Choose a non-black color\n        grid[x, y] = color  # Set source pixel\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/187/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/187/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/187/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/187/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/187/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/187/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/187/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/187/images/train_output_2.png"}]}, "index": 187, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color grouping, horizontal strips\n\n# description:\n# In the input, you will see a grid filled with pixels of different colors. \n# To make the output, group the colors into horizontal strips, where each strip contains the same color arranged from left to right. \n# Each strip\u0027s height corresponds to the count of that color in the input, and the colors are arranged from top to bottom based on the order of their first appearance in the input.\n\ndef main(input_grid):\n    # Create output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Count occurrences of each color\n    color_counts = {}\n    for row in input_grid:\n        for color in row:\n            if color != Color.BLACK:  # Ignore black background\n                if color in color_counts:\n                    color_counts[color] += 1\n                else:\n                    color_counts[color] = 1\n\n    # Get colors in order of appearance\n    ordered_colors = []\n    for row in input_grid:\n        for color in row:\n            if color != Color.BLACK and color not in ordered_colors:\n                ordered_colors.append(color)\n\n    # Fill output grid with color strips\n    current_row = 0\n    for color in ordered_colors:\n        count = color_counts[color]\n        output_grid[current_row:current_row + count, :] = color\n        current_row += count\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random colors, ensuring varying heights for each color\n    n, m = 10, 10  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select colors and their heights\n    available_colors = list(Color.NOT_BLACK)\n    num_colors = np.random.randint(2, 6)  # Random number of colors\n\n    # Keep track of the heights assigned to each color\n    heights = {}\n    for _ in range(num_colors):\n        color = np.random.choice(available_colors)\n        height = np.random.randint(1, n // num_colors + 1)  # Random height for the color\n        heights[color] = height\n        available_colors.remove(color)\n\n    # Fill the grid with the selected colors\n    current_row = 0\n    for color, height in heights.items():\n        grid[current_row:current_row + height, :] = color\n        current_row += height\n\n    # Fill the remaining space with black\n    grid[current_row:, :] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/188/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/188/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/188/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/188/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/188/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/188/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/188/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/188/images/train_output_2.png"}]}, "index": 188, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# concentric circles, radial lines\n\n# description:\n# In the input, you will see a number of colored pixels on a white background, forming small clusters of various colors.\n# To create the output, draw concentric circles around each cluster of the same color, connecting the outermost cluster to the inner clusters with radial lines.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find the background color (the most common color)\n    background_color = np.bincount(input_grid.flatten()).argmax()\n\n    # Extract connected components from the input grid\n    components = find_connected_components(input_grid, background=background_color, connectivity=4, monochromatic=False)\n\n    # Process each color cluster\n    for component in components:\n        # Get the color of the current component\n        color = component[0, 0]\n\n        if color == background_color:\n            continue\n\n        # Get the coordinates of the pixels in this color cluster\n        coords = np.argwhere(component != background_color)\n        if len(coords) == 0:\n            continue\n\n        # Calculate the centroid of the cluster\n        centroid_x = np.mean(coords[:, 0]).astype(int)\n        centroid_y = np.mean(coords[:, 1]).astype(int)\n\n        # Draw concentric circles for the cluster\n        radius = 1\n        while radius \u003c 5:  # Drawing up to a maximum radius of 4 (adjustable)\n            draw_circle(output_grid, centroid_x, centroid_y, radius, color)\n            radius += 1\n\n        # Connect the outermost circle to the inner clusters with radial lines\n        for x, y in coords:\n            draw_line(output_grid, centroid_x, centroid_y, end_x=x, end_y=y, color=color)\n\n    return output_grid\n\ndef draw_circle(grid, x, y, radius, color):\n    \"\"\" Draw a circle on the grid using Bresenham\u0027s circle algorithm. \"\"\"\n    for dx in range(-radius, radius + 1):\n        dy = int((radius**2 - dx**2)**0.5)\n        for sign in [1, -1]:\n            grid[x + dx, y + sign * dy] = color\n            grid[x + sign * dy, y + dx] = color\n\ndef generate_input():\n    # Create a white background grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), fill_value=Color.BLACK)\n\n    # Scatter colored pixels randomly\n    colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(2, 5), replace=False)\n\n    for color in colors:\n        # Create a random cluster of pixels for each color\n        n_pixels = np.random.randint(5, 15)\n        for _ in range(n_pixels):\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/189/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/189/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/189/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/189/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/189/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/189/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/189/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/189/images/train_output_2.png"}]}, "index": 189, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal symmetry, reflection\n\n# description:\n# In the input, you will see a grid with a complex shape that has diagonal symmetry.\n# To make the output, reflect the shape over its diagonal axis, creating a complete pattern that fills the grid symmetrically.\n\ndef main(input_grid):\n    # Get the size of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid with the same size, filled with the background color\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # Reflect the input grid over its diagonal (top-left to bottom-right)\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] != Color.BLACK:\n                output_grid[j, i] = input_grid[i, j]\n\n    # Merge the original and reflected patterns into the output grid\n    output_grid = np.where(output_grid == Color.BLACK, input_grid, output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Define the dimensions of the grid\n    n = np.random.randint(5, 10)\n    m = np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random diagonal symmetric pattern\n    pattern_size = np.random.randint(2, min(n, m) // 2)\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the diagonal symmetric pattern\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[i, j] = color\n            grid[j, i] = color  # Reflect over the diagonal\n\n    # Optionally introduce some random black pixels to create complexity\n    for _ in range(np.random.randint(5, 15)):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/190/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/190/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/190/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/190/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/190/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/190/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/190/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/190/images/train_output_2.png"}]}, "index": 190, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, concentric patterns, color mapping\n\n# description:\n# In the input, you will see a single colored pixel in the center of a blank grid. \n# To create the output, generate a radial pattern around the pixel by placing additional pixels in concentric circles around the center pixel,\n# with each circle having a different color. The first circle will have the same color as the center pixel,\n# the second circle will have a different color, and so forth, alternating in a clockwise manner.\n\ndef main(input_grid):\n    # Identify the center pixel and its color\n    center_pixel_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, allowed_dimensions=[(1, 1)], monochromatic=True)\n    assert len(center_pixel_objects) == 1\n    center_pixel = center_pixel_objects[0]\n\n    # Get the position of the center pixel\n    center_x, center_y = object_position(center_pixel, background=Color.BLACK, anchor=\"upper left\")\n    center_color = input_grid[center_x, center_y]\n\n    # Define the colors to be used for the radial pattern\n    colors = [center_color, Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.TEAL, Color.ORANGE, Color.MAROON]\n\n    # Start with a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Draw concentric circles around the center pixel\n    radius = 1\n    color_index = 0\n    while radius \u003c min(input_grid.shape) // 2:\n        # Draw the circle using the current color\n        for angle in range(0, 360, 10):  # Draw a circle with a step of 10 degrees\n            rad_angle = np.radians(angle)\n            x_offset = int(radius * np.cos(rad_angle))\n            y_offset = int(radius * np.sin(rad_angle))\n            x = center_x + x_offset\n            y = center_y + y_offset\n            # Ensure we stay within bounds\n            if 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:\n                output_grid[x, y] = colors[color_index]\n        \n        # Increment radius and change color for next circle\n        radius += 1\n        color_index = (color_index + 1) % len(colors)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m with a blank background\n    n, m = 7, 7\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select the center position for the colored pixel\n    center_x, center_y = n // 2, m // 2\n    # Randomly select a color for the center pixel\n    grid[center_x, center_y] = np.random.choice(Color.NOT_BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/191/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/191/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/191/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/191/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/191/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/191/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/191/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/191/images/train_output_2.png"}]}, "index": 191, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel clustering, density mapping\n\n# description:\n# In the input grid, you will see scattered colored pixels. To create the output, generate a density map where each pixel is colored \n# based on the number of colored neighbors around it, transitioning from green (low density) to red (high density). \n# The density is computed by counting the colored neighbors in a 3x3 region around each pixel, excluding the pixel itself.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create initial output grid which will hold the density colored output\n    output_grid = np.zeros_like(input_grid)\n\n    # Define a mapping from density to colors\n    density_color_map = {\n        0: Color.GREEN,\n        1: Color.YELLOW,\n        2: Color.ORANGE,\n        3: Color.RED\n    }\n\n    # Iterate over each pixel in the input grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # Count colored neighbors\n            colored_neighbor_count = 0\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    if dx == 0 and dy == 0:\n                        continue  # Skip the pixel itself\n                    nx, ny = x + dx, y + dy\n                    if 0 \u003c= nx \u003c input_grid.shape[0] and 0 \u003c= ny \u003c input_grid.shape[1]:\n                        if input_grid[nx, ny] != Color.BLACK:  # Count only colored pixels\n                            colored_neighbor_count += 1\n\n            # Map the count to appropriate color\n            if colored_neighbor_count \u003e 0 and colored_neighbor_count \u003c 4:\n                output_grid[x, y] = density_color_map[colored_neighbor_count]\n            else:\n                output_grid[x, y] = Color.BLACK  # No density, stays black\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of arbitrary size with a black background\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels\n    density = np.random.uniform(0.1, 0.5)  # Density of colored pixels\n    num_colored_pixels = int(density * n * m)  # Total number of colored pixels\n\n    for _ in range(num_colored_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(list(Color.NOT_BLACK))  # Assign a random color to the pixel\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/192/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/192/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/192/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/192/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/192/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/192/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/192/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/192/images/train_output_2.png"}]}, "index": 192, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, fill area\n\n# description:\n# In the input, you will see a grid with several random colored pixels scattered about. \n# To create the output, detect the outer boundary of the colored pixels and fill the enclosed area with a solid color, \n# creating a striking contrast with the scattered pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (colored pixels)\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # For each component, determine the bounding box\n    for component in components:\n        if np.any(component != Color.BLACK):\n            coords = np.argwhere(component != Color.BLACK)\n            min_x, min_y = np.min(coords, axis=0)\n            max_x, max_y = np.max(coords, axis=0)\n\n            # Fill the area inside the bounding box with a new color (e.g., Color.YELLOW)\n            fill_color = Color.YELLOW\n            for x in range(min_x, max_x + 1):\n                for y in range(min_y, max_y + 1):\n                    output_grid[x, y] = fill_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.full((n, m), fill_value=Color.BLACK)\n\n    # Randomly scatter colored pixels\n    num_colors = np.random.randint(1, 6)  # Number of different colors to scatter\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    for color in colors:\n        grid = random_scatter_points(grid=grid, color=color, density=0.3)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/193/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/193/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/193/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/193/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/193/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/193/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/193/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/193/images/train_output_2.png"}]}, "index": 193, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape recognition, simplification, connectivity\n\n# description:\n# In the input, you will see a grid with clusters of pixels of various colors, forming distinct shapes.\n# To create the output, you should identify each shape formed by connected pixels of the same color and replace it with a single pixel of that color, effectively simplifying the representation of the shapes.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Find all connected components (shapes) in the grid\n    connected_components = find_connected_components(input_grid, monochromatic=True)\n\n    # For each connected component, get the color and place a single pixel in the output grid\n    for component in connected_components:\n        # Get the color of the shape\n        color = component[0, 0]\n        # Find the centroid (or a representative point) to place the single pixel\n        x, y = np.mean(np.argwhere(input_grid == color), axis=0).astype(int)\n        output_grid[x, y] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a number of shapes (clusters) to create\n    num_shapes = np.random.randint(3, 6)\n\n    # Create random shapes on the grid\n    for _ in range(num_shapes):\n        color = random.choice(Color.NOT_BLACK)\n        # Randomly choose a starting point for the shape\n        start_x, start_y = np.random.randint(1, n-1), np.random.randint(1, m-1)\n        # Randomly generate a small shape using random scatter points\n        random_scatter_points(grid, color=color, density=0.3)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/194/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/194/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/194/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/194/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/194/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/194/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/194/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/194/images/train_output_2.png"}]}, "index": 194, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object alignment, filling, grid transformation\n\n# description:\n# In the input, you will see various colored objects scattered on a black grid, with each object containing a single blue pixel. The goal is to move all objects so that their blue pixels align in a straight vertical line in the output grid. Any empty spaces in the output grid should be filled with a designated background color (not black) while keeping the original colors of the objects.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the objects from the input grid using connected components\n    # 2. Find the positions of the blue pixels of each object\n    # 3. Calculate the target column for the blue pixels to align vertically\n    # 4. Create an output grid and place each object in the determined column\n    # 5. Fill the rest of the output grid with the background color\n\n    # Step 1: Extract objects from the input\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK, connectivity=4)\n    \n    # Step 2: Get positions of blue pixels\n    blue_pixel_positions = []\n    for obj in objects:\n        if np.any(obj == Color.BLUE):\n            blue_pixel_positions.append(np.argwhere(obj == Color.BLUE)[0])\n\n    # Step 3: Choose a target column for alignment\n    target_column = input_grid.shape[1] // 2  # center column\n\n    # Step 4: Create output grid and place each object\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    for obj in objects:\n        if np.any(obj == Color.BLUE):\n            # Find the blue pixel position\n            blue_pixel_x, blue_pixel_y = np.argwhere(obj == Color.BLUE)[0]\n            # Calculate the offset to move the blue pixel to the target column\n            x_offset = target_column - blue_pixel_y\n            # Translate the object to align the blue pixel\n            translated_object = translate(obj, x=x_offset, y=0, background=Color.BLACK)\n            # Blit the translated object onto the output grid\n            blit_object(output_grid, translated_object, background=Color.BLACK)\n\n    # Step 5: Fill remaining empty cells with a designated background color (e.g., Color.GREY)\n    output_grid[output_grid == Color.BLACK] = Color.GREY\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid with several colored objects, each containing a blue pixel.\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Number of objects to create\n    n_objects = np.random.randint(3, 8)\n    \n    for _ in range(n_objects):\n        # Create an object of random size (2x2 to 4x4) with a blue pixel\n        height, width = np.random.randint(2, 5), np.random.randint(2, 5)\n        obj = np.full((height, width), Color.BLACK)\n        blue_x, blue_y = np.random.randint(0, height), np.random.randint(0, width)\n        obj[blue_x, blue_y] = Color.BLUE\n\n        # Randomly color the other pixels (not blue, not black)\n        for i in range(height):\n            for j in range(width):\n                if (i, j) != (blue_x, blue_y):\n                    obj[i, j] = np.random.choice([c for c in Color.NOT_BLACK if c != Color.BLUE])\n\n        # Place the object on the grid\n        x, y = random_free_location_for_sprite(grid, obj, padding=1, padding_connectivity=4)\n        blit_sprite(grid, obj, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/195/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/195/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/195/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/195/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/195/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/195/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/195/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/195/images/train_output_2.png"}]}, "index": 195, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel expansion, object detection, color manipulation\n\n# description:\n# In the input, you will see small colored objects scattered across a black grid. Each object is made up of a single color, and the background is black.\n# To create the output, expand each object by two pixels in all directions, ensuring that the new pixels match the original color of the object.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect connected components (the objects) in the input grid.\n    # 2. For each object, expand it by two pixels in all directions.\n    # 3. Blit the expanded objects onto a new output grid, ensuring no overlap.\n\n    # Detect connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Create an output grid with the same shape as the input\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for obj in objects:\n        # Expand the object by 2 pixels in all directions\n        expanded_obj = scale_pattern(obj, scale_factor=3)  # Scale by 3 to achieve a 2-pixel expansion\n        # Determine the position to blit the expanded object\n        x_offset, y_offset = object_position(obj, background=Color.BLACK, anchor=\u0027upper left\u0027)\n        # Place the expanded object into the output grid\n        blit_sprite(output_grid, expanded_obj, x=x_offset-2, y=y_offset-2, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with small colored objects\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly create a number of objects (between 3 and 6)\n    num_objects = np.random.randint(3, 7)\n    for _ in range(num_objects):\n        # Create a random object size between 1x1 and 3x3\n        object_height = np.random.randint(1, 4)\n        object_width = np.random.randint(1, 4)\n        sprite = random_sprite(object_height, object_width, symmetry=\"not_symmetric\", color_palette=list(Color.NOT_BLACK))\n\n        # Find a random free location for the sprite\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=4)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/196/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/196/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/196/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/196/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/196/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/196/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/196/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/196/images/train_output_2.png"}]}, "index": 196, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# overlapping colors, blending\n\n# description:\n# In the input, you will see several colored shapes that overlap each other on a black background. \n# To make the output, blend the colors of the overlapping areas to create a new color, while keeping the non-overlapping areas unchanged.\n\ndef blend_colors(color1, color2):\n    # Simple blending function that averages the RGB values of two colors\n    # Assuming colors are represented as integers, we can convert them to RGB values\n    r1, g1, b1 = (color1 \u003e\u003e 16) \u0026 0xFF, (color1 \u003e\u003e 8) \u0026 0xFF, color1 \u0026 0xFF\n    r2, g2, b2 = (color2 \u003e\u003e 16) \u0026 0xFF, (color2 \u003e\u003e 8) \u0026 0xFF, color2 \u0026 0xFF\n    blended_color = ((r1 + r2) // 2 \u003c\u003c 16) | ((g1 + g2) // 2 \u003c\u003c 8) | ((b1 + b2) // 2)\n    return blended_color\n\ndef main(input_grid):\n    # Step 1: Find connected components in the input grid\n    components = find_connected_components(input_grid, monochromatic=False)\n    \n    # Step 2: Create an output grid initialized with black (background)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 3: Create a mask for the overlap areas\n    mask = np.zeros(input_grid.shape, dtype=bool)\n\n    # Step 4: Process each component\n    for component in components:\n        # Get the position and size of the current component\n        x, y, w, h = bounding_box(component)\n        \n        # Check for overlaps with the output grid\n        for i in range(h):\n            for j in range(w):\n                if component[i, j] != Color.BLACK:\n                    # If the pixel is already colored in the output, blend colors\n                    if output_grid[x + i, y + j] != Color.BLACK:\n                        output_grid[x + i, y + j] = blend_colors(output_grid[x + i, y + j], component[i, j])\n                    else:\n                        output_grid[x + i, y + j] = component[i, j]\n                    mask[x + i, y + j] = True\n\n    # Step 5: Fill in the non-overlapping areas\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if not mask[i, j]:\n                output_grid[i, j] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random number of colored shapes\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        shape_color = np.random.choice([Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.ORANGE, Color.PINK, Color.TEAL, Color.MAROON])\n        shape = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=1)\n\n        # Find a random free location to blit the shape on the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n        blit_sprite(grid, shape, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/197/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/197/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/197/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/197/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/197/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/197/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/197/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/197/images/train_output_2.png"}]}, "index": 197, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color separation, border detection, filling\n\n# description:\n# In the input, you will see a grid with a color gradient pattern that transitions through several colors, \n# with a solid border around the grid. The solid border is of a specific color, while the gradient fills the inside area.\n# To create the output, you should replace the entire gradient area with the color of the border, effectively filling the inner area \n# with the border color, while preserving the border itself.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Identify the border color (the color of the first row and column)\n    border_color = output_grid[0, 0]\n\n    # Replace all non-border pixels with the border color\n    output_grid[output_grid != border_color] = border_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly determine the grid size\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a border color\n    border_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create the border\n    grid[0, :] = border_color\n    grid[-1, :] = border_color\n    grid[:, 0] = border_color\n    grid[:, -1] = border_color\n\n    # Fill the inner area with a gradient pattern\n    for i in range(1, n - 1):\n        for j in range(1, m - 1):\n            # Create a gradient from the border color to some random color\n            inner_color = np.random.choice(Color.NOT_BLACK)\n            grid[i, j] = inner_color if np.random.rand() \u003e 0.5 else border_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/198/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/198/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/198/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/198/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/198/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/198/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/198/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/198/images/train_output_2.png"}]}, "index": 198, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, color spreading\n\n# description:\n# In the input, you will see a single colored pixel in the center of a grid. \n# To create the output, spread the color from the center pixel radially outward in all directions, \n# filling the surrounding pixels in a circular pattern until reaching the edges of the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the center pixel\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    center_color = input_grid[center_x, center_y]\n\n    # Create the output grid initialized to the background color (black)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Spread the color radially outward from the center pixel\n    radius = 0\n    while True:\n        # Iterate through points on the circumference of a circle with the current radius\n        for angle in range(360):\n            rad = np.deg2rad(angle)\n            x = int(center_x + radius * np.cos(rad))\n            y = int(center_y + radius * np.sin(rad))\n\n            # Check if the coordinates are within bounds\n            if 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:\n                output_grid[x, y] = center_color\n\n        # If a full circle was drawn, increase the radius\n        radius += 1\n\n        # Stop if we exceed the grid size\n        if radius \u003e max(output_grid.shape) // 2:\n            break\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid with a random size\n    width, height = np.random.randint(3, 30, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Choose a random color for the center pixel (not black)\n    center_color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the center colored pixel in the middle of the grid\n    input_grid[width // 2, height // 2] = center_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/199/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/199/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/199/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/199/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/199/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/199/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/199/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/199/images/train_output_2.png"}]}, "index": 199, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric transformation, rotation\n\n# description:\n# In the input, you will see a series of geometric shapes (triangles, circles, squares) arranged in a horizontal line.\n# Each shape has a different color. To create the output, rotate each shape by 90 degrees clockwise and display them in the same order.\n\ndef main(input_grid):\n    # Detect all shapes in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n    output_grid = np.full_like(input_grid, Color.BLACK)  # Initialize output grid with black background\n\n    for obj in objects:\n        # Determine the bounding box of each shape\n        x, y, width, height = bounding_box(obj)\n        shape_color = obj[obj != Color.BLACK][0]  # Get the color of the shape\n\n        # Rotate the shape by 90 degrees clockwise\n        rotated_shape = np.rot90(obj, -1)\n\n        # Calculate the position to place the rotated shape in the output grid\n        output_x = x  # Keep the same x position\n        output_y = height + y  # Stack shapes vertically in the output\n\n        # Place the rotated shape in the output grid\n        blit_sprite(output_grid, rotated_shape, output_x, output_y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid to put shapes in\n    grid = np.zeros((20, 20), dtype=int)\n\n    # Define possible shapes and colors\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.TEAL, Color.PINK]\n    shapes = []\n\n    # Create a series of shapes\n    for _ in range(np.random.randint(3, 6)):\n        shape_type = np.random.choice([\u0027square\u0027, \u0027circle\u0027, \u0027triangle\u0027])\n        color = np.random.choice(colors)\n\n        if shape_type == \u0027square\u0027:\n            size = np.random.randint(2, 5)\n            shape = np.full((size, size), color)\n            shapes.append(shape)\n        elif shape_type == \u0027circle\u0027:\n            size = np.random.randint(3, 6)\n            y, x = np.ogrid[-size//2:size//2, -size//2:size//2]\n            mask = x**2 + y**2 \u003c= (size//2)**2\n            shape = np.full((size, size), Color.BLACK)\n            shape[mask] = color\n            shapes.append(shape)\n        elif shape_type == \u0027triangle\u0027:\n            size = np.random.randint(2, 5)\n            shape = np.full((size, size), Color.BLACK)\n            for i in range(size):\n                shape[i, :i+1] = color\n            shapes.append(shape)\n\n    # Randomly place shapes in the grid\n    for shape in shapes:\n        x, y = random_free_location_for_sprite(grid, shape)\n        blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/200/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/200/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/200/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/200/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/200/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/200/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/200/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/200/images/train_output_2.png"}]}, "index": 200, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, transformation\n\n# description:\n# In the input, you will see a grid filled with pixels of different colors. \n# To create the output grid, map each color in the input grid to another color based on the following transformation:\n# - RED -\u003e BLUE\n# - GREEN -\u003e YELLOW\n# - BLUE -\u003e GREEN\n# - YELLOW -\u003e RED\n# - BLACK stays BLACK\n# - All other colors are not present in the input grid.\n# The output grid should have the same dimensions as the input grid with the transformed colors.\n\ndef main(input_grid):\n    # Create a mapping of colors\n    color_mapping = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.GREEN,\n        Color.YELLOW: Color.RED,\n        Color.BLACK: Color.BLACK\n    }\n    \n    # Initialize output grid with the same shape as input grid\n    output_grid = np.copy(input_grid)\n\n    # Transform the colors based on the mapping\n    for color in color_mapping.keys():\n        output_grid[output_grid == color] = color_mapping[color]\n\n    return output_grid\n\ndef generate_input():\n    # Define dimensions for the grid\n    n = np.random.randint(4, 8)\n    m = np.random.randint(4, 8)\n    \n    # Create a grid of specified dimensions filled with BLACK as default\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose a random density of colored pixels\n    density = np.random.uniform(0.2, 0.6)\n\n    # Get the number of pixels to color based on the density\n    total_pixels = n * m\n    num_colored_pixels = int(total_pixels * density)\n\n    # Available colors for random selection\n    available_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n\n    for _ in range(num_colored_pixels):\n        # Randomly select a position in the grid\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n\n        # Randomly select a color from the available colors\n        color = np.random.choice(available_colors)\n        \n        # Assign the selected color to the chosen position\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/201/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/201/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/201/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/201/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/201/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/201/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/201/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/201/images/train_output_2.png"}]}, "index": 201, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color, melting, gravity\n\n# description:\n# In the input grid, you will see a row of colored pixels at the top and a gray baseline at the bottom. \n# Between them, there may be some colored pixels that act as barriers. The colored pixels at the top will \"melt\" \n# downwards until they either touch the gray baseline or encounter a barrier. The melting effect means that \n# when a colored pixel moves down, it should replace any pixel directly below it that is of the same color, \n# but it cannot overwrite a barrier or the gray baseline.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    width, height = output_grid.shape\n\n    # Get the color of the baseline\n    baseline = output_grid[:, -1]\n    baseline_color = np.unique(baseline)[0]\n\n    # Iterate over each column from top to bottom\n    for x in range(width):\n        for y in range(height - 2, -1, -1):  # Start from the second to last row and go up\n            if output_grid[x, y] != baseline_color and output_grid[x, y] != Color.BLACK:\n                current_color = output_grid[x, y]\n                # Find where this color can \"melt\" down to\n                for down_y in range(y + 1, height):\n                    if output_grid[x, down_y] == baseline_color:\n                        output_grid[x, down_y] = current_color\n                        output_grid[x, y] = Color.BLACK  # Melted pixel is now empty\n                        break\n                    elif output_grid[x, down_y] != Color.BLACK:\n                        # Stop if we encounter a barrier (any non-black color)\n                        break\n\n    return output_grid\n\n\ndef generate_input():\n    width, height = 10, 10\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Create the gray baseline at the bottom\n    input_grid[:, height - 1] = Color.GRAY\n\n    # Randomly scatter some barriers (colored pixels) in the middle of the grid\n    barrier_positions = random.sample(range(1, height - 1), random.randint(5, 15))\n    for pos in barrier_positions:\n        input_grid[random.randint(0, width - 1), pos] = random.choice(Color.NOT_BLACK)\n\n    # Create a row of colored pixels at the top\n    top_colors = random.sample(Color.NOT_BLACK, k=5)\n    for x in range(width):\n        input_grid[x, 0] = random.choice(top_colors)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/202/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/202/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/202/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/202/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/202/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/202/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/202/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/202/images/train_output_2.png"}]}, "index": 202, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel sorting, alignment, color grouping\n\n# description:\n# In the input, you will see a grid filled with a random distribution of colored pixels.\n# To create the output, identify the unique colors present, then sort the pixels by color. \n# Each color should be grouped together, and for each unique color, the groups should be arranged in ascending order based on a predefined color hierarchy from darkest to lightest.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Define the color hierarchy based on perceived brightness (from darkest to lightest)\n    color_order = [Color.BLACK, Color.MAROON, Color.RED, Color.GREEN, \n                   Color.TEAL, Color.YELLOW, Color.BLUE, Color.PINK, \n                   Color.GREY, Color.ORANGE]\n\n    # Create an output grid filled with black (background)\n    output_grid = np.zeros_like(input_grid)\n\n    # Get unique colors in the input grid, excluding black\n    unique_colors = set(input_grid.flatten())\n    unique_colors.discard(Color.BLACK)\n\n    # Create a dictionary to hold the pixels for each color\n    color_pixel_map = {color: [] for color in unique_colors}\n\n    # Populate the color_pixel_map with pixel positions\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            pixel_color = input_grid[i, j]\n            if pixel_color in color_pixel_map:\n                color_pixel_map[pixel_color].append((i, j))\n\n    # Sort colors according to the defined color order\n    sorted_colors = sorted(unique_colors, key=lambda color: color_order.index(color))\n\n    # Fill the output grid with sorted colors\n    current_row = 0\n    for color in sorted_colors:\n        for (x, y) in color_pixel_map[color]:\n            output_grid[current_row, y] = color\n        current_row += 1\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter colors randomly in the grid\n    colors_to_use = random.sample(Color.NOT_BLACK, k=np.random.randint(2, 6))\n\n    for color in colors_to_use:\n        # Randomly determine how many pixels will be filled with this color\n        num_pixels = np.random.randint(1, n * m // len(colors_to_use))\n        for _ in range(num_pixels):\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/203/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/203/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/203/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/203/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/203/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/203/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/203/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/203/images/train_output_2.png"}]}, "index": 203, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, rotation\n\n# description:\n# In the input you will see a grid containing a 3x3 pattern of colored pixels in the center of a larger area of black pixels. \n# To create the output, extract the 3x3 pattern and rotate it 90 degrees clockwise, placing it back in the center of the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Determine the center of the grid\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n\n    # Extract the 3x3 pattern from the center\n    pattern = output_grid[center_x-1:center_x+2, center_y-1:center_y+2]\n\n    # Rotate the pattern 90 degrees clockwise\n    rotated_pattern = np.array([[pattern[2, 0], pattern[1, 0], pattern[0, 0]],\n                                 [pattern[2, 1], pattern[1, 1], pattern[0, 1]],\n                                 [pattern[2, 2], pattern[1, 2], pattern[0, 2]]])\n\n    # Place the rotated pattern back in the center of the output grid\n    output_grid[center_x-1:center_x+2, center_y-1:center_y+2] = rotated_pattern\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random sized grid around a 3x3 pattern\n    grid_size = random.randint(7, 15)  # Ensuring size allows for a center pattern with space\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Create a random 3x3 pattern of colors\n    colors = random.sample(Color.NOT_BLACK, 9)  # Choose 9 different colors, ensuring no black\n    pattern = np.array(colors).reshape((3, 3))\n\n    # Place the pattern in the center of the grid\n    center_x, center_y = grid_size // 2, grid_size // 2\n    grid[center_x-1:center_x+2, center_y-1:center_y+2] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/204/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/204/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/204/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/204/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/204/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/204/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/204/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/204/images/train_output_2.png"}]}, "index": 204, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, filling, color transformation\n\n# description:\n# In the input, you will see a series of irregularly shaped colored objects on a blue background. \n# To create the output, fill each colored object with a shade of grey that corresponds to the number of pixels in that object. \n# If the object has 2 pixels, fill it with light grey, 3 pixels with medium grey, and 4 pixels with dark grey. \n# Objects with less than 2 pixels are left unchanged, and those with more than 4 pixels are filled with black.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color (assumed to be blue)\n    # 2. Extract the colored objects from the input grid\n    # 3. Count the number of pixels in each object and fill with appropriate grey shades\n\n    # The background is the most common color\n    background_color = np.bincount(input_grid.flatten()).argmax()\n    assert background_color == Color.BLUE\n\n    # Find the connected components (colored objects)\n    objects = find_connected_components(input_grid, background=background_color, monochromatic=False)\n\n    # Create a mapping of pixel counts to grey colors\n    color_map = {\n        2: Color.BLUE,  # Light grey for 2 pixels\n        3: Color.PINK, # Medium grey for 3 pixels\n        4: Color.PINK,   # Dark grey for 4 pixels\n    }\n\n    # Fill the objects based on their pixel count\n    output_grid = np.copy(input_grid)\n    for obj in objects:\n        num_pixels = np.sum(obj != background_color)\n        if num_pixels in color_map:\n            output_grid[obj != background_color] = color_map[num_pixels]\n        elif num_pixels \u003e 4:\n            output_grid[obj != background_color] = Color.BLACK  # More than 4 pixels filled with black\n\n    return output_grid\n\ndef generate_input():\n    # Plan:\n    # 1. Randomly generate a number of colored objects on a blue background\n    # 2. Ensure some objects have 2, 3, or 4 pixels to demonstrate the filling logic\n\n    background_color = Color.BLUE\n    width, height = np.random.randint(7, 20, size=2)\n    input_grid = np.full((width, height), fill_value=background_color)\n\n    # Generate a random number of objects\n    n_objects = np.random.randint(3, 6)\n    for _ in range(n_objects):\n        # Create an object with a random size and color\n        obj_width, obj_height = np.random.randint(1, 5), np.random.randint(1, 5)\n        obj_color = np.random.choice(Color.NOT_BLACK)  # Choose a random color that\u0027s not black\n        object_sprite = random_sprite(obj_width, obj_height, color_palette=[obj_color], density=1)\n\n        # Place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(input_grid, object_sprite, background=background_color)\n            blit_sprite(input_grid, object_sprite, x=x, y=y, background=background_color)\n        except:\n            pass  # If placement fails, skip this object\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/205/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/205/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/205/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/205/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/205/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/205/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/205/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/205/images/train_output_2.png"}]}, "index": 205, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation based on shape\n\n# description:\n# In the input, you will see a grid with multiple irregularly shaped objects of different colors. \n# The output grid should transform the color of each object based on a predefined mapping while keeping the shapes intact.\n# The color mapping is as follows: \n# red -\u003e green, blue -\u003e yellow, green -\u003e red, yellow -\u003e blue, teal -\u003e pink, pink -\u003e teal, gray -\u003e maroon, maroon -\u003e grey.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Perform color mapping\n    color_map = {\n        Color.RED: Color.GREEN,\n        Color.BLUE: Color.YELLOW,\n        Color.GREEN: Color.RED,\n        Color.YELLOW: Color.BLUE,\n        Color.TEAL: Color.PINK,\n        Color.PINK: Color.TEAL,\n        Color.GREY: Color.MAROON,\n        Color.MAROON: Color.GREY\n    }\n\n    # Find connected components (objects) in the grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Replace colors in each object based on the mapping\n    for obj in objects:\n        bounding_box_coords = bounding_box(obj, background=Color.BLACK)\n        x, y, width, height = bounding_box_coords\n\n        # Loop through pixels of the object and change their colors\n        for i in range(x, x + width):\n            for j in range(y, y + height):\n                if obj[i - x, j - y] != Color.BLACK:  # Only change non-background pixels\n                    output_grid[i, j] = color_map.get(obj[i - x, j - y], obj[i - x, j - y])  # Map color or keep original\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with irregularly shaped objects of various colors\n    grid = np.full((10, 10), Color.BLACK)\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Generate a random sprite (object) with a random color\n        width = np.random.randint(2, 5)\n        height = np.random.randint(2, 5)\n        sprite = random_sprite(width, height)\n\n        # Choose a color for the sprite from the color mapping keys\n        color_choice = random.choice(list(Color.NOT_BLACK))\n        colored_sprite = np.copy(sprite)\n        colored_sprite[sprite != Color.BLACK] = color_choice\n        \n        # Find a random free location to place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, colored_sprite, padding=1)\n\n        # Blit the colored sprite onto the grid\n        blit_sprite(grid, colored_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/206/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/206/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/206/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/206/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/206/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/206/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/206/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/206/images/train_output_2.png"}]}, "index": 206, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, clustering, adjacent regions\n\n# description:\n# In the input, you will see a grid filled with randomly scattered colored pixels on a black background.\n# Each color represents a different type of cluster. The output should show the original grid with the clusters \n# highlighted: if a color appears in a cluster of size 3 or more, it should be highlighted in bright yellow.\n# If a color appears in a cluster of size 1 or 2, it should be highlighted in grey.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (clusters)\n    clusters = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Check the size of each cluster and update the output grid accordingly\n    for cluster in clusters:\n        cluster_color = cluster[0][0]  # Assuming all pixels in the cluster are the same color\n        cluster_size = np.sum(cluster == cluster_color)\n        \n        # Highlight the cluster based on its size\n        if cluster_size \u003e= 3:\n            output_grid[cluster == cluster_color] = Color.YELLOW  # Highlight large clusters in yellow\n        elif cluster_size \u003c= 2:\n            output_grid[cluster == cluster_color] = Color.GREY  # Highlight small clusters in grey\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 black grid as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly distribute colored pixels on the grid\n    num_pixels = np.random.randint(20, 40)  # Random number of colored pixels\n    for _ in range(num_pixels):\n        color = random.choice(list(Color.NOT_BLACK))  # Pick a random color\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color  # Place the pixel on the grid\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/207/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/207/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/207/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/207/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/207/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/207/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/207/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/207/images/train_output_2.png"}]}, "index": 207, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pixel filling\n\n# description:\n# In the input you will see a pattern that is almost symmetric but has a few missing pixels. \n# To make the output, identify the missing pixels that would create symmetry and fill \n# them in with the color of the nearest surrounding pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n    \n    # Find the center of the grid and detect rotational symmetry\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n    \n    # Get coordinates of the colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Fill missing pixels in the output grid\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        \n        # Loop through the symmetry to fill in the missing parts\n        for i in range(1, 5):  # 1 to 4 for the 4 possible rotations\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n            # Fill in the pixel if it\u0027s black\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random base grid size\n    grid_size = random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a random pattern with some missing pixels\n    pattern = random_sprite(5, 5, density=0.6, color_palette=list(Color.NOT_BLACK), symmetry=\u0027radial\u0027)\n    \n    # Place the pattern in the center\n    x, y = (grid_size - pattern.shape[0]) // 2, (grid_size - pattern.shape[1]) // 2\n    blit_sprite(grid, pattern, x, y)\n\n    # Randomly remove some pixels to create the \"missing\" effect\n    for i in range(pattern.shape[0]):\n        for j in range(pattern.shape[1]):\n            if random.random() \u003c 0.3:  # 30% chance to remove a pixel\n                grid[x + i, y + j] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/208/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/208/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/208/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/208/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/208/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/208/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/208/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/208/images/train_output_2.png"}]}, "index": 208, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alignment, radial pattern creation\n\n# description:\n# In the input grid, you will see a series of colored pixels arranged randomly.\n# To create the output, align all the colored pixels to the center of the grid,\n# and adjust their position based on their distance from the center, creating a radial pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the grid\n    rows, cols = input_grid.shape\n    center_x, center_y = rows // 2, cols // 2\n\n    # Find all colored pixels in the input grid\n    colored_pixels = detect_objects(input_grid, colors=list(Color.NOT_BLACK), monochromatic=False, connectivity=4)\n\n    # Create an output grid filled with black (background)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # For each colored pixel, calculate its distance from the center and place it in a radial pattern\n    for pixel in colored_pixels:\n        # Get the position of the pixel\n        x, y = object_position(pixel, background=Color.BLACK, anchor=\u0027center\u0027)\n\n        # Calculate the distance from the center\n        dist_x = x - center_x\n        dist_y = y - center_y\n        distance = int(np.sqrt(dist_x**2 + dist_y**2))\n\n        # Calculate new positions based on the distance\n        new_x = center_x + distance\n        new_y = center_y + distance\n\n        # Ensure new positions do not go out of bounds\n        if 0 \u003c= new_x \u003c rows and 0 \u003c= new_y \u003c cols:\n            output_grid[new_x, new_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colored pixels\n    num_pixels = np.random.randint(1, 10)\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/209/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/209/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/209/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/209/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/209/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/209/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/209/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/209/images/train_output_2.png"}]}, "index": 209, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, transparency, blending\n\n# description:\n# In the input you will see multiple layers of colored objects, some of which may be semi-transparent.\n# To create the output, overlay the colored objects while considering their transparency, resulting in a composite image that accurately represents the interaction between the layers.\n# Each color in the grid represents a different layer, and some layers are transparent (e.g., grey represents transparency).\n# The final output should blend the colors based on their transparency levels, where fully transparent pixels do not affect the output.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Iterate over the layers in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x, y]\n            if color != Color.BLACK:  # If it\u0027s not the background\n                if color == Color.GREY:  # Treat grey as transparency\n                    continue  # Skip transparent pixels\n                # Blend color with the output grid\n                if output_grid[x, y] == Color.BLACK:\n                    output_grid[x, y] = color  # First layer\n                else:\n                    # Blend colors (simple additive blending for this example)\n                    output_grid[x, y] = blend_colors(output_grid[x, y], color)\n    \n    return output_grid\n\ndef blend_colors(color1, color2):\n    # Simple function to blend two colors (assuming colors are integers)\n    return min(color1 + color2, len(Color.NOT_BLACK) - 1)  # Avoid exceeding color range\n\ndef generate_input():\n    # Create a random grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Random number of layers\n    num_layers = np.random.randint(3, 6)\n    \n    for _ in range(num_layers):\n        # Generate a random object with some transparency\n        layer_height, layer_width = np.random.randint(1, 5), np.random.randint(1, 5)\n        layer = random_sprite(layer_height, layer_width, color_palette=Color.NOT_BLACK)\n        \n        # Introduce some transparency\n        for x in range(layer.shape[0]):\n            for y in range(layer.shape[1]):\n                if np.random.rand() \u003c 0.5:  # 50% chance to set a pixel to transparency\n                    layer[x, y] = Color.GREY  # Set to transparent\n\n        # Place the layer on the grid randomly\n        x, y = random_free_location_for_sprite(grid, layer, padding=1)\n        blit_sprite(grid, layer, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/210/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/210/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/210/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/210/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/210/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/210/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/210/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/210/images/train_output_2.png"}]}, "index": 210, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# concentric shapes, color transformation\n\n# description:\n# In the input, you will see a series of concentric shapes, each of a different color. \n# To make the output, transform the colors of the shapes in such a way that each shape is a lighter shade of the color of the shape immediately surrounding it.\n\ndef main(input_grid):\n    # Get the bounding boxes of the shapes in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=False, background=Color.BLACK, connectivity=4)\n    \n    # Prepare the output grid with the same dimensions as the input\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Sort shapes by their area (or size) to ensure we process from the innermost to outermost\n    objects = sorted(objects, key=lambda obj: obj.size)\n\n    # Create a mapping of the colors to their lighter shades\n    lighter_colors = {Color.RED: Color.PINK, Color.GREEN: Color.GREY, Color.BLUE: Color.ORANGE,\n                      Color.YELLOW: Color.GRAY, Color.ORANGE: Color.ORANGE, \n                      Color.TEAL: Color.GREY, Color.MAROON: Color.MAROON, \n                      Color.GREY: Color.ORANGE}\n\n    # Process each shape and assign lighter colors based on the surrounding shape\n    for i, shape in enumerate(objects):\n        # Get the color of the current shape\n        shape_color = shape[0, 0]  # Assuming all pixels within the shape are the same color\n        if i == 0:\n            # The innermost shape retains its original color\n            output_grid[shape != Color.BLACK] = shape_color\n        else:\n            # Get the color of the surrounding shape\n            surrounding_color = objects[i - 1][0, 0]\n            lighter_color = lighter_colors.get(surrounding_color, surrounding_color)\n            output_grid[shape != Color.BLACK] = lighter_color\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a base grid\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Start by creating concentric shapes\n    num_shapes = np.random.randint(3, 6)  # Number of concentric shapes\n    colors = random.sample(list(Color.NOT_BLACK), num_shapes)\n\n    # Generate concentric shapes\n    for i in range(num_shapes):\n        shape_color = colors[i]\n        # Create a square shape at the center with decreasing size\n        size = grid_size - (i * 2)\n        if size \u003e 0:\n            # Draw a square shape\n            start = i\n            end = grid_size - i - 1\n            grid[start:end + 1, start] = shape_color  # left vertical\n            grid[start:end + 1, end] = shape_color    # right vertical\n            grid[start, start:end + 1] = shape_color  # top horizontal\n            grid[end, start:end + 1] = shape_color    # bottom horizontal\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/211/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/211/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/211/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/211/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/211/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/211/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/211/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/211/images/train_output_2.png"}]}, "index": 211, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, pixel expansion\n\n# description:\n# In the input, you will see a colored pixel at the center of the grid surrounded by a black background.\n# To make the output, expand the colored pixel outward in all directions, forming a radial pattern of the same color until it reaches the edge of the grid.\n\ndef main(input_grid):\n    # Step 1: Find the colored pixel at the center of the grid.\n    center_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(center_pixel_locations) == 1\n    center_pixel_location = center_pixel_locations[0]\n    center_x, center_y = center_pixel_location\n\n    # Get the color of the central pixel\n    central_color = input_grid[center_x, center_y]\n\n    # Step 2: Create an output grid filled with black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 3: Expand the colored pixel outward radially\n    max_x, max_y = output_grid.shape\n    for x in range(max_x):\n        for y in range(max_y):\n            if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= min(center_x, center_y, max_x - center_x - 1, max_y - center_y - 1) ** 2:\n                output_grid[x, y] = central_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m with a black background\n    n, m = 5, 5\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select the position of the colored pixel to place at the center\n    center_x, center_y = n // 2, m // 2\n    color = np.random.choice(Color.NOT_BLACK)\n    input_grid[center_x, center_y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/212/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/212/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/212/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/212/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/212/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/212/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/212/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/212/images/train_output_2.png"}]}, "index": 212, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# vertical symmetry, occlusion\n\n# description:\n# In the input, you will see a vertically symmetric object that is partially obscured by black pixels.\n# To make the output, remove the black pixels and fill in the missing parts of the object to restore its vertical symmetry.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect vertical symmetry in the input grid\n    # 2. Fill in the missing parts of the vertically symmetric object based on the symmetry\n\n    output_grid = input_grid.copy()\n\n    # Detect vertical symmetry and find the symmetric pairs\n    symmetries = detect_mirror_symmetry(input_grid, ignore_colors=[Color.BLACK])\n    assert len(symmetries) \u003e 0, \"No vertical symmetry found\"\n\n    # Fill in the missing colors using the symmetry\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            if output_grid[x, y] == Color.BLACK:\n                # For each black pixel, find its symmetric counterpart\n                for sym in symmetries:\n                    symmetric_x, symmetric_y = sym.apply(x, y)\n                    if output_grid[symmetric_x, symmetric_y] != Color.BLACK:\n                        # Fill in the black pixel with the color from the symmetric counterpart\n                        output_grid[x, y] = output_grid[symmetric_x, symmetric_y]\n                        break\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a vertically symmetric sprite\n    sprite = random_sprite(np.random.randint(5, n-2), np.random.randint(5, m-2), density=0.5, symmetry=\"vertical\", color_palette=list(Color.NOT_BLACK))\n    \n    # Randomly occlude parts of the sprite with black pixels\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.random() \u003c 0.3:  # 30% chance to occlude each pixel\n                sprite[i, j] = Color.BLACK\n\n    # Place the sprite randomly onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/213/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/213/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/213/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/213/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/213/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/213/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/213/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/213/images/train_output_2.png"}]}, "index": 213, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, overlap, color transformation\n\n# description:\n# In the input, you will see a grid containing a random arrangement of colored pixels. \n# The topmost layer of pixels with the same color will be transformed into a new color.\n# Specifically, for every pixel in the topmost layer, change its color to yellow.\n# A pixel is considered part of the topmost layer if there are no pixels of the same color directly beneath it.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Get the unique colors in the grid\n    unique_colors = np.unique(input_grid)\n\n    for color in unique_colors:\n        # Check for the topmost layer of this color\n        for x in range(input_grid.shape[0]):\n            for y in range(input_grid.shape[1]):\n                if input_grid[x, y] == color:\n                    # Check if there is no same color pixel directly beneath\n                    if x == input_grid.shape[0] - 1 or input_grid[x + 1, y] != color:\n                        # Change this pixel\u0027s color to yellow\n                        output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random colors in the grid\n    num_colors = np.random.randint(2, 5)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=num_colors, replace=False)\n\n    # Fill the grid with random colors\n    for x in range(n):\n        for y in range(m):\n            # Randomly choose color for each pixel\n            grid[x, y] = np.random.choice(colors)\n\n    # Randomly add some topmost layers of color by stacking\n    for color in colors:\n        # Choose a random starting row and column\n        start_x = np.random.randint(0, n)\n        start_y = np.random.randint(0, m)\n        # Create a random height for the stack\n        height = np.random.randint(1, n - start_x)\n        \n        for h in range(height):\n            if start_x + h \u003c n:\n                grid[start_x + h, start_y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/214/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/214/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/214/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/214/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/214/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/214/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/214/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/214/images/train_output_2.png"}]}, "index": 214, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, pattern recognition, mirroring\n\n# description:\n# In the input, you will see a grid with a pattern that is symmetric around a central axis.\n# To create the output, identify the symmetric pattern and replicate it on the opposite side of the axis, ensuring both halves match perfectly.\n\ndef main(input_grid):\n    # Determine the center of the grid\n    height, width = input_grid.shape\n    mid_row = height // 2\n    mid_col = width // 2\n    \n    # Create an output grid initialized with the input grid\n    output_grid = np.copy(input_grid)\n\n    # Fill in the mirrored part of the grid\n    for i in range(mid_row):\n        for j in range(width):\n            output_grid[height - i - 1, j] = input_grid[i, j]\n    \n    return output_grid\n\ndef generate_input():\n    # Randomly generate a grid of size between 5x5 and 10x10\n    height = np.random.randint(5, 11)\n    width = np.random.randint(5, 11)\n    grid = np.zeros((height, width), dtype=int)\n\n    # Select a color for the patterns\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a symmetric pattern in the top half of the grid\n    for i in range(height // 2):\n        for j in range(width):\n            # Randomly decide whether to place the color or leave it black\n            grid[i, j] = np.random.choice([color, Color.BLACK], p=[0.5, 0.5])\n    \n    # The bottom half will be filled in by the main function\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/215/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/215/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/215/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/215/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/215/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/215/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/215/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/215/images/train_output_2.png"}]}, "index": 215, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# concentric circles, distance calculation\n\n# description:\n# In the input, you will see a single colored pixel on a black background.\n# To make the output, draw concentric circles around the colored pixel using the same color. \n# The radius of these circles should increase in steps, creating a pattern of circles around the pixel.\n\ndef main(input_grid):\n    # Create output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the index of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Get the color from the colored pixel\n    color = input_grid[x, y]\n\n    # Draw concentric circles\n    radius = 1\n    while True:\n        # Circle coordinates based on the current radius\n        for angle in range(0, 360, 10): # Draw circle at every 10 degrees\n            rad = np.deg2rad(angle)\n            circle_x = int(x + radius * np.cos(rad))\n            circle_y = int(y + radius * np.sin(rad))\n            \n            # Check if the circle coordinates are within bounds\n            if 0 \u003c= circle_x \u003c output_grid.shape[0] and 0 \u003c= circle_y \u003c output_grid.shape[1]:\n                output_grid[circle_x, circle_y] = color\n        \n        # Stop if the circle exceeds the dimensions of the grid\n        if radius \u003e max(input_grid.shape):\n            break\n        \n        radius += 1  # Increment the radius for the next circle\n\n    return output_grid\n\ndef generate_input():\n    # Create a square black grid\n    n = m = np.random.randint(5, 20)  # size of the grid\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a randomly colored pixel at a random point on the grid\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/216/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/216/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/216/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/216/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/216/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/216/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/216/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/216/images/train_output_2.png"}]}, "index": 216, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape expansion, color gradient\n\n# description:\n# In the input, you will see a 5x5 shape made of colored pixels on a black background. \n# To make the output, extract the shape and transform it into a 10x10 version of the same shape, \n# filling the new pixels with a gradient based on the original shape\u0027s color.\n\ndef main(input_grid):\n    # Step 1: Crop the input grid to extract the shape\n    shape = crop(input_grid, background=Color.BLACK)\n\n    # Step 2: Get the dimensions of the original shape\n    original_height, original_width = shape.shape\n\n    # Step 3: Create a new grid for the output (10x10)\n    output_grid = np.full((10, 10), Color.BLACK)\n\n    # Step 4: Calculate the scaling factor\n    scale_factor = 10 / max(original_height, original_width)\n\n    # Step 5: Fill in the output grid with a gradient based on the original color\n    for x in range(original_height):\n        for y in range(original_width):\n            if shape[x, y] != Color.BLACK:\n                original_color = shape[x, y]\n\n                # Calculate the new position in the output grid\n                new_x = int(x * scale_factor)\n                new_y = int(y * scale_factor)\n\n                # Create a gradient towards the original color\n                for i in range(3):  # Assuming RGB gradient\n                    # Fill the output grid with a gradient color\n                    output_grid[new_x, new_y] = original_color\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Define dimensions for the sprite\n    width, height = 5, 5\n\n    # Step 2: Create a base grid filled with black\n    grid = np.full((width, height), Color.BLACK)\n\n    # Step 3: Generate a random shape\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape = random_sprite(width, height, color_palette=[shape_color], density=0.5)\n\n    # Step 4: Place the shape into the grid\n    grid = blit_sprite(grid, shape, x=0, y=0, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/217/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/217/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/217/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/217/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/217/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/217/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/217/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/217/images/train_output_2.png"}]}, "index": 217, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity detection, color overlay\n\n# description:\n# In the input, you will see a grid with colored pixels that are grouped closely together. \n# To create the output, overlay a translucent layer of a contrasting color over the groups,\n# highlighting their proximity without completely obscuring them.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect connected components in the grid.\n    # 2. Create an output grid initialized to black.\n    # 3. For each detected group, overlay a translucent contrasting color.\n\n    output_grid = np.copy(input_grid)\n\n    # Detect connected components in the input grid\n    components = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Define a contrasting color (let\u0027s say we choose RED as the overlay color)\n    overlay_color = Color.RED\n\n    # Overlay a translucent layer over each group of connected components\n    for component in components:\n        # Get the bounding box of the component\n        y_min, y_max = np.min(np.argwhere(component != Color.BLACK)[:, 0]), np.max(np.argwhere(component != Color.BLACK)[:, 0])\n        x_min, x_max = np.min(np.argwhere(component != Color.BLACK)[:, 1]), np.max(np.argwhere(component != Color.BLACK)[:, 1])\n\n        # Draw a translucent overlay (for simplicity, we can just draw the color over the bounding box)\n        for y in range(y_min, y_max + 1):\n            for x in range(x_min, x_max + 1):\n                if component[y - y_min, x - x_min] != Color.BLACK:  # Only overlay on the existing colored pixels\n                    output_grid[y, x] = overlay_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a black background.\n    n = m = 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly determine the number of groups between 2 and 5.\n    num_groups = np.random.randint(2, 6)\n\n    for _ in range(num_groups):\n        # Randomly determine the width and height of the colored group between 2 and 4.\n        width, height = np.random.randint(2, 5, size=2)\n        color_sprite = random_sprite(width, height, density=1, color_palette=Color.NOT_BLACK)\n\n        # Find a random free location for this sprite\n        x, y = random_free_location_for_sprite(grid, color_sprite, background=Color.BLACK, padding=1, border_size=1)\n        blit_sprite(grid, color_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/218/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/218/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/218/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/218/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/218/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/218/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/218/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/218/images/train_output_2.png"}]}, "index": 218, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object tracking, movement, color transformation\n\n# description:\n# In the input, you will see a grid with a colored sprite and a series of colored dots. \n# As the sprite moves in one of the four cardinal directions, leave a trail behind it \n# that matches the color of the pixels it passes over, while the sprite itself changes color \n# based on the last pixel it touched.\n\ndef main(input_grid):\n    # Initialize the output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # Determine the position of the sprite (the first colored pixel found)\n    sprite_position = np.argwhere(output_grid != Color.BLACK)[0]\n    sprite_x, sprite_y = sprite_position\n\n    # Define the direction of movement and trail color\n    direction = (1, 0)  # Initially moving to the right\n    trail_color = output_grid[sprite_x, sprite_y]\n    \n    # Move the sprite until it hits the edge of the grid or a colored dot\n    while True:\n        # Store the current color of the pixel the sprite is on\n        current_color = output_grid[sprite_x, sprite_y]\n\n        # Leave a trail\n        output_grid[sprite_x, sprite_y] = trail_color\n\n        # Calculate the next position\n        next_x = sprite_x + direction[0]\n        next_y = sprite_y + direction[1]\n\n        # Check if the next position is within bounds\n        if 0 \u003c= next_x \u003c output_grid.shape[0] and 0 \u003c= next_y \u003c output_grid.shape[1]:\n            # Update sprite\u0027s position\n            sprite_x, sprite_y = next_x, next_y\n            \n            # If we hit a colored dot, change direction or stop\n            if output_grid[sprite_x, sprite_y] != Color.BLACK:\n                # Change the trail color to the color of the last pixel touched\n                trail_color = output_grid[sprite_x, sprite_y]\n                break\n        else:\n            # Hit the edge of the grid\n            break\n\n    # Final position of the sprite\n    output_grid[sprite_x, sprite_y] = trail_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid size\n    n = np.random.randint(10, 15)\n    m = np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter a sprite in the grid\n    sprite_color = np.random.choice(Color.NOT_BLACK)  # Choose a random color for the sprite\n\n    # Place the sprite randomly in the grid\n    sprite_x = np.random.randint(1, n-1)\n    sprite_y = np.random.randint(1, m-1)\n    grid[sprite_x, sprite_y] = sprite_color\n\n    # Scatter colored dots throughout the grid\n    for _ in range(np.random.randint(5, 15)):\n        dot_x = np.random.randint(0, n)\n        dot_y = np.random.randint(0, m)\n        # Ensure the dot does not overwrite the sprite\n        if grid[dot_x, dot_y] == Color.BLACK:\n            grid[dot_x, dot_y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/219/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/219/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/219/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/219/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/219/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/219/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/219/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/219/images/train_output_2.png"}]}, "index": 219, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, color blending\n\n# description:\n# In the input grid, you will see various colored shapes on a black background. To create the output grid, apply a blending effect to the shapes: for each shape, draw a semi-transparent version of it in a darker shade overlapping it. The semi-transparent shape should be offset to the bottom-right of the original shape while maintaining the same dimensions.\n\ndef main(input_grid):\n    # Step 1: Find all connected components (shapes) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    output_grid = input_grid.copy()\n\n    # Step 2: For each object found, create a darker version and place it in the output grid\n    for obj in objects:\n        # Get the color of the object\n        color = obj[obj != Color.BLACK][0]\n        \n        # Create a darker shade of the color (simple method: just reduce intensity)\n        darker_color = color  # Placeholder for actual darker color logic\n        if color == Color.RED:\n            darker_color = Color.MAROON\n        elif color == Color.GREEN:\n            darker_color = Color.TEAL\n        elif color == Color.BLUE:\n            darker_color = Color.GREY\n        elif color == Color.YELLOW:\n            darker_color = Color.ORANGE\n        # ...add cases for other colors if needed...\n\n        # Step 3: Translate the object to create the shadow effect\n        translated_obj = translate(obj, x=1, y=1, background=Color.BLACK)  # Move bottom-right\n        # Step 4: Blit the darker version of the object onto the output grid\n        blit_object(output_grid, translated_obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly generate 3-5 shapes on the grid\n    for _ in range(np.random.randint(3, 6)):\n        # Generate a random size for the shape (2x2 to 5x5)\n        w, h = np.random.randint(2, 6, size=2)\n        # Create a random sprite (shape)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n        shape = random_sprite(w, h, color_palette=[shape_color])\n        \n        # Find a random free location to blit the shape\n        x, y = random_free_location_for_sprite(input_grid, shape)\n        blit_sprite(input_grid, shape, x, y)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/220/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/220/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/220/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/220/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/220/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/220/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/220/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/220/images/train_output_2.png"}]}, "index": 220, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color filling\n\n# description:\n# In the input, you will see a grid with colored pixels that are symmetric along the vertical axis.\n# To create the output, identify any missing pixels that would complete the symmetry and fill them with the corresponding color from the opposite side of the grid.\n\ndef main(input_grid):\n    n, m = input_grid.shape\n    output_grid = input_grid.copy()\n    \n    # Loop through the first half of the grid\n    for x in range(n):\n        for y in range(m // 2):\n            if output_grid[x, y] != Color.BLACK:  # Only consider non-black pixels\n                opposite_y = m - y - 1\n                if output_grid[x, opposite_y] == Color.BLACK:\n                    output_grid[x, opposite_y] = output_grid[x, y]  # Fill the opposite pixel\n    \n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a vertical symmetric pattern\n    for x in range(n):\n        for y in range(m // 2):\n            if np.random.rand() \u003c 0.5:  # Randomly decide whether to fill a color\n                color = np.random.choice(list(Color.NOT_BLACK))\n                grid[x, y] = color\n                grid[x, m - y - 1] = color  # Ensure symmetry by filling the opposite pixel\n\n    # Introduce some random black pixels to break symmetry\n    for x in range(n):\n        for y in range(m):\n            if np.random.rand() \u003c 0.2:  # 20% chance to turn any pixel into black\n                grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/221/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/221/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/221/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/221/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/221/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/221/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/221/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/221/images/train_output_2.png"}]}, "index": 221, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, symmetry, color transformation\n\n# description:\n# In the input, you will see a grid with a pattern on the left half and a black background on the right half.\n# To make the output, reflect the pattern across the vertical center line of the grid, \n# and fill the black background with the mirrored version of the pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Identify the width and height of the input grid\n    height, width = input_grid.shape\n\n    # Get the left half of the grid, which contains the pattern\n    left_half = input_grid[:, :width // 2]\n\n    # Reflect the left half horizontally to create the right half\n    reflected_half = left_half[:, ::-1]\n\n    # Create the output grid by concatenating the left half and the reflected right half\n    output_grid = np.concatenate((left_half, reflected_half), axis=1)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random height for the grid\n    height = np.random.randint(3, 10)\n\n    # Generate a random width for the grid (must be even to ensure symmetry)\n    width = np.random.randint(4, 12) * 2  # Ensures that width is even\n\n    # Create a grid with a black background\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Create a pattern on the left half of the grid\n    pattern_width = width // 2\n    pattern_height = np.random.randint(1, height + 1)  # Random height for the pattern\n\n    # Generate a random pattern of non-black colors\n    pattern = random_sprite(pattern_height, pattern_width, density=0.6, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    # Place the pattern in the left half of the grid\n    input_grid[:pattern_height, :pattern_width] = pattern\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/222/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/222/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/222/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/222/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/222/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/222/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/222/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/222/images/train_output_2.png"}]}, "index": 222, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel connectivity, color blending\n\n# description:\n# In the input grid, you will see several colored pixels scattered around, with some pixels of a specific color (e.g., green) forming a continuous shape.\n# To create the output grid, you should expand the shape of the specific color by blending it with adjacent colors. \n# Each adjacent pixel\u0027s color should be replaced with a mix of the specific color and the adjacent color, resulting in a gradient effect towards the specific color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Find the connected component of the specific color (e.g., green)\n    specific_color = Color.GREEN\n    components = find_connected_components(input_grid, monochromatic=True)\n    target_component = next(c for c in components if np.any(c == specific_color))\n\n    # Get the coordinates of the specific color shape\n    target_coords = np.argwhere(input_grid == specific_color)\n\n    # Define blending function\n    def blend_colors(color1, color2):\n        return color1 if color1 != Color.BLACK else color2\n    \n    # Expand the shape by blending adjacent colors\n    for x, y in target_coords:\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue  # Skip the specific color pixel itself\n                nx, ny = x + dx, y + dy\n                if 0 \u003c= nx \u003c output_grid.shape[0] and 0 \u003c= ny \u003c output_grid.shape[1]:\n                    if output_grid[nx, ny] != specific_color and output_grid[nx, ny] != Color.BLACK:\n                        # Blend the specific color with the adjacent color\n                        output_grid[nx, ny] = blend_colors(specific_color, output_grid[nx, ny])\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random colors for the scattered pixels\n    num_pixels = np.random.randint(30, 100)\n    colors = random.sample(Color.NOT_BLACK, k=5)  # Pick 5 different colors\n\n    # Scatter colors randomly in the grid\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = random.choice(colors)\n\n    # Create a continuous shape of the specific color, for example, green\n    specific_shape_color = Color.GREEN\n    shape_start_x, shape_start_y = np.random.randint(1, n // 2), np.random.randint(1, m // 2)\n    draw_line(grid, shape_start_x, shape_start_y, length=5, direction=(1, 0), color=specific_shape_color)  # Horizontal line\n    draw_line(grid, shape_start_x + 1, shape_start_y, length=5, direction=(0, 1), color=specific_shape_color)  # Vertical line\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/223/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/223/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/223/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/223/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/223/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/223/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/223/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/223/images/train_output_2.png"}]}, "index": 223, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# recursive filling, color propagation, confinement\n\n# description:\n# In the input, you will see a grid with a single colored pixel surrounded by black pixels. \n# To create the output, recursively fill in neighboring black pixels with the same color until no more black pixels are adjacent to the colored area.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the coordinates of the initial colored pixel\n    initial_color_location = np.argwhere(input_grid != Color.BLACK)\n    assert len(initial_color_location) == 1  # Make sure there is exactly one colored pixel\n    start_x, start_y = initial_color_location[0]\n\n    # Define a recursive function to fill the color\n    def flood_fill(x, y, color):\n        if x \u003c 0 or x \u003e= output_grid.shape[0] or y \u003c 0 or y \u003e= output_grid.shape[1]:\n            return  # Out of bounds\n        if output_grid[x, y] != Color.BLACK:\n            return  # Already filled or not black\n        output_grid[x, y] = color  # Fill the color\n        # Recursive calls for all 8 directions\n        for dx, dy in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n            flood_fill(x + dx, y + dy, color)\n\n    # Start filling from the initial colored pixel\n    initial_color = input_grid[start_x, start_y]\n    flood_fill(start_x, start_y, initial_color)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 black grid as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a color from Color.NOT_BLACK\n    fill_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly choose a non-border cell for the initial colored pixel\n    non_border_cells = [(i, j) for i in range(1, n-1) for j in range(1, m-1)]\n    initial_cell = np.random.choice(len(non_border_cells))\n    grid[non_border_cells[initial_cell]] = fill_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/224/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/224/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/224/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/224/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/224/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/224/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/224/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/224/images/train_output_2.png"}]}, "index": 224, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# adjacency, clustering, color mapping\n\n# description:\n# In the input, you will see a grid with randomly placed colored pixels. \n# To make the output, identify clusters of adjacent pixels (2 or more of the same color) \n# and color the entire cluster with a new color based on the count of pixels in that cluster: \n# 2-3 pixels become yellow, 4-5 pixels become blue, and 6 or more pixels become red.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True)\n\n    # Color the clusters based on their size\n    for obj in objects:\n        num_pixels = np.sum(obj == input_grid[obj.shape[0] // 2, obj.shape[1] // 2])  # Count the color of the object\n        if num_pixels \u003e= 2 and num_pixels \u003c= 3:\n            color = Color.YELLOW\n        elif num_pixels \u003e= 4 and num_pixels \u003c= 5:\n            color = Color.BLUE\n        elif num_pixels \u003e= 6:\n            color = Color.RED\n        else:\n            continue  # Ignore clusters smaller than 2 pixels\n\n        # Set the entire cluster to the new color\n        output_grid[obj == input_grid[obj.shape[0] // 2, obj.shape[1] // 2]] = color\n\n    return output_grid\n\ndef generate_input():\n    # Make a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random number of colored pixels\n    num_pixels = np.random.randint(10, 30)  # Randomly choose how many colored pixels to place\n\n    for _ in range(num_pixels):\n        color = np.random.choice(list(Color.NOT_BLACK))  # Choose a random color (not black)\n        # Randomly place the colored pixel in the grid\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    # Ensure some clusters are formed by placing additional pixels adjacent to each other\n    for _ in range(np.random.randint(3, 6)):  # Randomly create adjacent pixels\n        color = np.random.choice(list(Color.NOT_BLACK))\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if x \u003c n - 1:  # Place an adjacent pixel below\n            grid[x + 1, y] = color\n        if y \u003c m - 1:  # Place an adjacent pixel to the right\n            grid[x, y + 1] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/225/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/225/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/225/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/225/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/225/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/225/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/225/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/225/images/train_output_2.png"}]}, "index": 225, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, shape transformation\n\n# description:\n# In the input, you will see a grid with various circular shapes filled with different colors on a black background. \n# To create the output, replace each circle\u0027s color according to a predefined mapping (e.g., blue to red, green to orange) while preserving the circular outlines.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Perform color mapping\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n\n# Constructing the color map\ncolor_map = {Color.BLUE: Color.RED,\n             Color.GREEN: Color.ORANGE,\n             Color.RED: Color.YELLOW,\n             Color.YELLOW: Color.TEAL,\n             Color.TEAL: Color.MAROON,\n             Color.MAROON: Color.BLUE,\n             Color.BLACK: Color.BLACK}\n\ndef generate_input():\n    # Create a black grid\n    grid_size = (20, 20)\n    grid = np.full(grid_size, Color.BLACK)\n\n    # Randomly draw circles of various colors at random positions\n    num_circles = np.random.randint(3, 7)\n    colors = list(color_map.keys())\n    \n    for _ in range(num_circles):\n        color = np.random.choice(colors)\n        radius = np.random.randint(2, 5)\n        # Find a random center for the circle\n        center_x = np.random.randint(radius, grid_size[0] - radius)\n        center_y = np.random.randint(radius, grid_size[1] - radius)\n        \n        # Draw the circle in the grid\n        for x in range(center_x - radius, center_x + radius + 1):\n            for y in range(center_y - radius, center_y + radius + 1):\n                if (x - center_x)**2 + (y - center_y)**2 \u003c= radius**2:\n                    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/226/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/226/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/226/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/226/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/226/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/226/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/226/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/226/images/train_output_2.png"}]}, "index": 226, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, pattern generation\n\n# description:\n# In the input, you will see a single colored pixel on a black background.\n# To create the output, generate a pattern of pixels radiating outwards from the central pixel in a circular formation, using a sequence of colors.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the central colored pixel\n    central_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, allowed_dimensions=[(1, 1)], monochromatic=True)\n    assert len(central_objects) == 1\n    central_pixel = central_objects[0]\n    \n    # Find the position of the central pixel\n    cx, cy = object_position(central_pixel, background=Color.BLACK, anchor=\"upper left\")\n    \n    # Define the colors to use in the pattern\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.ORANGE]\n    \n    # Create the output grid large enough to fit the pattern\n    output_size = 9  # This can be adjusted based on the desired size\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n    \n    # Generate the radial pattern\n    for r in range(1, 5):  # Radii from 1 to 4\n        for angle in range(0, 360, 15):  # 15-degree increments\n            rad_angle = np.radians(angle)\n            x = int(cx + r * np.cos(rad_angle))\n            y = int(cy + r * np.sin(rad_angle))\n\n            # Wrap colors based on radius\n            color_index = r % len(colors)\n            if 0 \u003c= x \u003c output_size and 0 \u003c= y \u003c output_size:\n                output_grid[x, y] = colors[color_index]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid large enough to fit a central pixel\n    grid_size = 7\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n    \n    # Randomly select a position for the central pixel\n    cx, cy = np.random.randint(1, grid_size - 1), np.random.randint(1, grid_size - 1)\n    \n    # Choose a random color for the central pixel\n    central_color = np.random.choice(list(Color.NOT_BLACK))\n    grid[cx, cy] = central_color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/227/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/227/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/227/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/227/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/227/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/227/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/227/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/227/images/train_output_2.png"}]}, "index": 227, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gradient fill, border detection\n\n# description:\n# In the input, you will see a grid with a colored border surrounding a central area. \n# To create the output, apply a gradient fill to the central area starting from the color of the border \n# and transitioning to black, with the gradient applied horizontally and vertically.\n\ndef main(input_grid):\n    # Find the border color by detecting the connected component of the border\n    border_components = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=8)\n    border_color = border_components[0][0, 0] if border_components else Color.BLACK\n    \n    # Get the bounding box of the border\n    border_box = bounding_box(grid=border_components[0], background=Color.BLACK)\n    x, y, width, height = border_box\n    \n    # Create the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Apply gradient fill to the central area\n    for i in range(1, height - 1):\n        for j in range(1, width - 1):\n            # Calculate the gradient factor based on distance from the border\n            gradient_factor = (i + j) / (height + width)  # Normalize distance\n            # Interpolate between border color and black\n            output_color = interpolate_color(border_color, Color.BLACK, gradient_factor)\n            output_grid[y + i, x + j] = output_color\n\n    return output_grid\n\ndef interpolate_color(color1, color2, factor):\n    # Simple interpolation function to blend two colors\n    return color1 if factor \u003c= 0 else color2 if factor \u003e= 1 else Color.BLACK  # Placeholder for color blending logic\n\ndef generate_input():\n    # Initialize the grid size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose the border color from the available colors\n    border_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Draw the border\n    border_width = np.random.randint(1, 3)  # Random border width\n    draw_line(grid, 0, 0, length=n, direction=(1, 0), color=border_color)  # Top border\n    draw_line(grid, 0, m - 1, length=n, direction=(1, 0), color=border_color)  # Bottom border\n    draw_line(grid, 0, 0, length=m, direction=(0, 1), color=border_color)  # Left border\n    draw_line(grid, n - 1, 0, length=m, direction=(0, 1), color=border_color)  # Right border\n    \n    # Fill the central area with black\n    inner_area = np.full((n - 2 * border_width, m - 2 * border_width), Color.BLACK)\n    grid = blit_sprite(grid, inner_area, border_width, border_width, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/228/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/228/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/228/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/228/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/228/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/228/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/228/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/228/images/train_output_2.png"}]}, "index": 228, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity, color mapping, edge connection\n\n# description:\n# In the input, you will see a grid with scattered colored pixels. \n# To produce the output, draw a line connecting each colored pixel to the nearest edge of the grid, \n# using the color of the pixel for the line.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the dimensions of the input grid\n    rows, cols = input_grid.shape\n    \n    # Function to find the nearest edge for a given pixel\n    def nearest_edge(x, y):\n        distances = {\n            \u0027top\u0027: x,                               # distance to top edge\n            \u0027bottom\u0027: rows - 1 - x,                # distance to bottom edge\n            \u0027left\u0027: y,                              # distance to left edge\n            \u0027right\u0027: cols - 1 - y                  # distance to right edge\n        }\n        return min(distances, key=distances.get)\n\n    # Iterate over each pixel in the input grid\n    for x in range(rows):\n        for y in range(cols):\n            color = input_grid[x, y]\n            if color != Color.BLACK:  # Ignore background pixels\n                edge = nearest_edge(x, y)  # Get the nearest edge\n                if edge == \u0027top\u0027:\n                    draw_line(output_grid, x, y, length=None, color=color, direction=(0, -1))\n                elif edge == \u0027bottom\u0027:\n                    draw_line(output_grid, x, y, length=None, color=color, direction=(0, 1))\n                elif edge == \u0027left\u0027:\n                    draw_line(output_grid, x, y, length=None, color=color, direction=(-1, 0))\n                elif edge == \u0027right\u0027:\n                    draw_line(output_grid, x, y, length=None, color=color, direction=(1, 0))\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a random number of colors to use\n    colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(2, 6), replace=False)\n\n    # Scatter colored pixels across the grid\n    for color in colors:\n        grid = random_scatter_points(grid=grid, color=color, density=0.3)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/229/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/229/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/229/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/229/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/229/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/229/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/229/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/229/images/train_output_2.png"}]}, "index": 229, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# overlapping shapes, color blending\n\n# description:\n# In the input, you will see multiple colored shapes overlapping each other on a black background. \n# To create the output, blend the colors of the overlapping areas based on their transparency, \n# resulting in new colors where they intersect. Each shape has a specific transparency level that \n# determines how much it contributes to the final color in overlapping regions.\n\ndef main(input_grid):\n    # Step 1: Detect all connected components (shapes) in the input grid.\n    shapes = find_connected_components(input_grid, monochromatic=False)\n\n    # Initialize an output grid with black background.\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 2: For each shape, compute its blending contribution and apply it to the output grid.\n    for shape in shapes:\n        # Calculate the shape\u0027s bounding box and its transparency (for simplicity, we assume each shape has a fixed transparency level)\n        shape_color = shape[shape != Color.BLACK][0]  # Assume all pixels in shape are the same color\n        transparency = 0.5  # Example fixed transparency; adjust as needed.\n\n        # Blend this shape into the output grid\n        for x in range(input_grid.shape[0]):\n            for y in range(input_grid.shape[1]):\n                if shape[x, y] != Color.BLACK:\n                    # Calculate the blended color by averaging with existing color in output grid\n                    existing_color = output_grid[x, y]\n                    if existing_color == Color.BLACK:\n                        output_grid[x, y] = shape_color  # First shape, just set color\n                    else:\n                        # Simple blend: (color1 * alpha + color2 * (1 - alpha))\n                        output_grid[x, y] = blend_colors(existing_color, shape_color, transparency)\n\n    return output_grid\n\ndef blend_colors(color1, color2, alpha):\n    \"\"\" Blend two colors together based on the alpha transparency. \"\"\"\n    # Color blending logic (simple average in this example)\n    r1, g1, b1 = color_to_rgb(color1)\n    r2, g2, b2 = color_to_rgb(color2)\n    r_blended = int((r1 * alpha + r2 * (1 - alpha)) % 256)\n    g_blended = int((g1 * alpha + g2 * (1 - alpha)) % 256)\n    b_blended = int((b1 * alpha + b2 * (1 - alpha)) % 256)\n    return rgb_to_color(r_blended, g_blended, b_blended)\n\ndef color_to_rgb(color):\n    \"\"\" Convert a color to its RGB components. \"\"\"\n    # Dummy implementation for the sake of example; this should convert colors to RGB.\n    return (0, 0, 0)  # Replace with actual logic\n\ndef rgb_to_color(r, g, b):\n    \"\"\" Convert RGB components back to a color representation. \"\"\"\n    # Dummy implementation; this should convert RGB back to a color.\n    return Color.BLACK  # Replace with actual logic\n\ndef generate_input():\n    # Create a grid of random shapes with overlapping colors\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_shapes = np.random.randint(3, 6)  # Random number of shapes\n    for _ in range(num_shapes):\n        shape = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=Color.NOT_BLACK)\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n        blit_sprite(grid, shape, x, y, background=Color.BLACK)\n        \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/230/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/230/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/230/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/230/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/230/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/230/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/230/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/230/images/train_output_2.png"}]}, "index": 230, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, depth perception\n\n# description:\n# In the input, you will see a 2D grid with multiple layers represented by different colors. \n# To create the output, simulate depth perception by making the colors appear lighter or darker based on their \"depth\" in the stack\u2014 \n# colors that are \"closer\" will be brighter, while those further back will appear darker. \n# The top layer is the first row, and the bottom layer is the last row.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Calculate the number of rows in the grid\n    num_rows = input_grid.shape[0]\n    \n    # For each row, adjust the color based on its depth\n    for i in range(num_rows):\n        # Calculate the depth factor (0 for top layer, 1 for bottom layer)\n        depth_factor = i / (num_rows - 1)\n\n        # Iterate through each color in the row\n        for j in range(input_grid.shape[1]):\n            color = input_grid[i, j]\n            if color != Color.BLACK:  # Ignore background color\n                # Adjust the brightness based on depth factor\n                output_grid[i, j] = lighten_color(color, depth_factor)\n\n    return output_grid\n\ndef lighten_color(color, depth):\n    # Simulate the lightening of the color based on depth\n    # Define a mapping of colors to their RGB values for lightening\n    color_map = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.GREY: (128, 128, 128),\n        Color.PINK: (255, 192, 203),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.BLACK: (0, 0, 0)\n    }\n\n    # Get the RGB value of the color\n    rgb = np.array(color_map[color])\n    \n    # Lighten the color based on the depth factor\n    # The depth ranges from 0 (full color) to 1 (fully lightened)\n    lightened_rgb = (1 - depth) * rgb + depth * np.array([255, 255, 255])\n    \n    # Convert back to a color representation (nearest color)\n    for c, rgb_value in color_map.items():\n        if np.allclose(lightened_rgb, rgb_value, atol=50):  # Allow some tolerance for matching.\n            return c\n            \n    return color  # Fallback to original color if no match found\n\ndef generate_input():\n    # Create a grid with random layers of colors\n    n = 10  # Number of rows\n    m = 10  # Number of columns\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Randomly generate colors for each row\n    for i in range(n):\n        num_colors = np.random.randint(1, m + 1)  # Random number of colors in the row\n        colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)  # Choose colors without replacement\n        grid[i, :num_colors] = colors  # Fill the row with chosen colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/231/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/231/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/231/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/231/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/231/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/231/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/231/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/231/images/train_output_2.png"}]}, "index": 231, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, proximity, radial gradient\n\n# description:\n# In the input grid, you will see several colored pixels on a black background.\n# To create the output, blend the colors of the pixels into a radial gradient effect, where the color intensity decreases with distance from the colored pixels, fading into black.\n\ndef main(input_grid):\n    # Create an output grid initialized with black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Get the coordinates of all colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # For each colored pixel, draw a radial gradient\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        # Compute the distance to all points in the grid from the current colored pixel\n        for i in range(input_grid.shape[0]):\n            for j in range(input_grid.shape[1]):\n                distance = np.sqrt((x - i) ** 2 + (y - j) ** 2)\n                # Blend the color based on distance (closer pixels retain more color)\n                if output_grid[i, j] == Color.BLACK:\n                    output_grid[i, j] = color\n                else:\n                    # Create a simple blend (can be adjusted)\n                    existing_color = output_grid[i, j]\n                    # Blend logic: average the colors based on distance\n                    blended_color = blend_colors(existing_color, color, distance)\n                    output_grid[i, j] = blended_color\n\n    return output_grid\n\ndef blend_colors(color1, color2, distance):\n    # Simple blending logic based on distance; closer pixels retain more color\n    # Normalize distance for blending factor\n    max_distance = 10  # Set a maximum distance for blending (can be adjusted)\n    blend_factor = max(0, 1 - distance / max_distance)\n    # Blend the colors using a weighted average\n    return Color.RED if (color1 == Color.RED and color2 == Color.RED) else \\\n           Color.GREEN if (color1 == Color.GREEN and color2 == Color.GREEN) else \\\n           Color.BLUE if (color1 == Color.BLUE and color2 == Color.BLUE) else \\\n           Color.BLACK\n\ndef generate_input():\n    # Create a black grid\n    width, height = np.random.randint(10, 30, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Randomly place a number of colored pixels\n    num_pixels = np.random.randint(5, 15)\n    for _ in range(num_pixels):\n        color = np.random.choice(Color.NOT_BLACK)\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/232/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/232/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/232/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/232/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/232/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/232/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/232/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/232/images/train_output_2.png"}]}, "index": 232, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape stacking, color preservation\n\n# description:\n# In the input, you will see several colored shapes stacked vertically on a black grid. Each shape is a rectangle of a single color. The output grid should align all shapes to the same base level (the lowest point) by moving them down. The output grid should be the smallest possible size that contains all the shapes after their vertical alignment. Each shape should retain its original color.\n\ndef main(input_grid):\n    # Step 1: Detect the connected components (shapes) in the grid\n    shapes = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Step 2: Identify the lowest point of each shape\n    lowest_y_coords = []\n    for shape in shapes:\n        # Get the bounding box of the shape\n        _, _, _, height = bounding_box(shape)\n        lowest_y_coords.append(height - 1)  # Lowest y-coordinate is height - 1\n\n    # Step 3: Determine the lowest base level for all shapes\n    base_level = min(lowest_y_coords)\n\n    # Step 4: Create an output grid that can fit all shapes after alignment\n    output_grid_height = max(lowest_y_coords) + 1  # At least one row for the base level\n    output_grid_width = max(shape.shape[1] for shape in shapes)  # Maximum width of any shape\n    output_grid = np.full((output_grid_height, output_grid_width), Color.BLACK)\n\n    # Step 5: Align all shapes to the base level\n    for shape in shapes:\n        # Get the current bounding box of the shape\n        x, y, width, height = bounding_box(shape)\n\n        # Calculate the required translation to align with the base level\n        translation = base_level - (y + height - 1)\n\n        # Translate the shape down to the output grid\n        translated_shape = translate(shape, 0, translation)\n\n        # Blit the translated shape into the output grid\n        blit_object(output_grid, translated_shape)\n\n    # Step 6: Crop the output grid to the smallest size that contains all shapes\n    output_grid = crop(output_grid)\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with several randomly-sized colored rectangles stacked vertically\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a number of shapes\n    num_shapes = np.random.randint(3, 7)\n    for _ in range(num_shapes):\n        # Random dimensions for the shape\n        width = np.random.randint(1, 6)\n        height = np.random.randint(1, 6)\n\n        # Random color for the shape, avoiding black\n        color = np.random.choice(list(Color.NOT_BLACK))\n\n        # Create the colored rectangle shape\n        shape = np.full((height, width), color)\n\n        # Find a random free vertical position to place the shape\n        x, y = random_free_location_for_sprite(grid, shape)\n\n        # Blit the shape on the grid\n        blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/233/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/233/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/233/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/233/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/233/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/233/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/233/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/233/images/train_output_2.png"}]}, "index": 233, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid division, pattern duplication, color mapping\n\n# description:\n# In the input, you will see a grid that is divided into a checkerboard pattern of colored squares.\n# The top-left square contains a pattern, while the rest of the squares are filled with either the same color or black.\n# To create the output, you should duplicate the pattern from the top-left square to all other squares in the checkerboard pattern,\n# while maintaining the colors from the original grid, and keeping the black squares intact.\n\ndef main(input_grid):\n    # Get the pattern from the top-left square\n    top_left_pattern = crop(input_grid[:3, :3], background=Color.BLACK)\n    \n    # Create the output grid with the same shape as the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Determine the size of the checkerboard squares\n    size = 3  # Since we are working with 3x3 patterns in this example\n    \n    # Fill the output grid based on the checkerboard pattern\n    for i in range(0, output_grid.shape[0], size):\n        for j in range(0, output_grid.shape[1], size):\n            if (i // size + j // size) % 2 == 0:  # Check if the square is part of the checkerboard\n                blit_sprite(output_grid, top_left_pattern, x=i, y=j, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 9x9\n    n, m = 9, 9\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a pattern in the top-left 3x3 square\n    pattern = random_sprite(n=3, m=3, density=0.5, color_palette=list(Color.NOT_BLACK))\n    blit_sprite(grid, pattern, x=0, y=0)\n\n    # Fill the rest of the grid with a checkerboard pattern of colors\n    colors = list(Color.NOT_BLACK)  # Use all colors except black\n    for i in range(0, n, 3):\n        for j in range(0, m, 3):\n            if (i // 3 + j // 3) % 2 == 1:  # Fill only the black squares in checkerboard\n                color = np.random.choice(colors)\n                draw_line(grid, x=i, y=j, end_x=i + 3, end_y=j, color=color)\n                draw_line(grid, x=i, y=j + 3, end_x=i + 3, end_y=j + 3, color=color)\n                draw_line(grid, x=i, y=j, end_x=i, end_y=j + 3, color=color)\n                draw_line(grid, x=i + 3, y=j, end_x=i + 3, end_y=j + 3, color=color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/234/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/234/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/234/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/234/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/234/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/234/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/234/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/234/images/train_output_2.png"}]}, "index": 234, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color mirroring\n\n# description:\n# In the input you will see a shape with one color on the left side and a different color on the right side.\n# To produce the output, mirror the color from one side to the other, ensuring that the shape remains symmetrical in color.\n\ndef main(input_grid):\n    # Initialize the output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    rows, cols = output_grid.shape\n\n    # Loop through the left half of the grid\n    for x in range(rows):\n        for y in range(cols // 2):\n            left_color = output_grid[x, y]\n            # Mirror the left color to the right side of the grid\n            output_grid[x, cols - 1 - y] = left_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size with random colors\n    n = np.random.randint(5, 10)  # number of rows\n    m = np.random.randint(5, 10)  # number of columns\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random colors for left and right sides\n    left_color = np.random.choice(list(Color.NOT_BLACK))\n    right_color = np.random.choice([c for c in Color.NOT_BLACK if c != left_color])\n\n    # Fill the left half with the left color and the right half with the right color\n    for x in range(n):\n        for y in range(m):\n            if y \u003c m // 2:\n                grid[x, y] = left_color\n            else:\n                grid[x, y] = right_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/235/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/235/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/235/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/235/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/235/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/235/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/235/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/235/images/train_output_2.png"}]}, "index": 235, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color reflection\n\n# description:\n# In the input you will see a grid with a central pattern of colored pixels that is symmetrical along both the vertical and horizontal axes. \n# The output should be a new grid where the colors of the central pattern are reflected across both axes, while maintaining the same arrangement of colors.\n# The output grid will be equal in size to the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # The output grid is initialized as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the input grid\n    h, w = output_grid.shape\n\n    # Reflect the colors across both axes\n    for i in range(h):\n        for j in range(w):\n            # Reflect the color at (i, j) to its symmetric positions\n            output_grid[h - 1 - i, j] = input_grid[i, j]  # vertical reflection\n            output_grid[i, w - 1 - j] = input_grid[i, j]  # horizontal reflection\n\n    # Handle the center pixel in case of odd dimensions\n    if h % 2 == 1 and w % 2 == 1:\n        mid_x, mid_y = h // 2, w // 2\n        output_grid[mid_x, mid_y] = input_grid[mid_x, mid_y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the grid\n    h, w = np.random.randint(4, 8), np.random.randint(4, 8)\n\n    # Ensure the grid is even-sized to easily generate symmetrical patterns\n    if h % 2 != 0:\n        h += 1\n    if w % 2 != 0:\n        w += 1\n\n    # Create a grid filled with a background color (black)\n    grid = np.full((h, w), Color.BLACK)\n\n    # Define a set of colors for the pattern\n    colors = random.sample(Color.NOT_BLACK, k=4)\n\n    # Fill the central symmetrical pattern\n    center_x, center_y = h // 2, w // 2\n\n    # Create a symmetrical square pattern around the center\n    grid[center_x-1:center_x+1, center_y-1:center_y+1] = colors[0]  # Top-left \u0026 bottom-right\n    grid[center_x-1:center_x+1, center_y+1:center_y+2] = colors[1]  # Top-right\n    grid[center_x+1:center_x+2, center_y-1:center_y+1] = colors[2]  # Bottom-left\n    grid[center_x+1:center_x+2, center_y+1:center_y+2] = colors[3]  # Bottom-right\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/236/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/236/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/236/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/236/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/236/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/236/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/236/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/236/images/train_output_2.png"}]}, "index": 236, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape extraction, boundary detection, cropping\n\n# description:\n# In the input, you will see a grid containing multiple colored shapes surrounded by a black background. \n# Each shape is defined by a distinct color and has a unique boundary. \n# To create the output, you must extract the shape that has the largest area, cropping the grid to include only that shape.\n\ndef main(input_grid):\n    # Detect all colored shapes in the grid\n    shapes = detect_objects(grid=input_grid, background=Color.BLACK, monochromatic=False, connectivity=8)\n\n    # Find the largest shape by area\n    largest_shape = max(shapes, key=lambda shape: shape.size)\n\n    # Crop the grid to the bounding box of the largest shape\n    output_grid = crop(largest_shape, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid of size n x m\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Generate a random number of shapes (2-5)\n    num_shapes = np.random.randint(2, 6)\n\n    for _ in range(num_shapes):\n        # Create a random sprite shape with random dimensions (2-7) x (2-7)\n        width = np.random.randint(2, 8)\n        height = np.random.randint(2, 8)\n        color = np.random.choice(Color.NOT_BLACK)\n        sprite = random_sprite(width, height, color_palette=[color])\n\n        # Find a random free location to place the sprite\n        x, y = random_free_location_for_sprite(grid, sprite)\n\n        # Blit the sprite onto the grid\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/237/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/237/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/237/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/237/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/237/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/237/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/237/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/237/images/train_output_2.png"}]}, "index": 237, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, fill background\n\n# description:\n# In the input, you will see a colorful shape floating on a black background. \n# To make the output, rotate the shape 90 degrees counter-clockwise and fill the background with a contrasting color.\n\ndef main(input_grid):\n    # First, we need to crop the shape from the input grid\n    shape = crop(input_grid, background=Color.BLACK)\n\n    # Rotate the cropped shape 90 degrees counter-clockwise\n    rotated_shape = np.rot90(shape, k=1)\n\n    # Create a new output grid with the same dimensions as the rotated shape\n    output_grid = np.full(rotated_shape.shape, Color.BLACK, dtype=int)\n\n    # Fill the output grid with the rotated shape (it will be centered)\n    blit_object(output_grid, rotated_shape, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 12x12 filled with black\n    n, m = 12, 12\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a random sprite of size (3, 3) to (6, 6)\n    height = np.random.randint(3, 7)\n    width = np.random.randint(3, 7)\n    sprite = random_sprite(height, width, color_palette=Color.NOT_BLACK)\n\n    # Randomly place the sprite on the black grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/238/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/238/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/238/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/238/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/238/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/238/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/238/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/238/images/train_output_2.png"}]}, "index": 238, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, proximity effects\n\n# description:\n# In the input, you will see two colors of pixels: green and grey (the special colors). The task is to create an output grid where:\n# 1. For each green pixel, all adjacent (vertical and horizontal) pixels will turn light green.\n# 2. For each grey pixel, all diagonally adjacent pixels will turn light grey.\n# 3. If a pixel is affected by both green and grey, it should turn grey.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Create a temporary grid to track color changes\n    temp_grid = np.full_like(input_grid, Color.BLACK)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.GREEN:\n                # Turn adjacent pixels light green\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                        temp_grid[x + dx, y + dy] = Color.RED\n            elif color == Color.GREY:\n                # Turn diagonal pixels light grey\n                for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n                    if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                        temp_grid[x + dx, y + dy] = Color.GREEN\n\n    # Merge the effects into the output grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if temp_grid[x, y] == Color.RED and temp_grid[x, y] == Color.GREEN:\n                output_grid[x, y] = Color.GREY\n            elif temp_grid[x, y] == Color.RED:\n                output_grid[x, y] = Color.RED\n            elif temp_grid[x, y] == Color.GREEN:\n                output_grid[x, y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter green and grey pixels\n    num_green = np.random.randint(1, 5)\n    num_grey = np.random.randint(1, 5)\n\n    for _ in range(num_green):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.GREEN\n    \n    for _ in range(num_grey):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.GREY\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/239/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/239/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/239/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/239/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/239/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/239/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/239/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/239/images/train_output_2.png"}]}, "index": 239, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel clustering, color expansion\n\n# description:\n# In the input, you will see a grid filled with clusters of colored pixels. \n# To create the output, identify each cluster and replace it with a larger version of the same color (e.g., a 3x3 block of the same color) centered at the original cluster\u0027s centroid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the connected components (clusters) in the input grid\n    clusters = find_connected_components(input_grid, background=Color.BLACK)\n    \n    # Create a new output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for cluster in clusters:\n        # Get the coordinates of the cluster\u0027s pixels\n        coordinates = np.argwhere(cluster != Color.BLACK)\n        \n        # Calculate the centroid of the cluster\n        if len(coordinates) \u003e 0:\n            centroid_x = int(np.mean(coordinates[:, 0]))\n            centroid_y = int(np.mean(coordinates[:, 1]))\n\n            # Get the color of the cluster\n            cluster_color = cluster[centroid_x, centroid_y]\n\n            # Create a 3x3 block centered at the centroid\n            for dx in range(-1, 2):\n                for dy in range(-1, 2):\n                    output_grid[centroid_x + dx, centroid_y + dy] = cluster_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with random clusters of colored pixels\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a number of clusters\n    num_clusters = np.random.randint(3, 6)\n    colors = random.sample(Color.NOT_BLACK, num_clusters)\n\n    for color in colors:\n        # Randomly scatter points for each color\n        density = np.random.uniform(0.1, 0.5)  # Density of the cluster\n        cluster_size = np.random.randint(3, 6)  # Size of the cluster\n        cluster = random_sprite(cluster_size, cluster_size, density=density, color_palette=[color], background=Color.BLACK)\n        \n        # Find a free location to place the cluster\n        x, y = random_free_location_for_sprite(grid, cluster, padding=1, border_size=1)\n        blit_sprite(grid, cluster, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/240/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/240/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/240/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/240/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/240/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/240/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/240/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/240/images/train_output_2.png"}]}, "index": 240, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# vertical symmetry, color inversion\n\n# description:\n# In the input, you will see a grid with a vertical axis of symmetry, where one side is colored and the other side is mostly black. \n# To make the output, invert the colors on the black side to reflect the colors of the colored side, completing the symmetry.\n\ndef main(input_grid):\n    # Get the width of the grid\n    height, width = input_grid.shape\n    \n    # Split the grid into left and right halves\n    left_half = input_grid[:, :width // 2]\n    right_half = input_grid[:, width // 2:]\n    \n    # Create an output grid that is a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Invert colors on the black side (the right half)\n    for i in range(height):\n        for j in range(width // 2, width):\n            if right_half[i, j - width // 2] == Color.BLACK:\n                output_grid[i, j] = left_half[i, width // 2 - (j - width // 2) - 1]\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of random height and a width that is even\n    height = np.random.randint(3, 6)\n    width = np.random.randint(4, 8) * 2  # Ensure width is even\n    grid = np.zeros((height, width), dtype=int)\n    \n    # Create a random pattern on the left half and fill the right half with black\n    left_half = random_sprite(n=height, m=width // 2, density=0.5, color_palette=Color.NOT_BLACK)\n    grid[:, :width // 2] = left_half\n    grid[:, width // 2:] = Color.BLACK  # Fill right half with black\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/241/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/241/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/241/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/241/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/241/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/241/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/241/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/241/images/train_output_2.png"}]}, "index": 241, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shadowing, light source, color mapping\n\n# description:\n# In the input grid, you will see a colored object and a light source pixel indicated by a different color. \n# To make the output, cast a shadow of the object in the opposite direction of the light source by coloring the affected area in black. \n# The shadow extends until it reaches the edge of the grid or the boundary of the object.\n\ndef main(input_grid):\n    # Step 1: Identify the light source and the colored object\n    light_source_locations = np.argwhere(input_grid == Color.YELLOW)  # Assume the light source is always yellow\n    assert len(light_source_locations) == 1, \"There must be exactly one light source.\"\n    \n    light_x, light_y = light_source_locations[0]\n    \n    # Step 2: Find the colored object (not black and not the light source)\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n    colored_objects = [obj for obj in objects if np.any(obj != Color.BLACK) and np.any(obj != Color.YELLOW)]\n    \n    assert colored_objects, \"There must be at least one colored object.\"\n    colored_object = max(colored_objects, key=lambda o: np.count_nonzero(o))  # Find the largest object\n    \n    # Step 3: Get the color of the object\n    object_color = colored_object[colored_object != Color.BLACK][0]\n\n    # Step 4: Calculate shadow direction based on light source position\n    shadow_direction = (0, 0)\n    if light_x \u003c np.where(input_grid != Color.BLACK)[0].min():  # Light is to the left\n        shadow_direction = (1, 0)  # Shadow extends right\n    elif light_x \u003e np.where(input_grid != Color.BLACK)[0].max():  # Light is to the right\n        shadow_direction = (-1, 0)  # Shadow extends left\n    elif light_y \u003c np.where(input_grid != Color.BLACK)[1].min():  # Light is above\n        shadow_direction = (0, 1)  # Shadow extends down\n    elif light_y \u003e np.where(input_grid != Color.BLACK)[1].max():  # Light is below\n        shadow_direction = (0, -1)  # Shadow extends up\n\n    # Step 5: Cast the shadow in the opposite direction of the light source\n    output_grid = input_grid.copy()\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] == object_color:\n                # Extend shadow in the determined direction\n                draw_line(output_grid, x, y, direction=shadow_direction, color=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Choose colors for the object and the light source\n    object_color, light_color = np.random.choice(list(Color.NOT_BLACK), 2, replace=False)\n\n    # Create a random object (colored shape)\n    object_shape = random_sprite(5, 5, density=0.5, color_palette=[object_color])\n    blit_sprite(input_grid, object_shape, x=7, y=7)\n\n    # Place the light source in a random position, making sure it\u0027s not on the object\n    while True:\n        light_x, light_y = np.random.randint(20), np.random.randint(20)\n        if input_grid[light_x, light_y] == Color.BLACK:\n            input_grid[light_x, light_y] = Color.YELLOW  # Place light source\n            break\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/242/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/242/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/242/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/242/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/242/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/242/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/242/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/242/images/train_output_2.png"}]}, "index": 242, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection\n\n# description:\n# In the input, you will see a grid with colored pixels and a special color (e.g., yellow) that signifies a reflective axis. To create the output grid, reflect all colored pixels across the yellow line. The yellow line can be horizontal or vertical, depending on the placement of the yellow pixels.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    \n    # Find the indices of the yellow pixels that will serve as the reflective axis\n    yellow_pixels = np.argwhere(input_grid == Color.YELLOW)\n\n    # Check if yellow pixels create a horizontal or vertical reflective line\n    if yellow_pixels.size \u003e 0:\n        # Determine if the yellow line is horizontal or vertical\n        unique_rows = np.unique(yellow_pixels[:, 0])\n        unique_cols = np.unique(yellow_pixels[:, 1])\n        \n        if len(unique_rows) == 1:  # Horizontal line\n            row = unique_rows[0]\n            for col in range(input_grid.shape[1]):\n                if input_grid[row, col] != Color.BLACK and input_grid[row, col] != Color.YELLOW:\n                    # Reflect the pixel across the yellow line\n                    output_grid[input_grid.shape[0] - 1 - row, col] = input_grid[row, col]\n        \n        elif len(unique_cols) == 1:  # Vertical line\n            col = unique_cols[0]\n            for row in range(input_grid.shape[0]):\n                if input_grid[row, col] != Color.BLACK and input_grid[row, col] != Color.YELLOW:\n                    # Reflect the pixel across the yellow line\n                    output_grid[row, input_grid.shape[1] - 1 - col] = input_grid[row, col]\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m with random colors and a reflective yellow line\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide if the reflective line will be horizontal or vertical\n    is_horizontal = np.random.choice([True, False])\n    \n    # Choose a random row or column for the yellow line\n    if is_horizontal:\n        row = np.random.randint(1, n - 1)  # Avoid edges\n        grid[row, :] = Color.YELLOW  # Set the entire row to yellow\n    else:\n        col = np.random.randint(1, m - 1)  # Avoid edges\n        grid[:, col] = Color.YELLOW  # Set the entire column to yellow\n\n    # Scatter random colored pixels in the grid (excluding yellow)\n    for _ in range(np.random.randint(5, 15)):\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.YELLOW])\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/243/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/243/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/243/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/243/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/243/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/243/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/243/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/243/images/train_output_2.png"}]}, "index": 243, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color fill\n\n# description:\n# In the input, you will see a pattern that has mirror symmetry along the vertical axis. \n# To produce the output, fill in the missing colors on one side to match the corresponding colors on the other side, \n# ensuring the output maintains the vertical symmetry.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Get the number of columns in the grid\n    num_cols = input_grid.shape[1]\n\n    # Iterate over each row to fill in the colors\n    for row in range(input_grid.shape[0]):\n        for col in range(num_cols // 2):\n            # Get the corresponding column on the opposite side\n            opposite_col = num_cols - col - 1\n            \n            # If the left side (col) has a color and the right side (opposite_col) is empty (background)\n            if input_grid[row, col] != Color.BLACK and output_grid[row, opposite_col] == Color.BLACK:\n                output_grid[row, opposite_col] = input_grid[row, col]\n            # If the right side has a color and the left side is empty\n            elif input_grid[row, opposite_col] != Color.BLACK and output_grid[row, col] == Color.BLACK:\n                output_grid[row, col] = input_grid[row, opposite_col]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a vertical symmetry pattern\n    n = np.random.randint(3, 7)  # Height of the grid\n    m = np.random.randint(5, 11)  # Width of the grid\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a vertical symmetry pattern\n    for row in range(n):\n        for col in range(m // 2):\n            color = np.random.choice(Color.NOT_BLACK)  # Choose a random color\n            grid[row, col] = color\n            \n            # Mirror the color to the opposite side\n            grid[row, m - col - 1] = color if np.random.rand() \u003e 0.5 else Color.BLACK\n\n    # Randomly fill in some black pixels to create the need for filling\n    for _ in range(np.random.randint(1, 5)):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/244/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/244/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/244/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/244/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/244/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/244/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/244/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/244/images/train_output_2.png"}]}, "index": 244, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# overlapping shapes, color merging\n\n# description:\n# In the input, you will see multiple overlapping shapes of various colors. To make the output, \n# detect the areas where these shapes overlap and color those regions with a new color (purple). \n# Leave all other areas unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Get the unique colors in the input grid, excluding the background color\n    unique_colors = np.unique(input_grid[input_grid != Color.BLACK])\n    \n    # Create a mask to identify overlapping pixels\n    overlap_mask = np.zeros(input_grid.shape, dtype=bool)\n\n    # For each unique color, check where they overlap\n    for color in unique_colors:\n        # Create a mask for the current color\n        color_mask = (input_grid == color)\n        # Update the overlap mask\n        overlap_mask |= color_mask\n\n    # Set all overlapping pixels to purple\n    output_grid[overlap_mask] = Color.PINK  # Using PINK to denote overlap (as per problem statement)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly decide the number of shapes to generate\n    num_shapes = np.random.randint(3, 7)\n    \n    for _ in range(num_shapes):\n        # Generate a random shape (sprite) with colors other than black\n        shape = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=Color.NOT_BLACK)\n        \n        # Find a random free location to place the shape on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, shape)\n            blit_sprite(grid, shape, x=x, y=y)\n        except:\n            # If there is no free location, skip placing this shape\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/245/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/245/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/245/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/245/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/245/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/245/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/245/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/245/images/train_output_2.png"}]}, "index": 245, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, shape centering, background filling\n\n# description:\n# In the input, you will see a grid with a single colored shape surrounded by random black pixels.\n# To produce the output, extract the colored shape, center it in a new grid, and fill the remaining space with black pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Crop the shape from the input grid\n    cropped_shape = crop(input_grid, background=Color.BLACK)\n\n    # Step 2: Create a new output grid filled with black\n    output_size = max(cropped_shape.shape) + 2  # Add some padding\n    output_grid = np.zeros((output_size, output_size), dtype=int)\n\n    # Step 3: Calculate the position to center the cropped shape in the new grid\n    start_x = (output_size - cropped_shape.shape[0]) // 2\n    start_y = (output_size - cropped_shape.shape[1]) // 2\n\n    # Step 4: Blit the cropped shape into the center of the new grid\n    output_grid = blit_sprite(output_grid, cropped_shape, x=start_x, y=start_y)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly determine the size of the shape\n    n, m = random.randint(3, 10), random.randint(3, 10)\n\n    # Generate a random shape with a specific color\n    shape_color = random.choice(Color.NOT_BLACK)\n    shape = random_sprite(n, m, color_palette=[shape_color], density=0.4)\n\n    # Create a grid large enough to accommodate the shape and surrounding black pixels\n    grid_width, grid_height = random.randint(n + 6, 2 * n + 2), random.randint(m + 6, 2 * m + 2)\n    grid = np.zeros((grid_width, grid_height), dtype=int)\n\n    # Place the shape in the grid at a random position with enough space around it\n    pos_x = random.randint(2, grid_width - n - 4)\n    pos_y = random.randint(2, grid_height - m - 4)\n    grid = blit_sprite(grid, shape, x=pos_x, y=pos_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/246/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/246/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/246/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/246/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/246/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/246/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/246/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/246/images/train_output_2.png"}]}, "index": 246, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry folding, color reflection\n\n# description:\n# In the input, you will see a grid with a pattern that is symmetrical along one axis. \n# To create the output, reflect the pattern across the axis of symmetry, coloring the newly added pixels to match the original pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Determine the size of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid that is double the width of the input grid\n    output_grid = np.zeros((n, m * 2), dtype=int)\n\n    # Copy the original pattern to the left side of the output grid\n    output_grid[:, :m] = input_grid\n\n    # Reflect the pattern and fill the right side of the output grid\n    output_grid[:, m:] = input_grid[:, ::-1]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the grid\n    n = np.random.randint(3, 6)  # Number of rows\n    m = np.random.randint(3, 6)  # Number of columns\n\n    # Create a grid with a black background\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a color from the color palette (excluding black)\n    chosen_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the grid to ensure symmetry along the vertical axis\n    for i in range(n):\n        for j in range(m // 2):\n            if np.random.rand() \u003c 0.5:  # Randomly decide to color or not\n                grid[i, j] = chosen_color\n                grid[i, m - j - 1] = chosen_color  # Make it symmetrical\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/247/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/247/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/247/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/247/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/247/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/247/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/247/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/247/images/train_output_2.png"}]}, "index": 247, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object boundaries, color distinction, transformation\n\n# description:\n# In the input, you will see two distinct colored regions (yellow and green) that are surrounded by a black background.\n# The goal is to produce an output grid where each colored region is surrounded by a thick black border to clearly separate them visually.\n# The colored regions should retain their original colors.\n\ndef main(input_grid):\n    # Create an output grid initialized to the same background\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components (regions) in the input grid\n    colored_regions = find_connected_components(grid=input_grid, monochromatic=False, connectivity=4, background=Color.BLACK)\n\n    # For each colored region, draw a thick black border around it\n    for region in colored_regions:\n        # Get the bounding box of the colored region\n        x, y, width, height = bounding_box(region, background=Color.BLACK)\n\n        # Draw a thick black border around the region\n        for dx in range(-1, 2):  # -1, 0, 1 for width\n            for dy in range(-1, 2):  # -1, 0, 1 for height\n                if (dx == -1 or dx == 1 or dy == -1 or dy == 1):  # Only draw on the outer border\n                    draw_line(output_grid, x + dx, y + dy, length=width + 2, direction=(1, 0), color=Color.BLACK)\n                    draw_line(output_grid, x + dx, y + dy, length=height + 2, direction=(0, 1), color=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size between 10x10 and 20x20\n    grid_len = np.random.randint(10, 20)\n    n, m = grid_len, grid_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create two distinct regions of different colors (yellow and green)\n    for color in [Color.YELLOW, Color.GREEN]:\n        # Randomly determine the size of the region\n        width, height = np.random.randint(2, 6), np.random.randint(2, 6)\n\n        # Find a random location to draw this region\n        x, y = random_free_location_for_sprite(grid, np.full((width, height), color), background=Color.BLACK, padding=1)\n\n        # Blit the colored region into the grid\n        blit_sprite(grid, np.full((width, height), color), x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/248/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/248/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/248/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/248/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/248/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/248/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/248/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/248/images/train_output_2.png"}]}, "index": 248, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape extraction, color transformation, border enhancement\n\n# description:\n# In the input, you will see various colored shapes on a maroon background. Each shape is made of connected pixels of the same color. \n# To create the output, you should replace each shape with its color and add a thick border of black pixels around it.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color\n    output_grid = np.full_like(input_grid, fill_value=Color.BLACK)\n\n    # Identify the background color (which is assumed to be maroon here)\n    background_color = Color.MAROON\n\n    # Find all connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, background=background_color, connectivity=4, monochromatic=False)\n\n    # For each shape, determine its color and place it into the output grid with a black border\n    for shape in shapes:\n        # Determine the color of the shape (it should be monochromatic)\n        unique_colors = np.unique(shape)\n        # Filter out the background color\n        shape_color = unique_colors[unique_colors != background_color][0]\n\n        # Get the bounding box of the shape\n        x, y, width, height = bounding_box(shape, background=background_color)\n\n        # Place the shape color on the output grid\n        blit_object(output_grid, shape, background=Color.BLACK)\n\n        # Draw a black border around the shape\n        for i in range(x - 1, x + height + 1):\n            for j in range(y - 1, y + width + 1):\n                if output_grid[i, j] == background_color:\n                    output_grid[i, j] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a maroon background\n    width, height = np.random.randint(10, 20, size=2)\n    input_grid = np.full((width, height), fill_value=Color.MAROON)\n\n    # Randomly decide how many shapes to create\n    num_shapes = np.random.randint(3, 6)\n\n    for _ in range(num_shapes):\n        # Randomly generate shape dimensions\n        shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a shape sprite\n        shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=1)\n\n        # Find a random free location for the shape\n        x, y = random_free_location_for_sprite(input_grid, shape_sprite, background=Color.MAROON, padding=1)\n\n        # Blit the shape onto the grid\n        blit_sprite(input_grid, shape_sprite, x, y, background=Color.MAROON)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/249/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/249/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/249/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/249/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/249/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/249/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/249/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/249/images/train_output_2.png"}]}, "index": 249, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel clustering, color replacement, background manipulation\n\n# description:\n# In the input, you will see clusters of colored pixels on a black background. \n# To make the output, for each cluster of connected pixels of the same color, \n# replace the color of that cluster with a specified target color (for example, Color.YELLOW). \n# The background remains black.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find connected components of colored pixels.\n    # 2. Replace each cluster\u0027s color with the specified target color.\n    \n    target_color = Color.YELLOW  # The color we want to replace clusters with.\n    \n    # Find all connected components (clusters) in the input grid\n    clusters = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Replace the color of each cluster with the target color\n    for cluster in clusters:\n        # Get the color of the current cluster (should be the same for all pixels in the cluster)\n        cluster_color = cluster[0, 0]\n        # Color the entire cluster with the target color in the output grid\n        for x, y in np.argwhere(cluster != Color.BLACK):\n            output_grid[x, y] = target_color\n\n    return output_grid\n\ndef generate_input():\n    # Plan:\n    # 1. Create a black grid for the background.\n    # 2. Randomly generate clusters of colored pixels (not black).\n    # 3. Ensure that clusters are distinct and connected.\n\n    n, m = np.random.randint(5, 20, size=2)  # Dimensions of the grid\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Randomly generate a number of clusters\n    num_clusters = np.random.randint(1, 5)  # Number of color clusters (1 to 4)\n    for _ in range(num_clusters):\n        # Randomly choose a color for the cluster (cannot be black)\n        cluster_color = np.random.choice(Color.NOT_BLACK)\n        # Randomly choose a size for the cluster\n        cluster_size = np.random.randint(3, 10)  # Size of the cluster\n        \n        # Randomly choose a starting point for the cluster\n        start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n        # Create a cluster using a random walk or spreading method\n        cluster_points = [(start_x, start_y)]\n        for _ in range(cluster_size):\n            if cluster_points:\n                x, y = cluster_points[np.random.randint(len(cluster_points))]\n                # Attempt to spread to adjacent cells\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:  # Up, Down, Left, Right\n                    nx, ny = x + dx, y + dy\n                    if 0 \u003c= nx \u003c n and 0 \u003c= ny \u003c m and grid[nx, ny] == Color.BLACK:\n                        grid[nx, ny] = cluster_color  # Color the pixel\n                        cluster_points.append((nx, ny))  # Add to cluster points\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/250/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/250/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/250/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/250/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/250/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/250/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/250/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/250/images/train_output_2.png"}]}, "index": 250, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, radial gradient effect\n\n# description:\n# In the input, you will see a small grid with a solid color at its center. \n# To create the output, scale the grid up by a factor of 4, \n# and apply a radial gradient effect that transitions from the original color at the center \n# to a new color (e.g., from red to yellow) as it moves outward.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the center color of the input grid.\n    # 2. Scale the grid up by a factor of 4.\n    # 3. Create a radial gradient effect from the center color to a new color.\n    \n    # Get the center color from the input grid\n    center_color = input_grid[input_grid.shape[0] // 2, input_grid.shape[1] // 2]\n\n    # Define the new color for the radial gradient (example: yellow)\n    new_color = Color.YELLOW\n\n    # Scale the input grid by 4\n    output_grid = scale_pattern(pattern=input_grid, scale_factor=4)\n\n    # Get the dimensions of the scaled output grid\n    height, width = output_grid.shape\n\n    # Calculate the center of the output grid\n    center_x, center_y = height // 2, width // 2\n\n    # Apply radial gradient effect\n    for y in range(height):\n        for x in range(width):\n            # Calculate the distance from the center\n            distance = np.sqrt((x - center_x)**2 + (y - center_y)**2)\n            max_distance = np.sqrt(2) * (max(center_x, center_y))  # Max distance to the corners\n\n            # Calculate the ratio for blending colors\n            ratio = distance / max_distance\n            ratio = min(max(ratio, 0), 1)  # Clamp to [0, 1]\n\n            # Interpolate between the center color and the new color\n            blended_color = blend_colors(center_color, new_color, ratio)\n            output_grid[y, x] = blended_color\n\n    return output_grid\n\ndef blend_colors(color1, color2, ratio):\n    # Simple linear interpolation between two colors\n    return Color.RED if ratio \u003c 0.5 else Color.YELLOW  # Replace with actual blending logic\n\ndef generate_input():\n    # Generate a 5x5 grid with a solid color in the center\n    grid_size = 5\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Set the center pixel to a random color\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n    grid[grid_size // 2, grid_size // 2] = center_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/251/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/251/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/251/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/251/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/251/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/251/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/251/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/251/images/train_output_2.png"}]}, "index": 251, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, color tracking, shape extraction\n\n# description:\n# In the input, you will see multiple layers of colored shapes on a transparent background. \n# To produce the output, track the color of the bottommost layer and apply that color to the entire canvas, \n# effectively painting over the previous layers while maintaining their shapes.\n\ndef main(input_grid):\n    # Create a copy of the input grid to serve as the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the bottommost colored shape (the one that is not black)\n    layers = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # The bottommost layer is the last one in the list since they were added in order\n    bottommost_layer = layers[-1]\n\n    # Get the color of the bottommost layer (the first color found)\n    color_of_bottommost = bottommost_layer[bottommost_layer != Color.BLACK][0]\n\n    # Apply the color of the bottommost layer to the entire canvas\n    output_grid[output_grid != Color.BLACK] = color_of_bottommost\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black background grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Create a number of layers (shapes) to add to the grid\n    for _ in range(np.random.randint(2, 5)):  # Randomly create between 2 to 4 layers\n        # Create a random shape (sprite) of random size\n        width, height = np.random.randint(2, 6, size=2)\n        color = np.random.choice(list(Color.NOT_BLACK))  # Choose a random color that is not black\n        shape_sprite = random_sprite(width, height, density=0.5, color_palette=[color])\n\n        # Find a random free location for the sprite\n        x, y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK, border_size=1)\n        \n        # Blit the shape onto the grid\n        blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/252/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/252/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/252/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/252/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/252/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/252/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/252/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/252/images/train_output_2.png"}]}, "index": 252, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color cycling, grid filling\n\n# description:\n# In the input, you will see a sequence of colored pixels in a single row and a gray rectangle beneath it. \n# To create the output, fill the gray rectangle with colors from the input row, alternating between the colors based on their index. \n# The first color in the input row will fill the first row of the gray rectangle, the second color will fill the second row, and so on. \n# If the rectangle is taller than the number of colors, continue cycling through the colors.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the colors from the top row\n    colors = input_grid[0, :]\n    num_colors = len(colors)\n\n    # Get the y-coordinate of the gray rectangle\n    gray_rectangle_y = np.where(input_grid[1] == Color.GRAY)[0][0]\n\n    # Fill the gray rectangle with colors from the input\n    for i in range(output_grid.shape[0] - gray_rectangle_y - 1):\n        color_index = i % num_colors\n        draw_line(output_grid, 0, gray_rectangle_y + i + 1, length=None, color=colors[color_index], direction=(1, 0))\n\n    return output_grid\n\n\ndef generate_input():\n    # Decide how many colors to use\n    num_colors = np.random.randint(2, 6)\n\n    # Select colors for the sequence\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    # Create a grid with space for the colors and a gray rectangle below it\n    n = 2 + 3 * num_colors  # Height will be 2 rows (1 for colors, 1 for gray rectangle) + some extra for filling\n    m = num_colors  # Width is equal to the number of colors\n    grid = np.zeros((n, m), dtype=int)\n\n    # Put the colors in the top row\n    grid[0, :] = colors\n\n    # Create a gray rectangle in the second row\n    grid[1, :] = Color.GRAY\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/253/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/253/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/253/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/253/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/253/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/253/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/253/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/253/images/train_output_2.png"}]}, "index": 253, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, expansion, centered transformation\n\n# description:\n# In the input, you will see a single colored pixel surrounded by a black background. To make the output grid, \n# expand the pixel into a 3x3 square, filling the square with the same color as the original pixel, while keeping \n# the surrounding area black.\n\ndef main(input_grid):\n    # Find the single colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    colored_pixel_location = colored_pixel_locations[0]\n    colored_x, colored_y = colored_pixel_location\n\n    # Create the output grid, initially filled with black\n    output_grid = np.zeros_like(input_grid)\n\n    # Expand the pixel into a 3x3 square\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            output_grid[colored_x + dx, colored_y + dy] = input_grid[colored_x, colored_y]\n\n    return output_grid\n\ndef generate_input():\n    # Make a grid with a random background color (black) and one colored pixel\n    width, height = np.random.randint(3, 20, size=2)\n    input_grid = np.zeros((width, height), dtype=int)  # Initialize with black color\n\n    # Randomly select a color from Color.NOT_BLACK\n    colored_pixel = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly choose a location for the colored pixel, ensuring it\u0027s not on the border\n    x = np.random.randint(1, width - 1)\n    y = np.random.randint(1, height - 1)\n    \n    input_grid[x, y] = colored_pixel\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/254/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/254/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/254/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/254/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/254/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/254/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/254/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/254/images/train_output_2.png"}]}, "index": 254, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel expansion, color blending, distance calculation\n\n# description:\n# In the input, you will see a grid with several colored pixels scattered around. \n# To make the output, expand each colored pixel by one pixel in all directions, blending the new pixels into the color of the nearest existing pixel.\n# If two colors are equidistant, the new pixel becomes a blend of both colors.\n\ndef blend_colors(color1, color2):\n    # Simple color blending function (could be more complex if needed)\n    if color1 == color2:\n        return color1\n    return Color.GREY  # For simplicity, blend into grey for now\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    rows, cols = input_grid.shape\n\n    for x in range(rows):\n        for y in range(cols):\n            if input_grid[x, y] != Color.BLACK:  # If it\u0027s a colored pixel\n                # Expand to surrounding pixels\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if dx == 0 and dy == 0:\n                            continue  # Skip the original pixel\n                        nx, ny = x + dx, y + dy\n                        if 0 \u003c= nx \u003c rows and 0 \u003c= ny \u003c cols:\n                            if output_grid[nx, ny] == Color.BLACK:  # Only modify if it\u0027s black\n                                # Determine the nearest color\n                                nearest_color = input_grid[x, y]\n                                # Check surrounding pixels to see if they are closer\n                                for ddx in [-1, 0, 1]:\n                                    for ddy in [-1, 0, 1]:\n                                        if ddx == 0 and ddy == 0:\n                                            continue  # Skip the original pixel\n                                        nnx, nny = x + ddx, y + ddy\n                                        if 0 \u003c= nnx \u003c rows and 0 \u003c= nny \u003c cols:\n                                            if output_grid[nnx, nny] != Color.BLACK:\n                                                nearest_color = blend_colors(nearest_color, output_grid[nnx, nny])\n                                output_grid[nx, ny] = nearest_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    num_colors = np.random.randint(5, 15)\n\n    for _ in range(num_colors):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice([color for color in Color.NOT_BLACK])\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/255/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/255/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/255/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/255/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/255/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/255/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/255/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/255/images/train_output_2.png"}]}, "index": 255, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, transparency, overlapping shapes\n\n# description:\n# In the input, you will see two overlapping colored rectangles on a black background. \n# To make the output, compute the resulting color at the intersection of the two rectangles by blending the colors based on their opacities (50% opacity for each rectangle), \n# and retain the original rectangle colors in the rest of the area.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the input grid\n    rectangles = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Separate the rectangles from the background\n    colored_rectangles = [rect for rect in rectangles if np.count_nonzero(rect != Color.BLACK) \u003e 0]\n    \n    # If we don\u0027t have exactly two rectangles, return the output grid as is\n    if len(colored_rectangles) != 2:\n        return output_grid\n\n    # Get the colors of both rectangles\n    color1 = colored_rectangles[0][0, 0]  # Color of the first rectangle\n    color2 = colored_rectangles[1][0, 0]  # Color of the second rectangle\n\n    # Create a mask for the overlapping area\n    overlap_mask = (output_grid != Color.BLACK) \u0026 (np.roll(output_grid, 1, axis=0) != Color.BLACK)  # Check for overlap in the rectangles\n\n    # Blend the overlapping areas\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            if overlap_mask[x, y]:\n                # Blend colors using 50% opacity for each color\n                blended_color = blend_colors(color1, color2)\n                output_grid[x, y] = blended_color\n\n    return output_grid\n\ndef blend_colors(color1, color2):\n    # A simple blending function that averages the RGB values of two colors\n    # Assuming colors are represented as integers, we will convert them to RGB values for blending.\n    color_map = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.PINK: (255, 192, 203),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.GREY: (128, 128, 128),\n        Color.BLACK: (0, 0, 0),\n    }\n    \n    r1, g1, b1 = color_map[color1]\n    r2, g2, b2 = color_map[color2]\n    \n    # Blend colors\n    blended_r = (r1 + r2) // 2\n    blended_g = (g1 + g2) // 2\n    blended_b = (b1 + b2) // 2\n    \n    # Find the nearest color\n    blended_color = min(color_map.keys(), key=lambda c: (blended_r - color_map[c][0])**2 + (blended_g - color_map[c][1])**2 + (blended_b - color_map[c][2])**2)\n    return blended_color\n\ndef generate_input():\n    # Create a black grid for the background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate two different colored rectangles\n    color1, color2 = np.random.choice(list(Color.NOT_BLACK), size=2, replace=False)\n    \n    # Randomize sizes and positions of the rectangles\n    rect1_width, rect1_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    rect2_width, rect2_height = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    # Draw first rectangle\n    rect1 = random_sprite(rect1_width, rect1_height, color_palette=[color1], density=1)\n    rect1_x, rect1_y = random_free_location_for_sprite(grid, rect1, background=Color.BLACK)\n    blit_sprite(grid, rect1, x=rect1_x, y=rect1_y, background=Color.BLACK)\n\n    # Draw second rectangle\n    rect2 = random_sprite(rect2_width, rect2_height, color_palette=[color2], density=1)\n    rect2_x, rect2_y = random_free_location_for_sprite(grid, rect2, background=Color.BLACK)\n    blit_sprite(grid, rect2, x=rect2_x, y=rect2_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/256/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/256/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/256/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/256/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/256/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/256/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/256/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/256/images/train_output_2.png"}]}, "index": 256, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, transparency effects, color blending\n\n# description:\n# In the input, you will see multiple layers of colored shapes with varying transparency levels.\n# To make the output, blend the colors of the layers based on their transparency to create a visually cohesive new image,\n# where overlapping areas show the blended colors.\n\ndef main(input_grid):\n    # Create an output grid filled with black (transparent background)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find the connected components in the input grid\n    layers = find_connected_components(input_grid, monochromatic=False)\n\n    # For each layer, determine its transparency and color and blend it into the output grid\n    for layer in layers:\n        # Get the non-black pixels of the layer\n        non_black_pixels = layer[layer != Color.BLACK]\n        if non_black_pixels.size == 0:\n            continue\n\n        # Assume the first color in the layer is the color for blending; the rest are ignored for simplicity\n        color = non_black_pixels[0]\n        \n        # Determine the transparency based on the number of black pixels surrounding it\n        transparency = np.count_nonzero(layer == Color.BLACK) / layer.size\n\n        # Blend the color into the output grid based on its transparency\n        for x in range(layer.shape[0]):\n            for y in range(layer.shape[1]):\n                if layer[x, y] != Color.BLACK:\n                    # Calculate the blend based on transparency\n                    if output_grid[x, y] == Color.BLACK:\n                        output_grid[x, y] = color  # If the output is transparent, place the color\n                    else:\n                        # Simple blend: average the color with existing color in the output grid\n                        existing_color = output_grid[x, y]\n                        blended_color = blend_colors(existing_color, color, transparency)\n                        output_grid[x, y] = blended_color\n\n    return output_grid\n\ndef blend_colors(color1, color2, transparency):\n    \"\"\"\n    Blend two colors based on a transparency factor.\n    A straightforward averaging for blending purposes.\n    \"\"\"\n    return color1 if transparency == 0 else color2 if transparency == 1 else average_colors(color1, color2)\n\ndef average_colors(color1, color2):\n    \"\"\"\n    Average two colors (represented by integers) by using a simple average.\n    Assuming colors are encoded as integers.\n    \"\"\"\n    return (color1 + color2) // 2\n\ndef generate_input():\n    # Create a random grid with overlapping transparent layers\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Number of layers\n    num_layers = np.random.randint(3, 6)\n\n    for _ in range(num_layers):\n        # Create a random size for the layer\n        layer_width, layer_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        layer = random_sprite(layer_width, layer_height, color_palette=Color.NOT_BLACK, density=0.5)\n\n        # Randomly determine transparency (0 = opaque, 1 = fully transparent)\n        transparency = np.random.uniform(0, 1)\n\n        # Place the layer randomly on the grid\n        x, y = random_free_location_for_sprite(grid, layer, padding=1)\n        blit_sprite(grid, layer, x, y)\n\n        # Apply transparency to layer: set pixels to black based on transparency\n        for i in range(layer.shape[0]):\n            for j in range(layer.shape[1]):\n                if layer[i, j] != Color.BLACK and np.random.rand() \u003c transparency:\n                    layer[i, j] = Color.BLACK  # Make it transparent by setting to black\n\n        # Place the modified layer back to the grid\n        blit_sprite(grid, layer, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/257/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/257/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/257/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/257/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/257/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/257/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/257/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/257/images/train_output_2.png"}]}, "index": 257, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, mirroring\n\n# description:\n# In the input grid, you will see a colorful pattern on one side of the grid. \n# To generate the output, create a mirrored version of the pattern on the opposite side of the grid, \n# maintaining the same colors and shape.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid with the same number of rows but double the number of columns\n    output_grid = np.zeros((n, m * 2), dtype=int)\n    \n    # Fill the left side of the output grid with the input grid\n    output_grid[:, :m] = input_grid\n    \n    # Fill the right side of the output grid with the mirrored version of the input grid\n    output_grid[:, m:] = input_grid[:, ::-1]\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the dimensions of the input grid\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n    \n    # Create a random sprite with colors (not black) and a density of 0.7\n    grid = random_sprite(n, m, density=0.7, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/258/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/258/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/258/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/258/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/258/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/258/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/258/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/258/images/train_output_2.png"}]}, "index": 258, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern mirroring, reflection\n\n# description:\n# In the input, you will see a pattern of colors in a square region of the grid.\n# To make the output, reflect this pattern horizontally and vertically, creating a larger grid that contains both the original pattern and its reflections.\n\ndef main(input_grid):\n    # extract the original pattern\n    pattern = input_grid\n\n    # reflect the pattern horizontally\n    reflected_horizontally = pattern[:, ::-1]\n\n    # reflect the pattern vertically\n    reflected_vertically = pattern[::-1, :]\n\n    # reflect the pattern both horizontally and vertically\n    reflected_both = reflected_horizontally[::-1, :]\n\n    # create an output grid that combines the original pattern and its reflections\n    output_grid = np.block([[pattern, reflected_horizontally],\n                             [reflected_vertically, reflected_both]])\n\n    return output_grid\n\ndef generate_input():\n    # create a random square pattern of random size and colors\n    n = m = np.random.randint(3, 6)  # size of the pattern\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/259/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/259/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/259/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/259/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/259/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/259/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/259/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/259/images/train_output_2.png"}]}, "index": 259, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary tracing, shape outlining\n\n# description:\n# In the input grid, you will see several distinct shapes represented by different colors on a black background.\n# The task is to trace the boundary of each shape and replace the corresponding pixels with a new color, effectively outlining the shapes while leaving the inside of the shapes unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # Identify and extract distinct shapes (connected components)\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Outline each shape by tracing its boundary\n    for shape in shapes:\n        # Get the color of the current shape\n        shape_color = shape[shape != Color.BLACK][0]\n        \n        # Iterate over each pixel in the shape to find boundary pixels\n        for x, y in np.argwhere(input_grid == shape_color):\n            # Check the 4-connectivity neighbors to determine the boundary\n            neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n            for nx, ny in neighbors:\n                # If neighbor is out of bounds or is black, this pixel is on the boundary\n                if (nx \u003c 0 or nx \u003e= input_grid.shape[0] or \n                    ny \u003c 0 or ny \u003e= input_grid.shape[1] or \n                    input_grid[nx, ny] == Color.BLACK):\n                    output_grid[x, y] = shape_color\n                    break\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of shapes with different colors\n    num_shapes = np.random.randint(3, 7)\n    colors = random.sample(Color.NOT_BLACK, num_shapes)\n\n    for color in colors:\n        # Randomly determine size and position of the shape\n        shape_height, shape_width = np.random.randint(2, 6), np.random.randint(2, 6)\n        shape = np.random.choice([color, Color.BLACK], size=(shape_height, shape_width), p=[0.7, 0.3])\n\n        # Find a random location to place the shape in the grid\n        x, y = np.random.randint(0, n - shape_height), np.random.randint(0, m - shape_width)\n        \n        # Blit the shape onto the grid\n        for i in range(shape_height):\n            for j in range(shape_width):\n                if shape[i, j] != Color.BLACK:\n                    grid[x + i, y + j] = shape[i, j]\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/260/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/260/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/260/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/260/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/260/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/260/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/260/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/260/images/train_output_2.png"}]}, "index": 260, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape extraction, color transformation, mirroring\n\n# description:\n# In the input, you will see a grid containing a central shape made up of different colors, surrounded by a border of a single color (black). \n# To create the output, mirror the central shape horizontally and transform each color of the shape into a specified new color according to a mapping.\n\ndef main(input_grid):\n    # Crop the central shape from the input grid\n    central_shape = crop(input_grid, background=Color.BLACK)\n\n    # Create output grid with the same shape\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Define the color mapping\n    color_mapping = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN,\n        Color.PINK: Color.ORANGE,\n        Color.ORANGE: Color.PINK,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.TEAL\n    }\n\n    # Transform colors of the central shape according to the mapping\n    transformed_shape = np.vectorize(lambda color: color_mapping.get(color, color))(central_shape)\n\n    # Mirror the transformed shape horizontally\n    mirrored_shape = np.flip(transformed_shape, axis=1)\n\n    # Place the mirrored shape back into the output grid\n    output_grid[1:-1, 1:-1] = mirrored_shape  # Keep the border of black\n\n    return output_grid\n\n\ndef generate_input():\n    # Randomly generate the size of the central shape\n    height = np.random.randint(3, 10)\n    width = np.random.randint(3, 10)\n\n    # Create a random central shape\n    central_shape = random_sprite(height, width, density=0.5, background=Color.BLACK)\n\n    # Initialize the grid with a black border\n    input_grid = np.full((height + 2, width + 2), Color.BLACK)\n\n    # Place the central shape in the grid\n    input_grid[1:-1, 1:-1] = central_shape\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/261/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/261/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/261/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/261/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/261/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/261/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/261/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/261/images/train_output_2.png"}]}, "index": 261, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, restoration\n\n# description:\n# In the input, you will see a grid containing a symmetrical shape with one side missing, represented by black pixels.\n# To create the output, find the missing part of the shape and restore it to make it fully symmetrical on both sides.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the mirror symmetry of the shape in the grid.\n    # 2. Identify the missing pixels (black pixels).\n    # 3. Restore the shape by mirroring the existing colored pixels across the symmetry line.\n\n    # Find the horizontal mirror symmetry\n    mirrors = detect_mirror_symmetry(input_grid, ignore_colors=[Color.BLACK])\n    \n    # Create an output grid that we will modify\n    output_grid = input_grid.copy()\n\n    # For each colored pixel, fill in the corresponding mirrored position\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        for mirror in mirrors:\n            mirror_x, mirror_y = mirror.apply(x, y)\n            # If the mirrored position is black, fill it with the color from the original\n            if output_grid[mirror_x, mirror_y] == Color.BLACK:\n                output_grid[mirror_x, mirror_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random symmetrical shape.\n    # 2. Randomly remove half of it to create the occlusion (black pixels).\n    \n    # Generate a random sprite with horizontal symmetry\n    sprite = random_sprite(np.random.randint(5, 8), np.random.randint(5, 8), symmetry=\"horizontal\", color_palette=list(Color.NOT_BLACK), density=0.8)\n    \n    # Randomly occlude half of the sprite by setting black pixels\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.random() \u003c 0.5:  # 50% chance to occlude\n                sprite[i, j] = Color.BLACK\n\n    # Create a grid and place the sprite\n    grid_size = (10, 10)\n    grid = np.zeros(grid_size, dtype=int)\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/262/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/262/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/262/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/262/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/262/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/262/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/262/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/262/images/train_output_2.png"}]}, "index": 262, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partitioning, color extraction, pattern reconstruction\n\n# description:\n# In the input, you will see a large grid divided into 4 quadrants. Each quadrant may contain a pattern, but only one of them is filled with a recognizable pattern, while the others are either empty or corrupted. \n# Your task is to extract the recognizable pattern from the filled quadrant and distribute it evenly across all four quadrants of the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the size of the input grid\n    n, m = input_grid.shape\n\n    # Define the coordinates for each quadrant\n    quadrants = [\n        (0, 0, n // 2, m // 2),  # Top-left\n        (0, m // 2, n // 2, m),  # Top-right\n        (n // 2, 0, n, m // 2),  # Bottom-left\n        (n // 2, m // 2, n, m)   # Bottom-right\n    ]\n\n    # Extract the patterns from each quadrant\n    extracted_patterns = []\n    for x1, y1, x2, y2 in quadrants:\n        quadrant = input_grid[x1:x2, y1:y2]\n        # Find connected components in the quadrant\n        components = find_connected_components(quadrant, background=Color.BLACK)\n        if components:\n            # If we found a component, we take the first one\n            extracted_patterns.append(crop(components[0], background=Color.BLACK))\n        else:\n            extracted_patterns.append(np.zeros((x2-x1, y2-y1), dtype=int))  # Empty pattern\n\n    # Determine the size of the output grid\n    output_size = max(pattern.shape for pattern in extracted_patterns)\n    output_grid = np.full((output_size[0] * 2, output_size[1] * 2), Color.BLACK)\n\n    # Place the extracted pattern into each quadrant of output grid\n    for i, pattern in enumerate(extracted_patterns):\n        x_offset = (i // 2) * output_size[0]\n        y_offset = (i % 2) * output_size[1]\n        output_grid[x_offset:x_offset + pattern.shape[0], y_offset:y_offset + pattern.shape[1]] = pattern\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create a pattern in one of the quadrants\n    pattern_size = np.random.randint(3, 5)\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly select which quadrant to fill\n    filled_quadrant = np.random.choice([0, 1, 2, 3])\n    \n    # Define the coordinates for each quadrant\n    quadrants = [\n        (0, 0),  # Top-left\n        (0, m // 2),  # Top-right\n        (n // 2, 0),  # Bottom-left\n        (n // 2, m // 2)  # Bottom-right\n    ]\n\n    # Create the pattern and place it in the chosen quadrant\n    x_start, y_start = quadrants[filled_quadrant]\n    pattern = random_sprite(n=pattern_size, m=pattern_size, color_palette=[pattern_color], density=0.5)\n    grid[x_start:x_start + pattern_size, y_start:y_start + pattern_size] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/263/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/263/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/263/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/263/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/263/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/263/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/263/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/263/images/train_output_2.png"}]}, "index": 263, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, reflection, color transformation\n\n# description:\n# In the input, you will see a pattern of colored pixels arranged in a grid. \n# The pattern may or may not be symmetric around the horizontal axis. \n# If it is symmetric, reflect the pattern across the vertical axis to create the output. \n# If it is not symmetric, return the input pattern unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Check for horizontal symmetry\n    is_symmetric = np.array_equal(input_grid, input_grid[::-1, :])\n\n    if is_symmetric:\n        # If symmetric, reflect the pattern across the vertical axis\n        output_grid = input_grid[:, ::-1]\n    else:\n        # If not symmetric, return the input unchanged\n        output_grid = input_grid\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n, m = np.random.randint(3, 8), np.random.randint(3, 8)\n\n    # Randomly choose a density for the sprite\n    density = np.random.uniform(0.3, 0.7)\n\n    # Generate a random sprite which may or may not have horizontal symmetry\n    symmetry_type = np.random.choice([\u0027symmetric\u0027, \u0027not_symmetric\u0027])\n    if symmetry_type == \u0027symmetric\u0027:\n        # Create a symmetric pattern\n        half_height = n // 2\n        top_half = random_sprite(half_height, m, density=density, symmetry=\u0027horizontal\u0027)\n        bottom_half = top_half[::-1, :]  # Reflect to create symmetry\n        grid = np.vstack((top_half, bottom_half))\n    else:\n        # Create a non-symmetric pattern\n        grid = random_sprite(n, m, density=density, symmetry=\u0027not_symmetric\u0027)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/264/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/264/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/264/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/264/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/264/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/264/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/264/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/264/images/train_output_2.png"}]}, "index": 264, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape expansion, filling areas\n\n# description:\n# In the input grid, you will see a filled shape of one color on a black background.\n# To create the output grid, expand the shape outward by one pixel in all directions, filling the newly expanded area with that same color.\n\ndef main(input_grid):\n    # Get the shape\u0027s color and the dimensions of the grid\n    shape_color = None\n    n, m = input_grid.shape\n    \n    # Create an output grid initialized to black\n    output_grid = np.zeros((n, m), dtype=int)\n    \n    # Identify the color of the shape (it should be the only non-black color)\n    unique_colors = np.unique(input_grid)\n    if len(unique_colors) \u003e 1:\n        shape_color = [color for color in unique_colors if color != Color.BLACK][0]\n    \n    # Copy the original shape to the output grid and expand\n    for x in range(n):\n        for y in range(m):\n            if input_grid[x, y] == shape_color:\n                # Fill the current pixel and its neighbors\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        new_x = x + dx\n                        new_y = y + dy\n                        if 0 \u003c= new_x \u003c n and 0 \u003c= new_y \u003c m:\n                            output_grid[new_x, new_y] = shape_color\n                            \n    return output_grid\n\ndef generate_input():\n    # Create a random filled shape on a black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n    \n    # Randomly choose the shape color\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a random filled shape (circle-like for simplicity)\n    shape_x, shape_y = np.random.randint(5, 15), np.random.randint(5, 15)\n    radius = np.random.randint(3, 6)\n    \n    for x in range(max(0, shape_x - radius), min(20, shape_x + radius + 1)):\n        for y in range(max(0, shape_y - radius), min(20, shape_y + radius + 1)):\n            if (x - shape_x) ** 2 + (y - shape_y) ** 2 \u003c= radius ** 2:\n                input_grid[x, y] = shape_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/265/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/265/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/265/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/265/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/265/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/265/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/265/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/265/images/train_output_2.png"}]}, "index": 265, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, transparency, color mixing\n\n# description:\n# In the input, you will see several semi-transparent shapes overlapping each other, each represented as a colored object on a black background.\n# To create the output, adjust the opacity of each shape to create a new color where they overlap, effectively layering the colors and keeping their shapes intact to create a colorful mosaic effect.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the unique colored shapes present in the input grid.\n    # 2. For each shape, determine its position and color.\n    # 3. Create a new output grid initialized to black.\n    # 4. For each shape, blend its color into the output grid where it overlaps with the existing colors.\n    \n    # Detect connected components (colored shapes) in the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    \n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Iterate through each shape to apply its color to the output grid\n    for shape in shapes:\n        # Get the bounding box of the current shape\n        x, y, width, height = bounding_box(shape)\n        \n        # Get the color of the shape (assuming it is monochromatic)\n        shape_color = shape[shape != Color.BLACK][0]\n        \n        # Blend the color into the output grid at the shape\u0027s position\n        for i in range(height):\n            for j in range(width):\n                if shape[i, j] != Color.BLACK:\n                    # Blend colors by simple addition and clamping to the maximum color value\n                    output_grid[y + i, x + j] = blend_colors(output_grid[y + i, x + j], shape_color)\n\n    return output_grid\n\ndef blend_colors(color1, color2):\n    # Simple blending function that averages the two colors\n    # This could be improved by using a real alpha channel blending\n    if color1 == Color.BLACK:\n        return color2\n    if color2 == Color.BLACK:\n        return color1\n    # Return a new color based on simple average (modulo with available colors for simplicity)\n    return np.clip((color1 + color2) // 2, 0, len(Color.ALL_COLORS) - 1)\n\ndef generate_input():\n    # Create a grid with random overlapping shapes\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        # Generate random shapes\n        shape_width, shape_height = np.random.randint(3, 7), np.random.randint(3, 7)\n        shape_color = np.random.choice(list(Color.NOT_BLACK))\n\n        # Create a random sprite for this shape\n        shape = random_sprite(shape_height, shape_width, density=0.5, color_palette=[shape_color])\n        \n        # Place the shape randomly on the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n        blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/266/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/266/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/266/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/266/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/266/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/266/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/266/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/266/images/train_output_2.png"}]}, "index": 266, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, pattern duplication\n\n# description:\n# In the input, you will see a shape in the left half of the grid. To create the output, duplicate the shape to the right half of the grid, creating a mirror image of the original shape.\n\ndef main(input_grid):\n    # Get the width and height of the input grid\n    height, width = input_grid.shape\n\n    # The output grid will be the same height but double the width\n    output_grid = np.full((height, width * 2), Color.BLACK)\n\n    # Copy the original shape to the left half of the output grid\n    output_grid[:, :width] = input_grid\n\n    # Mirror the shape to create the right half of the output grid\n    output_grid[:, width:] = input_grid[:, ::-1]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid of size (1-4)x(1-8) representing the left half\n    height = np.random.randint(1, 5)\n    width = np.random.randint(1, 9)\n\n    # Generate a random shape on the left side, ensuring it is not all black\n    grid = np.full((height, width), Color.BLACK)\n    shape_density = np.random.uniform(0.3, 0.7)\n\n    for i in range(height):\n        for j in range(width):\n            if np.random.rand() \u003c shape_density:\n                grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/267/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/267/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/267/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/267/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/267/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/267/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/267/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/267/images/train_output_2.png"}]}, "index": 267, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color transformation\n\n# description:\n# In the input, you will see a small grid with a simple color pattern. \n# To make the output, you should scale the pattern up to a larger grid while also transforming the colors according to a specific mapping: \n# red -\u003e blue, green -\u003e yellow, yellow -\u003e orange, blue -\u003e blue.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.empty((input_grid.shape[0] * 3, input_grid.shape[1] * 3), dtype=int)\n    output_grid.fill(Color.BLACK)  # Fill the output grid with black (background)\n\n    # Define color mapping\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.YELLOW: Color.ORANGE,\n        Color.BLUE: Color.BLUE\n    }\n\n    # Transform and scale the input grid\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            color = input_grid[i, j]\n            if color != Color.BLACK:  # Ignore background\n                transformed_color = color_map.get(color, color)  # Transform color\n                # Scale the color into the output grid\n                for di in range(3):  # Scale by 3\n                    for dj in range(3):\n                        output_grid[i * 3 + di, j * 3 + dj] = transformed_color\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random small grid (3x3)\n    pattern_size = 3\n    grid = np.full((pattern_size, pattern_size), Color.BLACK)\n\n    # Define available colors for the pattern\n    available_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n    \n    # Fill the grid with random colors from the available colors\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            if np.random.rand() \u003e 0.5:  # Randomly decide to place a color\n                grid[i, j] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/268/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/268/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/268/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/268/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/268/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/268/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/268/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/268/images/train_output_2.png"}]}, "index": 268, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel clustering, shape extraction, color transformation\n\n# description:\n# In the input, you will see a black background with various shapes of different colors scattered throughout. \n# Some shapes will overlap and have additional noise pixels scattered around. \n# To produce the output, extract the distinct shapes and fill them with a specified color, while removing the noise pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Identify connected components (shapes) in the grid.\n    # 2. Fill each shape with a specified color (e.g., green).\n    # 3. Remove noise pixels that are not part of any shape.\n\n    output_grid = np.full(input_grid.shape, Color.BLACK)  # Start with a black output grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    fill_color = Color.GREEN  # The color to fill the shapes with\n\n    for shape in shapes:\n        if np.sum(shape != Color.BLACK) \u003e 1:  # Only fill shapes with more than one pixel\n            output_grid[shape != Color.BLACK] = fill_color  # Fill the shape with the specified color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random shapes with noise\n    w, h = np.random.randint(10, 25, size=2)\n    grid = np.full((w, h), Color.BLACK)\n\n    # Randomly select colors for shapes\n    shape_colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(2, 5), replace=False)\n\n    n_shapes = np.random.randint(3, 6)\n    \n    for color in shape_colors:\n        for _ in range(n_shapes):\n            rw, rh = np.random.randint(3, 6), np.random.randint(3, 6)  # Random shapes sizes\n            sprite = np.full((rw, rh), color)\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n\n    # Add noise pixels around the shapes\n    n_noise_pixels = np.random.randint(10, 30)\n    for _ in range(n_noise_pixels):\n        x, y = np.random.randint(w), np.random.randint(h)\n        if grid[x, y] == Color.BLACK:  # Only add noise to empty pixels\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/269/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/269/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/269/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/269/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/269/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/269/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/269/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/269/images/train_output_2.png"}]}, "index": 269, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# blending, overlapping shapes, color manipulation\n\n# description:\n# In the input, you will see two overlapping circular shapes, one red and one blue, on a teal background.\n# To produce the output, blend the overlapping area to create a gray color where the two circles intersect, \n# while keeping the original colors intact outside of the overlap.\n\ndef main(input_grid):\n    # Create a copy of the input grid to store the output\n    output_grid = np.copy(input_grid)\n\n    # Identify the red and blue colors\n    red_color = Color.RED\n    blue_color = Color.BLUE\n    \n    # Find the area of overlap\n    overlap_mask = (output_grid == red_color) \u0026 (np.roll(output_grid, 1, axis=0) == blue_color) | \\\n                   (output_grid == blue_color) \u0026 (np.roll(output_grid, -1, axis=0) == red_color) | \\\n                   (output_grid == red_color) \u0026 (np.roll(output_grid, 1, axis=1) == blue_color) | \\\n                   (output_grid == blue_color) \u0026 (np.roll(output_grid, -1, axis=1) == red_color)\n\n    # Blend the colors in the overlapping area\n    output_grid[overlap_mask] = Color.GRAY\n\n    return output_grid\n\ndef generate_input():\n    # Set grid size\n    n, m = 10, 10\n    grid = np.full((n, m), Color.TEAL)\n\n    # Randomly determine positions and sizes for the two circles\n    radius1 = np.random.randint(2, 5)\n    radius2 = np.random.randint(2, 5)\n    \n    # Random center for the first circle (red)\n    center1 = (np.random.randint(radius1, n-radius1), np.random.randint(radius1, m-radius1))\n    # Draw the first circle\n    for x in range(n):\n        for y in range(m):\n            if (x - center1[0])**2 + (y - center1[1])**2 \u003c= radius1**2:\n                grid[x, y] = Color.RED\n\n    # Random center for the second circle (blue)\n    center2 = (np.random.randint(radius2, n-radius2), np.random.randint(radius2, m-radius2))\n    # Draw the second circle\n    for x in range(n):\n        for y in range(m):\n            if (x - center2[0])**2 + (y - center2[1])**2 \u003c= radius2**2:\n                grid[x, y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/270/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/270/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/270/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/270/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/270/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/270/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/270/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/270/images/train_output_2.png"}]}, "index": 270, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# intersection, lines, color mapping\n\n# description:\n# In the input, you will see multiple colored lines crossing each other. \n# To make the output, draw a new line that connects the intersection points of all the lines, \n# coloring it with a new color.\n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # Find all the connected components (colored lines)\n    line_components = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n\n    # Find intersection points\n    intersection_points = set()\n\n    for line in line_components:\n        # Get the bounding box of each line\n        x, y, w, h = bounding_box(line, background=Color.BLACK)\n        # Collect all intersection points along the bounding box edges\n        for i in range(x, x + w):\n            intersection_points.add((i, y))  # top edge\n            intersection_points.add((i, y + h - 1))  # bottom edge\n        for j in range(y, y + h):\n            intersection_points.add((x, j))  # left edge\n            intersection_points.add((x + w - 1, j))  # right edge\n\n    # Draw a new line that connects all intersection points\n    if intersection_points:\n        intersection_points = sorted(intersection_points)  # Sort points to form a continuous line\n        # Draw the line connecting all intersection points\n        for i in range(1, len(intersection_points)):\n            start = intersection_points[i - 1]\n            end = intersection_points[i]\n            draw_line(output_grid, start[0], start[1], end_x=end[0], end_y=end[1], color=Color.RED)\n\n    return output_grid\n\ndef generate_input():\n    # Make a square black grid for the background\n    n = np.random.randint(10, 20)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Randomly determine the number of lines\n    num_lines = np.random.randint(3, 6)\n\n    # Generate random lines on the grid\n    for _ in range(num_lines):\n        color = np.random.choice(list(Color.NOT_BLACK))\n        start_x, start_y = np.random.randint(0, n), np.random.randint(0, n)\n        end_x, end_y = np.random.randint(0, n), np.random.randint(0, n)\n        draw_line(grid, start_x, start_y, end_x=end_x, end_y=end_y, color=color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/271/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/271/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/271/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/271/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/271/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/271/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/271/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/271/images/train_output_2.png"}]}, "index": 271, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel merging, color blending, gradient\n\n# description:\n# In the input, you will see colored pixels scattered across a black grid. \n# To make the output, merge adjacent pixels of the same color into larger blocks and create a gradient effect by blending the colors of neighboring pixels, \n# resulting in a smooth transition across the grid.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Detect the unique colors in the input grid (excluding black)\n    unique_colors = np.unique(output_grid)\n    unique_colors = unique_colors[unique_colors != Color.BLACK]\n\n    # Merge adjacent pixels of the same color into larger blocks\n    for color in unique_colors:\n        # Find all coordinates of the current color\n        coords = np.argwhere(output_grid == color)\n        for (x, y) in coords:\n            # Merge horizontally\n            if x \u003e 0 and output_grid[x - 1, y] == color:  # merge with top\n                output_grid[x - 1, y] = color\n            if x \u003c output_grid.shape[0] - 1 and output_grid[x + 1, y] == color:  # merge with bottom\n                output_grid[x + 1, y] = color\n            if y \u003e 0 and output_grid[x, y - 1] == color:  # merge with left\n                output_grid[x, y - 1] = color\n            if y \u003c output_grid.shape[1] - 1 and output_grid[x, y + 1] == color:  # merge with right\n                output_grid[x, y + 1] = color\n\n    # Create a gradient effect by blending colors of neighboring pixels\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            if output_grid[x, y] == Color.BLACK:  # only blend if it\u0027s black\n                # Get the colors of neighboring pixels\n                neighbors = []\n                if x \u003e 0: neighbors.append(output_grid[x - 1, y])\n                if x \u003c output_grid.shape[0] - 1: neighbors.append(output_grid[x + 1, y])\n                if y \u003e 0: neighbors.append(output_grid[x, y - 1])\n                if y \u003c output_grid.shape[1] - 1: neighbors.append(output_grid[x, y + 1])\n                \n                # Count occurrences of each color\n                color_count = {}\n                for neighbor in neighbors:\n                    if neighbor != Color.BLACK:\n                        if neighbor in color_count:\n                            color_count[neighbor] += 1\n                        else:\n                            color_count[neighbor] = 1\n                \n                # If there are neighboring colors, blend them\n                if color_count:\n                    dominant_color = max(color_count.items(), key=lambda item: item[1])[0]\n                    output_grid[x, y] = dominant_color  # Assign the dominant color to the black pixel\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid as the background\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels across the grid\n    num_pixels = np.random.randint(10, 30)\n    for _ in range(num_pixels):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        color = np.random.choice([c for c in Color.NOT_BLACK])  # Select a random color that is not black\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/272/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/272/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/272/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/272/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/272/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/272/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/272/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/272/images/train_output_2.png"}]}, "index": 272, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# spiral arrangement, grid transformation\n\n# description:\n# In the input, you will see a grid filled with colored pixels arranged in a specific pattern. \n# To create the output, rearrange the pixels in a spiral pattern, starting from the center of the grid and moving outward, while maintaining the original colors.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n    output_grid = np.full((n, m), Color.BLACK)  # Create an output grid initialized to black\n\n    # Find the center of the grid\n    center_x, center_y = n // 2, m // 2\n    \n    # Directions for spiral traversal (right, down, left, up)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    x, y = center_x, center_y  # Start at the center\n    step = 1  # Initial step length\n    color_index = 0  # To track the color index in the spiral\n\n    # Create a list of colors from the input grid, excluding black\n    colors = [input_grid[i, j] for i in range(n) for j in range(m) if input_grid[i, j] != Color.BLACK]\n    \n    while color_index \u003c len(colors):\n        for direction in directions:\n            for _ in range(step):\n                if color_index \u003e= len(colors):\n                    break\n                \n                # Set the color in the output grid\n                output_grid[x, y] = colors[color_index]\n                color_index += 1\n                \n                # Move in the current direction\n                x += direction[0]\n                y += direction[1]\n\n            # After two directions, increase the step length\n            if direction in [(0, 1), (0, -1)]:\n                step += 1\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly choose the size of the grid\n    n = np.random.randint(5, 11)  # Height of the grid\n    m = np.random.randint(5, 11)  # Width of the grid\n    grid = np.zeros((n, m), dtype=int)  # Create a black grid\n\n    # Populate the grid with random colors, avoiding black\n    num_colors = np.random.randint(5, 15)  # Number of colored pixels\n    available_colors = list(Color.NOT_BLACK)\n    \n    for _ in range(num_colors):\n        color = np.random.choice(available_colors)\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/273/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/273/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/273/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/273/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/273/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/273/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/273/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/273/images/train_output_2.png"}]}, "index": 273, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color propagation, symmetry\n\n# description:\n# In the input, you will see a central colored pixel with colored pixels arranged symmetrically around it.\n# To make the output, draw lines from the central pixel to the outer pixels, reflecting across the central pixel\u0027s position.\n# Each line should be extended in both directions symmetrically, and the color of the lines should match the color of the outer pixel.\n# If a line intersects another pixel, it stops there and adopts the color of the outer pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Find the center of the grid\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n\n    # Get the color of the central pixel\n    central_color = output_grid[center_x, center_y]\n\n    # Iterate through pixels around the center in a square grid\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx == 0 and dy == 0):\n                continue  # Skip the central pixel itself\n\n            outer_x, outer_y = center_x + dx, center_y + dy\n\n            if (0 \u003c= outer_x \u003c output_grid.shape[0]) and (0 \u003c= outer_y \u003c output_grid.shape[1]):\n                outer_color = output_grid[outer_x, outer_y]\n\n                # Draw lines in both directions (reflecting across the center)\n                draw_line(output_grid, center_x, center_y, end_x=center_x + dx, end_y=center_y + dy, color=outer_color)\n                draw_line(output_grid, center_x, center_y, end_x=center_x - dx, end_y=center_y - dy, color=outer_color)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid for background\n    n, m = 7, 7  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color for the central pixel\n    central_color = random.choice(list(Color.NOT_BLACK))\n    grid[n // 2, m // 2] = central_color\n\n    # Randomly color the surrounding pixels\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx == 0 and dy == 0):\n                continue  # Skip the central pixel\n            outer_x, outer_y = n // 2 + dx, m // 2 + dy\n            \n            if (0 \u003c= outer_x \u003c n) and (0 \u003c= outer_y \u003c m):\n                outer_color = random.choice(list(Color.NOT_BLACK))\n                grid[outer_x, outer_y] = outer_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/274/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/274/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/274/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/274/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/274/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/274/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/274/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/274/images/train_output_2.png"}]}, "index": 274, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, tiling\n\n# description:\n# In the input, you will see a small patterned tile in the center of a black grid. \n# To create the output grid, you should scale the patterned tile up by a factor of 4 and fill a larger grid with the scaled tile, creating a repeating pattern.\n\ndef main(input_grid):\n    # Detect the pattern tile in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n    \n    # Assume there\u0027s only one pattern tile in the center\n    pattern_tile = objects[0]\n    \n    # Crop the pattern tile to remove the background\n    cropped_tile = crop(pattern_tile, background=Color.BLACK)\n    \n    # Scale the cropped pattern tile by a factor of 4\n    scaled_tile = scale_pattern(cropped_tile, scale_factor=4)\n    \n    # Create an output grid that is large enough to fill with the scaled tile\n    output_height = input_grid.shape[0] * 4\n    output_width = input_grid.shape[1] * 4\n    output_grid = np.zeros((output_height, output_width), dtype=int)\n\n    # Fill the output grid with the scaled tile in a tiled pattern\n    for i in range(0, output_height, scaled_tile.shape[0]):\n        for j in range(0, output_width, scaled_tile.shape[1]):\n            output_grid = blit_sprite(output_grid, scaled_tile, x=j, y=i, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a small grid with black background\n    n, m = 8, 8\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a small pattern tile in the center of the grid\n    pattern_size = 3  # 3x3 pattern\n    center_x, center_y = n // 2, m // 2\n\n    # Randomly generate the pattern tile\n    colors = list(Color.NOT_BLACK)\n    random_color = np.random.choice(colors)\n\n    # Fill the pattern tile with random colors\n    pattern_tile = random_sprite(n=pattern_size, m=pattern_size, color_palette=[random_color], density=0.5)\n    \n    # Place the pattern tile in the center of the grid\n    grid[center_x - 1:center_x + 2, center_y - 1:center_y + 2] = pattern_tile\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/275/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/275/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/275/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/275/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/275/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/275/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/275/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/275/images/train_output_2.png"}]}, "index": 275, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filling, symmetry detection\n\n# description:\n# In the input, you will see a grid with a central pattern and a color on one side. \n# To make the output, identify the color of the central pattern and fill the missing half of the grid \n# (on the opposite side) with the same color to create a symmetrical pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Identify the central pattern and the color of the filled side\n    filled_side = input_grid[:, 0: m // 2]\n    empty_side = input_grid[:, m // 2: m]\n\n    # Check if the filled side is not empty\n    if np.any(filled_side != Color.BLACK):\n        # Get the unique color from the filled side (assuming a single color)\n        unique_colors = np.unique(filled_side)\n        unique_colors = unique_colors[unique_colors != Color.BLACK]  # Exclude black\n        if len(unique_colors) == 1:\n            fill_color = unique_colors[0]\n            # Fill the empty side with the same color\n            output_grid = np.copy(input_grid)\n            output_grid[:, m // 2:] = fill_color\n        else:\n            # If there is more than one color, we leave the empty side black\n            output_grid = np.copy(input_grid)\n    else:\n        # If the filled side is all black, output remains the same\n        output_grid = np.copy(input_grid)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n = np.random.randint(3, 6)\n    m = np.random.randint(5, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Fill the left half with the selected color\n    for i in range(n):\n        for j in range(m // 2):\n            if np.random.rand() \u003c 0.5:  # Randomly decide to fill or leave black\n                grid[i, j] = color\n            else:\n                grid[i, j] = Color.BLACK\n\n    # Fill the right half with black\n    for i in range(n):\n        for j in range(m // 2, m):\n            grid[i, j] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/276/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/276/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/276/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/276/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/276/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/276/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/276/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/276/images/train_output_2.png"}]}, "index": 276, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, rotation, color transformation\n\n# description:\n# In the input, you will see a non-black background filled with colored pixels forming a symmetric pattern. \n# The challenge is to take this symmetric pattern and rotate it 90 degrees clockwise while preserving the colors.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid of the same size\n    output_grid = np.zeros((m, n), dtype=int)  # Note: Transposed dimensions for a 90-degree rotation\n\n    # Rotate the grid 90 degrees clockwise\n    for i in range(n):\n        for j in range(m):\n            output_grid[j, n - 1 - i] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a grid of size 10x10 with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random color palette excluding black\n    colors = random.sample(Color.NOT_BLACK, k=5)\n\n    # Create a symmetric pattern in the grid\n    for i in range(n):\n        for j in range(m):\n            # Create a random symmetric pattern by mirroring pixels\n            if np.random.rand() \u003c 0.5:\n                color = random.choice(colors)\n                grid[i, j] = color\n                if j \u003c m // 2:\n                    grid[i, m - 1 - j] = color  # Mirror horizontally\n                if i \u003c n // 2:\n                    grid[n - 1 - i, j] = color  # Mirror vertically\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/277/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/277/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/277/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/277/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/277/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/277/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/277/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/277/images/train_output_2.png"}]}, "index": 277, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, extraction, scaling, rotation\n\n# description:\n# In the input, you will see a 2D grid filled with various colored shapes. \n# The task is to identify the largest shape, rotate it 90 degrees clockwise, \n# and place it back into the output grid at the same center position as its original location.\n\ndef main(input_grid):\n    # Step 1: Detect all objects in the input grid\n    objects = detect_objects(grid=input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n    \n    # Step 2: Identify the largest object\n    largest_object = max(objects, key=lambda obj: obj.shape[0] * obj.shape[1])\n    \n    # Step 3: Get the center position of the largest object\n    x, y = object_position(largest_object, background=Color.BLACK, anchor=\u0027center\u0027)\n    \n    # Step 4: Crop the largest object to create a sprite\n    cropped_sprite = crop(largest_object, background=Color.BLACK)\n    \n    # Step 5: Rotate the sprite 90 degrees clockwise\n    rotated_sprite = np.rot90(cropped_sprite, k=-1)  # k=-1 for clockwise rotation\n    \n    # Step 6: Calculate new position to place the rotated sprite centered\n    new_x = x - rotated_sprite.shape[0] // 2\n    new_y = y - rotated_sprite.shape[1] // 2\n    \n    # Step 7: Create output grid and place the rotated sprite\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid = blit_sprite(grid=output_grid, sprite=rotated_sprite, x=new_x, y=new_y, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Generate a few random shapes and place them in the grid\n    num_shapes = np.random.randint(2, 6)  # Random number of shapes\n    for _ in range(num_shapes):\n        # Random size for each shape\n        w, h = np.random.randint(2, 6), np.random.randint(2, 6)\n        # Generate a random sprite\n        sprite = random_sprite(n=w, m=h, density=0.7, color_palette=list(Color.NOT_BLACK))\n        \n        # Randomly find a position to place the sprite\n        x, y = random_free_location_for_sprite(grid, sprite)\n        grid = blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/278/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/278/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/278/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/278/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/278/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/278/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/278/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/278/images/train_output_2.png"}]}, "index": 278, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, mirroring, grid manipulation\n\n# description:\n# In the input you will see a grid with a pattern on the left half and a blank area on the right half.\n# To make the output, reflect the pattern from the left side over to the right side, maintaining the same orientation.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the height and width of the input grid\n    height, width = input_grid.shape\n    \n    # Split the input grid into left (pattern) and right (blank) halves\n    left_half = input_grid[:, :width // 2]\n    \n    # Reflect the left half to the right half\n    reflected_half = np.copy(left_half)\n    \n    # Create the output grid by combining the original left half and the reflected half\n    output_grid = np.zeros((height, width), dtype=int)\n    output_grid[:, :width // 2] = left_half\n    output_grid[:, width // 2:] = reflected_half\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random height for the grid\n    height = np.random.randint(3, 8)\n    \n    # Generate a random width which is even for clear splitting\n    width = np.random.randint(4, 12) * 2\n    \n    # Initialize the grid with black background\n    grid = np.zeros((height, width), dtype=int)\n    \n    # Create a random pattern in the left half of the grid\n    left_pattern = random_sprite(height, width // 2, density=0.5, color_palette=Color.NOT_BLACK)\n    \n    # Place the left pattern in the grid\n    grid[:, :width // 2] = left_pattern\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/279/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/279/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/279/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/279/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/279/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/279/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/279/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/279/images/train_output_2.png"}]}, "index": 279, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color assignment, object counting, diagonal connectivity\n\n# description:\n# In the input, you will see various colored squares scattered across a grid. Each square can be red, green, or blue. \n# To create the output, count the number of squares of each color, and create a vertical column of squares filled with that color in the output grid.\n# The height of each column corresponds to the count of the squares of that color in the input.\n\ndef main(input_grid):\n    # Prepare the output grid with a black background\n    output_grid = np.zeros_like(input_grid)\n\n    # Count the squares of each color\n    red_count = np.sum(input_grid == Color.RED)\n    green_count = np.sum(input_grid == Color.GREEN)\n    blue_count = np.sum(input_grid == Color.BLUE)\n\n    # Define the maximum height for the bar graph based on the highest count\n    max_height = max(red_count, green_count, blue_count)\n\n    # Create vertical columns for each color based on their counts\n    for i in range(red_count):\n        output_grid[max_height - 1 - i, 0] = Color.RED  # Red column\n    for i in range(green_count):\n        output_grid[max_height - 1 - i, 1] = Color.GREEN  # Green column\n    for i in range(blue_count):\n        output_grid[max_height - 1 - i, 2] = Color.BLUE  # Blue column\n\n    return output_grid\n\ndef generate_input():\n    # Create a black 10x10 grid as the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a number of colored squares to add to the grid\n    num_squares = np.random.randint(1, 21)  # Random number of squares between 1 and 20\n    for _ in range(num_squares):\n        color = np.random.choice([Color.RED, Color.GREEN, Color.BLUE])\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color  # Place the colored square in the grid\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/280/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/280/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/280/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/280/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/280/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/280/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/280/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/280/images/train_output_2.png"}]}, "index": 280, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# tessellation, object extraction, pattern repetition\n\n# description:\n# In the input, you will see a small shape surrounded by a black background. To create the output, tessellate the shape throughout the grid, filling the entire area with the pattern of the shape. The shape may be of any size but must be a single connected component.\n\ndef main(input_grid):\n    # Step 1: Find the shape in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n    \n    # There should only be one shape in the input grid\n    assert len(objects) == 1\n    shape = objects[0]\n\n    # Step 2: Crop this shape to get the sprite\n    sprite = crop(shape, background=Color.BLACK)\n\n    # Step 3: Determine the dimensions of the output grid\n    output_height = input_grid.shape[0]\n    output_width = input_grid.shape[1]\n\n    # Step 4: Create the output grid filled with black\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Step 5: Fill the output grid with the sprite in a tessellated pattern\n    for y in range(0, output_height, sprite.shape[0]):\n        for x in range(0, output_width, sprite.shape[1]):\n            # Check if the sprite fits in the output grid at this position\n            if x + sprite.shape[1] \u003c= output_width and y + sprite.shape[0] \u003c= output_height:\n                blit_sprite(output_grid, sprite, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Create a random grid size\n    n = np.random.randint(5, 10)\n    m = np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Step 2: Randomly determine the size of the shape\n    shape_height = np.random.randint(2, n // 2 + 1)\n    shape_width = np.random.randint(2, m // 2 + 1)\n\n    # Step 3: Create a random shape in the grid\n    shape = np.full((shape_height, shape_width), Color.RED)\n\n    # Step 4: Find a random free location for the shape\n    x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n    blit_sprite(grid, shape, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/281/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/281/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/281/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/281/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/281/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/281/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/281/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/281/images/train_output_2.png"}]}, "index": 281, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape recognition, counting, color transformation\n\n# description:\n# In the input, you will see multiple 3x3 green squares scattered across the grid.\n# To create the output grid, count the number of 3x3 green squares and create a new grid \n# where each 3x3 block is colored yellow if there are 1 or 2 green squares, blue if there are 3 or 4 green squares, \n# and red if there are 5 or more green squares.\n\ndef main(input_grid):\n    # Count the number of 3x3 green squares in the input grid\n    green_square_count = 0\n    n, m = input_grid.shape\n\n    for x in range(n - 2):  # leave space for a 3x3 block\n        for y in range(m - 2):  # leave space for a 3x3 block\n            if np.all(input_grid[x:x+3, y:y+3] == Color.GREEN):\n                green_square_count += 1\n\n    # Create the output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Determine the color based on the number of green squares counted\n    if green_square_count \u003e= 5:\n        color = Color.RED\n    elif green_square_count \u003e= 3:\n        color = Color.BLUE\n    elif green_square_count \u003e= 1:\n        color = Color.YELLOW\n    else:\n        color = Color.BLACK  # No green squares found\n\n    # Fill the output grid with the determined color\n    output_grid[:] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid of size n x m\n    n, m = np.random.randint(6, 12), np.random.randint(6, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place a number of 3x3 green squares in the grid\n    green_square = np.full((3, 3), Color.GREEN, dtype=int)\n    for _ in range(np.random.randint(0, 5)):\n        try:\n            x, y = random_free_location_for_sprite(grid, green_square, padding=0, padding_connectivity=4)\n            blit_sprite(grid, green_square, x, y)\n        except:\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/282/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/282/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/282/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/282/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/282/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/282/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/282/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/282/images/train_output_2.png"}]}, "index": 282, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection, color mapping\n\n# description:\n# In the input, you will see a grid filled with colored pixels. The grid can contain any arrangement of colors.\n# To create the output, reflect the grid along its vertical axis, so that the left side mirrors the right side.\n# Each pixel\u0027s color from the left side should be replaced by the corresponding pixel\u0027s color from the right side.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a new grid of the same shape as the input grid.\n    # 2. For each pixel in the input grid, determine its mirrored position in the output grid.\n    # 3. Copy the color from the input grid to the mirrored position in the output grid.\n\n    output_grid = np.zeros_like(input_grid)\n\n    rows, cols = input_grid.shape\n    for i in range(rows):\n        for j in range(cols):\n            # Reflect along the vertical axis\n            output_grid[i, cols - 1 - j] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a random grid filled with colors from the defined color palette.\n    # 2. The grid size can be randomly selected within a certain range.\n    # 3. Fill the grid with random colors, ensuring it is not monochromatic.\n\n    n, m = np.random.randint(5, 15, size=2)  # Random grid dimensions between 5x5 and 15x15\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Fill the grid with random colors\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.5:  # 50% chance to add a color\n                grid[i, j] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/283/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/283/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/283/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/283/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/283/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/283/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/283/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/283/images/train_output_2.png"}]}, "index": 283, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern shift, color layering\n\n# description:\n# In the input, you will see a grid consisting of various colored pixels, with a specific color (let\u0027s say gray) representing a \"blank\" space. \n# To create the output, shift each colored pixel in the grid one position to the right. \n# If a colored pixel moves out of bounds, it will wrap around to the left side of the same row. Blank spaces remain unchanged.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n\n    for x in range(n):\n        for y in range(m):\n            color = input_grid[x][y]\n            if color != Color.GRAY:  # Only shift colored pixels\n                new_y = (y + 1) % m  # Shift right and wrap around\n                output_grid[x][new_y] = color\n                output_grid[x][y] = Color.GRAY  # Set the original position to blank\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with colored pixels and gray pixels\n    n, m = np.random.randint(5, 12), np.random.randint(5, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors, ensuring some gray spaces\n    num_colors = np.random.randint(1, 6)\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n    \n    # Fill the grid with random colors and gray pixels\n    for x in range(n):\n        for y in range(m):\n            if np.random.random() \u003c 0.3:  # 30% chance to be gray\n                grid[x][y] = Color.GRAY\n            else:\n                grid[x][y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/284/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/284/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/284/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/284/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/284/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/284/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/284/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/284/images/train_output_2.png"}]}, "index": 284, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color gradient, layering\n\n# description:\n# In the input, you will see a grid filled with a single color at the top and another color at the bottom.\n# To create the output, apply a color gradient that transitions smoothly from the top color to the bottom color across the entire grid.\n\ndef main(input_grid):\n    # Get the top and bottom colors from the input grid\n    top_color = input_grid[0, 0]\n    bottom_color = input_grid[-1, 0]\n\n    # Create the output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Calculate the gradient for each row\n    for y in range(input_grid.shape[0]):\n        # Calculate the ratio of the current row\u0027s position to the total number of rows\n        ratio = y / (input_grid.shape[0] - 1)\n        \n        # Interpolate the color\n        output_grid[y] = interpolate_color(top_color, bottom_color, ratio)\n\n    return output_grid\n\ndef interpolate_color(color1, color2, ratio):\n    \"\"\"\n    Interpolates between two colors based on the given ratio.\n    Here, we\u0027ll assume colors are represented as integers or strings,\n    and we will create a basic linear interpolation.\n    \"\"\"\n    # For simplicity, let\u0027s consider colors as tuples of RGB values\n    color_values = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.ORANGE: (255, 165, 0),\n        Color.PINK: (255, 192, 203),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.GRAY: (128, 128, 128),\n        Color.BLACK: (0, 0, 0)\n    }\n    \n    # Get the RGB values of the colors\n    rgb1 = np.array(color_values[color1])\n    rgb2 = np.array(color_values[color2])\n    \n    # Interpolate\n    interpolated_color = (1 - ratio) * rgb1 + ratio * rgb2\n    interpolated_color = np.clip(interpolated_color, 0, 255).astype(int)\n\n    # Convert back to Color format (for simplicity, we return a color string based on the closest color)\n    for color, rgb in color_values.items():\n        if np.array_equal(interpolated_color, rgb):\n            return color\n    return Color.BLACK  # Fallback\n\ndef generate_input():\n    # Randomly select two colors from the available colors (not black)\n    top_color, bottom_color = np.random.choice(list(Color.NOT_BLACK), 2, replace=False)\n\n    # Create a grid of size 20x20\n    grid_size = 20\n    grid = np.full((grid_size, 1), top_color, dtype=int)\n\n    # Set the bottom row to the bottom color\n    grid[-1, 0] = bottom_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/285/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/285/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/285/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/285/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/285/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/285/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/285/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/285/images/train_output_2.png"}]}, "index": 285, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, central positioning\n\n# description:\n# The input grid contains a central colored square surrounded by a border of black pixels. \n# To produce the output grid, you should extract the central colored square and position it in the center of the output grid, \n# leaving the rest of the grid black.\n\ndef main(input_grid):\n    # Find the bounding box of the central colored square.\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # There should only be one colored object detected.\n    assert len(components) == 1\n    colored_square = components[0]\n    \n    # Get the bounding box of the colored square.\n    x, y, width, height = bounding_box(colored_square, background=Color.BLACK)\n\n    # Create an output grid filled with black pixels.\n    output_grid = np.zeros_like(input_grid)\n\n    # Calculate the center position for the colored square in the output grid.\n    center_x = (output_grid.shape[0] - width) // 2\n    center_y = (output_grid.shape[1] - height) // 2\n\n    # Place the colored square in the center of the output grid.\n    blit_sprite(output_grid, colored_square, x=center_x, y=center_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a black grid with size of n x m.\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide the size of the central colored square.\n    size = np.random.randint(2, min(n, m) // 2)\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Position the colored square in the center of the grid.\n    start_x = (n - size) // 2\n    start_y = (m - size) // 2\n\n    # Draw the central colored square.\n    for i in range(size):\n        for j in range(size):\n            grid[start_x + i, start_y + j] = color\n\n    # Ensure the grid is bordered by black pixels.\n    grid[0, :] = Color.BLACK\n    grid[:, 0] = Color.BLACK\n    grid[-1, :] = Color.BLACK\n    grid[:, -1] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/286/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/286/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/286/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/286/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/286/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/286/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/286/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/286/images/train_output_2.png"}]}, "index": 286, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# adjacency, color blending\n\n# description:\n# In the input, you will see a grid with colored pixels. For each pixel, create the output by blending the color of the pixel with the colors of its adjacent pixels (up, down, left, right).\n# The blending rule is: if two colors are adjacent, the output color for that pixel will be the average of the color values of the original pixel and the most frequently occurring adjacent color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n    rows, cols = input_grid.shape\n\n    for x in range(rows):\n        for y in range(cols):\n            current_color = input_grid[x][y]\n            if current_color == Color.BLACK:\n                continue  # Skip black cells\n\n            # Count adjacent colors\n            color_counts = {}\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 \u003c= nx \u003c rows and 0 \u003c= ny \u003c cols:\n                    neighbor_color = input_grid[nx][ny]\n                    if neighbor_color != Color.BLACK:\n                        if neighbor_color not in color_counts:\n                            color_counts[neighbor_color] = 0\n                        color_counts[neighbor_color] += 1\n\n            # Determine the most frequently occurring adjacent color\n            if color_counts:\n                most_frequent_color = max(color_counts, key=color_counts.get)\n                # Blend the colors\n                blended_color = blend_colors(current_color, most_frequent_color)\n                output_grid[x][y] = blended_color\n\n    return output_grid\n\ndef blend_colors(color1, color2):\n    # Basic blending logic: average the color values\n    # Since colors are represented as strings, we assume we have a mapping to numeric values.\n    # This is a placeholder implementation; the actual blending will depend on the color representation.\n    \n    # Assume colors are represented as integers for blending purposes\n    color_value1 = color_to_value(color1)\n    color_value2 = color_to_value(color2)\n    \n    # Blend colors\n    blended_value = (color_value1 + color_value2) // 2\n    return value_to_color(blended_value)\n\ndef color_to_value(color):\n    # This function maps color strings to integers (0-9)\n    return {\n        Color.BLACK: 0,\n        Color.BLUE: 1,\n        Color.RED: 2,\n        Color.GREEN: 3,\n        Color.YELLOW: 4,\n        Color.GREY: 5,\n        Color.PINK: 6,\n        Color.ORANGE: 7,\n        Color.TEAL: 8,\n        Color.MAROON: 9\n    }[color]\n\ndef value_to_color(value):\n    # This function maps integers (0-9) back to color strings\n    return {\n        0: Color.BLACK,\n        1: Color.BLUE,\n        2: Color.RED,\n        3: Color.GREEN,\n        4: Color.YELLOW,\n        5: Color.GREY,\n        6: Color.PINK,\n        7: Color.ORANGE,\n        8: Color.TEAL,\n        9: Color.MAROON\n    }[value]\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random colors with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors, avoiding black\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.3:  # 30% chance to be colored\n                grid[i, j] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/287/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/287/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/287/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/287/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/287/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/287/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/287/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/287/images/train_output_2.png"}]}, "index": 287, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color saturation, background interaction\n\n# description:\n# In the input, you will see a grid consisting of various colors on a black background. \n# To make the output, increase the saturation of each colored pixel, making it brighter, while leaving the black background unchanged. \n# Pixels that are already the brightest color (e.g., Color.YELLOW) should not change.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Define a function to increase saturation\n    def increase_saturation(color):\n        if color == Color.YELLOW:\n            return color  # YELLOW is the brightest, do not change\n        # Increase the color by a simple rule, e.g., shift to a brighter color\n        if color == Color.RED:\n            return Color.ORANGE\n        elif color == Color.GREEN:\n            return Color.YELLOW\n        elif color == Color.BLUE:\n            return Color.TEAL\n        elif color == Color.TEAL:\n            return Color.GREEN\n        elif color == Color.PINK:\n            return Color.RED\n        elif color == Color.MAROON:\n            return Color.RED\n        elif color == Color.GREY:\n            return Color.MAROON  # Assuming a LIGHT_GREY exists\n        elif color == Color.BLACK:\n            return color  # Keep black unchanged\n        return color  # Fallback for other colors\n\n    # Iterate through the grid and apply saturation increase\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            current_color = input_grid[x, y]\n            output_grid[x, y] = increase_saturation(current_color)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid of colors on a black background\n    n, m = np.random.randint(5, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)  # Black background\n\n    # Randomly choose a number of colored pixels to add\n    num_colored_pixels = np.random.randint(1, n * m // 4)  # Limit number to avoid too dense\n    colors = list(Color.NOT_BLACK)  # All colors except black\n\n    for _ in range(num_colored_pixels):\n        color = np.random.choice(colors)\n        # Choose a random position to place the colored pixel\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/288/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/288/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/288/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/288/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/288/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/288/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/288/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/288/images/train_output_2.png"}]}, "index": 288, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color separation, pixel inversion\n\n# description:\n# In the input, you will see a grid filled with multiple colored objects (not including black) on a black background.\n# To create the output grid, you will invert the colors of the objects in the grid, changing each color to its complementary color.\n# The colors are defined as follows: \n# - Red becomes Grey\n# - Green becomes Gray\n# - Blue becomes Yellow\n# - Teal becomes Orange\n# - Maroon becomes Light Green\n# - Grey becomes Grey (stays the same)\n# - Black stays Black (stays the same)\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Define a color mapping for inversion\n    color_mapping = {\n        Color.RED: Color.GREY,\n        Color.GREEN: Color.GRAY,\n        Color.BLUE: Color.YELLOW,\n        Color.TEAL: Color.ORANGE,\n        Color.MAROON: Color.GREEN,\n        Color.GREY: Color.GREY,\n        Color.BLACK: Color.BLACK\n    }\n\n    # Iterate over the grid and apply the color inversion\n    for original_color, inverted_color in color_mapping.items():\n        output_grid[input_grid == original_color] = inverted_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define a list of colors to use (excluding black)\n    available_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.TEAL, Color.MAROON, Color.GREY]\n\n    # Randomly scatter colored objects on the grid\n    for _ in range(np.random.randint(5, 15)):  # Random number of colored pixels\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice(available_colors)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/289/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/289/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/289/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/289/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/289/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/289/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/289/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/289/images/train_output_2.png"}]}, "index": 289, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# spiral pattern, grid manipulation\n\n# description:\n# In the input, you will see a grid filled with colored squares arranged randomly. \n# To create the output, rearrange the squares in a spiral pattern starting from the center of the grid, \n# moving outward, while maintaining the original colors of the squares.\n\ndef main(input_grid):\n    # Determine the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid filled with zeros (black)\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # Calculate the center of the grid\n    center_x, center_y = n // 2, m // 2\n\n    # Create a list to store the colors from the input grid\n    colors = []\n\n    # Extract the colors from the input grid (ignoring black)\n    for x in range(n):\n        for y in range(m):\n            if input_grid[x, y] != Color.BLACK:\n                colors.append(input_grid[x, y])\n\n    # Generate the spiral order of positions\n    positions = []\n    left, right, top, bottom = 0, m - 1, 0, n - 1\n    while left \u003c= right and top \u003c= bottom:\n        for i in range(left, right + 1):\n            positions.append((top, i))\n        top += 1\n        for i in range(top, bottom + 1):\n            positions.append((i, right))\n        right -= 1\n        if top \u003c= bottom:\n            for i in range(right, left - 1, -1):\n                positions.append((bottom, i))\n            bottom -= 1\n        if left \u003c= right:\n            for i in range(bottom, top - 1, -1):\n                positions.append((i, left))\n            left += 1\n\n    # Fill the output grid in spiral order with the colors\n    for color, (x, y) in zip(colors, positions):\n        output_grid[x, y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Random grid dimensions, ensuring it is at least 5x5 to accommodate the spiral\n    n, m = np.random.randint(5, 12), np.random.randint(5, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors, avoiding black\n    available_colors = list(Color.NOT_BLACK)\n\n    # Randomly fill the grid with colors\n    for x in range(n):\n        for y in range(m):\n            if np.random.random() \u003c 0.7:  # 70% chance to fill a color\n                grid[x, y] = np.random.choice(available_colors)\n            else:\n                grid[x, y] = Color.BLACK  # 30% chance to leave it black\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/290/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/290/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/290/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/290/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/290/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/290/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/290/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/290/images/train_output_2.png"}]}, "index": 290, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, layering, transparency\n\n# description:\n# In the input, you will see several circles of different colors on a grey background. \n# To make the output, calculate the resulting color at each pixel by blending the colors of the circles according to their transparency, \n# producing a new grid that represents the composite color at each pixel.\n\ndef main(input_grid):\n    # Initialize the output grid with the background (grey)\n    output_grid = np.full(input_grid.shape, Color.GREY)\n\n    # Find all the colored circles in the input grid\n    colored_objects = detect_objects(input_grid, background=Color.GREY, monochromatic=False)\n\n    # For each colored object, blend its color with the output grid\n    for obj in colored_objects:\n        # Get the color of the current object\n        color = obj[obj != Color.GREY][0]  # Assuming all pixels in an object are the same color\n        \n        # Blend the object with the output grid\n        for x in range(obj.shape[0]):\n            for y in range(obj.shape[1]):\n                if obj[x, y] != Color.GREY:  # Only process non-grey pixels\n                    output_grid[x, y] = blend_colors(output_grid[x, y], color)\n    \n    return output_grid\n\ndef blend_colors(base_color, overlay_color):\n    # Simple blending function (similar to averaging)\n    if base_color == Color.GREY:\n        return overlay_color\n    return base_color  # For simplicity, we can just return the existing color for now\n\ndef generate_input():\n    # Create a 20x20 grey grid\n    input_grid = np.full((20, 20), Color.GREY)\n\n    # Randomly decide how many circles to draw\n    num_circles = np.random.randint(3, 6)\n\n    for _ in range(num_circles):\n        # Randomly pick a color for the circle\n        circle_color = np.random.choice(list(Color.NOT_BLACK))\n\n        # Randomly determine the radius of the circle\n        radius = np.random.randint(3, 6)\n\n        # Randomly place the circle in the grid\n        center_x = np.random.randint(radius, 20 - radius)\n        center_y = np.random.randint(radius, 20 - radius)\n\n        # Draw the circle on the grid\n        for x in range(center_x - radius, center_x + radius + 1):\n            for y in range(center_y - radius, center_y + radius + 1):\n                if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                    input_grid[x, y] = circle_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/291/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/291/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/291/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/291/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/291/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/291/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/291/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/291/images/train_output_2.png"}]}, "index": 291, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape identification, boundary tracing\n\n# description:\n# In the input grid, you will see colored shapes on a red background. \n# To produce the output, identify the contours of each shape and create a colored outline around each shape to emphasize their boundaries, \n# while leaving the interior colors unchanged. Each shape will be outlined in black.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (shapes) in the input grid\n    shapes = find_connected_components(grid=input_grid, background=Color.RED)\n\n    # Loop over each shape to outline its boundary\n    for shape in shapes:\n        # Get the bounding box of the shape\n        x, y, w, h = bounding_box(shape, background=Color.RED)\n\n        # Get the coordinates of the shape\n        shape_coordinates = np.argwhere(shape != Color.RED)\n\n        # Create a blank grid to draw the outline\n        outline_grid = np.full(shape.shape, Color.RED)\n\n        # Draw the outline for the shape\n        for coord in shape_coordinates:\n            cx, cy = coord\n            # Check all 4 neighboring pixels to see if they are background\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                if (0 \u003c= cx + dx \u003c h) and (0 \u003c= cy + dy \u003c w):\n                    if shape[cx + dx, cy + dy] == Color.RED:\n                        outline_grid[cx, cy] = Color.BLACK\n                        break\n        \n        # Blit the outline onto the output grid\n        blit_object(output_grid, outline_grid, background=Color.RED)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a red background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.RED)\n\n    # Generate a random number of colored shapes\n    num_shapes = np.random.randint(1, 5)\n\n    for _ in range(num_shapes):\n        # Randomly choose dimensions for the shape\n        shape_height = np.random.randint(2, 6)\n        shape_width = np.random.randint(2, 6)\n        shape_color = np.random.choice(Color.GRAY)\n\n        # Create a random shape\n        sprite = random_sprite(shape_height, shape_width, density=0.5, color_palette=[shape_color])\n\n        # Find a random free location to place the shape in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.RED)\n        \n        # Blit the shape onto the grid\n        blit_sprite(grid, sprite, x, y, background=Color.RED)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/292/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/292/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/292/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/292/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/292/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/292/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/292/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/292/images/train_output_2.png"}]}, "index": 292, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, object merging, grid manipulation\n\n# description:\n# In the input, you will see a grid containing colored objects made up of 1x1 cells of various colors. \n# Some of these objects are adjacent to each other, and you need to identify any group of adjacent \n# colored cells (connected components) that form a shape with a specific size (e.g., 3x3 or larger). \n# To make the output, merge these connected components into a single block of that color, preserving \n# the shape but filling the interior cells completely with that color.\n\ndef main(input_grid):\n    # Detect colored objects and their shapes\n    detected_objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n    \n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    for obj in detected_objects:\n        # Crop the detected object\n        cropped_obj = crop(obj, background=Color.BLACK)\n        \n        # Get the color of the detected object\n        color = np.unique(cropped_obj[cropped_obj != Color.BLACK])\n        \n        if len(color) == 1:\n            color = color[0]  # Get the single color of the object\n            \n            # Get the dimensions of the cropped object\n            height, width = cropped_obj.shape\n            \n            # Merge the object into the output grid at the same location\n            blit_sprite(output_grid, np.full(cropped_obj.shape, color), x=0, y=0, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random colored objects\n    num_objects = np.random.randint(5, 10)\n\n    for _ in range(num_objects):\n        # Randomly generate the size of the object (between 1x1 to 3x3)\n        object_size = np.random.randint(1, 4)\n        \n        # Create a random color object\n        color = np.random.choice([c for c in Color.NOT_BLACK])\n        object_sprite = np.full((object_size, object_size), color)\n        \n        # Find a random location for the object\n        try:\n            x, y = random_free_location_for_sprite(grid, object_sprite, padding=1, padding_connectivity=8)\n            blit_sprite(grid, object_sprite, x=x, y=y)\n        except:\n            continue  # If placement fails, skip to the next object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/293/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/293/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/293/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/293/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/293/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/293/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/293/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/293/images/train_output_2.png"}]}, "index": 293, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric transformation, shape recognition, color filling\n\n# description:\n# In the input, you will see various colored shapes on a grey background. \n# To produce the output, identify the shapes and fill them with a contrasting color (e.g., black).\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color.\n    # 2. Extract connected components (shapes) from the grid.\n    # 3. Fill each shape with black (or another contrasting color).\n\n    # The background is the most common color\n    background = np.bincount(input_grid.flatten()).argmax()\n\n    # Find connected components (shapes)\n    objects = find_connected_components(input_grid, background=background, connectivity=4, monochromatic=False)\n\n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, fill_value=background)\n\n    # Fill each shape with black\n    for obj in objects:\n        shape_color = obj[0, 0]  # Get the color of the shape\n        if shape_color != background:\n            output_grid[obj != background] = Color.BLACK  # Fill the shape with black\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Generate a grid with a grey background.\n    # 2. Randomly create colored shapes of varying sizes and positions.\n\n    width, height = np.random.randint(10, 25, size=2)\n    input_grid = np.full((width, height), fill_value=Color.GREY)\n\n    n_shapes = np.random.randint(3, 6)\n    for _ in range(n_shapes):\n        # Random shape size\n        shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a random shape\n        shape_sprite = random_sprite(shape_width, shape_height, density=1, color_palette=[shape_color])\n        x, y = random_free_location_for_sprite(input_grid, shape_sprite, background=Color.GREY)\n\n        # Blit the shape onto the input grid\n        blit_sprite(input_grid, shape_sprite, x=x, y=y, background=Color.GREY)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/294/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/294/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/294/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/294/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/294/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/294/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/294/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/294/images/train_output_2.png"}]}, "index": 294, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, pixel connection\n\n# description:\n# In the input, you will see a colored shape made of pixels on a black background, with some additional colored pixels scattered around. \n# The goal is to connect each of the scattered colored pixels to the nearest edge of the colored shape by drawing a line of the same color. \n# If the pixel is already adjacent to the shape, it should not draw a line.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Identify the background color\n    background_color = Color.BLACK\n\n    # Find the connected components (the shape)\n    shape_objects = find_connected_components(output_grid, monochromatic=True, background=background_color)\n\n    # Assume the largest object is the shape we want to connect to\n    shape_object = max(shape_objects, key=lambda obj: np.sum(obj != background_color))\n\n    # Get the boundary of the shape\n    boundary_coords = np.argwhere(shape_object != background_color)\n    boundary_set = set(tuple(coord) for coord in boundary_coords)\n\n    # Now, find scattered colored pixels\n    scattered_pixels = np.argwhere((output_grid != background_color) \u0026 (output_grid != shape_object))\n    \n    for pixel in scattered_pixels:\n        x, y = pixel\n        pixel_color = output_grid[x, y]\n\n        # Check if the pixel is already adjacent to the shape\n        if any((x + dx, y + dy) in boundary_set for dx in [-1, 0, 1] for dy in [-1, 0, 1]):\n            continue  # skip if adjacent\n\n        # Otherwise, find the nearest edge of the shape to connect to\n        min_distance = float(\u0027inf\u0027)\n        nearest_edge = None\n\n        for bx, by in boundary_coords:\n            distance = abs(bx - x) + abs(by - y)  # Manhattan distance\n            if distance \u003c min_distance:\n                min_distance = distance\n                nearest_edge = (bx, by)\n\n        # Draw a line from the pixel to the nearest edge\n        if nearest_edge:\n            draw_line(output_grid, x, y, end_x=nearest_edge[0], end_y=nearest_edge[1], color=pixel_color)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate an empty grid with a black background\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a shape using random lines\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    shape_start_x, shape_start_y = np.random.randint(0, n - shape_height), np.random.randint(0, m - shape_width)\n\n    # Draw a filled rectangle as the shape\n    for i in range(shape_start_x, shape_start_x + shape_height):\n        for j in range(shape_start_y, shape_start_y + shape_width):\n            grid[i, j] = shape_color\n\n    # Scatter some pixels on the grid\n    num_scattered = np.random.randint(5, 15)\n    for _ in range(num_scattered):\n        scattered_color = np.random.choice(Color.NOT_BLACK)\n        while True:\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            if grid[x, y] == Color.BLACK:  # ensure it\u0027s on black background\n                grid[x, y] = scattered_color\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/295/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/295/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/295/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/295/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/295/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/295/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/295/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/295/images/train_output_2.png"}]}, "index": 295, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# distance mapping, color encoding\n\n# description:\n# In the input, you will see a grid with a central colored pixel and varying distances from that pixel. \n# To create the output, color each pixel based on its distance from the central pixel: \n# pixels that are 1 unit away should be colored blue, those 2 units away should be colored green, \n# and those 3 units away should be colored yellow. Pixels beyond 3 units should remain black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)  # Start with a black grid\n\n    # Find the central pixel\n    central_pixel_location = np.argwhere(input_grid != Color.BLACK)\n    if not central_pixel_location.size:\n        return output_grid  # If no colored pixel found, return black grid.\n\n    central_pixel = central_pixel_location[0]\n    cx, cy = central_pixel  # Central pixel coordinates\n\n    # Iterate through each pixel in the input grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            distance = abs(cx - x) + abs(cy - y)  # Manhattan distance\n            if distance == 1:\n                output_grid[x, y] = Color.BLUE\n            elif distance == 2:\n                output_grid[x, y] = Color.GREEN\n            elif distance == 3:\n                output_grid[x, y] = Color.YELLOW\n            # Pixels beyond 3 units remain black (value 0)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Position the central pixel randomly\n    cx, cy = np.random.randint(1, n-1), np.random.randint(1, m-1)\n    grid[cx, cy] = np.random.choice(Color.NOT_BLACK)  # Central pixel with any color except black\n\n    # Optionally scatter additional random pixels of different colors\n    num_other_pixels = np.random.randint(5, 15)  # Random number of other colored pixels\n    for _ in range(num_other_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if (x, y) != (cx, cy):  # Ensure not to overwrite the central pixel\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/296/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/296/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/296/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/296/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/296/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/296/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/296/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/296/images/train_output_2.png"}]}, "index": 296, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, color extraction, topmost layer\n\n# description:\n# In the input, you will see layers of colored shapes stacked on top of each other. \n# To produce the output, extract the color from the topmost layer and fill the entire output grid with that color, removing all other layers.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the topmost layer color (non-black pixel)\n    topmost_color = Color.BLACK  # Initialize with black\n    for row in output_grid:\n        for color in row:\n            if color != Color.BLACK:  # Found a non-black pixel\n                topmost_color = color\n                break\n        if topmost_color != Color.BLACK:\n            break\n\n    # Fill the entire grid with the topmost color\n    output_grid[:, :] = topmost_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define grid size\n    n, m = np.random.randint(5, 12), np.random.randint(5, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide how many layers to create\n    num_layers = np.random.randint(1, 6)\n\n    # Randomly create layers\n    for layer in range(num_layers):\n        # Create a random sprite for the layer\n        layer_sprite = random_sprite(n, m, density=0.3)\n        \n        # Randomly place the layer sprite in the grid\n        pos_x = np.random.randint(0, n)\n        pos_y = np.random.randint(0, m)\n        \n        # Blit the sprite onto the grid, allowing it to overlap\n        blit_sprite(grid, layer_sprite, pos_x, pos_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/297/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/297/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/297/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/297/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/297/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/297/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/297/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/297/images/train_output_2.png"}]}, "index": 297, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, scaling, color transformation\n\n# description:\n# In the input, you will see a colorful object surrounded by a black background.\n# To create the output, extract the object, scale it to double its size, and change its colors to their complementary hues.\n\ndef main(input_grid):\n    # Step 1: Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Step 2: Crop the object from the input grid\n    object_sprite = crop(output_grid, background=Color.BLACK)\n\n    # Step 3: Scale the object to double its size\n    scaled_sprite = np.kron(object_sprite, np.ones((2, 2)))  # Using Kronecker product to scale by 2\n\n    # Step 4: Get the complementary colors\n    color_map = {Color.RED: Color.BLUE, Color.GREEN: Color.PINK, Color.BLUE: Color.YELLOW,\n                 Color.BLUE: Color.RED, Color.PINK: Color.GREEN, Color.YELLOW: Color.BLUE,\n                 Color.PINK: Color.TEAL, Color.TEAL: Color.PINK, Color.ORANGE: Color.MAROON,\n                 Color.MAROON: Color.ORANGE}\n    \n    # Change colors to their complementary hues\n    for original_color, comp_color in color_map.items():\n        scaled_sprite[scaled_sprite == original_color] = comp_color\n\n    # Step 5: Create an empty output grid of the appropriate size\n    output_grid = np.full((scaled_sprite.shape[0], scaled_sprite.shape[1]), Color.BLACK)\n\n    # Step 6: Blit the scaled sprite onto the output grid\n    blit_sprite(output_grid, scaled_sprite, 0, 0)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random dimensions between 10x10 and 15x15\n    n = np.random.randint(10, 15)\n    m = np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a random sprite of size between 2x2 and 6x6 with random colors\n    w = np.random.randint(2, 7)\n    h = np.random.randint(2, 7)\n    sprite_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(w, h, density=0.8, color_palette=[sprite_color])\n\n    # Blit the sprite onto a random location within the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/298/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/298/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/298/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/298/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/298/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/298/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/298/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/298/images/train_output_2.png"}]}, "index": 298, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object merging, color blending\n\n# description:\n# In the input, you will see several colored objects (shapes) on a black background. The objects may overlap with each other.\n# To create the output, you should merge the overlapping objects. If two or more objects overlap, the overlapping area should take on a new color that is the blend of the colors of the overlapping objects.\n# For example, if a red object overlaps with a blue object, the overlapping area should be gray. If an object overlaps with itself, it retains its original color.\n\ndef main(input_grid):\n    # Identify all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Initialize the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Create a color blending function\n    def blend_colors(colors):\n        # Simple blending logic: if there are two colors, return a mixed color (e.g., average), for three colors, blend them further etc.\n        unique_colors = set(colors)\n        if len(unique_colors) == 1:\n            return unique_colors.pop()\n        elif Color.RED in unique_colors and Color.BLUE in unique_colors:\n            return Color.GRAY\n        elif Color.RED in unique_colors and Color.YELLOW in unique_colors:\n            return Color.ORANGE\n        elif Color.BLUE in unique_colors and Color.YELLOW in unique_colors:\n            return Color.GREEN\n        # Add more blending rules as needed\n        return Color.BLACK  # Default case\n\n    # Create a mask to keep track of where colors have been placed\n    color_mask = np.full(input_grid.shape, Color.BLACK)\n\n    for obj in objects:\n        # Get the bounding box for the object to process it\n        x, y, w, h = bounding_box(obj)\n\n        # Extract the object\n        cropped_obj = crop(obj, background=Color.BLACK)\n\n        # Blend colors in the overlapping region\n        for i in range(cropped_obj.shape[0]):\n            for j in range(cropped_obj.shape[1]):\n                if cropped_obj[i, j] != Color.BLACK:\n                    # Get the existing color in the output grid\n                    existing_color = color_mask[y + i, x + j]\n                    if existing_color != Color.BLACK:\n                        # Blend the existing color with the new color\n                        blended_color = blend_colors([existing_color, cropped_obj[i, j]])\n                        output_grid[y + i, x + j] = blended_color\n                    else:\n                        # If no existing color, just place the new color\n                        output_grid[y + i, x + j] = cropped_obj[i, j]\n                    # Update the color mask\n                    color_mask[y + i, x + j] = output_grid[y + i, x + j]\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of objects (between 3 and 5)\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Create a random sprite representing an object\n        width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n        sprite = random_sprite(width, height, density=0.7, color_palette=Color.NOT_BLACK)\n\n        # Find a random free location for this sprite and blit it to the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/299/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/299/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/299/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/299/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/299/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/299/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/299/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/299/images/train_output_2.png"}]}, "index": 299, "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# extraction, rotation, positioning\n\n# description:\n# In the input, you will see a grid with several colored blocks, one of which is enclosed by a blue border. \n# To make the output, extract the object within the blue border, rotate it 180 degrees, and place it in the center of a new grid.\n\ndef main(input_grid):\n    # Step 1: Detect the blue border object\n    blue_border_color = Color.BLUE\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK)\n    \n    # Filter to find the object with a blue border\n    bordered_object = None\n    for obj in objects:\n        if np.any(obj == blue_border_color):  # Check if the object contains blue\n            bordered_object = obj\n            break\n    \n    assert bordered_object is not None, \"There should be exactly one object with a blue border\"\n\n    # Step 2: Crop to just the object inside the blue border\n    extracted_object = crop(bordered_object, background=blue_border_color)\n\n    # Step 3: Rotate the extracted object 180 degrees\n    rotated_object = np.rot90(extracted_object, k=2)\n\n    # Step 4: Create a new output grid\n    output_grid_size = (10, 10)\n    output_grid = np.full(output_grid_size, Color.BLACK)\n\n    # Step 5: Calculate position to place the rotated object in the center of the output grid\n    center_x = (output_grid_size[0] - rotated_object.shape[0]) // 2\n    center_y = (output_grid_size[1] - rotated_object.shape[1]) // 2\n\n    # Step 6: Place the rotated object in the center of the output grid\n    blit_sprite(output_grid, rotated_object, x=center_x, y=center_y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random colors and a blue bordered shape\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Define the blue border\n    border_size = np.random.randint(3, 6)\n    x_start = np.random.randint(0, grid_size - border_size)\n    y_start = np.random.randint(0, grid_size - border_size)\n\n    # Draw blue border\n    draw_line(grid, x=x_start, y=y_start, end_x=x_start + border_size - 1, end_y=y_start, color=Color.BLUE)  # Top border\n    draw_line(grid, x=x_start, y=y_start + border_size - 1, end_x=x_start + border_size - 1, end_y=y_start + border_size - 1, color=Color.BLUE)  # Bottom border\n    draw_line(grid, x=x_start, y=y_start, end_x=x_start, end_y=y_start + border_size - 1, color=Color.BLUE)  # Left border\n    draw_line(grid, x=x_start + border_size - 1, y=y_start, end_x=x_start + border_size - 1, end_y=y_start + border_size - 1, color=Color.BLUE)  # Right border\n\n    # Fill the inside with random colors (except blue)\n    inside_colors = [color for color in Color.NOT_BLACK if color != Color.BLUE]\n    for i in range(x_start + 1, x_start + border_size - 1):\n        for j in range(y_start + 1, y_start + border_size - 1):\n            grid[i, j] = np.random.choice(inside_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/0/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/0/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/0/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/0/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/0/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/0/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/0/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/0/images/train_output_2.png"}]}, "index": 0, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color transformation\n\n# description:\n# In the input you will see a grid with different colors of pixels scattered on the grid.\n# To make the output grid, you should first only scale the pixels by 2 times, \n# then scale the whole grid 2 times. Finally, change all red pixels to blue.\n\ndef main(input_grid):\n    # Step 1: Detect all the colored pixels\n    pixel_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK,\n                                   allowed_dimensions=[(1, 1)],\n                                   monochromatic=True, connectivity=4)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    scale_factor = 2\n    for obj in pixel_objects:\n        # Get the position of each colored pixel, and crop it to produce a sprite\n        x, y = object_position(obj, background=Color.BLACK, anchor=\"upper left\")\n        single_pixel_sprite = crop(obj, background=Color.BLACK)\n\n        # Scale the sprite by `scale_factor` times\n        scaled_sprite = scale_sprite(single_pixel_sprite, scale_factor)\n\n        # The coordinate of the scaled pattern (anchored at the upper left)\n        new_x, new_y = x * scale_factor, y * scale_factor\n\n        # Put the scaled pattern on the output grid\n        output_grid = blit_sprite(grid=output_grid, x=new_x, y=new_y, sprite=scaled_sprite, background=Color.BLACK)\n\n    # Step 2: Scale the whole grid by scale_factor times\n    output_grid = scale_sprite(output_grid, scale_factor)\n\n    # Step 3: Change all red pixels to blue\n    output_grid[output_grid == Color.RED] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_size = 10\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # randomly scatter the pixels on the grid\n    density = 0.4\n    colors = Color.NOT_BLACK\n    for x in range(grid_size):\n        for y in range(grid_size):\n            # Randomly scatter the pixels on the grid\n            if np.random.rand() \u003c density:\n                grid[x, y] = np.random.choice(colors)\n    \n    # Ensure some red pixels are present for transformation\n    num_red_pixels = np.random.randint(1, 5)\n    for _ in range(num_red_pixels):\n        x, y = np.random.randint(0, grid_size), np.random.randint(0, grid_size)\n        grid[x, y] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/1/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/1/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/1/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/1/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/1/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/1/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/1/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/1/images/train_output_2.png"}]}, "index": 1, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, transformation\n\n# description:\n# In the input, you will see a colorful pattern. To create the output, \n# you should reflect the pattern across the y-axis and then reflect the \n# resulting pattern across the x-axis.\n\ndef main(input_grid):\n    # Reflect the pattern across the y-axis\n    reflected_y = input_grid[:, ::-1]\n    \n    # Reflect the result across the x-axis\n    output_grid = reflected_y[::-1]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random square pattern of random size and colors\n    n = m = np.random.randint(3, 6)  # Size of the pattern (between 3 and 5)\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/2/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/2/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/2/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/2/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/2/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/2/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/2/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/2/images/train_output_2.png"}]}, "index": 2, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object placement, color sorting\n\n# description:\n# In the input, you will see a grid with multiple shapes of different colors scattered around.\n# To make the output, arrange the shapes so that they form a larger shape.\n# The shapes should not overlap, and they should be placed based on their color:\n# red shapes should be on the left, green shapes in the center, and blue shapes on the right.\n\ndef main(input_grid):\n    # Step 1: Find all the colored shapes in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Step 2: Separate the shapes based on color\n    red_shapes = [obj for obj in objects if object_colors(obj)[0] == Color.RED]\n    green_shapes = [obj for obj in objects if object_colors(obj)[0] == Color.GREEN]\n    blue_shapes = [obj for obj in objects if object_colors(obj)[0] == Color.BLUE]\n\n    # Step 3: Create an output grid that is wide enough to fit all shapes side by side\n    max_height = max(len(obj) for obj in objects) if objects else 0\n    output_width = sum(max(len(shape), 1) for shape in [red_shapes, green_shapes, blue_shapes])\n    output_grid = np.full((max_height, output_width), Color.BLACK)\n\n    # Step 4: Place red shapes on the left\n    current_x = 0\n    for shape in red_shapes:\n        shape_cropped = crop(shape)\n        blit_sprite(output_grid, shape_cropped, x=current_x, y=0)\n        current_x += shape_cropped.shape[1]\n\n    # Step 5: Place green shapes in the center\n    current_x = len(red_shapes)\n    for shape in green_shapes:\n        shape_cropped = crop(shape)\n        blit_sprite(output_grid, shape_cropped, x=current_x, y=0)\n        current_x += shape_cropped.shape[1]\n\n    # Step 6: Place blue shapes on the right\n    current_x = len(red_shapes) + len(green_shapes)\n    for shape in blue_shapes:\n        shape_cropped = crop(shape)\n        blit_sprite(output_grid, shape_cropped, x=current_x, y=0)\n        current_x += shape_cropped.shape[1]\n\n    return output_grid\n\n\ndef generate_input():\n    # Create an empty black grid\n    grid_height = np.random.randint(10, 20)\n    grid_width = np.random.randint(15, 30)\n    grid = np.full((grid_height, grid_width), Color.BLACK)\n\n    # Randomly decide how many shapes of each color to create\n    num_red_shapes = np.random.randint(1, 4)\n    num_green_shapes = np.random.randint(1, 4)\n    num_blue_shapes = np.random.randint(1, 4)\n\n    # Generate red shapes\n    for _ in range(num_red_shapes):\n        shape_size = np.random.randint(2, 5)\n        red_shape = random_sprite(shape_size, shape_size, color_palette=[Color.RED])\n        x, y = random_free_location_for_sprite(grid, red_shape)\n        blit_sprite(grid, red_shape, x, y)\n\n    # Generate green shapes\n    for _ in range(num_green_shapes):\n        shape_size = np.random.randint(2, 5)\n        green_shape = random_sprite(shape_size, shape_size, color_palette=[Color.GREEN])\n        x, y = random_free_location_for_sprite(grid, green_shape)\n        blit_sprite(grid, green_shape, x, y)\n\n    # Generate blue shapes\n    for _ in range(num_blue_shapes):\n        shape_size = np.random.randint(2, 5)\n        blue_shape = random_sprite(shape_size, shape_size, color_palette=[Color.BLUE])\n        x, y = random_free_location_for_sprite(grid, blue_shape)\n        blit_sprite(grid, blue_shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/3/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/3/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/3/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/3/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/3/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/3/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/3/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/3/images/train_output_2.png"}]}, "index": 3, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cropping, resizing, scaling\n\n# description:\n# In the input, you will see a colored object on a black background. The object can be of any size, but it should not exceed a certain maximum size.\n# The output grid should resize the object to a fixed size (for example, 5x5) and place it in the center of a new black background grid.\n# If the object is smaller than the target size, it should be scaled up; if it is larger, it should be scaled down.\n\ndef main(input_grid):\n    # Crop the object from the input grid\n    object_cropped = crop(input_grid, background=Color.BLACK)\n    \n    # Resize the object to a fixed size of 5x5\n    target_size = (5, 5)\n    resized_object = np.full(target_size, Color.BLACK, dtype=int)\n\n    # Calculate the scaling factors\n    scale_x = target_size[0] / object_cropped.shape[0]\n    scale_y = target_size[1] / object_cropped.shape[1]\n\n    # Create a scaled version of the object\n    for x in range(target_size[0]):\n        for y in range(target_size[1]):\n            # Calculate the original coordinates for the scaling\n            orig_x = int(x / scale_x)\n            orig_y = int(y / scale_y)\n\n            # Check if the original coordinates are within bounds of the cropped object\n            if orig_x \u003c object_cropped.shape[0] and orig_y \u003c object_cropped.shape[1]:\n                resized_object[x, y] = object_cropped[orig_x, orig_y]\n\n    return resized_object\n\ndef generate_input():\n    # Create a grid of random size (8x8 to 12x12)\n    n = np.random.randint(8, 13)\n    m = np.random.randint(8, 13)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a random sprite with dimensions between 2 and 6\n    sprite_width = np.random.randint(2, 7)\n    sprite_height = np.random.randint(2, 7)\n    sprite = random_sprite(n=sprite_height, m=sprite_width, color_palette=[np.random.choice(Color.NOT_BLACK)])\n\n    # Place the sprite in a random location in the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/4/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/4/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/4/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/4/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/4/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/4/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/4/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/4/images/train_output_2.png"}]}, "index": 4, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input you will see a grid with a single colored rectangle (non-black) surrounded by a black background.\n# To make the output, rotate that rectangle by 90 degrees clockwise and change its color to blue.\n\ndef main(input_grid):\n    # Find the bounding box of the non-black pixels (the rectangle)\n    x, y, width, height = bounding_box(grid=input_grid, background=Color.BLACK)\n    rectangle = input_grid[x:x + width, y:y + height]\n\n    # Rotate the rectangle by 90 degrees clockwise\n    rotated_rectangle = np.rot90(rectangle, -1)  # -1 for clockwise rotation\n\n    # Create the output grid by copying the input grid\n    output_grid = np.copy(input_grid)\n\n    # Clear the area where the original rectangle was\n    output_grid[x:x + width, y:y + height] = Color.BLACK\n\n    # Change the color of the rotated rectangle to blue\n    rotated_rectangle[rotated_rectangle != Color.BLACK] = Color.BLUE\n\n    # Place the rotated rectangle back into the output grid\n    output_grid[x:x + rotated_rectangle.shape[0], y:y + rotated_rectangle.shape[1]] = rotated_rectangle\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a rectangle with a size of x_len x y_len\n    x_len = np.random.randint(2, 5)\n    y_len = np.random.randint(2, 5)\n\n    # Create a rectangle sprite with a non-black color (e.g., teal)\n    rectangle_sprite = random_sprite(n=x_len, m=y_len, color_palette=[Color.TEAL], density=1.0)\n\n    # Randomly choose a position to draw the rectangle\n    x, y = random_free_location_for_sprite(grid=grid, sprite=rectangle_sprite, border_size=1)\n    grid = blit_sprite(grid=grid, sprite=rectangle_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/5/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/5/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/5/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/5/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/5/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/5/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/5/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/5/images/train_output_2.png"}]}, "index": 5, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object detection\n\n# description:\n# In the input, you will see a grid containing one circular object of a specific color. \n# To make the output, change the color of the circular object to a specified target color, \n# while ensuring to maintain the object\u0027s shape and position.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the circular object in the grid.\n    # 2. Change its color to the target color.\n    \n    # Detect the circular object (assuming it is the only object)\n    circular_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=4)\n    \n    # Assert we found exactly one circular object\n    assert len(circular_objects) == 1\n    circular_object = circular_objects[0]\n\n    # Create an output grid based on the input\n    output_grid = np.copy(input_grid)\n\n    # Change the color of the object to the target color (e.g., Color.PINK)\n    output_grid[circular_object != Color.BLACK] = Color.PINK\n\n    return output_grid\n\ndef generate_input():\n    # Make a black grid of size 7x7\n    n = m = 7\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a circular object randomly\n    radius = np.random.randint(1, 3)  # Choose a small radius for the circular object\n    center_x = np.random.randint(radius, n - radius)\n    center_y = np.random.randint(radius, m - radius)\n\n    # Create the circular object\n    for x in range(center_x - radius, center_x + radius + 1):\n        for y in range(center_y - radius, center_y + radius + 1):\n            if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                grid[x, y] = Color.GREEN  # Use green for the circular object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/6/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/6/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/6/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/6/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/6/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/6/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/6/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/6/images/train_output_2.png"}]}, "index": 6, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, color layering\n\n# description:\n# In the input you will see a grid with a pattern of colored pixels. \n# To make the output, translate the pattern down by two pixels and overlay it with the original pattern, blending the colors. \n# If a pixel in the original and translated positions overlap, the resulting pixel color is a mix of the two colors.\n\ndef blend_colors(color1, color2):\n    # Simple blending function: average the colors.\n    return Color.RED if (color1 == color2) else Color.GREEN  # Use RED for same colors, GREEN for different colors\n\ndef main(input_grid):\n    # Get the connected components (the colored patterns)\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n\n    # Create an output grid initialized with BLACK\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Translate each object down by 2 pixels\n    for obj in objects:\n        # Get the position and colors of the object\n        x, y = object_position(obj)\n        colors = object_colors(obj)\n\n        # Draw the original pattern onto the output grid\n        for i in range(obj.shape[0]):\n            for j in range(obj.shape[1]):\n                if obj[i, j] != Color.BLACK:\n                    output_grid[x + i, y + j] = obj[i, j]\n                    # Overlay the translated pattern 2 pixels down\n                    if x + i + 2 \u003c output_grid.shape[0]:  # Ensure we don\u0027t go out of bounds\n                        if output_grid[x + i + 2, y + j] != Color.BLACK:\n                            # Blend colors if there is already a color present\n                            output_grid[x + i + 2, y + j] = blend_colors(output_grid[x + i + 2, y + j], obj[i, j])\n                        else:\n                            output_grid[x + i + 2, y + j] = obj[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Choose a number of patterns to add\n    num_patterns = np.random.randint(1, 4)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_patterns, replace=False)\n\n    # Randomly place patterns in the grid\n    for color in colors:\n        # Randomly define size and position for the pattern\n        pattern_width, pattern_height = np.random.randint(1, 4, size=2)\n        x, y = np.random.randint(0, width - pattern_width), np.random.randint(0, height - pattern_height - 2)\n\n        # Draw the pattern in the grid\n        for i in range(pattern_width):\n            for j in range(pattern_height):\n                if (i + x \u003c width) and (j + y \u003c height):\n                    grid[x + i, y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/7/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/7/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/7/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/7/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/7/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/7/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/7/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/7/images/train_output_2.png"}]}, "index": 7, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, rotation, grid transformation\n\n# description:\n# In the input, you will see a symmetric pattern at the center of the grid. \n# Your task is to rotate this pattern 90 degrees clockwise and place it in the output grid.\n# Additionally, you should also include the original pattern in the output grid.\n\ndef main(input_grid):\n    # Create an empty output grid of the same size as input\n    n, m = input_grid.shape\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # Find the bounding box of the symmetric pattern\n    objects = find_connected_components(grid=input_grid, background=Color.BLACK)\n    symmetric_object = max(objects, key=lambda obj: object_position(obj, background=Color.BLACK))\n\n    # Get the bounding box of the symmetric pattern\n    x, y, w, h = bounding_box(symmetric_object, background=Color.BLACK)\n\n    # Crop the symmetric pattern\n    pattern = crop(symmetric_object, background=Color.BLACK)\n    \n    # Rotate the pattern 90 degrees clockwise\n    rotated_pattern = np.rot90(pattern, -1)  # -1 indicates clockwise rotation\n\n    # Place the original pattern in the output grid\n    output_grid = blit_sprite(output_grid, sprite=pattern, x=x, y=y)\n\n    # Calculate the new position to place the rotated pattern\n    # Center the rotated pattern in the same space as the original pattern\n    new_x = x + (w - rotated_pattern.shape[0]) // 2\n    new_y = y + (h - rotated_pattern.shape[1]) // 2\n\n    # Place the rotated pattern in the output grid\n    output_grid = blit_sprite(output_grid, sprite=rotated_pattern, x=new_x, y=new_y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 2D background\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a symmetric pattern in the middle of the grid\n    pattern_color = Color.GREEN\n    symmetric_sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6),\n                                     color_palette=[pattern_color], connectivity=8, \n                                     symmetry=\"mirror\")\n\n    # Place the symmetric pattern in the center of the grid\n    center_x = n // 2 - symmetric_sprite.shape[0] // 2\n    center_y = m // 2 - symmetric_sprite.shape[1] // 2\n    grid = blit_sprite(grid, symmetric_sprite, center_x, center_y)\n\n    # Randomly rotate the grid to create variety in the appearance\n    if np.random.rand() \u003c 0.5:\n        grid = np.rot90(grid, k=np.random.randint(4))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/8/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/8/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/8/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/8/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/8/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/8/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/8/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/8/images/train_output_2.png"}]}, "index": 8, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# path creation, color filling, grid manipulation\n\n# description:\n# In the input you will see a grid with a single colored pixel surrounded by empty pixels. \n# To make the output, create a path from the colored pixel to all four edges of the grid. \n# The path should be colored with the same color as the original pixel. \n# The path must be drawn horizontally and vertically until it hits the edge of the grid.\n\ndef main(input_grid):\n    # Find the single colored pixel in the grid\n    colored_pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(colored_pixel)\n    pixel_color = object_colors(colored_pixel)[0]\n    \n    # Initialize the output grid with the same background\n    output_grid = np.zeros_like(input_grid)\n\n    # Draw paths to all four edges\n    # Draw to the top edge\n    draw_line(output_grid, x=pixel_x, y=pixel_y, direction=(0, -1), color=pixel_color)\n    # Draw to the bottom edge\n    draw_line(output_grid, x=pixel_x, y=pixel_y, direction=(0, 1), color=pixel_color)\n    # Draw to the left edge\n    draw_line(output_grid, x=pixel_x, y=pixel_y, direction=(-1, 0), color=pixel_color)\n    # Draw to the right edge\n    draw_line(output_grid, x=pixel_x, y=pixel_y, direction=(1, 0), color=pixel_color)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color for the pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place a single colored pixel in the grid\n    x, y = np.random.randint(1, n-1), np.random.randint(1, m-1)  # Avoid edges\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/9/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/9/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/9/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/9/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/9/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/9/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/9/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/9/images/train_output_2.png"}]}, "index": 9, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transition, radial expansion\n\n# description:\n# In the input you will see a square of a certain color. \n# To make the output, you need to expand that square into a larger square, \n# and transition its color to a lighter shade while maintaining its original hue.\n\ndef main(input_grid):\n    # Find the square in the input grid\n    square_objects = find_connected_components(grid=input_grid, monochromatic=True, connectivity=4)\n    \n    # Prepare the output grid of the same size as input\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Iterate through each square object found in the input\n    for square in square_objects:\n        # Get the bounding box of the square\n        x, y, w, h = bounding_box(square)\n        original_color = square[0, 0]  # All pixels in the square have the same color\n        \n        # Transition to a lighter shade (for simplicity, let\u0027s just pick a lighter color)\n        lighter_color = transition_color(original_color)\n\n        # Expand the square - for example, expanding it to twice its size\n        new_size = max(w, h) * 2\n        expanded_square = np.full((new_size, new_size), lighter_color)\n\n        # Center the expanded square on the original square\u0027s position\n        new_x = x - (new_size - w) // 2\n        new_y = y - (new_size - h) // 2\n        blit_sprite(output_grid, expanded_square, new_x, new_y, background=Color.BLACK)\n    \n    return output_grid\n\ndef transition_color(color):\n    # A simple function to return a lighter shade of a color\n    # This is a placeholder; in practice, you would define how to lighten a color.\n    lighter_shade_map = {\n        Color.RED: Color.PINK,\n        Color.GREEN: Color.TEAL,  # Assume LIGHT_GREEN is defined somewhere\n        Color.BLUE: Color.RED,      # Assume LIGHT_BLUE is defined somewhere\n        Color.YELLOW: Color.MAROON,  # Assume LIGHT_YELLOW is defined somewhere\n        Color.MAROON: Color.RED,  # Assume LIGHT_MAROON is defined somewhere\n        Color.ORANGE: Color.BLUE,  # Assume LIGHT_ORANGE is defined somewhere\n        Color.TEAL: Color.GREEN,      # Assume LIGHT_TEAL is defined somewhere\n        Color.GREY: Color.GREEN,      # Assume LIGHT_GREY is defined somewhere\n        Color.PINK: Color.GREY,      # Assume LIGHT_PINK is defined somewhere\n        Color.BLACK: Color.GREY             # Lighten black to grey\n    }\n    return lighter_shade_map.get(color, color)  # Default to original color if not found\n\ndef generate_input():\n    # Generate a random grid of size n x n\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Randomly choose a size for the square\n    square_size = np.random.randint(2, 5)\n    square_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly find a position for the square\n    x = np.random.randint(0, n - square_size)\n    y = np.random.randint(0, n - square_size)\n\n    # Create the square and place it in the grid\n    square = np.full((square_size, square_size), square_color)\n    blit_sprite(grid, square, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/10/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/10/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/10/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/10/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/10/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/10/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/10/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/10/images/train_output_2.png"}]}, "index": 10, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation\n\n# description:\n# In the input you will see several colored circles on a grid. Each circle has a specific color and is surrounded by a black background.\n# To make the output grid, rotate each circle 180 degrees (flipping it upside down), and change its color to a new color based on a predefined mapping.\n\ndef main(input_grid):\n    # Define the color mapping\n    color_mapping = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN,\n        Color.PINK: Color.MAROON,\n        Color.MAROON: Color.PINK,\n        Color.TEAL: Color.GREY,\n        Color.GREY: Color.TEAL,\n        # Colors that don\u0027t change remain the same (like BLACK)\n        Color.BLACK: Color.BLACK,\n    }\n\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (circles) in the grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8, background=background)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj, background=background)\n        # Crop the object from the grid\n        sprite = crop(obj, background=background)\n\n        # Determine the new color based on the original color\n        original_color = object_colors(obj, background=background)[0]\n        new_color = color_mapping.get(original_color, original_color)  # Default to original if not found\n\n        # Rotate the sprite 180 degrees (which is two 90-degree rotations)\n        sprite_rotated = np.rot90(sprite, k=2)\n\n        # Change the color of the rotated sprite\n        sprite_rotated[sprite_rotated == original_color] = new_color\n\n        # Place the rotated and recolored sprite back into the output grid\n        blit_sprite(output_grid, sprite=sprite_rotated, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random circles of color\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Add a random number of colored circles\n    num_circles = np.random.randint(3, 8)\n\n    for _ in range(num_circles):\n        # Randomly choose a color for the circle\n        color = np.random.choice([Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.MAROON, Color.TEAL, Color.GREY])\n        \n        # Generate a random circle sprite\n        circle_radius = np.random.randint(2, 5)\n        circle_sprite = random_sprite(n=circle_radius * 2 + 1, m=circle_radius * 2 + 1, density=0.5, color_palette=[color])\n\n        # Randomly place the circle on the grid\n        x, y = random_free_location_for_sprite(grid, circle_sprite, padding=1, padding_connectivity=8)\n        blit_sprite(grid, circle_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/11/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/11/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/11/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/11/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/11/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/11/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/11/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/11/images/train_output_2.png"}]}, "index": 11, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirror, reflection, pixel manipulation\n\n# description:\n# In the input you will see a grid with a single colored pixel on a black background.\n# To make the output, draw a mirror image of the grid, with the mirror line being the horizontal line passing through the colored pixel.\n# The color of the reflection should be the same as the color of the original pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the position and color of the colored pixel.\n    # 2. Create an output grid that mirrors the input grid across the row containing the colored pixel.\n\n    # 1. Find the colored pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # 2. Create an output grid\n    output_grid = np.copy(input_grid)\n\n    # Mirror the grid along the horizontal line passing through the colored pixel\n    for x in range(output_grid.shape[0]):\n        if pixel_x + (pixel_x - x) \u003e= 0:  # Check if the mirrored position is within bounds\n            output_grid[x, pixel_y] = pixel_color\n            if (pixel_x - x) != x:  # Avoid double writing for the mirrored pixel itself\n                output_grid[pixel_x + (pixel_x - x), pixel_y] = pixel_color\n            \n    return output_grid\n\ndef generate_input():\n    # Create a grid with a single colored pixel on a black background\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly place a colored pixel\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/12/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/12/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/12/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/12/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/12/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/12/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/12/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/12/images/train_output_2.png"}]}, "index": 12, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# repeating pattern, rotation\n\n# description:\n# In the input grid, you will see a pattern consisting of three dots of the same color in a perfect 45 degree diagonal, but equally spaced apart from each other.\n# To create the output grid, rotate the pattern 90 degrees clockwise and repeat it to fill the grid.\n\ndef main(input_grid):\n    # 1. Identify the three colored dots in the input grid.\n    # 2. Determine the positions of the dots.\n    # 3. Create a new output grid and fill it by rotating the pattern.\n\n    # Identify the colored pixels\n    pixel_xs, pixel_ys = np.where(input_grid != Color.BLACK)\n    pixel_locations = list(zip(pixel_xs, pixel_ys))\n    assert len(pixel_locations) == 3  # Ensure there are exactly 3 dots\n\n    # Sort the pixel locations to identify the pattern\n    pixel_locations.sort()  # Sort by y-coordinate (or x) to maintain order\n    color = input_grid[pixel_locations[0]]  # Get the color of the dots\n\n    # Calculate the distance between the dots\n    distance = pixel_locations[1][0] - pixel_locations[0][0]  # Distance in x or y\n\n    # Create the output grid\n    output_size = input_grid.shape[0] + (distance * 2)\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # Function to draw a dot\n    def draw_dot(grid, x, y, color):\n        if 0 \u003c= x \u003c grid.shape[0] and 0 \u003c= y \u003c grid.shape[1]:\n            grid[x, y] = color\n\n    # Fill the output grid by repeating the rotated pattern\n    for i in range(0, output_size, distance):\n        for j in range(0, output_size, distance):\n            # Draw the original pattern\n            draw_dot(output_grid, i, j, color)  # Original position\n            draw_dot(output_grid, i + distance, j, color)  # Top-right\n            draw_dot(output_grid, i, j + distance, color)  # Bottom-left\n            draw_dot(output_grid, i + distance, j + distance, color)  # Bottom-right\n\n    return output_grid\n\ndef generate_input():\n    # 1. Create a 28x28 black grid\n    # 2. Randomly select a distance for the dots\n    # 3. Place three dots in a 45-degree diagonal pattern\n\n    input_grid = np.full((28, 28), Color.BLACK)\n    distance = np.random.randint(3, 8)  # Random distance between 3 and 8\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly select a starting point for the first dot\n    start_x = np.random.randint(0, 28 - 2 * distance)\n    start_y = np.random.randint(0, 28 - 2 * distance)\n\n    # Place the dots in a 45-degree diagonal\n    input_grid[start_x, start_y] = color\n    input_grid[start_x + distance, start_y + distance] = color\n    input_grid[start_x + 2 * distance, start_y + 2 * distance] = color\n\n    # Randomly rotate the input grid sometimes\n    if np.random.rand() \u003c 0.5:\n        input_grid = np.rot90(input_grid)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/13/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/13/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/13/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/13/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/13/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/13/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/13/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/13/images/train_output_2.png"}]}, "index": 13, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color identification, object isolation\n\n# description:\n# In the input, you will see a grid with several colored objects. \n# Each object is a single solid color, with one object having a unique color that does not appear elsewhere.\n# To create the output grid, extract this uniquely colored object and fill the rest of the grid with a black background.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a blank output grid\n    # 2. Identify the unique color in the input grid\n    # 3. Extract the connected component of the uniquely colored object\n    # 4. Fill the output grid with the extracted object, while the rest remains black\n\n    output_grid = np.zeros_like(input_grid)\n\n    # 2. Identify the unique color\n    color_counts = {}\n    for color in Color.NOT_BLACK:\n        color_counts[color] = np.count_nonzero(input_grid == color)\n\n    unique_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    if unique_color is None:\n        raise ValueError(\"No unique color found in the input grid.\")\n\n    # 3. Extract the uniquely colored object\n    objects = detect_objects(input_grid, colors=[unique_color], monochromatic=True, connectivity=4)\n    if not objects:\n        raise ValueError(\"No objects found for the unique color.\")\n\n    unique_object = objects[0]  # Assuming the first object is the unique one\n    unique_object_cropped = crop(unique_object, background=Color.BLACK)\n\n    # 4. Place the unique object in the output grid\n    x_offset, y_offset = 0, 0  # Output grid starts from the top-left corner\n    blit_sprite(output_grid, unique_object_cropped, x_offset, y_offset, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid where one color is unique and appears only once\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a unique color from Color.NOT_BLACK\n    unique_color = random.choice(Color.NOT_BLACK)\n\n    # Ensure the unique color appears only once\n    unique_position = (np.random.randint(0, n), np.random.randint(0, m))\n    grid[unique_position] = unique_color\n\n    # Fill the rest of the grid with other colors\n    remaining_colors = [color for color in Color.NOT_BLACK if color != unique_color]\n\n    for i in range(n):\n        for j in range(m):\n            if (i, j) != unique_position:\n                # Randomly assign a color from the remaining colors\n                grid[i, j] = random.choice(remaining_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/14/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/14/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/14/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/14/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/14/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/14/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/14/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/14/images/train_output_2.png"}]}, "index": 14, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color replacement, shape detection\n\n# description:\n# In the input you will see several blue shapes (circles, squares, etc.) on a black background. \n# To make the output, replace the blue pixels with green pixels if they are part of a shape with an area of 5 or more pixels, \n# and replace them with yellow pixels if the area is less than 5 pixels.\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n    \n    shape_color = Color.BLUE\n    large_shape_color = Color.GREEN\n    small_shape_color = Color.YELLOW\n    background = Color.BLACK\n\n    # Find connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, background=background)\n\n    # Replace colors based on the area of each shape\n    for shape in shapes:\n        area = np.sum(shape == shape_color)\n        if area \u003e= 5:\n            output_grid[shape == shape_color] = large_shape_color\n        else:\n            output_grid[shape == shape_color] = small_shape_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of shapes\n    num_shapes = np.random.randint(3, 8)\n    for _ in range(num_shapes):\n        # Create a random shape with varying areas\n        shape_area = np.random.randint(1, 10)  # Shapes can have areas from 1 to 9 pixels\n        shape_type = np.random.choice([\u0027circle\u0027, \u0027square\u0027])\n\n        if shape_type == \u0027circle\u0027:\n            # Create a circular shape\n            radius = int(np.sqrt(shape_area / np.pi))\n            circle_sprite = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n            for x in range(circle_sprite.shape[0]):\n                for y in range(circle_sprite.shape[1]):\n                    if (x - radius) ** 2 + (y - radius) ** 2 \u003c= radius ** 2:\n                        circle_sprite[x, y] = Color.BLUE\n        \n            # Randomly place the circle\n            try:\n                x, y = random_free_location_for_sprite(grid, circle_sprite, padding=1, background=Color.BLACK)\n                blit_sprite(grid, circle_sprite, x=x, y=y)\n            except:\n                continue\n\n        elif shape_type == \u0027square\u0027:\n            # Create a square shape\n            side_length = int(np.sqrt(shape_area)) + 1  # Shapes can be slightly larger\n            square_sprite = np.full((side_length, side_length), Color.BLUE)\n            \n            # Randomly place the square\n            try:\n                x, y = random_free_location_for_sprite(grid, square_sprite, padding=1, background=Color.BLACK)\n                blit_sprite(grid, square_sprite, x=x, y=y)\n            except:\n                continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/15/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/15/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/15/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/15/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/15/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/15/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/15/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/15/images/train_output_2.png"}]}, "index": 15, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, resizing, mirroring\n\n# description:\n# In the input, you will see a grid with colored pixels, including a red square in the top left corner.\n# To create the output:\n# 1. Count the number of distinct colors in the grid, excluding red.\n# 2. Enlarge every pixel in the input grid by a factor equal to the count of distinct colors.\n# 3. Mirror the enlarged grid horizontally.\n\ndef main(input_grid):\n    # 1. Count the number of distinct colors excluding red\n    distinct_colors = len(set(input_grid.flatten()) - {Color.RED})\n\n    # 2. Enlarge the input grid by the number of distinct colors\n    output_grid = np.repeat(np.repeat(input_grid, distinct_colors, axis=0), distinct_colors, axis=1)\n\n    # 3. Mirror the enlarged grid horizontally\n    output_grid = np.flip(output_grid, axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 6x6 grid filled with red color\n    n, m = 6, 6\n    grid = np.full((n, m), Color.RED)\n\n    # Randomly scatter a few colors in the grid while avoiding red\n    colors = list(Color.NOT_BLACK)\n    num_colors = np.random.randint(2, 6)  # at least 2 colors\n    chosen_colors = np.random.choice(colors, num_colors, replace=False)\n\n    # Scatter colored pixels randomly in the grid\n    for color in chosen_colors:\n        num_pixels = np.random.randint(5, 15)  # random number of pixels for this color\n        for _ in range(num_pixels):\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            grid[x, y] = color\n\n    # Place a red square in the top left corner\n    red_square = np.full((2, 2), Color.RED)\n    blit_sprite(grid, red_square, 0, 0)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/16/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/16/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/16/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/16/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/16/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/16/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/16/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/16/images/train_output_2.png"}]}, "index": 16, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, reflection, symmetry\n\n# description:\n# In the input you will see a grid with a pattern of colors on one side (left or top). \n# To make the output, create a new grid that mirrors the pattern across the center line (vertical or horizontal) of the grid.\n\ndef main(input_grid):\n    n, m = input_grid.shape\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # Check if the pattern is on the left or top side\n    if np.any(input_grid[:, m//2:] != Color.BLACK):\n        # Mirror across the vertical center line\n        for i in range(n):\n            for j in range(m // 2):\n                output_grid[i, j] = input_grid[i, m - j - 1]\n                output_grid[i, m - j - 1] = input_grid[i, j]\n    else:\n        # Mirror across the horizontal center line\n        for i in range(n // 2):\n            for j in range(m):\n                output_grid[i, j] = input_grid[n - i - 1, j]\n                output_grid[n - i - 1, j] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Random grid dimensions\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Choose to fill either the left half or the top half\n    if np.random.rand() \u003c 0.5:\n        # Fill the left half\n        for i in range(n):\n            for j in range(m // 2):\n                if np.random.rand() \u003c 0.7:  # Randomly fill some pixels\n                    grid[i, j] = color\n    else:\n        # Fill the top half\n        for i in range(n // 2):\n            for j in range(m):\n                if np.random.rand() \u003c 0.7:  # Randomly fill some pixels\n                    grid[i, j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/17/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/17/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/17/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/17/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/17/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/17/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/17/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/17/images/train_output_2.png"}]}, "index": 17, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color mapping\n\n# description:\n# In the input, you will see a grid with several distinct shapes represented by different colors.\n# To create the output, color the shapes based on their area: \n# shapes with an area less than 5 will be colored blue, \n# areas between 5 and 10 will be colored green, \n# and shapes with an area greater than 10 will be colored red.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all the colored shapes in the grid\n    background_color = Color.BLACK\n    shapes = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background_color)\n\n    for shape in shapes:\n        area = np.sum(shape != background_color)\n\n        # Determine the new color based on the area of the shape\n        if area \u003c 5:\n            new_color = Color.BLUE\n        elif 5 \u003c= area \u003c= 10:\n            new_color = Color.GREEN\n        else:\n            new_color = Color.RED\n\n        # Color the shape with the new color\n        shape[shape != background_color] = new_color\n        output_grid = blit_object(output_grid, shape, background=background_color)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate shapes and place them in the grid\n    for _ in range(np.random.randint(3, 6)):\n        # Random dimensions for the shape\n        w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n        \n        # Generate a random shape with a random color (not black)\n        shape_color = np.random.choice(list(Color.NOT_BLACK))\n        shape = random_sprite(w, h, color_palette=[shape_color], density=0.5)\n\n        # Place the shape randomly within the grid\n        x, y = random_free_location_for_sprite(grid, shape)\n        grid = blit_sprite(grid, shape, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/18/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/18/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/18/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/18/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/18/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/18/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/18/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/18/images/train_output_2.png"}]}, "index": 18, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, color transformation\n\n# description:\n# In the input, you will see a grid containing several colored objects on a black background. Each object is represented by a single color.\n# To make the output, change the color of all boundary pixels of each object to gray, while keeping the inner pixels of each object the same color as in the input.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect all connected components (objects) in the grid.\n    # 2. For each object, change its boundary pixels to gray while keeping the inner pixels the same color.\n\n    output_grid = np.copy(input_grid)\n    \n    # 1. Find connected components (objects)\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj)\n        \n        # Change the boundary pixels to gray\n        for i in range(x, x + width):\n            for j in range(y, y + height):\n                if output_grid[i, j] == Color.BLACK:  # Only change if the pixel is part of the background\n                    continue\n                # Check if it is a boundary pixel\n                is_boundary = (i == x or i == x + width - 1 or j == y or j == y + height - 1)\n                if is_boundary:\n                    output_grid[i, j] = Color.GRAY\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid with random colored objects on a black background.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Number of objects to create\n    num_objects = np.random.randint(2, 5)\n\n    for _ in range(num_objects):\n        # Random size for the object\n        width, height = np.random.randint(2, 4), np.random.randint(2, 4)\n        color = random.choice(Color.NOT_BLACK)\n\n        # Find a random free location for the object\n        x, y = random_free_location_for_sprite(grid, np.full((width, height), color), background=Color.BLACK)\n\n        # Draw the object onto the grid\n        blit_sprite(grid, np.full((width, height), color), x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/19/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/19/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/19/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/19/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/19/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/19/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/19/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/19/images/train_output_2.png"}]}, "index": 19, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid tiling, pattern repetition\n\n# description:\n# In the input grid, you will see a small square pattern located in the center of the grid. \n# To make the output, you should tile this pattern to fill the entire grid. \n# The output grid should have the same dimensions as the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Calculate the size of the pattern by finding the bounding box of the non-black pixels\n    pattern_objects = find_connected_components(input_grid, background=Color.BLACK)\n    assert len(pattern_objects) == 1, \"Input should contain exactly one pattern\"\n    \n    # Crop the pattern\n    pattern = crop(pattern_objects[0], background=Color.BLACK)\n    pattern_height, pattern_width = pattern.shape\n\n    # Create the output grid with the same size as the input grid\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # Tile the pattern across the output grid\n    for i in range(0, n, pattern_height):\n        for j in range(0, m, pattern_width):\n            blit_sprite(output_grid, pattern, x=j, y=i, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size 10x10 with a black background\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly choose the size of the pattern (2 to 4)\n    pattern_size = np.random.randint(2, 5)\n\n    # Randomly select a color for the pattern\n    pattern_color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the pattern in the center of the grid\n    start_x = (grid_size - pattern_size) // 2\n    start_y = (grid_size - pattern_size) // 2\n\n    # Fill the center pattern with the selected color\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[start_x + i, start_y + j] = pattern_color if np.random.rand() \u003c 0.7 else Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/20/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/20/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/20/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/20/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/20/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/20/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/20/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/20/images/train_output_2.png"}]}, "index": 20, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mixing, area calculation, filling shapes\n\n# description:\n# In the input, you will see several colored shapes (circles or squares) on a black background.\n# To make the output, you should calculate the area of each shape and fill it with a mixed color based on the area:\n# - If the area is 1, fill with YELLOW.\n# - If the area is 4, fill with GREEN.\n# - If the area is 9, fill with BLUE.\n# - If the area is greater than 9, fill with RED.\n\ndef main(input_grid):\n    # Initialize the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Process each shape to calculate the area and fill with the appropriate color\n    for shape in shapes:\n        area = np.sum(shape != Color.BLACK)  # Calculate the area of the shape\n        color = Color.BLACK  # Default color\n        \n        # Determine the fill color based on the area\n        if area == 1:\n            color = Color.YELLOW\n        elif area == 4:\n            color = Color.GREEN\n        elif area == 9:\n            color = Color.BLUE\n        elif area \u003e 9:\n            color = Color.RED\n\n        # Fill the shape in the output grid with the determined color\n        output_grid[shape != Color.BLACK] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10 with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create a number of shapes\n    num_shapes = np.random.randint(3, 7)\n    for _ in range(num_shapes):\n        # Randomly choose a shape (circle or square)\n        shape_type = np.random.choice([\u0027circle\u0027, \u0027square\u0027])\n        shape_size = np.random.randint(1, 4)  # Size of the shape (1x1, 2x2, or 3x3)\n        \n        # Create the shape sprite\n        if shape_type == \u0027circle\u0027:\n            # Create a circular sprite using a mask\n            sprite = np.zeros((shape_size, shape_size), dtype=int)\n            rr, cc = np.ogrid[:shape_size, :shape_size]\n            mask = (rr - shape_size // 2) ** 2 + (cc - shape_size // 2) ** 2 \u003c= (shape_size // 2) ** 2\n            sprite[mask] = 1  # Fill the circle\n\n        elif shape_type == \u0027square\u0027:\n            sprite = np.ones((shape_size, shape_size), dtype=int)\n\n        # Try to place the shape on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no space was available, skip this shape\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/21/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/21/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/21/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/21/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/21/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/21/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/21/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/21/images/train_output_2.png"}]}, "index": 21, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel transformation, color filling, grid manipulation\n\n# description:\n# In the input you will see a grid with a single colored pixel in the center.\n# To make the output, you should expand outwards from the pixel, coloring all pixels in a diamond pattern.\n# The diamond pattern should alternate colors, starting from the pixel\u0027s color and changing to a different color on each layer.\n\ndef main(input_grid):\n    # Identify the center pixel and its color\n    center_color = input_grid[input_grid.shape[0] // 2, input_grid.shape[1] // 2]\n    if center_color == Color.BLACK:\n        raise ValueError(\"Center pixel must be colored.\")\n\n    # Create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # Get the dimensions of the grid\n    rows, cols = input_grid.shape\n    center_x, center_y = rows // 2, cols // 2\n\n    # Initialize the current color and the layer index\n    current_color = center_color\n    layer = 0\n\n    # Expand outwards in a diamond shape\n    while True:\n        # Calculate the boundaries of the current layer\n        if center_x - layer \u003c 0 or center_x + layer \u003e= rows or center_y - layer \u003c 0 or center_y + layer \u003e= cols:\n            break  # Stop if we go out of bounds\n        \n        # Color the diamond layer\n        for dx in range(-layer, layer + 1):\n            output_grid[center_x + dx, center_y + (layer - abs(dx))] = current_color\n            output_grid[center_x + dx, center_y - (layer - abs(dx))] = current_color\n\n        # Alternate color for the next layer\n        current_color = Color.BLACK if current_color != Color.BLACK else Color.RED  # Switch between two colors\n        layer += 1\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a single colored pixel in the center\n    n, m = np.random.randint(5, 11, size=2)\n    # Ensure n and m are odd for a center pixel\n    n += n % 2 == 0\n    m += m % 2 == 0\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a color for the center pixel\n    center_color = np.random.choice(Color.NOT_BLACK)\n    grid[n // 2, m // 2] = center_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/22/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/22/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/22/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/22/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/22/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/22/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/22/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/22/images/train_output_2.png"}]}, "index": 22, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern expansion, color transformation\n\n# description:\n# In the input you will see a grid with a circular pattern of colored pixels. \n# To make the output, you should expand the circular pattern outward, \n# filling in the surrounding area with the same color as the outermost pixels of the circle.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find the circular pattern in the input grid\n    # 2. Identify the outermost pixels of the circle\n    # 3. Create a new output grid and fill in the outer area with the outermost color\n\n    # Find the connected components (the circular pattern)\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1, \"exactly one circular pattern expected\"\n    \n    circle = objects[0]\n    outer_color = object_colors(circle, background=Color.BLACK)[0]  # Get the color of the outermost pixels\n\n    # Get the bounding box of the circle to determine its location\n    x, y, width, height = bounding_box(circle)\n    output_grid = np.full_like(input_grid, Color.BLACK)  # Create an output grid filled with black\n\n    # Expand the circle outwards\n    for i in range(x - 1, x + width + 1):\n        for j in range(y - 1, y + height + 1):\n            if 0 \u003c= i \u003c output_grid.shape[0] and 0 \u003c= j \u003c output_grid.shape[1]:\n                # If the current pixel is outside the original circle\n                if (i \u003c x or i \u003e= x + width) or (j \u003c y or j \u003e= y + height):\n                    output_grid[i, j] = outer_color  # Fill with the outermost color\n\n    # Overlay the original circular pattern on the output grid\n    blit_sprite(output_grid, circle, x, y)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random sized grid with black background\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly select a color for the circle\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Generate a random radius for the circle\n    radius = np.random.randint(2, min(width, height) // 4)\n\n    # Create a circular pattern\n    for i in range(-radius, radius + 1):\n        for j in range(-radius, radius + 1):\n            if i**2 + j**2 \u003c= radius**2:\n                x, y = radius + i, radius + j  # Center the circle in the grid\n                if 0 \u003c= x \u003c width and 0 \u003c= y \u003c height:\n                    grid[x, y] = color  # Set the pixel color to the chosen color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/23/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/23/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/23/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/23/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/23/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/23/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/23/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/23/images/train_output_2.png"}]}, "index": 23, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, transformation, alignment\n\n# description:\n# In the input, you will see a grid containing various multicolored shapes. Each shape is made of connected pixels of the same color, and the shapes can vary in size and form. To make the output, place each shape into a designated area within a fixed-size output grid such that all shapes are arranged in a compact manner, maintaining their original orientation and color. The output should fill the grid as much as possible without overlap.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all the distinct shapes in the input grid.\n    # 2. Create an output grid of fixed size.\n    # 3. Arrange the identified shapes in the output grid, ensuring they do not overlap and are placed as close together as possible.\n\n    # Step 1: Extract shapes from the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Step 2: Create an output grid of fixed size (10x10)\n    output_grid = np.full((10, 10), Color.BLACK)\n\n    # Track the current position to place shapes in the output grid\n    current_x, current_y = 0, 0\n\n    for shape in shapes:\n        # Step 3: Crop the shape to get its sprite representation\n        sprite = crop(shape, background=Color.BLACK)\n\n        # Check for space in the output grid and place the sprite\n        try:\n            # Blit the sprite into the output grid\n            blit_sprite(output_grid, sprite, x=current_x, y=current_y, background=Color.BLACK)\n\n            # Move to the next position in the output grid\n            current_y += sprite.shape[1]\n            if current_y \u003e= output_grid.shape[1]:  # If we exceed the row length, move to the next row\n                current_y = 0\n                current_x += sprite.shape[0]\n\n            # If current_x exceeds the grid height, break the loop\n            if current_x \u003e= output_grid.shape[0]:\n                break\n\n        except ValueError:\n            # If we cannot place a shape, we skip to the next shape\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size (15x15) filled with shapes\n    n, m = 15, 15\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the number of shapes to create\n    num_shapes = np.random.randint(5, 10)\n\n    for _ in range(num_shapes):\n        # Randomly generate a shape of random dimensions\n        shape_width = np.random.randint(3, 6)\n        shape_height = np.random.randint(3, 6)\n        shape = random_sprite(shape_height, shape_width, color_palette=Color.NOT_BLACK, density=0.5)\n\n        # Find a free location to place the shape in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, padding=1, background=Color.BLACK)\n            blit_sprite(grid, shape, x=x, y=y)\n        except ValueError:\n            # If no free location is found, we skip to the next shape\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/24/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/24/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/24/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/24/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/24/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/24/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/24/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/24/images/train_output_2.png"}]}, "index": 24, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, colors, direction\n\n# description:\n# In the input, you will see several colored lines organized in a grid. \n# Each line has a specific color: green lines move upwards, \n# yellow lines move downwards, and blue lines move horizontally. \n# The output should show the lines after they have moved in their respective directions. \n# Lines should stop when they either reach the edge of the grid or encounter another line of any color.\n\ndef main(input_grid):\n    # Start with a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n\n    # Process each color and draw the lines accordingly\n    for y in range(n):\n        for x in range(m):\n            color = output_grid[y, x]\n            if color == Color.GREEN:\n                # Move upwards\n                draw_line(output_grid, x, y, length=None, color=color, direction=(-1, 0), stop_at_color=[Color.GREEN, Color.YELLOW, Color.BLUE])\n            elif color == Color.YELLOW:\n                # Move downwards\n                draw_line(output_grid, x, y, length=None, color=color, direction=(1, 0), stop_at_color=[Color.GREEN, Color.YELLOW, Color.BLUE])\n            elif color == Color.BLUE:\n                # Move horizontally (to the right)\n                draw_line(output_grid, x, y, length=None, color=color, direction=(0, 1), stop_at_color=[Color.GREEN, Color.YELLOW, Color.BLUE])\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid with a black background\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Randomly place colored lines in the grid\n    num_lines = np.random.randint(5, 15)\n    for _ in range(num_lines):\n        # Randomly choose a color for the line\n        color = np.random.choice([Color.GREEN, Color.YELLOW, Color.BLUE])\n        # Randomly choose a starting position for the line\n        start_x = np.random.randint(0, 10)\n        start_y = np.random.randint(0, 10)\n        # Draw a line of length 3 in a random direction\n        if color == Color.GREEN:\n            draw_line(grid, start_x, start_y, length=3, color=color, direction=(-1, 0))  # Up\n        elif color == Color.YELLOW:\n            draw_line(grid, start_x, start_y, length=3, color=color, direction=(1, 0))   # Down\n        elif color == Color.BLUE:\n            draw_line(grid, start_x, start_y, length=3, color=color, direction=(0, 1))   # Right\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/25/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/25/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/25/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/25/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/25/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/25/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/25/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/25/images/train_output_2.png"}]}, "index": 25, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel growing, directional change\n\n# description:\n# In the input grid, you will see a single colored pixel. To produce the output, grow the pixel to the right by three pixels, \n# then change direction upwards and grow by three pixels, forming a right-angled line.\n\ndef main(input_grid):\n    # Find the single colored pixel in the input grid\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # Create an output grid based on the input grid\n    output_grid = input_grid.copy()\n\n    # Step 1: Grow the pixel to the right by 3 pixels\n    for dx in range(4):  # 0 to 3 inclusive\n        if pixel_x + dx \u003c output_grid.shape[0]:\n            output_grid[pixel_x + dx, pixel_y] = pixel_color\n\n    # Step 2: Change direction upwards and grow by 3 pixels\n    for dy in range(1, 4):  # 1 to 3 inclusive\n        if pixel_y - dy \u003e= 0:\n            output_grid[pixel_x + 3, pixel_y - dy] = pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly choose a color for the pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place a single colored pixel\n    x, y = np.random.randint(0, 20), np.random.randint(0, 20)\n    input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/26/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/26/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/26/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/26/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/26/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/26/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/26/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/26/images/train_output_2.png"}]}, "index": 26, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color correspondence, edge manipulation\n\n# description:\n# In the input, you will see a grid with a colored pixel at the center and colored pixels at the edges. \n# To make the output, you should rotate the edge pixels towards the center pixel in a clockwise direction. \n# The number of steps for the rotation corresponds to the color of the center pixel (e.g., red = 1 step, blue = 2 steps, etc.). \n# The colors correspond as follows: \n# Red = 1 step, Blue = 2 steps, Green = 3 steps, Yellow = 4 steps, Grey = 5 steps, \n# Pink = 6 steps, Orange = 7 steps, Teal = 8 steps, Maroon = 9 steps, and Black = 0 steps.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Get the center pixel\u0027s color and determine the number of steps\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    center_color = input_grid[center_x, center_y]\n    \n    # Map colors to rotation steps\n    color_to_steps = {\n        Color.RED: 1,\n        Color.BLUE: 2,\n        Color.GREEN: 3,\n        Color.YELLOW: 4,\n        Color.GREY: 5,\n        Color.PINK: 6,\n        Color.ORANGE: 7,\n        Color.TEAL: 8,\n        Color.MAROON: 9,\n        Color.BLACK: 0\n    }\n    \n    steps = color_to_steps.get(center_color, 0)\n    \n    # Define the edge positions (top, bottom, left, right)\n    edge_positions = [\n        [(0, y) for y in range(input_grid.shape[1])],  # Top row\n        [(input_grid.shape[0] - 1, y) for y in range(input_grid.shape[1])],  # Bottom row\n        [(x, 0) for x in range(input_grid.shape[0])],  # Left column\n        [(x, input_grid.shape[1] - 1) for x in range(input_grid.shape[0])]   # Right column\n    ]\n    \n    for positions in edge_positions:\n        # Rotate the edge pixels\n        if steps \u003e 0:\n            colors = [output_grid[x, y] for x, y in positions]\n            # Rotate colors clockwise\n            rotated_colors = colors[-steps:] + colors[:-steps]\n            # Assign back the rotated colors\n            for (x, y), color in zip(positions, rotated_colors):\n                output_grid[x, y] = color\n                \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a center pixel\n    center_x, center_y = n // 2, m // 2\n    grid[center_x, center_y] = np.random.choice(Color.NOT_BLACK)\n\n    # Fill the edges with random colors\n    edge_colors = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.GREY, \n                   Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON]\n    \n    # Draw colors on the top and bottom edge\n    for y in range(m):\n        grid[0, y] = np.random.choice(edge_colors)\n        grid[n-1, y] = np.random.choice(edge_colors)\n\n    # Draw colors on the left and right edge\n    for x in range(n):\n        grid[x, 0] = np.random.choice(edge_colors)\n        grid[x, m-1] = np.random.choice(edge_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/27/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/27/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/27/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/27/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/27/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/27/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/27/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/27/images/train_output_2.png"}]}, "index": 27, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# sliding objects, collision detection\n\n# description:\n# In the input you will see a red 2x2 square and a blue object (which can be of any shape).\n# Slide the blue object down by one pixel until it just touches the red square.\n\ndef main(input_grid):\n    # Find the red object\n    red_object = np.zeros_like(input_grid)\n    red_object[input_grid == Color.RED] = Color.RED\n\n    # Find the blue object\n    blue_object = np.zeros_like(input_grid)\n    blue_object[input_grid == Color.BLUE] = Color.BLUE\n\n    # Start the output grid with the red object\n    output_grid = np.copy(red_object)\n\n    # Consider sliding the blue object down\n    for slide_distance in range(input_grid.shape[0]):\n        # Translate the blue object down\n        translated_blue_object = translate(blue_object, 0, slide_distance, background=Color.BLACK)\n        \n        # Check for contact with the red object\n        if contact(object1=red_object, object2=translated_blue_object):\n            # Place the blue object where it touches the red object\n            blit_object(output_grid, translated_blue_object, background=Color.BLACK)\n            return output_grid\n\n    # If no valid slide found, this should not happen given correct input\n    assert 0, \"No valid slide found\"\n\ndef generate_input():\n    # Create a black grid of size 5x5 to 10x10\n    n, m = random.randint(5, 10), random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a 2x2 red square\n    red_square = np.full((2, 2), Color.RED)\n    x_red, y_red = random_free_location_for_sprite(grid, red_square, background=Color.BLACK, padding=1)\n    blit_sprite(grid, red_square, x_red, y_red, background=Color.BLACK)\n\n    # Generate a random sprite for the blue object (size 2x2 to 4x4)\n    blue_sprite = random_sprite(random.randint(2, 4), random.randint(2, 4), symmetry=\"not_symmetric\", color_palette=[Color.BLUE])\n\n    # Place the blue sprite somewhere random on the grid\n    x_blue, y_blue = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, blue_sprite, x_blue, y_blue, background=Color.BLACK)\n\n    # Ensure the blue object can slide to touch the red square\n    # There should be a straight column below the red square for the blue object to slide down\n    bottom_red_y = y_red + 1  # The row immediately below the red square\n    if bottom_red_y \u003c n:  # Ensure it is within bounds\n        for col in range(x_red, x_red + 2):  # Check the columns where the red square is\n            grid[bottom_red_y, col] = Color.BLUE  # Make a spot for the blue object to slide down\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/28/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/28/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/28/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/28/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/28/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/28/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/28/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/28/images/train_output_2.png"}]}, "index": 28, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color counting, vertical bars, grid transformation\n\n# description:\n# In the input, you will see a grid filled with pixels in a single row (1 x n).\n# To make the output grid, count how many times each color appears in the input row.\n# Then create a vertical bar for each color in the output grid, where the height of the bar corresponds to the number of pixels of that color.\n# The output should be arranged from left to right.\n\ndef main(input_grid):\n    # Count occurrences of each color in the single row input\n    color_counts = {}\n    \n    for color in input_grid.flatten():\n        if color != Color.BLACK:  # Exclude the background color\n            if color in color_counts:\n                color_counts[color] += 1\n            else:\n                color_counts[color] = 1\n\n    # Determine the output grid size\n    num_colors = len(color_counts)\n    max_height = max(color_counts.values()) if color_counts else 0\n\n    # Create an output grid with a height equal to max_height and a width equal to the number of unique colors\n    output_grid = np.full((max_height, num_colors), Color.BLACK)\n\n    # Fill the output grid with vertical bars\n    for idx, (color, count) in enumerate(color_counts.items()):\n        output_grid[max_height - count:max_height, idx] = color  # Fill from the bottom up\n\n    return output_grid\n\ndef generate_input():\n    # Generate a row of random colors\n    width = np.random.randint(5, 15)  # Width of the input grid (1 x n)\n    grid = np.full((1, width), Color.BLACK)\n\n    # Randomly choose colors for each pixel, ensuring some colors appear multiple times\n    colors = np.random.choice(Color.NOT_BLACK, size=width, replace=True)\n    for x in range(width):\n        grid[0, x] = colors[x]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/29/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/29/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/29/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/29/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/29/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/29/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/29/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/29/images/train_output_2.png"}]}, "index": 29, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, rotation\n\n# description:\n# In the input you will see a grid with a pattern of colored squares. \n# To make the output, blend each color with its adjacent squares (up, down, left, right) \n# and then rotate the resulting grid 90 degrees clockwise.\n\ndef blend_colors(color1, color2):\n    # A simplistic color blending function: average RGB values\n    # Assign each color a unique integer value for blending purposes\n    color_map = {\n        Color.BLUE: (0, 0, 255),\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.YELLOW: (255, 255, 0),\n        Color.GREY: (128, 128, 128),\n        Color.PINK: (255, 192, 203),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.BLACK: (0, 0, 0)\n    }\n\n    if color1 == Color.BLACK and color2 == Color.BLACK:\n        return Color.BLACK\n\n    rgb1 = np.array(color_map[color1])\n    rgb2 = np.array(color_map[color2])\n    blended_rgb = (rgb1 + rgb2) // 2\n\n    # Find the closest color to the blended RGB\n    closest_color = min(color_map.keys(), key=lambda c: np.linalg.norm(blended_rgb - np.array(color_map[c])))\n    return closest_color\n\ndef main(input_grid):\n    # Get dimensions of the input grid\n    height, width = input_grid.shape\n    output_grid = np.full((width, height), Color.BLACK)\n\n    # Create a new grid to hold blended colors\n    blended_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Blend colors from adjacent cells\n    for y in range(height):\n        for x in range(width):\n            current_color = input_grid[y, x]\n            blended_color = current_color\n\n            # Check adjacent cells (up, down, left, right)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 \u003c= nx \u003c width and 0 \u003c= ny \u003c height:\n                    adjacent_color = input_grid[ny, nx]\n                    if adjacent_color != Color.BLACK:  # Ignore black cells in blending\n                        blended_color = blend_colors(blended_color, adjacent_color)\n\n            # Set the blended color in the grid\n            blended_grid[y, x] = blended_color\n\n    # Rotate the blended grid 90 degrees clockwise\n    output_grid = np.rot90(blended_grid, -1)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(5, 10, size=2)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly fill the grid with colors\n    num_colors = np.random.randint(1, 6)\n    colors = np.random.choice(Color.NOT_BLACK, num_colors, replace=False)\n\n    for y in range(height):\n        for x in range(width):\n            if np.random.rand() \u003e 0.5:  # 50% chance to fill with a color\n                grid[y, x] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/30/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/30/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/30/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/30/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/30/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/30/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/30/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/30/images/train_output_2.png"}]}, "index": 30, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, shape detection, object framing\n\n# description:\n# In the input grid, you will see various colored objects. Some are \"hollow\" and contain a fully-enclosed region, while others are solid without any enclosed regions.\n# To create the output grid, copy the input grid. Then, change the color of all \"hollow\" shapes to be green and all the \"solid\" shapes to be red.\n\ndef main(input_grid):\n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=4)\n    \n    # Create an output grid initialized to the same background color\n    output_grid = input_grid.copy()\n    \n    for obj in objects:\n        # Determine if the object is hollow or solid\n        if is_hollow(obj):\n            # Change hollow shapes to green\n            obj[obj != Color.BLACK] = Color.GREEN\n        else:\n            # Change solid shapes to red\n            obj[obj != Color.BLACK] = Color.RED\n        \n        # Place the modified object back into the output grid\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef is_hollow(object):\n    # Check if the object has a fully enclosed region\n    interior_mask = object_interior(object)\n    object_mask = object != Color.BLACK\n    hollow_mask = interior_mask \u0026 ~object_mask\n    return np.any(hollow_mask)\n\ndef generate_input():\n    n = np.random.randint(10, 20)  # size of the grid\n    input_grid = np.full((n, n), Color.BLACK)\n\n    def random_hollow_object():\n        size = np.random.randint(3, 7)\n        obj = np.full((size, size), Color.BLUE)\n        obj[1:size-1, 1:size-1] = Color.BLACK  # creating a hollow square\n        return obj\n\n    def random_solid_object():\n        size = np.random.randint(3, 7)\n        obj = np.full((size, size), Color.BLUE)\n        # making the entire object solid by not changing any inner pixel\n        return obj\n\n    # Ensure at least one hollow and one solid object\n    try:\n        # Add one hollow object\n        hollow_obj = random_hollow_object()\n        x, y = random_free_location_for_sprite(input_grid, hollow_obj, padding=1)\n        blit_sprite(input_grid, hollow_obj, x=x, y=y)\n\n        # Add one solid object\n        solid_obj = random_solid_object()\n        x, y = random_free_location_for_sprite(input_grid, solid_obj, padding=1)\n        blit_sprite(input_grid, solid_obj, x=x, y=y)\n    except ValueError:\n        return generate_input()\n\n    # Add random objects until the grid is reasonably filled\n    while True:\n        obj_choice = np.random.choice([random_hollow_object, random_solid_object])\n        obj = obj_choice()\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            return input_grid  # Return the filled grid if no more space is available", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/31/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/31/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/31/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/31/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/31/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/31/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/31/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/31/images/train_output_2.png"}]}, "index": 31, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern duplication, mirroring\n\n# description:\n# In the input you will see a pattern of colored pixels in the left half of the grid. \n# To make the output, duplicate the pattern on the right half of the grid, but mirrored horizontally.\n# The output grid should maintain the same dimensions as the input grid.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the number of columns in the input grid\n    width = input_grid.shape[1]\n\n    # Define the midpoint to separate the left and right halves\n    midpoint = width // 2\n\n    # Loop through each row to mirror the left half to the right half\n    for row in range(input_grid.shape[0]):\n        for col in range(midpoint):\n            # Copy the left half and mirror it to the right half\n            output_grid[row, width - 1 - col] = input_grid[row, col]\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random height for the grid\n    height = np.random.randint(5, 10)\n    # Create a grid with a width that allows for a left half and a right half\n    width = np.random.randint(4, 10) * 2  # Ensure even width for symmetry\n    grid = np.zeros((height, width), dtype=int)\n\n    # Randomly select a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random pattern on the left half of the grid\n    for row in range(height):\n        for col in range(width // 2):\n            # Randomly decide to color the pixel or leave it as black\n            grid[row, col] = np.random.choice([color, Color.BLACK], p=[0.5, 0.5])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/32/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/32/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/32/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/32/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/32/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/32/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/32/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/32/images/train_output_2.png"}]}, "index": 32, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color transformation, grid manipulation\n\n# description:\n# In the input, you will see colored pixels arranged in a pattern at the top half of a black grid.\n# To make the output, reflect the upper pattern downwards into the lower half of the grid.\n# The reflected pixels should maintain their color, but we will replace every pixel\u0027s color with a new one determined by a transformation rule: \n# If the original color is RED, it changes to BLUE; if it\u0027s GREEN, it changes to YELLOW; if it\u0027s BLUE, it changes to RED; \n# If a pixel is BLACK, it remains BLACK. All other colors will turn to GREY.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the size of the input grid and create an output grid of the same size.\n    # 2. Iterate through the upper half of the input grid and reflect the colors to the lower half.\n    # 3. Apply the color transformation rule to each pixel as we copy them.\n\n    # Step 1: Determine the size of the input grid and create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 2: Reflect the upper half downwards\n    rows, cols = input_grid.shape\n    for x in range(rows // 2):\n        for y in range(cols):\n            original_color = input_grid[x, y]\n            reflected_color = Color.BLACK  # Default to BLACK\n\n            # Step 3: Apply the transformation rules\n            if original_color == Color.RED:\n                reflected_color = Color.BLUE\n            elif original_color == Color.GREEN:\n                reflected_color = Color.YELLOW\n            elif original_color == Color.BLUE:\n                reflected_color = Color.RED\n            elif original_color == Color.BLACK:\n                reflected_color = Color.BLACK\n            else:\n                reflected_color = Color.GREY\n\n            # Place the transformed color in the lower half\n            output_grid[rows - 1 - x, y] = reflected_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid of random size\n    height = np.random.randint(5, 11) * 2  # Ensure even height for upper-lower reflection\n    width = np.random.randint(5, 11)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Fill the upper half of the grid with random colors\n    for x in range(height // 2):\n        for y in range(width):\n            if np.random.rand() \u003c 0.5:  # 50% chance to place a color\n                grid[x, y] = np.random.choice([Color.RED, Color.GREEN, Color.BLUE])\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/33/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/33/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/33/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/33/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/33/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/33/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/33/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/33/images/train_output_2.png"}]}, "index": 33, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, pattern recognition\n\n# description:\n# In the input, you will see a grid with pixels of various colors arranged in a checkerboard pattern. \n# The task is to create an output grid where each color in the checkerboard is replaced with another color in a deterministic manner: \n# the color in the output should be the one that is diagonally opposite in the checkerboard.\n# If the color in the input is at (x, y), the color in the output at (x, y) should be the color at (width-1-x, height-1-y).\n\ndef main(input_grid):\n    # Get the shape of the input grid\n    width, height = input_grid.shape\n    \n    # Create an output grid of the same shape\n    output_grid = np.zeros_like(input_grid)\n    \n    # Loop through each pixel in the input grid and apply the transformation\n    for x in range(width):\n        for y in range(height):\n            # Find the diagonal opposite position\n            opposite_x = width - 1 - x\n            opposite_y = height - 1 - y\n            \n            # Assign the color from the input grid to the output grid\n            output_grid[x, y] = input_grid[opposite_x, opposite_y]\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a checkerboard pattern of colors\n    width, height = np.random.randint(4, 10), np.random.randint(4, 10)  # Size of the grid\n    grid = np.zeros((width, height), dtype=int)  # Initialize the grid\n    \n    # Choose two colors for the checkerboard pattern\n    color1, color2 = np.random.choice(Color.NOT_BLACK, size=2, replace=False)\n    \n    # Fill the grid with a checkerboard pattern\n    for x in range(width):\n        for y in range(height):\n            if (x + y) % 2 == 0:\n                grid[x, y] = color1\n            else:\n                grid[x, y] = color2\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/34/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/34/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/34/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/34/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/34/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/34/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/34/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/34/images/train_output_2.png"}]}, "index": 34, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# path following, color transformation, nearest neighbor\n\n# description:\n# In the input, you will see a grid with a single colored line and several colored dots. \n# To make the output, follow the line from left to right, changing the color of the line to match the color of the nearest dot.\n\ndef main(input_grid):\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Get the coordinates of the line (non-black pixels)\n    line_coords = np.argwhere(input_grid != Color.BLACK)\n\n    # Iterate through each pixel of the line\n    for x, y in line_coords:\n        # Find the nearest dot from the current line pixel\n        nearest_color = Color.BLACK\n        nearest_distance = float(\u0027inf\u0027)\n\n        # Check all colored pixels in the grid\n        for dot_x, dot_y in np.argwhere(input_grid != Color.BLACK):\n            if (dot_x, dot_y) != (x, y):  # Avoid the current line pixel\n                # Calculate the Manhattan distance\n                distance = abs(dot_x - x) + abs(dot_y - y)\n                if distance \u003c nearest_distance:\n                    nearest_distance = distance\n                    nearest_color = input_grid[dot_x, dot_y]\n\n        # Change line pixel color to the nearest dot color\n        output_grid[x, y] = nearest_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random colors\n    colors = np.random.choice(Color.NOT_BLACK, size=5, replace=False)\n    line_color = colors[0]  # One color will be the line color\n    dot_colors = colors[1:]  # The rest will be dot colors\n\n    # Draw a line from the left to the right\n    line_x = np.random.randint(0, n)\n    draw_line(grid, x=line_x, y=0, end_x=line_x, end_y=m, length=m, direction=(0, 1), color=line_color)\n\n    # Randomly scatter dots in the grid\n    for color in dot_colors:\n        randomly_scatter_points(grid, color=color, density=0.1)\n\n    # Ensure at least one of each dot color is present\n    for color in dot_colors:\n        if np.sum(grid == color) == 0:\n            # Place it at a random position\n            x, y = np.random.randint(1, n-1), np.random.randint(1, m-1)\n            grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/35/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/35/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/35/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/35/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/35/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/35/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/35/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/35/images/train_output_2.png"}]}, "index": 35, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines, alternating patterns, grid manipulation\n\n# description:\n# In the input, you will see a square grid with a diagonal line from the top left to the bottom right.\n# To create the output grid, color the diagonal line in alternating colors: red, blue, green.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n    \n    # Iterate through the diagonal line\n    for i in range(min(n, m)):\n        # Color the diagonal line with alternating colors\n        if i % 3 == 0:\n            output_grid[i, i] = Color.RED\n        elif i % 3 == 1:\n            output_grid[i, i] = Color.BLUE\n        else:\n            output_grid[i, i] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a square grid with black background\n    grid_len = np.random.randint(5, 15)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Draw a diagonal line from top left to bottom right\n    for i in range(grid_len):\n        grid[i, i] = Color.BLACK  # Keep it black for input\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/36/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/36/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/36/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/36/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/36/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/36/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/36/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/36/images/train_output_2.png"}]}, "index": 36, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, size-based transformation\n\n# description:\n# In the input grid, you will see several yellow objects of varying sizes.\n# To create the output grid, change all yellow objects with an area greater than 3 to blue, \n# and all yellow objects with an area of 3 or less to pink.\n\ndef main(input_grid):\n    # Extract all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Process each detected object\n    for obj in objects:\n        area = np.sum(obj != Color.BLACK)  # Calculate the area of the object\n\n        if area \u003e 3:\n            # Change color to blue for objects with area greater than 3\n            obj[obj != Color.BLACK] = Color.BLUE\n        else:\n            # Change color to pink for objects with area 3 or less\n            obj[obj != Color.BLACK] = Color.PINK\n        \n        # Place the modified object back into the output grid\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a number of yellow objects with varying sizes\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Randomly create a sprite (object) of random size\n        w, h = np.random.randint(1, 5), np.random.randint(1, 5)\n        sprite = random_sprite(w, h, color_palette=[Color.YELLOW], density=0.5)\n\n        # Ensure the sprite is placed in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            grid = blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no space, try creating a new object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/37/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/37/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/37/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/37/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/37/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/37/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/37/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/37/images/train_output_2.png"}]}, "index": 37, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color conversion, pattern recognition\n\n# description:\n# In the input you will see a grid with several colored patterns. Each pattern has a unique color. \n# Convert each color according to the following rule: \n# red to blue, blue to green, green to yellow, yellow to red. \n# Keep all other colors as they are.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Create a color mapping based on the description\n    color_map = {Color.RED: Color.BLUE,\n                 Color.BLUE: Color.GREEN,\n                 Color.GREEN: Color.YELLOW,\n                 Color.YELLOW: Color.RED}\n    \n    # Perform color mapping using vectorization\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random colors\n    color_choices = list(Color.NOT_BLACK)  # All colors except black\n    grid_size = np.random.randint(5, 8)  # Random sizes for the grid\n    grid = np.random.choice(color_choices, size=(grid_size, grid_size))\n\n    # Ensure there are at least a few different colors to map\n    if not any(color in grid for color in [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]):\n        return generate_input()  # Regenerate if conditions are not met\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/38/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/38/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/38/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/38/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/38/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/38/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/38/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/38/images/train_output_2.png"}]}, "index": 38, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mixing, neighborhood analysis, grid transformation\n\n# description:\n# In the input you will see a grid filled with various colors. \n# To create the output grid, each pixel\u0027s color is determined by the average color of its neighboring pixels (4-way connectivity).\n# If the average results in a color that is not one of the predefined colors, it will be rounded to the nearest predefined color.\n\ndef average_color(colors):\n    # Calculate the average color as a weighted sum of predefined colors\n    color_map = {Color.BLACK: 0, Color.BLUE: 1, Color.RED: 2, Color.GREEN: 3, \n                 Color.YELLOW: 4, Color.GREY: 5, Color.PINK: 6, Color.ORANGE: 7, \n                 Color.TEAL: 8, Color.MAROON: 9}\n\n    # Create a sum of color values\n    total_value = sum(color_map[color] for color in colors if color in color_map)\n    num_colors = len(colors)\n    \n    if num_colors == 0:\n        return Color.BLACK  # default to black if no colors\n\n    # Calculate average and round to nearest predefined color\n    average_value = total_value / num_colors\n    nearest_color_index = int(round(average_value))\n    nearest_color = list(color_map.keys())[nearest_color_index]\n\n    return nearest_color\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # Iterate over the grid to compute the output colors\n    for x in range(n):\n        for y in range(m):\n            # Gather neighboring colors (4-way connectivity)\n            neighbors = []\n            if x \u003e 0:\n                neighbors.append(input_grid[x-1, y])  # Top\n            if x \u003c n - 1:\n                neighbors.append(input_grid[x+1, y])  # Bottom\n            if y \u003e 0:\n                neighbors.append(input_grid[x, y-1])  # Left\n            if y \u003c m - 1:\n                neighbors.append(input_grid[x, y+1])  # Right\n            \n            # Average color of the pixel and its neighbors\n            output_grid[x, y] = average_color(neighbors)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random colors\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Populate the grid with random colors from the available palette\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/39/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/39/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/39/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/39/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/39/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/39/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/39/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/39/images/train_output_2.png"}]}, "index": 39, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color extraction, resizing\n\n# description:\n# In the input, you will see a grid with several objects of different colors and sizes. \n# Identify the smallest object, extract its color, and resize all other objects to match its size, \n# while preserving their original colors.\n\ndef main(input_grid):\n    # Detect all the objects in the grid\n    objects = detect_objects(grid=input_grid, monochromatic=True, connectivity=4)\n\n    # Find the smallest object\n    smallest_object = min(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    \n    # Get the dimensions of the smallest object\n    smallest_height, smallest_width = smallest_object.shape\n\n    # Create an output grid initialized with the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Resize all other objects to the size of the smallest object and preserve their colors\n    for obj in objects:\n        # Get the color of the object\n        color = np.unique(obj[obj != Color.BLACK])[0]\n\n        # Create a new resized object\n        resized_object = np.full((smallest_height, smallest_width), Color.BLACK)\n        height, width = obj.shape\n\n        # Fill the resized object with the object\u0027s color\n        resized_object[:min(smallest_height, height), :min(smallest_width, width)] = color\n\n        # Place the resized object in a random location in the output grid\n        x, y = random_free_location_for_sprite(output_grid, resized_object, background=Color.BLACK)\n        blit_sprite(output_grid, resized_object, x, y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of objects\n    num_objects = np.random.randint(3, 8)\n\n    for _ in range(num_objects):\n        # Create a random sprite (object)\n        sprite = random_sprite(n=np.random.randint(2, 6), m=np.random.randint(2, 6), density=0.5)\n        \n        # Randomly place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/40/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/40/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/40/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/40/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/40/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/40/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/40/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/40/images/train_output_2.png"}]}, "index": 40, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape rotation, grid transformation\n\n# description:\n# In the input, you will see a grid containing a shape made up of colored pixels. \n# To make the output, rotate the shape 90 degrees clockwise and fill a larger grid with the rotated shape.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Crop the input grid to isolate the shape\n    shape = crop(input_grid, background=Color.BLACK)\n    \n    # Step 2: Rotate the shape 90 degrees clockwise\n    rotated_shape = np.rot90(shape, k=-1)  # k=-1 rotates clockwise\n    \n    # Step 3: Create a new larger grid to fill with the rotated shape\n    new_size = (rotated_shape.shape[0] + 4, rotated_shape.shape[1] + 4)  # Add padding\n    output_grid = np.full(new_size, Color.BLACK)\n    \n    # Step 4: Blit the rotated shape onto the center of the new grid\n    x_start = 2  # Padding from the left\n    y_start = 2  # Padding from the top\n    blit_sprite(output_grid, rotated_shape, x=x_start, y=y_start, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a base grid\n    n = np.random.randint(8, 12)\n    m = np.random.randint(8, 12)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random shape (2-5)x(2-5)\n    shape_width = np.random.randint(2, 6)\n    shape_height = np.random.randint(2, 6)\n    shape = random_sprite(shape_width, shape_height, density=0.5, color_palette=[np.random.choice(Color.NOT_BLACK)])\n\n    # Place the shape in a random free location in the grid\n    x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n    blit_sprite(grid, shape, x=x, y=y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/41/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/41/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/41/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/41/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/41/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/41/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/41/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/41/images/train_output_2.png"}]}, "index": 41, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color matching, object detection\n\n# description:\n# In the input, you will see a grid with scattered colored pixels and several colored rectangles.\n# The task is to rotate each rectangle 90 degrees clockwise if it matches the color of any of the scattered pixels. \n# The output grid will contain the rotated rectangles in the positions of the original rectangles.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the unique colors in the grid that are not the background\n    unique_colors = set(input_grid.flatten()) - {Color.BLACK}\n\n    # Find all rectangles in the grid\n    rectangles = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    for rect in rectangles:\n        # Get the color of the current rectangle\n        rect_color = np.unique(rect)\n        \n        # Check if the rectangle color matches any scattered pixel color\n        if any(color in unique_colors for color in rect_color):\n            # Rotate the rectangle 90 degrees clockwise\n            rotated_rect = np.rot90(rect, -1)  # -1 for clockwise\n            \n            # Get the position of the rectangle\n            x, y = object_position(rect, background=Color.BLACK)\n            \n            # Blit the rotated rectangle back to the output grid\n            blit_sprite(output_grid, sprite=rotated_rect, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter some colored pixels\n    num_scattered_pixels = np.random.randint(5, 20)\n    colors_to_use = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n    \n    for _ in range(num_scattered_pixels):\n        color = np.random.choice(colors_to_use)\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    # Randomly generate colored rectangles\n    num_rectangles = np.random.randint(1, 4)\n    \n    for _ in range(num_rectangles):\n        color = np.random.choice(colors_to_use)\n        width, height = np.random.randint(2, 4), np.random.randint(2, 4)\n        rectangle = np.full((height, width), color)\n        \n        try:\n            # Get a random free location for the rectangle\n            x, y = random_free_location_for_sprite(grid, rectangle)\n            # Blit the rectangle onto the grid\n            blit_sprite(grid, sprite=rectangle, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no free location is found, skip to the next rectangle\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/42/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/42/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/42/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/42/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/42/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/42/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/42/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/42/images/train_output_2.png"}]}, "index": 42, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# swirling, color mixing\n\n# description:\n# In the input you will see a single red pixel on a black background.\n# To make the output, shoot the red pixel in a clockwise spiral pattern, changing its color to yellow, \n# until it exits the grid. Each time you move, you should leave a yellow trail.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the location of the red pixel\n    # 2. Move in a clockwise spiral, leaving a yellow trail until exiting the grid\n    # 3. Change the color of the red pixel to yellow and leave a trail of yellow pixels.\n\n    # 1. Find the location of the red pixel\n    red_pixel_x, red_pixel_y = np.argwhere(input_grid == Color.RED)[0]\n\n    # Initialize direction as right (dx=1, dy=0) and the spiral movements\n    direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # right, down, left, up\n    dir_idx = 0  # Start by moving to the right\n    steps = 1  # Number of steps to take in the current direction\n    current_steps = 0  # How many steps taken in the current direction\n    output_grid = input_grid.copy()\n\n    while 0 \u003c= red_pixel_x \u003c output_grid.shape[0] and 0 \u003c= red_pixel_y \u003c output_grid.shape[1]:\n        # Change the current pixel to yellow\n        output_grid[red_pixel_x, red_pixel_y] = Color.YELLOW\n\n        # Move in the current direction\n        dx, dy = direction[dir_idx]\n        red_pixel_x += dx\n        red_pixel_y += dy\n        current_steps += 1\n\n        # Check if we need to change direction\n        if current_steps == steps:\n            dir_idx = (dir_idx + 1) % 4  # Change direction\n            current_steps = 0  # Reset step count\n            if dir_idx % 2 == 0:  # Every two turns, increase step count\n                steps += 1\n\n    return output_grid\n\n\ndef generate_input():\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n    \n    # Place a single red pixel at a random location within the grid\n    red_x = np.random.randint(0, width)\n    red_y = np.random.randint(0, height)\n    grid[red_x, red_y] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/43/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/43/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/43/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/43/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/43/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/43/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/43/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/43/images/train_output_2.png"}]}, "index": 43, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, rotation\n\n# description:\n# In the input, you will see a grid with several colored shapes. \n# To create the output, each shape must be rotated 90 degrees clockwise and the colors must be transformed as follows:\n# red -\u003e blue, blue -\u003e green, green -\u003e yellow, yellow -\u003e red.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Create a color mapping\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.BLUE: Color.GREEN,\n        Color.GREEN: Color.YELLOW,\n        Color.YELLOW: Color.RED\n    }\n\n    # Find all connected components (shapes) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n\n    for obj in objects:\n        # Get the bounding box of the sprite and crop the sprite\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Rotate the sprite 90 degrees clockwise\n        rotated_sprite = np.rot90(sprite, k=-1)\n        \n        # Transform colors in the rotated sprite\n        transformed_sprite = np.vectorize(lambda color: color_map.get(color, color))(rotated_sprite)\n\n        # Blit the transformed sprite back to the output grid at the same position\n        blit_sprite(output_grid, transformed_sprite, x, y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # The possible shape colors\n    shape_colors = list(Color.NOT_BLACK)\n\n    # Randomly generate a number of shapes\n    num_shapes = np.random.randint(1, 5)\n    \n    for _ in range(num_shapes):\n        # Randomly create a shape (sprite)\n        w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n        sprite_color = np.random.choice(shape_colors)\n        sprite = random_sprite(n=w, m=h, color_palette=[sprite_color], symmetry=\"not_symmetric\", density=0.5)\n\n        # Randomly place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/44/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/44/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/44/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/44/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/44/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/44/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/44/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/44/images/train_output_2.png"}]}, "index": 44, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color matching, translation, bounding box\n\n# description:\n# In the input, you will see several colored squares placed randomly. The first square\u0027s color will be used as a reference. \n# All other squares will be moved to the same location as the first square and their colors will be changed to match the first square\u0027s color.\n\ndef main(input_grid):\n    # Find the coordinates of the first square (the first non-black pixel)\n    first_square_coords = np.argwhere(input_grid != Color.BLACK)[0]\n    \n    # Get the color of the first square\n    target_color = input_grid[first_square_coords[0], first_square_coords[1]]\n\n    # Create a new output grid initialized to the background color (black)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Move all squares to the position of the first square and change their color\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Set the output pixel to the target color at the position of the first square\n        output_grid[first_square_coords[0], first_square_coords[1]] = target_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly decide how many squares to place\n    num_squares = np.random.randint(3, 10)\n\n    for _ in range(num_squares):\n        # Random size for each square\n        size = np.random.randint(1, 4)\n        color = np.random.choice(list(Color.NOT_BLACK))  # Choose a random color from the available palette\n\n        # Find a random free location to place the square\n        x, y = random_free_location_for_sprite(grid, np.ones((size, size)), background=Color.BLACK)\n        \n        # Draw the square in the grid\n        grid[x:x+size, y:y+size] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/45/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/45/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/45/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/45/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/45/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/45/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/45/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/45/images/train_output_2.png"}]}, "index": 45, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, pattern generation, alignment\n\n# description:\n# In the input you will see a grid with several pixels of different colors in a random arrangement.\n# To make the output grid, count the number of pixels of each color and then generate a line of squares for each color.\n# The number of squares should match the count of each color, arranged in a straight line horizontally across the output grid.\n\ndef main(input_grid):\n    # Count the pixels of each color\n    color_counts = {}\n    for row in input_grid:\n        for color in row:\n            if color != Color.BLACK:  # Ignore background\n                if color in color_counts:\n                    color_counts[color] += 1\n                else:\n                    color_counts[color] = 1\n\n    # Determine the width of the output grid based on color counts\n    total_squares = sum(color_counts.values())\n    output_width = total_squares + 1  # Add one for the background color\n    output_grid = np.full((1, output_width), Color.BLACK)\n\n    # Fill the output grid with squares according to the counts\n    current_index = 0\n    for color, count in color_counts.items():\n        for _ in range(count):\n            output_grid[0, current_index] = color\n            current_index += 1\n    \n    return output_grid\n\n\ndef generate_input():\n    # Randomly generate a grid size\n    n = np.random.randint(5, 10)\n    m = np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a number of colored pixels\n    num_pixels = np.random.randint(5, 20)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=True)\n\n    # Randomly place the colored pixels in the grid\n    for color in colors:\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/46/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/46/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/46/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/46/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/46/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/46/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/46/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/46/images/train_output_2.png"}]}, "index": 46, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern replication, diagonal mirroring\n\n# description:\n# In the input, you will see a grid with a central pattern surrounded by a border of black pixels. \n# The central pattern will have pixels of varying colors. \n# To make the output, you should replicate the central pattern in each quadrant of the output grid, \n# mirroring it diagonally. The output grid should be twice the size of the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid that is twice the size of the input grid\n    output_grid = np.full((2 * n, 2 * m), Color.BLACK)\n\n    # Copy the central pattern into each quadrant of the output grid\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] != Color.BLACK:\n                output_grid[i, j] = input_grid[i, j]  # Top-left\n                output_grid[i, j + m] = input_grid[i, j]  # Top-right\n                output_grid[i + n, j] = input_grid[i, j]  # Bottom-left\n                output_grid[i + n, j + m] = input_grid[i, j]  # Bottom-right\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the central pattern\n    n, m = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    # Create a grid for the central pattern with a black border\n    grid = np.full((n, m), Color.BLACK)\n\n    # Populate the central pattern with random colors\n    colors = np.random.choice(Color.NOT_BLACK, size=(n, m), replace=True)\n    grid = colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/47/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/47/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/47/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/47/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/47/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/47/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/47/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/47/images/train_output_2.png"}]}, "index": 47, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color sorting, alignment\n\n# description:\n# In the input, you will see a black grid with several colored squares randomly placed. \n# To make the output, align the squares from left to right, top to bottom, in order of their colors in the rainbow (red, orange, yellow, green, blue, pink, maroon).\n\ndef main(input_grid):\n    # Find the colored squares in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=False, background=Color.BLACK, connectivity=4)\n\n    # Sort the colors in the order of the rainbow\n    rainbow_order = [Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.BLUE, Color.PINK, Color.MAROON]\n    \n    # Create a dictionary to hold squares by color\n    color_dict = {color: [] for color in rainbow_order}\n\n    # Organize objects by their color\n    for obj in objects:\n        color = obj[0, 0]  # Assuming each object is monochromatic\n        if color in color_dict:\n            color_dict[color].append(obj)\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Place the squares according to the sorted colors\n    current_y = 0\n    current_x = 0\n    for color in rainbow_order:\n        for obj in color_dict[color]:\n            # Get the dimensions of the object\n            obj_height, obj_width = obj.shape\n            # Check if the object fits in the current position\n            if current_x + obj_width \u003e output_grid.shape[1]:\n                current_x = 0\n                current_y += obj_height  # Move to the next row\n            # Blit the object onto the output grid\n            blit_sprite(output_grid, obj, current_x, current_y)\n            current_x += obj_width  # Move to the next column position\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly determine number of colored squares to place\n    num_squares = np.random.randint(5, 15)\n\n    # Available colors excluding black\n    available_colors = Color.NOT_BLACK\n\n    for _ in range(num_squares):\n        color = np.random.choice(available_colors)\n        square = random_sprite(2, 2, density=1.0, color_palette=[color])\n        x, y = random_free_location_for_sprite(grid, square, padding=1)\n        grid = blit_sprite(grid, square, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/48/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/48/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/48/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/48/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/48/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/48/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/48/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/48/images/train_output_2.png"}]}, "index": 48, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bouncing, reflection\n\n# description:\n# In the input, you will see a red diagonal line pointing at a blue square on a black background.\n# To make the output, shoot outward from the red line, but change the color to orange. Reflect off the blue square.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the objects: the red line and the blue square.\n    # 2. Determine the orientation of the red line and its endpoints.\n    # 3. Shoot an orange line outward until it hits the blue square.\n    # 4. Reflect the orange line off the blue square, continuing in orange.\n\n    red_line = detect_objects(input_grid, colors=[Color.RED], monochromatic=True, connectivity=8)\n    assert len(red_line) == 1, \"There should be exactly one red line\"\n    red_line = list(red_line)[0]\n    blue_square = detect_objects(input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=8)\n    assert len(blue_square) == 1, \"There should be exactly one blue square\"\n    blue_square = list(blue_square)[0]\n\n    output_grid = input_grid.copy()\n\n    # Get the endpoints of the red line\n    x1, y1 = max((x, y) for x, y in np.argwhere(red_line == Color.RED))\n    x2, y2 = min((x, y) for x, y in np.argwhere(red_line == Color.RED))\n    direction12 = (int(np.sign(x2 - x1)), int(np.sign(y2 - y1)))\n    direction21 = (-direction12[0], -direction12[1])\n\n    # Try both (direction, x2, y2) and (-direction, x1, y1) as starting points\n    for (dx, dy), start_x, start_y in [(direction12, x2, y2), (direction21, x1, y1)]:\n        start_x += dx\n        start_y += dy\n        # Loop, shooting lines off the blue square until we run out of the canvas\n        while 0 \u003c= start_x \u003c output_grid.shape[0] and 0 \u003c= start_y \u003c output_grid.shape[1]:\n            stop_x, stop_y = draw_line(output_grid, start_x, start_y, direction=(dx, dy), color=Color.ORANGE, stop_at_color=[Color.BLUE])\n\n            # Reflection geometry depends on if we hit the blue square on our left/right/up/down\n            # did we hit the blue square on our right? \n            if stop_x + 1 \u003c output_grid.shape[0] and output_grid[stop_x + 1, stop_y] != Color.BLACK:\n                dx = -dx\n            # did we hit the blue square on our left?\n            elif stop_x - 1 \u003e= 0 and output_grid[stop_x - 1, stop_y] != Color.BLACK:\n                dx = -dx\n            # did we hit the blue square on our bottom?\n            elif stop_y + 1 \u003c output_grid.shape[1] and output_grid[stop_x, stop_y + 1] != Color.BLACK:\n                dy = -dy\n            # did we hit the blue square on our top?\n            elif stop_y - 1 \u003e= 0 and output_grid[stop_x, stop_y - 1] != Color.BLACK:\n                dy = -dy\n            else:\n                # didn\u0027t do any reflections, so stop\n                break\n\n            start_x, start_y = stop_x + dx, stop_y + dy\n\n    return output_grid\n\ndef generate_input():\n    # Make a grid with a blue square in the center and a red diagonal line pointing at it.\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a blue square in the center\n    square_size = np.random.randint(2, 5)\n    square_x = width // 2 - square_size // 2\n    square_y = height // 2 - square_size // 2\n    grid[square_x:square_x + square_size, square_y:square_y + square_size] = Color.BLUE\n\n    # Create a diagonal line pointing at the blue square\n    line_x_start = np.random.randint(max(0, square_x - 5), min(width, square_x + square_size + 5))\n    line_y_start = 0\n    draw_line(grid, line_x_start, line_y_start, direction=(1, 1), color=Color.RED, length=5)\n\n    # Randomly rotate to get a variety of orientations\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/49/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/49/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/49/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/49/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/49/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/49/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/49/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/49/images/train_output_2.png"}]}, "index": 49, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection, flipping\n\n# description:\n# In the input, you will see several objects of different colors. Each object is positioned in a way that they can be reflected across a vertical line. \n# To make the output, reflect each object across the vertical midline of the bounding box that contains it.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all the objects in the input grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=background)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj, background=background)\n        sprite = crop(obj, background=background)\n\n        # Reflect the sprite across its vertical midline\n        reflected_sprite = np.fliplr(sprite)\n\n        # Place the reflected sprite in the output grid\n        blit_sprite(output_grid, reflected_sprite, x=x+w, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate between 1 and 5 objects\n    num_objects = np.random.randint(1, 6)\n\n    for _ in range(num_objects):\n        # Randomly generate dimensions for the object\n        width, height = np.random.randint(2, 6), np.random.randint(2, 6)\n\n        # Create a random sprite\n        color = np.random.choice(Color.NOT_BLACK)\n        sprite = random_sprite(width, height, color_palette=[color], density=1.0)\n\n        # Randomly place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/50/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/50/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/50/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/50/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/50/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/50/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/50/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/50/images/train_output_2.png"}]}, "index": 50, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color blending, rotation\n\n# description:\n# In the input, you will see a grid with two objects of different colors and a set of overlapping transparent pixels. \n# To create the output, rotate each object by 90 degrees clockwise, then blend the colors of the objects with the overlapping pixels, \n# using a simple averaging method to produce a new color at the overlap.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the two main objects in the grid.\n    # 2. Rotate each object by 90 degrees clockwise.\n    # 3. Blend the colors where the two objects overlap.\n\n    # 1. Object detection (find connected components)\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, connectivity=8, background=background)\n    assert len(objects) == 2  # expecting exactly two main objects\n\n    # Initialize an output grid\n    output_grid = np.full(input_grid.shape, background)\n\n    # 2. Rotate each object and keep their positions\n    rotated_objects = []\n    for obj in objects:\n        rotated_obj = np.rot90(obj, -1)  # rotate 90 degrees clockwise\n        rotated_objects.append(rotated_obj)\n\n    # Place rotated objects in the output grid\n    for rotated_obj in rotated_objects:\n        output_grid = blit_object(output_grid, rotated_obj, background=background)\n\n    # 3. Blend colors where the two objects overlap\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            if (output_grid[x, y] != background and \n                np.sum(rotated_objects[0][x, y] != background) \u003e 0 and \n                np.sum(rotated_objects[1][x, y] != background) \u003e 0):\n                # Calculate the blended color\n                color1 = rotated_objects[0][x, y]\n                color2 = rotated_objects[1][x, y]\n                if color1 != background and color2 != background:\n                    blended_color = blend_colors(color1, color2)\n                    output_grid[x, y] = blended_color\n\n    return output_grid\n\ndef blend_colors(color1, color2):\n    # Simple color blending: average the RGB values\n    # Since colors are represented as strings, we could use a mapping for average calculation\n    color_mapping = {Color.RED: [255, 0, 0], Color.GREEN: [0, 255, 0], Color.BLUE: [0, 0, 255], \n                     Color.YELLOW: [255, 255, 0], Color.ORANGE: [255, 165, 0], Color.PINK: [255, 192, 203], \n                     Color.GREY: [128, 128, 128], Color.TEAL: [0, 128, 128], Color.MAROON: [128, 0, 0], \n                     Color.BLACK: [0, 0, 0]}\n    inv_color_mapping = {tuple(v): k for k, v in color_mapping.items()}\n\n    rgb1 = color_mapping[color1]\n    rgb2 = color_mapping[color2]\n\n    # Average the RGB values\n    average_color = [(rgb1[i] + rgb2[i]) // 2 for i in range(3)]\n    # Find the closest color\n    return inv_color_mapping[tuple(average_color)]\n\ndef generate_input():\n    # Create a grid with two objects that will overlap\n    width, height = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create two sprites\n    object1_color = np.random.choice(Color.NOT_BLACK)\n    object2_color = np.random.choice(Color.NOT_BLACK)\n    while object2_color == object1_color:  # ensure different colors\n        object2_color = np.random.choice(Color.NOT_BLACK)\n\n    object1 = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=[object1_color])\n    object2 = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=[object2_color])\n\n    # Randomly place the first object\n    x1, y1 = random_free_location_for_sprite(grid, object1)\n    blit_sprite(grid, object1, x1, y1)\n\n    # Randomly place the second object with a chance of overlapping the first\n    x2, y2 = random_free_location_for_sprite(grid, object2)\n    if np.random.rand() \u003c 0.5:  # 50% chance of overlapping\n        x2 = x1 + np.random.randint(-1, 2)  # slight horizontal movement\n        y2 = y1 + np.random.randint(-1, 2)  # slight vertical movement\n    blit_sprite(grid, object2, x2, y2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/51/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/51/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/51/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/51/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/51/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/51/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/51/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/51/images/train_output_2.png"}]}, "index": 51, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, rotation, reflection, grid manipulation\n\n# description:\n# In the input you will see a grid with a diamond pattern. Each pixel in the diamond has a different color.\n# To make the output, you should create a new grid where the diamond is rotated 90 degrees clockwise and then reflected horizontally.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the diamond pattern from the input grid\n    # 2. Rotate the diamond 90 degrees clockwise\n    # 3. Reflect the rotated diamond horizontally\n    # 4. Place the transformed diamond in the center of a new output grid\n\n    # 1. Extract the diamond pattern\n    objects = find_connected_components(input_grid, monochromatic=False)\n    assert len(objects) == 1, \"exactly one diamond expected\"\n    diamond = objects[0]\n    diamond_x, diamond_y = object_position(diamond)\n\n    # Create output grid based on the input grid dimensions\n    output_width = input_grid.shape[1]\n    output_height = input_grid.shape[0]\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Crop the diamond\n    sprite = crop(diamond)\n\n    # 2. Rotate the diamond 90 degrees clockwise\n    rotated_sprite = np.rot90(sprite, k=-1)\n\n    # 3. Reflect the rotated diamond horizontally\n    reflected_sprite = np.flip(rotated_sprite, axis=1)\n\n    # 4. Place the transformed diamond in the center of the output grid\n    diamond_width, diamond_height = reflected_sprite.shape\n    start_x = (output_width - diamond_width) // 2\n    start_y = (output_height - diamond_height) // 2\n    blit_sprite(output_grid, reflected_sprite, x=start_x, y=start_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colors\n    num_colors = np.random.randint(3, 6)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    # Create a diamond shape in the grid\n    diamond_size = np.random.randint(3, min(width, height) // 2)\n    center_x, center_y = width // 2, height // 2\n\n    for i in range(diamond_size):\n        # Fill the diamond pattern: expanding outwards from the center\n        for j in range(-i, i + 1):\n            if 0 \u003c= center_x + j \u003c width and 0 \u003c= center_y + i \u003c height:\n                grid[center_y + i, center_x + j] = colors[i % num_colors]\n            if 0 \u003c= center_x + j \u003c width and 0 \u003c= center_y - i \u003c height:\n                grid[center_y - i, center_x + j] = colors[i % num_colors]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/52/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/52/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/52/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/52/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/52/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/52/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/52/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/52/images/train_output_2.png"}]}, "index": 52, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid traversal, color filling\n\n# description:\n# In the input, you will see a grid containing two distinct colors representing regions and a single maroon starting point. \n# Your task is to fill the entire region connected to the maroon point with a new color (yellow). \n# If the connected region is blocked by any other color, the fill should stop there.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = input_grid.copy()\n\n    # Identify the start point (maroon)\n    start_point = np.argwhere(output_grid == Color.MAROON)\n\n    assert len(start_point) == 1, \"There should be exactly one starting point (maroon)\"\n\n    start_x, start_y = start_point[0]\n    fill_color = Color.YELLOW\n    original_color = output_grid[start_x, start_y]\n\n    # Using a stack for depth-first search (DFS) to fill the connected region\n    stack = [(start_x, start_y)]\n\n    while stack:\n        x, y = stack.pop()\n        \n        # If we\u0027ve already filled this pixel or it\u0027s not the original color, skip it\n        if output_grid[x, y] != original_color:\n            continue\n        \n        # Fill the pixel with the fill color\n        output_grid[x, y] = fill_color\n\n        # Check all four directions (up, down, left, right)\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            \n            # Ensure we stay within grid bounds\n            if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                stack.append((new_x, new_y))\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly assign two distinct colors for regions\n    region_colors = [Color.RED, Color.GREEN]\n\n    # Fill the grid with the two colors randomly, ensuring they create distinct regions\n    for _ in range(np.random.randint(3, 6)):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        color = np.random.choice(region_colors)\n\n        # Randomly make a region of size 3x3 or 4x4\n        region_size = np.random.randint(3, 5)\n        for i in range(region_size):\n            for j in range(region_size):\n                if 0 \u003c= x + i \u003c width and 0 \u003c= y + j \u003c height:\n                    grid[x + i, y + j] = color\n\n    # Add a single maroon starting point\n    while True:\n        start_x, start_y = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[start_x, start_y] not in region_colors:  # Ensure it\u0027s not in the existing regions\n            grid[start_x, start_y] = Color.MAROON\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/53/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/53/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/53/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/53/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/53/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/53/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/53/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/53/images/train_output_2.png"}]}, "index": 53, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color changing, centering\n\n# description:\n# In the input grid, you will see several shapes made up of colored pixels. \n# To create the output grid, you should first find the largest shape (by area) \n# and then color it with a different color (e.g., YELLOW). \n# Finally, place this shape at the center of the output grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all connected components in the input grid (the shapes).\n    # 2. Determine the largest shape by area.\n    # 3. Change the color of the largest shape to YELLOW.\n    # 4. Center the largest shape in the output grid.\n\n    # 1. Find all connected components\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Find the largest shape\n    largest_shape = max(shapes, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # 2. Change the color of the largest shape to YELLOW\n    largest_shape_yellow = np.where(largest_shape != Color.BLACK, Color.YELLOW, Color.BLACK)\n\n    # 3. Initialize the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 4. Calculate center position for placing the largest shape\n    shape_x, shape_y, shape_w, shape_h = bounding_box(largest_shape_yellow)\n    shape_center_x = shape_x + shape_w // 2\n    shape_center_y = shape_y + shape_h // 2\n\n    # Calculate offset to center the yellow shape on the output grid\n    output_center_x = output_grid.shape[0] // 2\n    output_center_y = output_grid.shape[1] // 2\n\n    x_offset = output_center_x - shape_center_x\n    y_offset = output_center_y - shape_center_y\n\n    # Place the yellow shape in the center of the output grid\n    blit_sprite(output_grid, largest_shape_yellow, x_offset, y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the number of shapes\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        shape_width = np.random.randint(1, 5)\n        shape_height = np.random.randint(1, 5)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a rectangular shape\n        shape = np.full((shape_height, shape_width), shape_color)\n\n        # Attempt to place the shape randomly on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n            blit_sprite(grid, shape, x, y)\n        except ValueError:\n            # If no free location can be found, try again\n            return generate_input()\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/54/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/54/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/54/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/54/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/54/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/54/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/54/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/54/images/train_output_2.png"}]}, "index": 54, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, rotation\n\n# description:\n# In the input, you will see a grid containing a shape that is rotated 90 degrees clockwise.\n# To make the output, rotate the shape back to its original orientation (90 degrees counterclockwise).\n\ndef main(input_grid):\n    # Rotate the input grid 90 degrees counterclockwise\n    output_grid = np.rot90(input_grid, k=1)  # k=1 rotates 90 degrees counterclockwise\n    return output_grid\n\ndef generate_input():\n    # Randomly generate a grid with a shape that is rotated 90 degrees clockwise\n    original_width = np.random.randint(3, 6)\n    original_height = np.random.randint(3, 6)\n    \n    # Create an original grid with a shape (not just a random fill)\n    original_shape = random_sprite(original_width, original_height, density=0.5, symmetry=\u0027not_symmetric\u0027, color_palette=Color.NOT_BLACK)\n    \n    # Rotate the original shape 90 degrees clockwise to create the input grid\n    input_grid = np.rot90(original_shape, k=-1)  # k=-1 rotates 90 degrees clockwise\n    \n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/55/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/55/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/55/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/55/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/55/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/55/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/55/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/55/images/train_output_2.png"}]}, "index": 55, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color inversion\n\n# description:\n# In the input, you will see objects of various colors on a black background.\n# To generate the output, extract each object and change its color to the inverted color, keeping the background black.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all the objects in the input grid.\n    # 2. For each object, invert its color and place it in the output grid.\n    \n    # 1. Find the objects in the input grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False, background=background)\n    \n    # Create an output grid initialized to the background color\n    output_grid = np.full_like(input_grid, background)\n\n    # 2. Invert colors and place them in the output grid\n    for obj in objects:\n        # Get the colors in the object\n        colors = object_colors(obj, background=background)\n        # Invert colors for this object\n        inverted_color = {color: invert_color(color) for color in set(colors)}\n        \n        # Create an inverted sprite\n        inverted_sprite = np.copy(obj)\n        for original_color, new_color in inverted_color.items():\n            inverted_sprite[inverted_sprite == original_color] = new_color\n        \n        # Determine the position of the object and blit the inverted sprite onto the output grid\n        x, y = object_position(obj, background=background, anchor=\"upper left\")\n        blit_sprite(output_grid, inverted_sprite, x, y, background=background)\n\n    return output_grid\n\ndef invert_color(color):\n    \"\"\"Inverts a color in the color palette.\"\"\"\n    color_map = {\n        Color.RED: Color.MAROON,\n        Color.GREEN: Color.GRAY,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE,\n        Color.MAROON: Color.RED,\n        Color.GRAY: Color.GREEN,\n        Color.BLACK: Color.PINK,\n        Color.PINK: Color.BLACK,\n        Color.GREY: Color.GREY,\n        Color.PINK: Color.ORANGE,\n        # Add more color inversions if needed\n    }\n    return color_map.get(color, color)\n\ndef generate_input():\n    # Create a black background and place random colored objects on it\n    width, height = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    num_objects = np.random.randint(1, 5)\n    for _ in range(num_objects):\n        # Randomly determine the size and color of the object\n        object_color = np.random.choice(Color.NOT_BLACK)\n        sprite = random_sprite([2, 3, 4], [2, 3, 4], color_palette=[object_color], background=Color.BLACK)\n        \n        # Place the sprite randomly in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            pass  # Skip if no space is found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/56/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/56/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/56/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/56/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/56/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/56/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/56/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/56/images/train_output_2.png"}]}, "index": 56, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, pattern separation, grid manipulation\n\n# description:\n# In the input, you will see two separate vertical patterns of blue pixels each 5 cells tall, \n# with a separator of black pixels in between. The patterns are on the left and right sides of the grid. \n# To create the output grid, you should blend the colors of the two patterns where they occur. \n# The blending rule is as follows: \n# - If both patterns are blue, the output should be yellow.\n# - If one pattern is blue and the other is black, the output should be blue.\n# - If both patterns are black, the output should be black.\n# The output grid will have the same height as the input but will only have one column width.\n\ndef main(input_grid):\n    height = input_grid.shape[0]\n    \n    # Initialize the output grid\n    output_grid = np.zeros((height, 1), dtype=int)\n\n    # Split the input grid into left and right patterns\n    left_pattern = input_grid[:, :input_grid.shape[1] // 2]\n    right_pattern = input_grid[:, input_grid.shape[1] // 2 + 1:]\n\n    # Process each row and determine the output color based on the blending rules\n    for y in range(height):\n        left_color = left_pattern[y, 0]\n        right_color = right_pattern[y, 0]\n        \n        if left_color == Color.BLUE and right_color == Color.BLUE:\n            output_grid[y, 0] = Color.YELLOW  # Both patterns are blue\n        elif left_color == Color.BLUE:\n            output_grid[y, 0] = Color.BLUE  # Left pattern blue, right black\n        elif right_color == Color.BLUE:\n            output_grid[y, 0] = Color.BLUE  # Right pattern blue, left black\n        else:\n            output_grid[y, 0] = Color.BLACK  # Both patterns are black\n\n    return output_grid\n\n\ndef generate_input():\n    # Define grid dimensions\n    width = 6  # 3 for the left pattern + 1 for separator + 3 for the right pattern\n    height = 5  # Fixed height for the patterns\n\n    # Create an empty grid\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Randomly assign blue or black to the left and right patterns\n    for y in range(height):\n        # Left pattern (first 3 columns)\n        left_color = np.random.choice([Color.BLUE, Color.BLACK])\n        input_grid[y, :3] = left_color\n\n        # Right pattern (last 3 columns)\n        right_color = np.random.choice([Color.BLUE, Color.BLACK])\n        input_grid[y, 4:] = right_color\n\n    # Set the separator column to black\n    input_grid[:, 3] = Color.BLACK\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/57/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/57/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/57/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/57/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/57/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/57/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/57/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/57/images/train_output_2.png"}]}, "index": 57, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, color connection\n\n# description:\n# In the input, you will see a non-black background with a colored circle and scattered colored pixels. \n# To make the output, draw lines from each colored pixel to the nearest point on the circumference of the circle. \n# Color the line the same as the pixel.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Determine the background color\n    background_color = np.bincount(input_grid.flatten()).argmax()\n\n    # Find the connected components in the grid\n    objects = find_connected_components(input_grid, background=background_color)\n    \n    # Identify the circle object (the largest non-background object)\n    circle_object = max(objects, key=lambda obj: np.sum(obj != background_color))\n\n    # Get the coordinates of the circle\u0027s center and its radius\n    circle_x, circle_y, circle_width, circle_height = bounding_box(circle_object)\n    center = (circle_x + circle_width // 2, circle_y + circle_height // 2)\n    radius = circle_width // 2  # Assuming it is a perfect circle\n\n    # Find colored pixels and draw lines to the circle\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            pixel_color = input_grid[x, y]\n            if pixel_color != background_color and pixel_color != Color.BLACK:\n                # Calculate the closest point on the circumference of the circle\n                dx = x - center[0]\n                dy = y - center[1]\n                distance = np.sqrt(dx**2 + dy**2)\n\n                if distance != 0:\n                    # Normalize the direction vector\n                    normalized_dx = dx / distance\n                    normalized_dy = dy / distance\n                    \n                    # Calculate the closest point on the circumference\n                    closest_x = int(center[0] + normalized_dx * radius)\n                    closest_y = int(center[1] + normalized_dy * radius)\n\n                    # Draw the line from the pixel to the closest point on the circle\n                    draw_line(output_grid, x, y, end_x=closest_x, end_y=closest_y, color=pixel_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), fill_value=Color.BLACK)\n\n    # Pick a random background color different from black\n    background_color = np.random.choice(Color.NOT_BLACK)\n    grid[:, :] = background_color\n\n    # Create a circle in the grid\n    circle_color = np.random.choice(Color.NOT_BLACK)\n    radius = np.random.randint(2, min(width, height) // 4)\n    center_x = np.random.randint(radius, width - radius)\n    center_y = np.random.randint(radius, height - radius)\n\n    # Draw the circle using points\n    for angle in np.linspace(0, 2 * np.pi, 100):\n        x = int(center_x + radius * np.cos(angle))\n        y = int(center_y + radius * np.sin(angle))\n        if 0 \u003c= x \u003c width and 0 \u003c= y \u003c height:\n            grid[x, y] = circle_color\n\n    # Scatter colored pixels randomly\n    n_pixels = np.random.randint(5, 15)\n    for _ in range(n_pixels):\n        pixel_color = np.random.choice(Color.NOT_BLACK)\n        # Ensure pixel isn\u0027t placed in the circle\n        while True:\n            px = np.random.randint(0, width)\n            py = np.random.randint(0, height)\n            if (px - center_x) ** 2 + (py - center_y) ** 2 \u003e radius ** 2:\n                grid[px, py] = pixel_color\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/58/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/58/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/58/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/58/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/58/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/58/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/58/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/58/images/train_output_2.png"}]}, "index": 58, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# horizontal bars, longest segment extraction\n\n# description:\n# In the input you will see several horizontal bars of different colors.\n# To make the output, find the longest horizontal bar and output it.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    longest_length = 0\n    longest_bar_color = None\n\n    # Iterate over each row to find the longest horizontal bar\n    for row in input_grid:\n        current_color = None\n        current_length = 0\n        \n        for pixel in row:\n            if pixel != Color.BLACK:\n                if pixel == current_color:\n                    current_length += 1\n                else:\n                    # Check if the current bar is longer than the longest found so far\n                    if current_length \u003e longest_length:\n                        longest_length = current_length\n                        longest_bar_color = current_color\n                    \n                    # Reset for the new color\n                    current_color = pixel\n                    current_length = 1\n            else:\n                # If we encounter a black pixel, check for the longest bar\n                if current_length \u003e longest_length:\n                    longest_length = current_length\n                    longest_bar_color = current_color\n                \n                # Reset on encountering black\n                current_color = None\n                current_length = 0\n\n        # Final check at the end of the row\n        if current_length \u003e longest_length:\n            longest_length = current_length\n            longest_bar_color = current_color\n    \n    # If we found a longest bar, fill it in the output grid\n    if longest_bar_color is not None:\n        for i in range(input_grid.shape[1]):\n            output_grid[0, i] = longest_bar_color  # Place the longest bar at the first row for visibility\n        # Draw the longest bar in the output grid\n        output_grid[0, :longest_length] = longest_bar_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    grid_height = np.random.randint(5, 10)\n    grid_width = np.random.randint(10, 20)\n    grid = np.zeros((grid_height, grid_width), dtype=int)\n\n    # Randomly generate horizontal bars\n    for i in range(grid_height):\n        # Randomly decide on the length of the bar and the color\n        bar_length = np.random.randint(1, grid_width // 2)\n        color = random.choice(Color.NOT_BLACK)\n\n        # Random position to place the bar\n        start_col = np.random.randint(0, grid_width - bar_length)\n        grid[i, start_col:start_col + bar_length] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/59/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/59/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/59/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/59/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/59/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/59/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/59/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/59/images/train_output_2.png"}]}, "index": 59, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# concentric shapes, non-black background\n\n# description:\n# In the input you will see a non-black background with a single colored pixel located at the center of the grid.\n# To create the output, draw concentric squares around this pixel, each square being one pixel wider than the last, using the same color as the center pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the center pixel and its color\n    # 2. Draw concentric squares around the center pixel\n\n    # Find the center pixel (assuming the grid size is odd)\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    center_color = input_grid[center_x, center_y]\n\n    # Create a copy of the input grid to draw on\n    output_grid = input_grid.copy()\n\n    # Draw concentric squares\n    for size in range(1, min(center_x, center_y) + 1):\n        for dx in range(-size, size + 1):\n            output_grid[center_x + dx, center_y - size] = center_color  # top edge\n            output_grid[center_x + dx, center_y + size] = center_color  # bottom edge\n        for dy in range(-size, size + 1):\n            output_grid[center_x - size, center_y + dy] = center_color  # left edge\n            output_grid[center_x + size, center_y + dy] = center_color  # right edge\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random non-black background\n    background_color = np.random.choice(Color.NOT_BLACK)\n    width, height = np.random.randint(3, 30, size=2)\n    # Ensure the grid has odd dimensions to have a clear center\n    if width % 2 == 0:\n        width += 1\n    if height % 2 == 0:\n        height += 1\n    \n    input_grid = np.full((width, height), background_color)\n\n    # Place a colored pixel in the center\n    center_color = np.random.choice(Color.NOT_BLACK)\n    input_grid[width // 2, height // 2] = center_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/60/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/60/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/60/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/60/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/60/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/60/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/60/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/60/images/train_output_2.png"}]}, "index": 60, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color transformation\n\n# description:\n# In the input, you will see a black grid containing several 3x3 objects of different colors.\n# The output should change the color of the objects that are symmetric to teal.\n# Symmetry is defined as having a matching object across the middle of the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the center of the grid to determine the axis of symmetry.\n    # 2. Extract all 3x3 objects from the grid.\n    # 3. Check each object for symmetry with respect to the teal color.\n    # 4. Change the color of the symmetric objects to a different color (e.g., yellow).\n\n    # Step 1: Find the center of the grid\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n\n    # Step 2: Detect all 3x3 objects in the input grid\n    square_length = 3\n    objects = detect_objects(input_grid, background=Color.BLACK, allowed_dimensions=[(square_length, square_length)])\n\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 3: Check for symmetry and change color if necessary\n    for obj in objects:\n        cropped_object = crop(obj, background=Color.BLACK)\n        x, y = np.where(cropped_object == Color.TEAL)\n\n        # If there\u0027s a teal pixel, we need to check for its symmetry\n        if len(x) \u003e 0:\n            # Check for symmetry across the center\n            obj_center_x = obj.shape[0] // 2\n            obj_center_y = obj.shape[1] // 2\n            \n            # Calculate the mirrored positions for symmetry\n            mirrored_positions = [(center_x + (obj_center_x - dx), center_y + (obj_center_y - dy)) for dx, dy in zip(x, y)]\n            \n            for mirror_x, mirror_y in mirrored_positions:\n                # If the mirrored position is within bounds and not black\n                if (0 \u003c= mirror_x \u003c output_grid.shape[0] and 0 \u003c= mirror_y \u003c output_grid.shape[1]):\n                    # Change the color to yellow\n                    output_grid[mirror_x, mirror_y] = Color.YELLOW\n\n    # Blit the original objects into the output grid\n    for obj in objects:\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_objects = np.random.randint(1, 6)  # Number of 3x3 objects to place\n\n    for _ in range(num_objects):\n        # Create a random 3x3 object of random color\n        color = np.random.choice([Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.ORANGE])\n        object_grid = np.full((3, 3), color)\n\n        # Randomly place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, object_grid, background=Color.BLACK)\n            blit_sprite(grid, object_grid, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If we can\u0027t find a location, skip this object\n\n    # Randomly place a teal 3x3 object for symmetry\n    teal_object = np.full((3, 3), Color.TEAL)\n    try:\n        x, y = random_free_location_for_sprite(grid, teal_object, background=Color.BLACK)\n        blit_sprite(grid, teal_object, x=x, y=y, background=Color.BLACK)\n    except ValueError:\n        pass  # If we can\u0027t find a location for teal, we can skip this\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/61/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/61/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/61/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/61/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/61/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/61/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/61/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/61/images/train_output_2.png"}]}, "index": 61, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alignment, color matching\n\n# description:\n# In the input, you will see a medium-sized object that has a main color and a few scattered pixels of different colors around it.\n# To make the output, align the object such that its main color perfectly overlaps with the nearby scattered pixels, changing those pixels to match the object\u0027s color.\n# If there are multiple scattered pixels, the object should align to the pixel that results in the minimum distance to the center of the object.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the main object and its main color.\n    # 2. Identify all scattered colored pixels around the object.\n    # 3. For each scattered pixel, compute the distance to the center of the object.\n    # 4. Align the object to the pixel with the minimum distance.\n    # 5. Update the output grid with the aligned object while changing the pixel color to the object\u0027s main color.\n\n    # Step 1: Extract the object and determine its main color\n    objects = find_connected_components(input_grid, monochromatic=False)\n    main_object = max(objects, key=lambda obj: np.count_nonzero(obj != Color.BLACK))\n    main_color = np.argmax(np.bincount(main_object[main_object != Color.BLACK].flatten()))\n\n    # Step 2: Identify all scattered colored pixels\n    scattered_pixels = [obj for obj in objects if np.count_nonzero(obj != Color.BLACK) == 1 and obj[0, 0] != main_color]\n\n    # Step 3: Calculate the center of the main object\n    object_center_x, object_center_y = np.argwhere(main_object != Color.BLACK).mean(axis=0).astype(int)\n\n    # Step 4: Find the best pixel to align with\n    best_pixel = None\n    best_distance = float(\u0027inf\u0027)\n    \n    for pixel in scattered_pixels:\n        pixel_x, pixel_y = np.argwhere(pixel != Color.BLACK)[0]\n        distance = np.sqrt((object_center_x - pixel_x) ** 2 + (object_center_y - pixel_y) ** 2)\n        if distance \u003c best_distance:\n            best_distance = distance\n            best_pixel = (pixel_x, pixel_y)\n\n    # Step 5: Align the object to the best pixel and update colors\n    if best_pixel:\n        pixel_x, pixel_y = best_pixel\n        offset_x = pixel_x - object_center_x\n        offset_y = pixel_y - object_center_y\n        \n        output_grid = np.full(input_grid.shape, Color.BLACK)\n        blit_sprite(output_grid, main_object, offset_x, offset_y, background=Color.BLACK)\n        \n        # Change the color of the pixel to the main color\n        output_grid[pixel_x, pixel_y] = main_color\n        \n        return output_grid\n    return input_grid  # If no suitable pixel found, return the original grid\n\ndef generate_input():\n    # Create a medium-sized object with a main color and a few scattered pixels of other colors\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate the main object (medium-sized)\n    main_color = np.random.choice(Color.NOT_BLACK)\n    main_object = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=[main_color], density=0.5)\n    \n    # Place the main object on the grid\n    x, y = random_free_location_for_sprite(grid, main_object, padding=1)\n    blit_sprite(grid, main_object, x, y)\n\n    # Add scattered pixels of different colors\n    num_pixels = np.random.randint(3, 6)\n    for _ in range(num_pixels):\n        scatter_color = np.random.choice([color for color in Color.NOT_BLACK if color != main_color])\n        scatter_pixel = np.full((1, 1), scatter_color)\n        scatter_x, scatter_y = np.random.randint(0, n), np.random.randint(0, m)\n\n        # Ensure the pixel does not overlap with the main object\n        while np.any(np.argwhere(main_object != Color.BLACK) + (x, y) == (scatter_x, scatter_y)):\n            scatter_x, scatter_y = np.random.randint(0, n), np.random.randint(0, m)\n        \n        grid[scatter_x, scatter_y] = scatter_color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/62/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/62/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/62/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/62/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/62/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/62/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/62/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/62/images/train_output_2.png"}]}, "index": 62, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity, color matching, horizontal/vertical lines\n\n# description:\n# In the input, you will see a pair of horizontal lines on the edges of the canvas and yellow pixels randomly placed in between these lines. \n# Change the color of each yellow pixel to match the color of the line it is closest to.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the positions of the horizontal lines by removing yellow pixels\n    line_positions = np.where((input_grid != Color.YELLOW) \u0026 (input_grid != Color.BLACK))\n    \n    # Get the unique y-coordinates of the horizontal lines\n    horizontal_line_y = set(line_positions[0])\n\n    # Iterate through the grid to find yellow pixels and change their color\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] == Color.YELLOW:\n                # Find the closest horizontal line\n                closest_line_y = min(horizontal_line_y, key=lambda line_y: abs(line_y - x))\n                # Get the color of the closest line\n                output_grid[x, y] = input_grid[closest_line_y, y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose two colors for the horizontal lines\n    line_colors = random.sample([color for color in Color.ALL_COLORS if color != Color.BLACK and color != Color.YELLOW], 2)\n\n    # Draw two horizontal lines at random rows\n    top_line_row = np.random.randint(0, n//2)\n    bottom_line_row = np.random.randint(n//2, n)\n\n    grid[top_line_row, :] = line_colors[0]\n    grid[bottom_line_row, :] = line_colors[1]\n\n    # Sprinkle yellow pixels randomly between the two lines\n    for _ in range(random.randint(5, 20)):\n        x = np.random.randint(top_line_row + 1, bottom_line_row)  # Ensure yellow pixels are between the lines\n        y = np.random.randint(0, m)\n        grid[x, y] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/63/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/63/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/63/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/63/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/63/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/63/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/63/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/63/images/train_output_2.png"}]}, "index": 63, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# overlapping shapes, color blending\n\n# description:\n# In the input, you will see a grid with colored shapes that may overlap. \n# Each shape is a distinct color and can be of different sizes. \n# To make the output, blend the colors of the overlapping shapes according to the following rules:\n# 1. If two colors overlap, the resulting color is the average of the two colors.\n# 2. If three or more colors overlap, the resulting color is the average of all overlapping colors.\n# The output grid should display the blended colors in the areas where the shapes overlap.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify unique connected components (shapes) in the input grid.\n    # 2. For each pixel, determine which shapes overlap and blend their colors accordingly.\n    \n    # Get the connected components (shapes) from the input grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Create a color map to blend colors where overlaps occur\n    for shape in shapes:\n        # Get the color of the current shape\n        color = object_colors(shape)[0]\n        \n        # Get the bounding box of the shape to limit the blending area\n        x, y, width, height = bounding_box(shape)\n        \n        # Blend the colors in the overlapping area\n        for i in range(width):\n            for j in range(height):\n                if shape[i, j] != Color.BLACK:\n                    # If there is already a color in the output grid, blend it\n                    if output_grid[x+i, y+j] != Color.BLACK:\n                        # Average the existing color and the new shape\u0027s color\n                        existing_color = output_grid[x+i, y+j]\n                        blended_color = blend_colors(existing_color, color)\n                        output_grid[x+i, y+j] = blended_color\n                    else:\n                        # If there\u0027s no color, just set it to the current shape\u0027s color\n                        output_grid[x+i, y+j] = color\n\n    return output_grid\n\ndef blend_colors(color1, color2):\n    # A simple average blend function for colors\n    # Convert colors to RGB and average them\n    rgb1 = np.array([int(c) for c in color1[1:]])  # Assuming color is in hex format\n    rgb2 = np.array([int(c) for c in color2[1:]])\n    blended_rgb = np.clip((rgb1 + rgb2) // 2, 0, 255)\n    return f\u0027#{blended_rgb[0]:02x}{blended_rgb[1]:02x}{blended_rgb[2]:02x}\u0027  # Convert back to hex\n\ndef generate_input() -\u003e np.ndarray:\n    # Plan:\n    # 1. Randomly generate a grid and place random shapes of different colors.\n    # 2. Ensure some shapes overlap to create blending scenarios.\n\n    grid = np.full((10, 10), Color.BLACK)  # Create a 10x10 black grid\n    n_shapes = np.random.randint(3, 6)  # Random number of shapes\n\n    for _ in range(n_shapes):\n        # Generate a random sprite with random dimensions\n        width, height = np.random.randint(1, 4), np.random.randint(1, 4)\n        shape = random_sprite(width, height, density=1)\n        color = np.random.choice(Color.NOT_BLACK)  # Random color for the shape\n        \n        # Color the shape\n        shape[shape != Color.BLACK] = color\n        \n        # Randomly place the shape in the grid\n        x, y = random_free_location_for_sprite(grid, shape)\n        blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/64/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/64/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/64/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/64/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/64/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/64/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/64/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/64/images/train_output_2.png"}]}, "index": 64, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, radial expansion, color sequence\n\n# description:\n# In the input you will see a grid with a central point that has a different color. Each surrounding pixel of the central pixel has a different color. \n# To make the output, you should expand those surrounding colors radially outward in all directions, repeating the color sequence as you go.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the central pixel and surrounding colors in the input grid.\n    # 2. Create an output grid that is larger than the input grid to accommodate the expansion.\n    # 3. For each surrounding color, expand it radially outward from the central pixel according to its position.\n\n    # 1. Identify the central pixel\n    objects = find_connected_components(input_grid, monochromatic=False)\n    assert len(objects) == 1, \"exactly one central object expected\"\n    central_object = objects[0]\n    central_x, central_y = object_position(central_object)\n\n    # Create output grid, larger than the input grid\n    output_width = input_grid.shape[0] + 6  # adding space for expansion\n    output_height = input_grid.shape[1] + 6\n    output_grid = np.full((output_width, output_height), Color.BLACK)\n\n    # 2. Extract surrounding colors\n    surrounding_colors = []\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx != 0 or dy != 0):\n                if (0 \u003c= central_x + dx \u003c input_grid.shape[0] and\n                    0 \u003c= central_y + dy \u003c input_grid.shape[1]):\n                    color = input_grid[central_x + dx, central_y + dy]\n                    if color != Color.BLACK:\n                        surrounding_colors.append(color)\n\n    # 3. Expanding each surrounding color radially outward\n    for index, color in enumerate(surrounding_colors):\n        radius = index + 1  # radius starts from 1\n        # Draw in a diamond shape (Manhattan distance)\n        for x_offset in range(-radius, radius + 1):\n            for y_offset in range(-radius, radius + 1):\n                if abs(x_offset) + abs(y_offset) == radius:  # diamond shape condition\n                    output_grid[central_x + x_offset + 3, central_y + y_offset + 3] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = 5, 5\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose colors for the central and surrounding pixels\n    central_color = np.random.choice(Color.NOT_BLACK)\n    surrounding_colors = np.random.choice(Color.NOT_BLACK, size=8, replace=False)\n\n    # Set the central pixel\n    grid[2, 2] = central_color\n\n    # Set the surrounding pixels\n    offsets = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    for idx, (dx, dy) in enumerate(offsets):\n        grid[2 + dx, 2 + dy] = surrounding_colors[idx]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/65/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/65/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/65/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/65/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/65/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/65/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/65/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/65/images/train_output_2.png"}]}, "index": 65, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# star shape, infinite ray, color guide\n\n# description:\n# In the input you will see a star shape with a flat base (possibly rotated), with a single special pixel inside of it that is a different color. The special pixel is centered along the base of the star, opposite the tip of the star. To make the output, draw a line starting from the tip of the star and extending outward infinitely (away from the star). The color of the line is the color of the special pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the special pixel and the star shape\n    # 2. Find the tip of the star, and which way it is pointing\n    # 3. Draw a line outward from the tip of the star in the correct direction (away from the star)\n\n    # 1. Find the special pixel and the star, and extract the color of the special pixel\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n    for obj in objects:\n        if np.count_nonzero(obj) == 1:\n            special_pixel = obj\n        else:\n            star = obj\n    special_pixel_color = next(iter(set(special_pixel.flatten()) - {Color.BLACK}))\n\n    # 2. Find the tip of the star, and which way it is pointing\n    # The tip of the star is at the topmost point of the star shape\n    # We can assume it\u0027s the pixel with the highest y-coordinate (smallest index in y)\n    tip_coords = np.argwhere(star != Color.BLACK)\n    tip_y, tip_x = tip_coords[np.argmin(tip_coords[:, 0])]  # get the tip\n\n    # 3. Draw a line outward from the tip of the star in the correct direction (away from the star)\n    output_grid = np.copy(input_grid)\n    \n    # Determine the direction to draw the line (away from the star)\n    line_direction = (0, 1)  # Draw vertically up\n\n    draw_line(output_grid, tip_x, tip_y, length=None, direction=line_direction, color=special_pixel_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a star shape and a special pixel\n    star_color = np.random.choice(Color.NOT_BLACK)\n    special_color = np.random.choice([color for color in Color.NOT_BLACK if color != star_color])\n\n    # Define star shape matrix (5-pointed star)\n    star = np.array([[0, 0, star_color, 0, 0],\n                     [0, star_color, star_color, star_color, 0],\n                     [star_color, star_color, 0, star_color, star_color],\n                     [0, star_color, star_color, star_color, 0],\n                     [0, 0, star_color, 0, 0]])\n\n    # Place the special pixel at the base of the star\n    special_x = 2\n    special_y = 4\n    star[special_y, special_x] = special_color\n\n    # Randomly rotate the star\n    rotated_star = np.rot90(star, np.random.randint(4))\n\n    # Create the output grid, ensuring it is large enough to contain the rotated star\n    width, height = np.random.randint(rotated_star.shape[0]+2, 20), np.random.randint(rotated_star.shape[1]+2, 20)\n    output_grid = np.full((width, height), Color.BLACK)\n\n    # Place the rotated star in the output grid\n    x, y = random_free_location_for_sprite(output_grid, rotated_star, border_size=1)\n    blit_sprite(output_grid, rotated_star, x, y, background=Color.BLACK)\n\n    return output_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/66/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/66/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/66/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/66/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/66/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/66/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/66/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/66/images/train_output_2.png"}]}, "index": 66, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation, rotation\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels. To make the output, generate the same pattern but rotate it 90 degrees clockwise and then 90 degrees counter-clockwise, placing the first rotation in the top half of the output grid and the second in the bottom half.\n\ndef main(input_grid):\n    # Get dimensions of the input grid\n    input_height, input_width = input_grid.shape\n\n    # Create output grid which will be double the height of the input grid\n    output_height = input_height * 2\n    output_grid = np.full((output_height, input_width), Color.BLACK)\n\n    # Rotate input grid 90 degrees clockwise\n    rotated_clockwise = np.rot90(input_grid, -1)\n\n    # Copy the rotated grid into the top half of the output grid\n    blit_sprite(output_grid, rotated_clockwise, x=0, y=0)\n\n    # Rotate input grid 90 degrees counter-clockwise\n    rotated_counter_clockwise = np.rot90(input_grid, 1)\n\n    # Copy the rotated grid into the bottom half of the output grid\n    blit_sprite(output_grid, rotated_counter_clockwise, x=0, y=input_height)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with a pattern\n    n = np.random.randint(3, 6)  # Height of the pattern\n    m = np.random.randint(3, 6)  # Width of the pattern\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Draw a simple pattern in the grid with some randomness\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.5:  # Randomly fill half of the grid with the chosen color\n                grid[i, j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/67/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/67/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/67/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/67/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/67/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/67/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/67/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/67/images/train_output_2.png"}]}, "index": 67, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object separation, color matching, boundary detection\n\n# description:\n# In the input, you will see a grid with several objects of different colors, some of which overlap with a specific color (blue).\n# To make the output, separate any objects that overlap with the blue object, and change their color to match the color of the blue object.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Detect the blue object in the grid\n    blue_objects = detect_objects(input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=8)\n    \n    # There should only be one blue object detected in the grid.\n    assert len(blue_objects) == 1\n    blue_object = blue_objects[0]\n\n    # Detect all other objects that overlap with the blue object\n    other_objects = detect_objects(input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=8)\n\n    # Change the color of any overlapping objects to match the blue object\n    for obj in other_objects:\n        if contact(object1=blue_object, object2=obj, connectivity=8):\n            # Change color to match blue\n            obj_color = object_colors(blue_object)[0]\n            mask = obj != Color.BLACK\n            output_grid[mask] = obj_color\n            \n    return output_grid\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a black background.\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Create a blue object\n    blue_sprite = random_sprite(n=3, m=3, density=0.5, color_palette=[Color.BLUE])\n    \n    # Place the blue object at a random location\n    x, y = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK)\n    blit_sprite(grid, blue_sprite, x, y)\n\n    # Randomly generate overlapping objects of different colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        sprite = random_sprite(n=3, m=3, density=0.5, color_palette=[c for c in Color.NOT_BLACK if c != Color.BLUE])\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        \n        # Blit the sprite onto the grid, allowing overlapping\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/68/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/68/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/68/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/68/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/68/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/68/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/68/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/68/images/train_output_2.png"}]}, "index": 68, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# Largest area detection, filling\n\n# description:\n# In the input you will see a grid filled with random colored pixels (mostly blue).\n# The goal is to identify the largest contiguous area of black cells \n# (where a cell is adjacent to another black cell either vertically or horizontally)\n# and fill that area with the color yellow.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find all connected components of black pixels\n    black_components = find_connected_components(input_grid, background=Color.BLUE, connectivity=4, monochromatic=True)\n\n    # Identify the largest component\n    largest_component = max(black_components, key=lambda component: np.sum(component == Color.BLACK))\n\n    # Create an output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Fill the largest component with yellow\n    output_grid[largest_component == Color.BLACK] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Set the random seed for reproducibility\n    np.random.seed()\n\n    # Generate a grid of random size\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((n, m), Color.BLUE)  # Fill the grid with blue pixels\n\n    # Randomly scatter black pixels in the grid\n    # The density of black pixels will determine the size of the largest area\n    density = np.random.uniform(0.2, 0.5)\n    num_black_pixels = int(density * n * m)\n\n    for _ in range(num_black_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLACK  # Assign black color to randomly chosen cells\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/69/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/69/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/69/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/69/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/69/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/69/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/69/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/69/images/train_output_2.png"}]}, "index": 69, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, lines, color blending\n\n# description:\n# In the input, you will see a blue pixel and a yellow pixel. \n# To make the output, create a green pixel between the blue and yellow pixels by drawing a vertical and a horizontal line.\n# The green pixel should be placed at the intersection of these lines. \n\ndef main(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # find the blue and yellow pixels\n    blue_x, blue_y = np.where(input_grid == Color.BLUE)\n    yellow_x, yellow_y = np.where(input_grid == Color.YELLOW)\n\n    # calculate the average position for the green pixel\n    green_x = (blue_x[0] + yellow_x[0]) // 2\n    green_y = (blue_y[0] + yellow_y[0]) // 2\n\n    # place the green pixel\n    output_grid[green_x, green_y] = Color.GREEN\n\n    # draw vertical line from blue to green\n    draw_line(output_grid, blue_x[0], blue_y[0], end_x=green_x, end_y=green_y, color=Color.GREEN)\n\n    # draw horizontal line from yellow to green\n    draw_line(output_grid, yellow_x[0], yellow_y[0], end_x=green_x, end_y=green_y, color=Color.GREEN)\n\n    return output_grid\n\ndef generate_input():\n    # make a black grid as the background\n    n = np.random.randint(6, 15)\n    m = np.random.randint(6, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # select a random position for the blue pixel\n    blue_x = np.random.randint(0, n)\n    blue_y = np.random.randint(0, m)\n    grid[blue_x, blue_y] = Color.BLUE\n\n    # select a random position for the yellow pixel\n    yellow_x = np.random.randint(0, n)\n    yellow_y = np.random.randint(0, m)\n\n    # ensure yellow pixel is not on the same position as blue\n    while (yellow_x == blue_x and yellow_y == blue_y):\n        yellow_x = np.random.randint(0, n)\n        yellow_y = np.random.randint(0, m)\n    \n    grid[yellow_x, yellow_y] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/70/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/70/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/70/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/70/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/70/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/70/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/70/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/70/images/train_output_2.png"}]}, "index": 70, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# path detection, color transformation\n\n# description:\n# In the input you will see a grid with a single colored path that can be a straight line or a curved line.\n# To make the output, change the color of the path to red if it\u0027s a straight line, or blue if it\u0027s a curved line.\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Define the path color\n    path_color = Color.GREEN\n    background_color = Color.BLACK\n\n    # Find all connected components (the path) in the grid\n    paths = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background_color)\n\n    for path in paths:\n        # Get the bounding box of the path\n        x, y, w, h = bounding_box(path, background=background_color)\n        sprite = crop(path, background=background_color)\n\n        # Check if the path is straight or curved\n        # A path is straight if all pixels in one row or one column are occupied\n        is_straight = False\n\n        # Check horizontally\n        if np.any(np.all(sprite != background_color, axis=0)):\n            is_straight = True\n        # Check vertically\n        elif np.any(np.all(sprite != background_color, axis=1)):\n            is_straight = True\n\n        # Change the color of the path based on its shape\n        new_color = Color.RED if is_straight else Color.BLUE\n        sprite[sprite == path_color] = new_color\n\n        # Blit the modified sprite back onto the output grid\n        blit_sprite(output_grid, sprite, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # The path color is green\n    path_color = Color.GREEN\n\n    # Randomly decide to create a straight or curved path\n    is_straight = np.random.choice([True, False])\n    \n    # If straight, create a straight line\n    if is_straight:\n        start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n        length = np.random.randint(3, 10)\n        direction = np.random.choice([(0, 1), (1, 0)])  # Horizontal or vertical\n        for i in range(length):\n            x = start_x + i * direction[0]\n            y = start_y + i * direction[1]\n            if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m:\n                grid[x, y] = path_color\n    else:\n        # If curved, create a path with a turn\n        start_x, start_y = np.random.randint(1, n-1), np.random.randint(1, m-1)\n        grid[start_x, start_y] = path_color  # Start point\n        # Draw the first segment horizontally\n        length = np.random.randint(3, 6)\n        for i in range(length):\n            if start_y + i \u003c m:\n                grid[start_x, start_y + i] = path_color\n\n        # Draw the second segment vertically\n        turn_length = np.random.randint(3, 6)\n        for i in range(turn_length):\n            if start_x + i \u003c n:\n                grid[start_x + i, start_y + length - 1] = path_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/71/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/71/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/71/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/71/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/71/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/71/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/71/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/71/images/train_output_2.png"}]}, "index": 71, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, checkerboard pattern generation\n\n# description:\n# In the input you will see a grid with a blue square.\n# To make the output grid, detect the blue square and generate a checkerboard pattern within the square.\n\ndef main(input_grid):\n    # Detect the blue square in the grid.\n    blue_squares = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    \n    # Initialize the output grid as a copy of the input grid.\n    output_grid = np.copy(input_grid)\n\n    # For each detected blue square, create a checkerboard pattern within it.\n    for blue_square in blue_squares:\n        # Determine the position of the blue square\n        x, y = object_position(blue_square, background=Color.BLACK, anchor=\"upper left\")\n        square_size = blue_square.shape[0]  # Assuming the blue square is a perfect square\n\n        # Create a checkerboard pattern\n        checkerboard = np.empty((square_size, square_size), dtype=int)\n        for i in range(square_size):\n            for j in range(square_size):\n                if (i + j) % 2 == 0:\n                    checkerboard[i, j] = Color.BLACK\n                else:\n                    checkerboard[i, j] = Color.MAROON  # Using WHITE for the checkerboard pattern\n\n        # Place the checkerboard pattern in the output grid at the position of the blue square\n        blit_sprite(output_grid, checkerboard, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = 20, 20\n    grid = np.zeros((n, m), dtype=int)\n\n    # Get the random scatter color pixels on the grid.\n    avaliable_colors = [c for c in Color.NOT_BLACK if c != Color.BLUE]\n    background_color = np.random.choice(avaliable_colors)\n\n    # Generate random color pixels on the grid.\n    randomly_scatter_points(grid, color=background_color, density=0.7)\n\n    # Randomly generate the number of blue squares.\n    square_num = np.random.randint(1, 4)\n\n    # Generate the blue squares on the grid.\n    square_len = np.random.randint(2, 5)  # Size of the blue squares (2x2 to 4x4)\n    blue_square = np.full((square_len, square_len), Color.BLUE)\n\n    for _ in range(square_num):\n        try:\n            # Get a random free location for the blue square.\n            x, y = random_free_location_for_sprite(grid=grid, sprite=blue_square, background=background_color)\n            grid = blit_sprite(grid=grid, sprite=blue_square, x=x, y=y, background=background_color)\n        except:\n            continue  # If no space found, try again\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/72/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/72/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/72/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/72/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/72/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/72/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/72/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/72/images/train_output_2.png"}]}, "index": 72, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, symmetry, color\n\n# description:\n# In the input, you will see a grid with a single colored pixel. \n# To create the output, reflect the colored pixel across both the vertical and horizontal midlines of the grid.\n# The reflected pixels should be the same color as the original pixel.\n\ndef main(input_grid):\n    # Create an output grid as a copy of the original input grid\n    output_grid = np.copy(input_grid)\n    \n    # Find the location of the colored pixel\n    pixel_coords = np.argwhere(input_grid != Color.BLACK)\n    \n    # There should be exactly one colored pixel\n    if len(pixel_coords) != 1:\n        return output_grid  # Return unchanged grid if not exactly one colored pixel\n\n    x, y = pixel_coords[0]\n\n    # Get the color of the pixel\n    color = input_grid[x, y]\n\n    # Calculate midpoints\n    mid_x = input_grid.shape[0] // 2\n    mid_y = input_grid.shape[1] // 2\n\n    # Reflect across the vertical midline\n    reflected_x1 = mid_x + (mid_x - x)\n    reflected_x2 = mid_x - (mid_x - x)\n\n    # Reflect across the horizontal midline\n    reflected_y1 = mid_y + (mid_y - y)\n    reflected_y2 = mid_y - (mid_y - y)\n\n    # Set the reflected pixels in the output grid\n    if 0 \u003c= reflected_x1 \u003c output_grid.shape[0]:\n        output_grid[reflected_x1, y] = color\n    if 0 \u003c= reflected_x2 \u003c output_grid.shape[0]:\n        output_grid[reflected_x2, y] = color\n    if 0 \u003c= x \u003c output_grid.shape[0]:\n        output_grid[x, reflected_y1] = color\n    if 0 \u003c= x \u003c output_grid.shape[0]:\n        output_grid[x, reflected_y2] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size\n    n, m = np.random.randint(5, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose one color\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly place the colored pixel on the grid\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/73/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/73/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/73/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/73/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/73/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/73/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/73/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/73/images/train_output_2.png"}]}, "index": 73, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sorting, size classification\n\n# description:\n# In the input, you will see a grid filled with various colored objects of different sizes. \n# To produce the output grid, sort the objects by their area from left to right and color them according \n# to a preset color sequence: small objects are colored red, medium objects are colored yellow, \n# and large objects are colored blue.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n\n    # Classify objects by size\n    small_objects = []\n    medium_objects = []\n    large_objects = []\n    \n    for obj in objects:\n        area = np.sum(obj == Color.GREEN)  # Assuming the objects are initially colored green\n        if area \u003c 10:\n            small_objects.append(obj)\n        elif area \u003c 20:\n            medium_objects.append(obj)\n        else:\n            large_objects.append(obj)\n\n    # Define the color mapping\n    color_mapping = {Color.RED: small_objects, Color.YELLOW: medium_objects, Color.BLUE: large_objects}\n    sorted_objects = [(Color.RED, small_objects), (Color.YELLOW, medium_objects), (Color.BLUE, large_objects)]\n\n    # Calculate the current x position for placing objects in the output grid\n    current_x = 0\n    \n    for color, objects_list in sorted_objects:\n        for obj in objects_list:\n            # Calculate the bounding box and crop the object\n            x, y, w, h = bounding_box(obj)\n            sprite = crop(obj, background=Color.BLACK)\n\n            # Color the object with the designated color\n            sprite[sprite == Color.GREEN] = color\n            \n            # Place the object in the output grid\n            blit_sprite(output_grid, sprite, x=current_x, y=(output_grid.shape[0] - h) // 2, background=Color.BLACK)\n\n            # Move current_x to the right for the next object\n            current_x += w\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # The objects will be green\n    object_color = Color.GREEN\n\n    for _ in range(random.randint(3, 6)):\n        # Randomly generate an object with a certain area\n        area = np.random.randint(1, 40)\n        width = np.random.randint(1, 8)\n        height = area // width if area % width == 0 else area // width + 1\n\n        # Generate sprite with the object color\n        sprite = random_sprite(width, height, color_palette=[object_color], density=0.5, symmetry=\"not_symmetric\")\n\n        # Randomly place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8)\n\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/74/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/74/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/74/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/74/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/74/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/74/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/74/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/74/images/train_output_2.png"}]}, "index": 74, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color inversion\n\n# description:\n# In the input you will see a grid with various colored objects.\n# To produce the output grid, identify all the objects that are blue and change their color to orange. \n# Additionally, invert the colors of all non-blue pixels in the grid.\n\ndef main(input_grid):\n    # First, we find all the connected components in the grid.\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change color of blue objects to orange and invert other colors\n    for obj in objects:\n        if np.any(obj == Color.BLUE):\n            # Change blue to orange\n            obj[obj == Color.BLUE] = Color.ORANGE\n            # Blit this modified object to output grid\n            output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n        else:\n            # Invert the color of non-blue objects\n            inverted_colors = np.where(obj != Color.BLACK, Color.NOT_BLACK - obj, Color.BLACK)\n            output_grid = blit_object(output_grid, inverted_colors, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid size of 8x8\n    grid_size = 8\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly place colored objects in the grid\n    colors = [Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.ORANGE, Color.GREY, Color.PINK]\n    num_objects = np.random.randint(1, 6)  # Number of objects to create\n\n    for _ in range(num_objects):\n        # Create a random sprite with a random color from the palette\n        sprite_width, sprite_height = np.random.randint(1, 4), np.random.randint(1, 4)\n        sprite_color = np.random.choice(colors)\n        sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[sprite_color], density=1)\n\n        # Randomly place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no space is found, skip this sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/75/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/75/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/75/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/75/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/75/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/75/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/75/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/75/images/train_output_2.png"}]}, "index": 75, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, pixel manipulation, square identification\n\n# description:\n# In the input, you will see a grid with various colored squares. Each square is surrounded by four differently colored pixels. \n# To make the output, rotate each square 90 degrees clockwise, using the surrounding colored pixels as the rotation axis.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Find all squares in the grid\n    square_color = Color.NOT_BLACK  # any color that is not black\n    height, width = input_grid.shape\n    \n    for x in range(height):\n        for y in range(width):\n            # Check if the current pixel is part of a square\n            if input_grid[x, y] in square_color:\n                # Check the surrounding colors\n                if (x \u003e 0 and y \u003e 0 and x \u003c height - 1 and y \u003c width - 1 and\n                    input_grid[x - 1, y] != Color.BLACK and\n                    input_grid[x + 1, y] != Color.BLACK and\n                    input_grid[x, y - 1] != Color.BLACK and\n                    input_grid[x, y + 1] != Color.BLACK):\n                    \n                    # Identify the square\n                    square = crop(input_grid[x-1:x+2, y-1:y+2], background=Color.BLACK)\n                    \n                    # Rotate the square 90 degrees clockwise\n                    rotated_square = np.rot90(square, -1)\n                    \n                    # Place the rotated square back into the output grid at the original position\n                    output_grid[x-1:x-1+rotated_square.shape[0], y-1:y-1+rotated_square.shape[1]] = rotated_square\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place some squares with surrounding colors\n    num_squares = np.random.randint(2, 5)\n\n    for _ in range(num_squares):\n        square_size = np.random.randint(2, 4)\n        \n        # Find a random free location to place the square\n        try:\n            x, y = random_free_location_for_sprite(grid, np.zeros((square_size, square_size)), background=Color.BLACK)\n        except ValueError:\n            continue\n\n        # Create a square with random colors and blit it\n        square_colors = np.random.choice(Color.NOT_BLACK, size=(square_size, square_size))\n        blit_sprite(grid, square_colors, x, y)\n\n        # Surround the square with different colored pixels\n        surrounding_colors = np.random.choice(Color.NOT_BLACK, size=4, replace=False)\n        grid[x-1, y-1] = surrounding_colors[0]  # top-left\n        grid[x-1, y+square_size] = surrounding_colors[1]  # bottom-left\n        grid[x+square_size, y-1] = surrounding_colors[2]  # top-right\n        grid[x+square_size, y+square_size] = surrounding_colors[3]  # bottom-right\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/76/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/76/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/76/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/76/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/76/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/76/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/76/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/76/images/train_output_2.png"}]}, "index": 76, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, mirroring, color transformation\n\n# description:\n# In the input, you will see a grid with various colored objects. \n# To create the output, any object that exhibits symmetry about the vertical axis should be transformed by mirroring it to the opposite side of the grid and coloring it blue.\n# Objects that do not exhibit this symmetry should remain unchanged.\n\ndef main(input_grid):\n    # Create an empty output grid of the same size as the input\n    output_grid = np.copy(input_grid)\n    \n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n    \n    for obj in objects:\n        # Check for vertical symmetry\n        symmetries = detect_mirror_symmetry(obj, ignore_colors=[Color.BLACK])\n        \n        if symmetries:\n            # If vertical mirror symmetry exists, apply the transformation\n            for x, y in np.argwhere(obj != Color.BLACK):\n                # Get the original color of the object\n                original_color = obj[x, y]\n                # Get the mirrored coordinates\n                for symmetry in symmetries:\n                    mirrored_x, mirrored_y = symmetry.apply(x, y)\n                    # Set the mirrored position to blue\n                    output_grid[mirrored_x, mirrored_y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10 and 20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide the number of objects to create\n    num_objects = np.random.randint(3, 6)\n    colors = list(Color.NOT_BLACK)  # Exclude black\n\n    for _ in range(num_objects):\n        # Randomly generate object dimensions\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n        # Create a sprite with random color and possibly symmetric\n        sprite = random_sprite(w, h, color_palette=[np.random.choice(colors)], symmetry=\u0027mirror\u0027)\n        \n        # Find a random position to place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/77/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/77/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/77/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/77/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/77/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/77/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/77/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/77/images/train_output_2.png"}]}, "index": 77, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color replacement, grid manipulation\n\n# description:\n# In the input, you will see a colored object in the center of the grid and a single pixel in the bottom right corner of a different color.\n# To make the output, remove the pixel from the bottom right corner and color the object in the center with the color from the pixel you removed.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the pixel in the bottom right corner\n    color = output_grid[-1, -1]\n\n    # Remove the pixel from the bottom right corner\n    output_grid[-1, -1] = Color.BLACK\n\n    # Color the object in the middle with the color of the pixel from the bottom right corner\n    # First, we find the bounding box of the object\n    x, y, width, height = bounding_box(output_grid != Color.BLACK)\n\n    # Use flood fill to color the object with the new color\n    output_grid = np.where(output_grid == Color.BLACK, output_grid, color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid with a defined size\n    n = m = 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the sprite\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Select a color for the corner pixel\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Ensure colors are different\n    if sprite_color == corner_color:\n        return generate_input()\n    \n    # Generate random sprite and place it in the middle of the grid\n    sprite = random_sprite(n - 2, m - 2, density=0.5, color_palette=[sprite_color])\n    blit_sprite(grid, sprite, x=1, y=1)\n\n    # Place a single pixel in the bottom right corner\n    grid[-1, -1] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/78/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/78/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/78/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/78/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/78/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/78/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/78/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/78/images/train_output_2.png"}]}, "index": 78, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color change\n\n# description:\n# In the input you will see a grid with several colored objects.\n# To create the output grid, determine if each object\u0027s shape has rotational symmetry (90 degrees).\n# If it does, change the object\u0027s color to blue. If it does not, change the object\u0027s color to yellow.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    \n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Check for 90-degree rotational symmetry\n        rotated_90 = np.rot90(sprite)\n        rotated_180 = np.rot90(rotated_90)\n        rotated_270 = np.rot90(rotated_180)\n\n        if np.array_equal(sprite, rotated_90) or np.array_equal(sprite, rotated_180) or np.array_equal(sprite, rotated_270):\n            # If the object has rotational symmetry, change its color to blue\n            sprite[sprite != Color.BLACK] = Color.BLUE\n        else:\n            # Otherwise, change its color to yellow\n            sprite[sprite != Color.BLACK] = Color.YELLOW\n\n        # Blit the new colored sprite back to the output grid\n        blit_sprite(output_grid, sprite, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate grid of size n x m\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of sprites\n    for _ in range(np.random.randint(3, 6)):\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n        \n        # Create a sprite with a color palette of any color\n        sprite = random_sprite(w, h, color_palette=[Color.RED, Color.BLUE, Color.YELLOW, Color.GREEN], symmetry=None, density=0.5)\n\n        # Randomly place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/79/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/79/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/79/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/79/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/79/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/79/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/79/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/79/images/train_output_2.png"}]}, "index": 79, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern duplication, alignment\n\n# description:\n# In the input you will see a grid with a single colored pattern in the center.\n# To make the output, duplicate this pattern and align it below the original.\n\ndef main(input_grid):\n    # Get the bounding box of the input pattern\n    x, y, width, height = bounding_box(input_grid, background=Color.BLACK)\n\n    # Create the output grid, which will be the same width and double the height of the input\n    output_grid = np.full((height * 2, width), Color.BLACK)\n\n    # Copy the original pattern to the output grid\n    blit_sprite(output_grid, input_grid, x=x, y=y)\n    \n    # Copy the pattern again below the original\n    blit_sprite(output_grid, input_grid, x=x, y=y + height)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n = np.random.randint(5, 10)\n    m = np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Define a random size for the pattern\n    pattern_height = np.random.randint(1, n // 2 + 1)\n    pattern_width = np.random.randint(1, m + 1)\n\n    # Choose a random starting point for the pattern\n    start_x = np.random.randint((n - pattern_height + 1) // 2)\n    start_y = np.random.randint((m - pattern_width + 1) // 2)\n\n    # Draw the pattern in the center of the grid\n    for i in range(start_x, start_x + pattern_height):\n        for j in range(start_y, start_y + pattern_width):\n            grid[i, j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/80/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/80/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/80/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/80/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/80/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/80/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/80/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/80/images/train_output_2.png"}]}, "index": 80, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color diffusion\n\n# description:\n# In the input you will see a grid with several colored pixels, some of which are green. \n# To make the output, for each green pixel, change the color of the four adjacent pixels (up, down, left, right) to a new color (for example, orange). \n# If the adjacent pixel is already a color, it will remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x][y] == Color.GREEN:\n                # Change the colors of adjacent pixels to orange if they are not already colored\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    neighbor_x = x + dx\n                    neighbor_y = y + dy\n                    if 0 \u003c= neighbor_x \u003c input_grid.shape[0] and 0 \u003c= neighbor_y \u003c input_grid.shape[1]:\n                        if output_grid[neighbor_x, neighbor_y] == Color.BLACK:\n                            output_grid[neighbor_x, neighbor_y] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter green pixels in the grid\n    num_green_pixels = np.random.randint(1, 6)\n    for _ in range(num_green_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.GREEN\n\n    # Optionally scatter some other colors (not black or green)\n    num_other_pixels = np.random.randint(5, 20)\n    for _ in range(num_other_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color != Color.GREEN])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/81/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/81/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/81/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/81/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/81/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/81/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/81/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/81/images/train_output_2.png"}]}, "index": 81, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, object detection\n\n# description:\n# In the input you will see a grid with multicolored objects on a yellow background. \n# To make the output, invert the colors of each object, changing yellow to black and vice versa.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all connected components (objects) in the grid that are not the background (yellow).\n    # 2. For each object, invert its colors. Change yellow pixels to black and all other colors to their inverted counterparts.\n\n    background = Color.YELLOW\n    objects = find_connected_components(input_grid, background=background, connectivity=8, monochromatic=False)\n\n    # Create a copy of the input grid to draw on\n    output_grid = input_grid.copy()\n\n    # Invert colors for each object found\n    for obj in objects:\n        # Get the colors of the object\n        obj_colors = object_colors(obj, background=background)\n        \n        # Create a color inversion mapping\n        inversion_map = {color: Color.YELLOW if color == Color.BLACK else Color.BLACK for color in Color.ALL_COLORS}\n        for color in obj_colors:\n            if color != background:\n                inverted_color = inversion_map[color]\n                # Apply the inverted color to the object in the output grid\n                output_grid[obj == color] = inverted_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a yellow background and a few randomly placed colored objects\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.YELLOW)\n\n    num_objects = np.random.randint(1, 5)  # Random number of objects\n    for _ in range(num_objects):\n        # Create a random sprite object\n        sprite_width, sprite_height = np.random.randint(2, 6), np.random.randint(2, 6)\n        colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(1, 4), replace=False)  # Choose random colors\n        \n        sprite = random_sprite(sprite_width, sprite_height, color_palette=colors, symmetry=\"not_symmetric\")\n        \n        # Find a free location in the grid to place the sprite\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.YELLOW)\n        blit_sprite(grid, sprite, x, y, background=Color.YELLOW)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/82/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/82/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/82/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/82/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/82/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/82/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/82/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/82/images/train_output_2.png"}]}, "index": 82, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape completion, color propagation\n\n# description:\n# In the input, you will see a grid with an incomplete circular shape. \n# To produce the output grid, complete the circle using the color of the existing part of the circle.\n\ndef main(input_grid):\n    # Find the bounding box of the incomplete circle to extract the sprite\n    x, y, width, height = bounding_box(grid=input_grid)\n    circle_sprite = input_grid[x:x + width, y:y + height]\n\n    # Identify the color of the existing part of the circle\n    circle_color = np.unique(circle_sprite[circle_sprite != Color.BLACK])\n\n    if len(circle_color) == 0:\n        return input_grid  # If no color found, return the input grid as is.\n\n    circle_color = circle_color[0]  # Take the first color found\n\n    # Complete the circle by replacing the black pixels with the circle color\n    completed_circle_sprite = np.where(circle_sprite == Color.BLACK, circle_color, circle_sprite)\n\n    # Make the output by copying the sprite to a new canvas\n    output_grid = np.copy(input_grid)\n    output_grid = blit_sprite(grid=output_grid, sprite=completed_circle_sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a size of n x m\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a circle with a small radius\n    radius = np.random.randint(2, 5)\n\n    # Create the center of the circle\n    center_x, center_y = np.random.randint(radius, n - radius), np.random.randint(radius, m - radius)\n\n    # Draw a circle with a certain density\n    for x in range(center_x - radius, center_x + radius + 1):\n        for y in range(center_y - radius, center_y + radius + 1):\n            if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                if np.random.rand() \u003c 0.5:  # 50% chance to leave the pixel black (incomplete circle)\n                    grid[x, y] = Color.BLACK\n                else:\n                    grid[x, y] = Color.TEAL  # Color of the existing part of the circle\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/83/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/83/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/83/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/83/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/83/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/83/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/83/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/83/images/train_output_2.png"}]}, "index": 83, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pixel transformation\n\n# description:\n# In the input you will see a grid with a pattern of three colors: red, blue, and black.\n# To make the output, you should invert the colors in the pattern: \n# change red to blue, blue to red, and black to orange.\n\ndef main(input_grid):\n    # Prepare an output grid with the same shape as the input grid\n    output_grid = np.zeros(input_grid.shape, dtype=int)\n\n    # Loop through each pixel in the input grid\n    for y in range(input_grid.shape[0]):\n        for x in range(input_grid.shape[1]):\n            # Invert the colors according to the specified rules\n            if input_grid[y, x] == Color.RED:\n                output_grid[y, x] = Color.BLUE\n            elif input_grid[y, x] == Color.BLUE:\n                output_grid[y, x] = Color.RED\n            elif input_grid[y, x] == Color.BLACK:\n                output_grid[y, x] = Color.ORANGE\n            else:\n                # Preserve any other colors (if they exist)\n                output_grid[y, x] = input_grid[y, x]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m, filling it with a random pattern of red, blue, and black\n    n, m = 5, 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter red, blue, and black pixels in the grid\n    colors = [Color.RED, Color.BLUE, Color.BLACK]\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/84/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/84/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/84/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/84/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/84/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/84/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/84/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/84/images/train_output_2.png"}]}, "index": 84, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, row-based transformation\n\n# description:\n# The input is a grid where each cell represents a unique position in a 3x3 grid filled with colors.\n# The transformation is based on the following rules:\n# - If a row is completely filled with the same color, transform that row to black.\n# - If a row contains at least one pixel that is not the same color as the others, transform that row to orange.\n# The output grid should reflect these transformations.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Iterate over each row in the input grid\n    for row in range(input_grid.shape[0]):\n        # Check if all colors in the row are the same\n        if np.all(input_grid[row, :] == input_grid[row, 0]):\n            # If they are the same, keep the output row as black\n            output_grid[row, :] = Color.BLACK\n        else:\n            # If they are not the same, set the output row to orange\n            output_grid[row, :] = Color.ORANGE\n            \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random 3x3 grid with colors\n    grid = np.zeros((3, 3), dtype=int)\n    \n    # Randomly fill each row with colors, ensuring some rows are uniform and some are not\n    for i in range(3):\n        if np.random.rand() \u003c 0.5:  # 50% chance of having a uniform row\n            color = np.random.choice(Color.NOT_BLACK)  # Choose a random color\n            grid[i, :] = color  # Fill entire row with that color\n        else:\n            # Fill the row with random colors to ensure it\u0027s not uniform\n            for j in range(3):\n                grid[i, j] = np.random.choice(Color.NOT_BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/85/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/85/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/85/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/85/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/85/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/85/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/85/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/85/images/train_output_2.png"}]}, "index": 85, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, symmetry detection, reflection\n\n# description:\n# In the input, you will see a sprite repeated horizontally, and some of those repetitions might be reflected top/down/right/left.\n# To make the output, just extract the repeated sprite and return it.\n\ndef main(input_grid):\n    # Identify the sprite height\n    sprite_height = 0\n\n    # Check for translational symmetry horizontally\n    for height in range(1, input_grid.shape[0]):\n        sprite = input_grid[:height]\n        repetitions = [input_grid[i * height:(i + 1) * height] for i in range(input_grid.shape[0] // height)]\n\n        valid = True\n        for rep in repetitions:\n            reflections = [rep, np.flip(rep, 0), np.flip(rep, 1)]\n            if not any([np.array_equal(sprite, r) for r in reflections]):\n                valid = False\n\n        if valid:\n            sprite_height = height\n            break\n\n    assert sprite_height \u003e 0, \"No valid sprite found\"\n\n    # Extract and return the sprite\n    return input_grid[:sprite_height]\n\ndef generate_input():\n    # Create the sprite to be duplicated; pick a trio of random colors\n    n = random.randint(2, 6)  # Height of sprite\n    sprite = random_sprite(n, n, color_palette=random.sample(list(Color.NOT_BLACK), 3))\n\n    # Duplicate the sprite 3 times horizontally\n    grid_width = 3 * n\n    grid_height = n + random.randint(1, 3) * n  # Add some random height variation\n    grid = np.zeros((grid_height, grid_width), dtype=int)\n\n    for i in range(3):\n        if i % 2 == 1:  # Introduce reflection for every second sprite\n            sprite = np.flip(sprite, axis=0)  # Reflect the sprite vertically\n        blit_sprite(grid, sprite, x=i * n, y=0)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/86/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/86/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/86/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/86/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/86/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/86/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/86/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/86/images/train_output_2.png"}]}, "index": 86, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color transformation\n\n# description:\n# In the input, you will see a small grid containing a colored shape. \n# The shape will be scaled up by a factor of 3, and its color will be changed to match the color of the bottom right pixel in the input grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the colored shape in the input grid.\n    # 2. Get the color of the bottom right pixel.\n    # 3. Scale the detected shape by a factor of 3.\n    # 4. Blit the scaled shape onto a new output grid.\n    # 5. Change the color of the scaled shape to the color of the bottom right pixel.\n\n    # Detect the colored shape. We will use allowed dimensions to ensure we capture the whole shape\n    shapes = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the color of the bottom right pixel\n    bottom_right_color = input_grid[-1, -1]  # Last pixel in the grid\n\n    # Scale factor\n    scale_factor = 3\n\n    for shape in shapes:\n        # Scale the shape\n        scaled_shape = scale_sprite(shape, scale_factor)\n        \n        # Get the position to blit the scaled shape at the top-left corner of the original shape\n        x, y = object_position(shape, background=Color.BLACK, anchor=\u0027upper left\u0027)\n\n        # Blit the scaled shape onto the output grid\n        blit_sprite(output_grid, scaled_shape, x=x * scale_factor, y=y * scale_factor, background=Color.BLACK)\n\n        # Change the color of the scaled shape to the color of the bottom right pixel\n        for i in range(scaled_shape.shape[0]):\n            for j in range(scaled_shape.shape[1]):\n                if scaled_shape[i, j] != Color.BLACK:  # Check for the non-background pixels\n                    scaled_shape[i, j] = bottom_right_color\n\n        # Blit the color-modified scaled shape back to the output grid\n        blit_sprite(output_grid, scaled_shape, x=x * scale_factor, y=y * scale_factor, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid of size 10x10\n    grid_size = 10\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly choose the location for a shape\n    shape_width, shape_height = np.random.randint(2, 5, size=2)  # Shape size between 2x2 and 4x4\n    shape_color = np.random.choice(Color.NOT_BLACK)  # Choose a random color\n    shape = np.full((shape_width, shape_height), shape_color)  # Create the shape\n\n    # Find a random position to place this shape\n    x, y = np.random.randint(0, grid_size - shape_width), np.random.randint(0, grid_size - shape_height)\n    blit_sprite(grid, shape, x, y, background=Color.BLACK)\n\n    # Set the bottom right pixel color\n    grid[grid_size - 1, grid_size - 1] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/87/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/87/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/87/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/87/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/87/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/87/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/87/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/87/images/train_output_2.png"}]}, "index": 87, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flipping, color change\n\n# description:\n# In the input you will see a grid with a single colored object. \n# To make the output, flip the object along the horizontal axis and change its color from yellow to blue.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the single colored object (which is yellow)\n    # 2. Change its color to blue\n    # 3. Flip it along the horizontal axis\n\n    # 1. Find the yellow object\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    assert len(objects) == 1\n    yellow_object = objects[0]\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 2. Change the color of the object to blue\n    yellow_object[yellow_object != Color.BLACK] = Color.BLUE\n\n    # 3. Flip the object horizontally\n    flipped_object = np.fliplr(yellow_object)\n\n    # Blit the flipped blue object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=flipped_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid with random size\n    grid_len = np.random.randint(4, 8)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Randomly generate a yellow object and place it on the grid\n    sprite_width, sprite_height = np.random.randint(1, grid_len - 1), np.random.randint(1, grid_len - 1)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.YELLOW], density=0.5)\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/88/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/88/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/88/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/88/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/88/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/88/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/88/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/88/images/train_output_2.png"}]}, "index": 88, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, perimeter calculation, color change\n\n# description:\n# The input consists of a grid containing several yellow and black objects. \n# To create the output, find all yellow objects and change the color of the objects \n# with a perimeter of 8 or greater to red, while changing the color of all other yellow objects to green.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all yellow objects in the grid\n    yellow_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    for obj in yellow_objects:\n        # Get the bounding box of the yellow object\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        \n        # Calculate the perimeter of the object\n        perimeter = 2 * (w + h)\n\n        # Change color based on perimeter\n        if perimeter \u003e= 8:\n            obj[obj != Color.BLACK] = Color.RED\n        else:\n            obj[obj != Color.BLACK] = Color.GREEN\n\n        # Place the colored object back into the output grid\n        blit_sprite(output_grid, obj, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate yellow objects in the grid\n    for _ in range(np.random.randint(2, 6)):\n        while True:\n            # Create a random sprite representing a yellow object\n            sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[Color.YELLOW])\n            x, y = random_free_location_for_sprite(grid, sprite)\n\n            # Place the object in the grid\n            grid = blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n            # Break the loop after placing the object\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/89/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/89/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/89/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/89/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/89/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/89/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/89/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/89/images/train_output_2.png"}]}, "index": 89, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, corner filling\n\n# description:\n# In the input you will see a grid with a pattern in the center surrounded by black pixels.\n# To make the output, you should replicate the pattern in each of the four corners of the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Determine the size of the input grid\n    height, width = input_grid.shape\n\n    # Calculate the center of the grid\n    center_x, center_y = height // 2, width // 2\n\n    # Define the size of the pattern (assume it\u0027s a square pattern)\n    # This assumes the pattern is the largest monochromatic connected component in the center\n    pattern_size = min(center_x, center_y)\n\n    # Crop the pattern from the center\n    pattern = crop(input_grid[center_x - pattern_size // 2:center_x + pattern_size // 2 + 1,\n                              center_y - pattern_size // 2:center_y + pattern_size // 2 + 1])\n\n    # Fill the four corners with the detected pattern\n    blit_sprite(output_grid, pattern, x=0, y=0)  # Top-left corner\n    blit_sprite(output_grid, pattern, x=0, y=height - pattern.shape[0])  # Bottom-left corner\n    blit_sprite(output_grid, pattern, x=width - pattern.shape[1], y=0)  # Top-right corner\n    blit_sprite(output_grid, pattern, x=width - pattern.shape[1], y=height - pattern.shape[0])  # Bottom-right corner\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size between 7x7 and 15x15\n    size = np.random.randint(7, 16)\n    grid = np.full((size, size), Color.BLACK)\n\n    # Define the size of the pattern in the center\n    pattern_size = np.random.randint(3, size // 2)\n\n    # Create a random pattern in the center\n    center_x, center_y = size // 2, size // 2\n    pattern = random_sprite(n=pattern_size, m=pattern_size, density=0.5, connectivity=4)\n\n    # Place the pattern in the center of the grid\n    blit_sprite(grid, pattern, x=center_x - pattern_size // 2, y=center_y - pattern_size // 2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/90/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/90/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/90/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/90/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/90/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/90/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/90/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/90/images/train_output_2.png"}]}, "index": 90, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color replacement, grid transformation\n\n# description:\n# In the input, you will see a grid filled with various colors. \n# The transformation should change each color according to the following mapping:\n# orange -\u003e grey, pink -\u003e black, black -\u003e gray, gray -\u003e orange, and all other colors remain unchanged.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Create color mapping\n    color_map = {\n        Color.ORANGE: Color.GREY,\n        Color.PINK: Color.BLACK,\n        Color.BLACK: Color.GRAY,\n        Color.GRAY: Color.ORANGE\n    }\n\n    # Apply color mapping\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Fill the grid with random colors including the ones that will be transformed\n    colors_to_use = [Color.ORANGE, Color.PINK, Color.BLACK, Color.GRAY] + list(Color.NOT_BLACK)\n    \n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(colors_to_use)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/91/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/91/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/91/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/91/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/91/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/91/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/91/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/91/images/train_output_2.png"}]}, "index": 91, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input, you will see a colored triangle. To make the output, you need to:\n# 1. Rotate the triangle 90 degrees clockwise.\n# 2. Change its color to yellow.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the triangle object in the input grid.\n    # 2. Rotate the triangle 90 degrees clockwise.\n    # 3. Change the color of the triangle to yellow.\n    \n    # 1. Detect the triangle object\n    triangle_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. Process each triangle object\n    for triangle in triangle_objects:\n        # Get the position and bounding box of the triangle\n        x, y, w, h = bounding_box(triangle)\n        \n        # Create a new grid for the rotated triangle\n        rotated_triangle = np.full((h, w), Color.BLACK)  # Create a new grid with black background\n\n        # Rotate 90 degrees clockwise\n        for i in range(h):\n            for j in range(w):\n                if triangle[i, j] != Color.BLACK:  # Only rotate non-background pixels\n                    rotated_triangle[j, h - 1 - i] = triangle[i, j]\n\n        # 3. Change the color of the rotated triangle to yellow\n        rotated_triangle[rotated_triangle != Color.BLACK] = Color.YELLOW\n\n        # Place the rotated triangle into the output grid, centering it\n        new_x = (output_grid.shape[0] - h) // 2\n        new_y = (output_grid.shape[1] - w) // 2\n        blit_sprite(output_grid, rotated_triangle, new_x, new_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width = np.random.randint(10, 20)\n    height = width\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a triangle shape\n    triangle_height = np.random.randint(3, 6)  # Random height for the triangle\n    triangle_width = triangle_height  # Equilateral triangle for simplicity\n\n    triangle = np.full((triangle_height, triangle_width), Color.GREEN)\n\n    # Fill the triangle shape\n    for i in range(triangle_height):\n        for j in range(triangle_width):\n            if j \u003c= i:  # Making a right-angled triangle\n                triangle[i, j] = Color.GREEN\n            else:\n                triangle[i, j] = Color.BLACK  # Background color\n\n    # Place the triangle in a random location\n    try:\n        x, y = random_free_location_for_sprite(grid, triangle, background=Color.BLACK)\n        blit_sprite(grid, triangle, x, y, background=Color.BLACK)\n    except:\n        return generate_input()  # Regenerate if no space\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/92/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/92/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/92/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/92/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/92/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/92/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/92/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/92/images/train_output_2.png"}]}, "index": 92, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry generation, color mapping\n\n# description:\n# In the input you will see a grid with a single colored object. \n# To make the output, generate a pattern that is symmetric across the center of the grid using the colors of the object.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Find the object in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one colored object in the grid.\"\n    object_pixels = objects[0]\n\n    # Step 2: Determine dimensions of the output grid\n    output_height, output_width = input_grid.shape\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Step 3: Fill the output grid with the object\u0027s colors symmetrically\n    for x, y in np.argwhere(object_pixels != Color.BLACK):\n        color = object_pixels[x, y]\n        \n        # Calculate the symmetric positions\n        symmetric_positions = [\n            (x, y), \n            (x, output_width - 1 - y), \n            (output_height - 1 - x, y), \n            (output_height - 1 - x, output_width - 1 - y)\n        ]\n        \n        for sx, sy in symmetric_positions:\n            if 0 \u003c= sx \u003c output_height and 0 \u003c= sy \u003c output_width:\n                output_grid[sx, sy] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid size\n    height, width = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Generate a random colored object with a specific density\n    object_sprite = random_sprite(n=np.random.randint(1, 5), m=np.random.randint(1, 5),\n                                  density=0.5, symmetry=None, color_palette=Color.NOT_BLACK)\n\n    # Randomly place the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, object_sprite)\n    blit_sprite(grid, object_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/93/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/93/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/93/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/93/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/93/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/93/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/93/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/93/images/train_output_2.png"}]}, "index": 93, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean logical operations, bitmasks with separator\n\n# description:\n# Compute the OR operation of two grids separated by a yellow line. In the output, color the cells blue where at least one of the grids has that color, \n# and color the cells black where both grids are black. The input consists of two patterns, one on top and one on the bottom separated by a horizontal yellow line.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    height, width = input_grid.shape\n\n    # Locate the yellow horizontal separator\n    for y_bar in range(height):\n        if np.all(input_grid[y_bar, :] == Color.YELLOW):\n            break\n\n    # Extract the top and bottom patterns\n    top_pattern = input_grid[:y_bar, :]\n    bottom_pattern = input_grid[y_bar + 1:, :]\n\n    output_grid = np.zeros_like(top_pattern)\n\n    # Apply the OR operation\n    output_grid[(top_pattern != Color.BLACK) | (bottom_pattern != Color.BLACK)] = Color.BLUE\n    output_grid[(top_pattern == Color.BLACK) \u0026 (bottom_pattern == Color.BLACK)] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the grid size\n    width = 5  \n    height = 13  # 6 top + 1 yellow line + 6 bottom\n\n    # Initialize an empty grid\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Randomly assign colors to the top and bottom patterns\n    for x in range(width):\n        for y in range(height):\n            if y \u003c height // 2:  # Top pattern\n                input_grid[y, x] = np.random.choice([Color.BLACK, Color.BLUE, Color.RED, Color.GREEN])\n            elif y \u003e height // 2:  # Bottom pattern\n                input_grid[y, x] = np.random.choice([Color.BLACK, Color.BLUE, Color.RED, Color.GREEN])\n\n    # Set the yellow horizontal line\n    input_grid[height // 2, :] = Color.YELLOW\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/94/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/94/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/94/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/94/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/94/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/94/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/94/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/94/images/train_output_2.png"}]}, "index": 94, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, largest object extraction\n\n# description:\n# In the input, you will see a grid filled with various objects of different colors, including some black pixels.\n# Each object is a contiguous area of pixels that are not black. \n# The goal is to find the largest object in terms of pixel count and return it as an output grid \n# while replacing all black pixels in the object with green pixels.\n\ndef main(input_grid):\n    # Step 1: Find all the connected components in the grid that are not black.\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Step 2: Identify the largest object based on the number of pixels.\n    largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Step 3: Crop the largest object to remove any unnecessary black pixels surrounding it.\n    output_grid = crop(largest_object, background=Color.BLACK)\n\n    # Step 4: Replace all black pixels in the output with green pixels.\n    output_grid[output_grid == Color.BLACK] = Color.GREEN\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid of random size filled with various objects and black pixels.\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of objects\n    num_objects = np.random.randint(3, 6)\n    \n    for _ in range(num_objects):\n        # Randomly define the size and color of the object\n        obj_height = np.random.randint(2, 5)\n        obj_width = np.random.randint(2, 5)\n        color = random.choice([c for c in Color.NOT_BLACK if c != Color.GREEN])\n        \n        # Create the object with the selected color\n        object_sprite = np.full((obj_height, obj_width), color)\n\n        # Try placing the object in the grid without overlapping\n        try:\n            x, y = random_free_location_for_sprite(grid, object_sprite, padding=1, padding_connectivity=4)\n            blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # Skip if no free location is found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/95/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/95/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/95/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/95/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/95/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/95/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/95/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/95/images/train_output_2.png"}]}, "index": 95, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reflection, vertical symmetry\n\n# description:\n# In the input grid, you will see a pattern on the left half of the grid. \n# To generate the output, reflect the left half of the grid vertically to the right half.\n\ndef main(input_grid):\n    # Determine the width of the input grid\n    height, width = input_grid.shape\n\n    # Split the input grid into left and right halves\n    left_half = input_grid[:, :width // 2]\n\n    # Reflect the left half to the right half\n    reflected_half = left_half[:, ::-1]\n\n    # Create the output grid combining the left half and reflected right half\n    output_grid = np.zeros_like(input_grid)\n    output_grid[:, :width // 2] = left_half\n    output_grid[:, width // 2:] = reflected_half\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a pattern on the left half\n    height = np.random.randint(5, 8)\n    width = np.random.randint(6, 12)\n    grid = np.zeros((height, width), dtype=int)\n\n    # Define the colors to choose from (excluding black)\n    colors = list(Color.NOT_BLACK)\n    \n    # Create a random pattern on the left half of the grid\n    for i in range(height):\n        for j in range(width // 2):\n            # Randomly assign colors from the color palette\n            grid[i, j] = np.random.choice(colors) if np.random.random() \u003e 0.3 else Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/96/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/96/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/96/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/96/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/96/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/96/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/96/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/96/images/train_output_2.png"}]}, "index": 96, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color counting, pattern recognition\n\n# description:\n# In the input, you will see a grid filled with colored squares, including a distinctive black border.\n# To make the output, identify the most frequent color inside the black border and replace all occurrences of that color with a distinct new color (e.g., orange). \n# Then, color the border with blue to highlight it.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the border and background color\n    border_color = Color.BLACK\n    background_color = np.bincount(output_grid.flatten()).argmax()\n\n    # Find the most common color inside the border\n    color_counts = {}\n    height, width = output_grid.shape\n    \n    for y in range(height):\n        for x in range(width):\n            if output_grid[y, x] != border_color:\n                color = output_grid[y, x]\n                if color in color_counts:\n                    color_counts[color] += 1\n                else:\n                    color_counts[color] = 1\n\n    # Get the most common color\n    most_common_color = max(color_counts, key=color_counts.get)\n\n    # Color the border blue\n    output_grid[output_grid == border_color] = Color.BLUE\n\n    # Replace the most common color with orange\n    output_grid[output_grid == most_common_color] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid dimensions\n    height, width = np.random.randint(10, 20, size=2)\n    grid = np.full((height, width), Color.BLACK)  # Start with a black border\n\n    # Fill the inner grid randomly with colors\n    inner_height, inner_width = height - 2, width - 2\n    colors = list(Color.NOT_BLACK)  # All colors except black\n\n    for y in range(1, height - 1):\n        for x in range(1, width - 1):\n            grid[y, x] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/97/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/97/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/97/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/97/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/97/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/97/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/97/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/97/images/train_output_2.png"}]}, "index": 97, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, pixel stacking, grid transformation\n\n# description:\n# In the input you will see a grid containing several vertical columns of colored pixels.\n# To make the output, create a new grid where each column of the output corresponds to a column of the input. \n# Each pixel in the output will be stacked vertically, filling from the bottom up, and the colors will be in the order they appear from left to right.\n\ndef main(input_grid):\n    # Determine the size of the input grid\n    input_height, input_width = input_grid.shape\n    \n    # Create an output grid with the same width but height equal to the sum of the non-black pixels in each column\n    output_height = 0\n    for x in range(input_width):\n        output_height += np.count_nonzero(input_grid[:, x] != Color.BLACK)\n\n    output_grid = np.full((output_height, input_width), Color.BLACK)\n\n    # Fill the output grid by stacking the colors from the bottom up\n    current_row = output_height - 1\n    for x in range(input_width):\n        # Get the colors in the column, ignoring black pixels\n        column_colors = input_grid[:, x][input_grid[:, x] != Color.BLACK]\n        for color in column_colors:\n            output_grid[current_row, x] = color\n            current_row -= 1\n    \n    return output_grid\n\ndef generate_input():\n    # Initialize the grid with random dimensions\n    height = np.random.randint(5, 10)\n    width = np.random.randint(3, 6)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly choose colors for vertical columns\n    for x in range(width):\n        # Randomly decide the number of colored pixels in this column\n        num_colored_pixels = np.random.randint(1, height + 1)\n        colors = np.random.choice(Color.NOT_BLACK, size=num_colored_pixels, replace=False)\n        \n        # Fill the column from the bottom up\n        for y in range(num_colored_pixels):\n            grid[height - 1 - y, x] = colors[y]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/98/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/98/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/98/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/98/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/98/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/98/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/98/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/98/images/train_output_2.png"}]}, "index": 98, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, rotation, stacking\n\n# description:\n# In the input you will see several colored shapes scattered around a grid filled with black pixels. Each shape has a distinct color and is represented with a 3x3 area. The task is to stack these shapes on top of each other, aligning them by their centers, while ensuring that the output grid contains all stacked shapes in the smallest possible bounding box. The colors of the shapes should remain distinct in the output.\n\ndef main(input_grid):\n    # Step 1: Detect all shapes in the input grid\n    shapes = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n\n    # Step 2: Create a list to hold the cropped shapes\n    cropped_shapes = [crop(shape, background=Color.BLACK) for shape in shapes]\n\n    # Step 3: Create a new output grid\n    max_height = sum(sprite.shape[0] for sprite in cropped_shapes)\n    max_width = max(sprite.shape[1] for sprite in cropped_shapes)\n    output_grid = np.full((max_height, max_width), Color.BLACK)\n\n    # Step 4: Stack each shape on top of each other\n    current_y = 0\n    for sprite in cropped_shapes:\n        # Calculate the center of the output grid\n        center_x = output_grid.shape[1] // 2\n        # Calculate the x offset to center the sprite\n        x_offset = center_x - (sprite.shape[1] // 2)\n        \n        # Blit the sprite onto the output grid\n        blit_sprite(output_grid, sprite, x=x_offset, y=current_y)\n        current_y += sprite.shape[0]  # Move down for the next shape\n\n    # Step 5: Crop to the smallest bounding box containing all shapes\n    return crop(output_grid, background=Color.BLACK)\n\ndef generate_input():\n    # Create a grid and randomly place several distinct colored shapes in it\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of distinct shapes\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        color = random.choice(Color.NOT_BLACK)\n        # Create a 3x3 sprite with the chosen color\n        sprite = random_sprite(3, 3, density=0.5, color_palette=[color], background=Color.BLACK)\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=4)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue  # Skip if there\u0027s no free location\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/99/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/99/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/99/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/99/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/99/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/99/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/99/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/99/images/train_output_2.png"}]}, "index": 99, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, pattern expansion, non-white background\n\n# description:\n# In the input you will see a color grid with a pattern made of two colors. The background is not white.\n# To make the output, blend the two colors based on their positions, creating a gradient effect,\n# and repeat the blended pattern until it covers the entire canvas.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the two primary colors in the input pattern.\n    # 2. Create a new grid, blending the two colors based on their positions.\n    # 3. Tile the blended pattern across the entire grid.\n\n    # Find the unique colors in the input, excluding the background color\n    unique_colors = set(input_grid.flatten())\n    background_color = Color.BLACK  # Assuming background is always BLACK for this puzzle\n    unique_colors.discard(background_color)\n\n    # We expect exactly two unique colors for this puzzle\n    assert len(unique_colors) == 2, \"Expected exactly two unique colors in the input grid.\"\n    color1, color2 = list(unique_colors)\n\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n\n    # Create the blended pattern grid\n    blended_pattern = np.zeros_like(input_grid)\n\n    for x in range(height):\n        for y in range(width):\n            if input_grid[x, y] == color1:\n                blended_pattern[x, y] = color1\n            elif input_grid[x, y] == color2:\n                blended_pattern[x, y] = color2\n            else:\n                # Blend colors based on their positions\n                blending_ratio = (x + y) / (height + width)  # Simple gradient blending\n                blended_color = blend_colors(color1, color2, blending_ratio)\n                blended_pattern[x, y] = blended_color\n\n    # Create the output grid which tiles the blended pattern\n    output_height = 30  # Fixed output size for consistency\n    output_width = 30\n    output_grid = np.tile(blended_pattern, (output_height // height + 1, output_width // width + 1))\n    \n    # Crop to the desired output size\n    output_grid = output_grid[:output_height, :output_width]\n\n    return output_grid\n\ndef blend_colors(color1, color2, ratio):\n    \"\"\"\n    Blend two colors together based on the given ratio.\n    This function assumes color representation as RGB tuples for blending.\n    \"\"\"\n    # Convert colors to RGB format for blending\n    rgb1 = color_to_rgb(color1)\n    rgb2 = color_to_rgb(color2)\n    \n    # Perform the blending\n    blended_rgb = tuple(int((1 - ratio) * c1 + ratio * c2) for c1, c2 in zip(rgb1, rgb2))\n    \n    return rgb_to_color(blended_rgb)\n\ndef color_to_rgb(color):\n    \"\"\" Convert a color to an RGB tuple (dummy implementation). \"\"\"\n    color_map = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.PINK: (255, 192, 203),\n        Color.GREY: (128, 128, 128),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.BLACK: (0, 0, 0),\n    }\n    return color_map.get(color, (0, 0, 0))  # Default to black if color not found\n\ndef rgb_to_color(rgb):\n    \"\"\" Convert an RGB tuple back to a color (dummy implementation). \"\"\"\n    for color, rgb_value in color_to_rgb.items():\n        if rgb_value == rgb:\n            return color\n    return Color.BLACK  # Default to black if no match found\n\ndef generate_input():\n    # Create a random grid with a non-white background\n    background_color = random.choice(Color.NOT_BLACK)\n    grid = np.full((np.random.randint(10, 15), np.random.randint(10, 15)), background_color)\n\n    # Choose two random colors for the pattern\n    colors = random.sample([color for color in Color.NOT_BLACK if color != background_color], 2)\n\n    # Create a simple pattern with the two colors\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if (i + j) % 2 == 0:\n                grid[i, j] = colors[0]\n            else:\n                grid[i, j] = colors[1]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/100/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/100/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/100/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/100/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/100/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/100/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/100/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/100/images/train_output_2.png"}]}, "index": 100, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color propagation\n\n# description:\n# In the input grid, there is a single colored pixel on a black background.\n# To make the output, draw a vertical line from the colored pixel to the bottom of the grid in the same color as the pixel.\n# Next, reflect the color horizontally around the center of the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the colored pixel from the input grid.\n    # 2. Draw a vertical line from the pixel to the bottom of the grid in the same color.\n    # 3. Reflect the vertical line horizontally across the center of the grid.\n\n    # 1. Extract the pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # 2. Draw the vertical line from the pixel to the bottom\n    for y in range(pixel_y, output_grid.shape[1]):\n        output_grid[pixel_x, y] = pixel_color\n\n    # 3. Reflect the color horizontally around the center\n    center_y = output_grid.shape[1] // 2\n    for y in range(center_y, output_grid.shape[1]):\n        for x in range(output_grid.shape[0]):\n            if output_grid[x, y] == pixel_color:\n                output_grid[x, output_grid.shape[1] - (y - center_y + 1)] = pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid\n    width, height = np.random.randint(5, 30, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose one color\n    color = np.random.choice([color for color in Color.NOT_BLACK])\n    \n    # Randomly place the pixel on the grid\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/101/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/101/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/101/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/101/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/101/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/101/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/101/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/101/images/train_output_2.png"}]}, "index": 101, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color transformation\n\n# description:\n# In the input you will see a rectangular grid containing two vertical stripes of different colors on opposite sides.\n# Each stripe has a height of 1 pixel and is surrounded by a background color.\n# To make the output, you should reflect the colors of the stripes across the center of the grid and expand them vertically to fill the grid.\n# The colors of the left stripe should fill the right side, and the colors of the right stripe should fill the left side.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n\n    # Create the output grid initialized to the background color\n    output_grid = np.full((height, width), Color.BLACK)\n\n    # Determine the colors of the left and right stripes\n    left_color = input_grid[:, 0]\n    right_color = input_grid[:, width - 1]\n\n    # Fill the left side of the output grid with the right color\n    for y in range(height):\n        output_grid[y, 0] = right_color[y]\n\n    # Fill the right side of the output grid with the left color\n    for y in range(height):\n        output_grid[y, width - 1] = left_color[y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly choose two colors for the stripes\n    colors = np.random.choice(Color.NOT_BLACK, size=2, replace=False)\n    left_color, right_color = colors\n\n    # Create vertical stripes at the left and right edges of the grid\n    for y in range(height):\n        grid[y, 0] = left_color  # Left stripe\n        grid[y, width - 1] = right_color  # Right stripe\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/102/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/102/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/102/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/102/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/102/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/102/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/102/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/102/images/train_output_2.png"}]}, "index": 102, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, color change\n\n# description:\n# In the input grid, you will see various colored objects. Some objects are fully enclosed by other objects, while others are not. \n# To create the output grid, change the color of all objects that are fully enclosed by other objects to yellow.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    \n    # Find all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Check each object to see if it is fully enclosed\n    for obj in objects:\n        # Create a mask of the object\u0027s interior\n        interior_mask = object_interior(obj, background=Color.BLACK)\n        \n        # Check if the boundaries of the object touch the grid\u0027s boundary (i.e., it\u0027s not fully enclosed)\n        if np.any(interior_mask[0, :] | interior_mask[-1, :] | interior_mask[:, 0] | interior_mask[:, -1]):\n            continue  # It\u0027s not fully enclosed\n        \n        # If fully enclosed, change its color to yellow\n        obj[obj != Color.BLACK] = Color.YELLOW\n        \n        # Place the modified object back into the output grid\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 10x10 grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Generate random objects and place them into the grid\n    for _ in range(random.randint(3, 6)):\n        obj = random_sprite(random.randint(1, 5), random.randint(1, 5), color_palette=[Color.RED, Color.GREEN, Color.BLUE])\n        \n        # Try to place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If placement fails, try again\n\n    # Ensure that some objects are fully enclosed\n    for _ in range(random.randint(1, 2)):\n        enclosing_obj = random_sprite(random.randint(6, 8), random.randint(6, 8), color_palette=[Color.YELLOW])\n        \n        # Try to place the enclosing object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, enclosing_obj, padding=1)\n            grid = blit_sprite(grid, enclosing_obj, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If placement fails, try again\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/103/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/103/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/103/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/103/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/103/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/103/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/103/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/103/images/train_output_2.png"}]}, "index": 103, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern generation, concentric shapes\n\n# description:\n# In the input you will see a grid with a single colored pixel.\n# To make the output, you should create concentric squares around the pixel:\n# step 1: draw a square of the pixel\u0027s color, centered at the pixel\u0027s position.\n# step 2: draw additional squares of increasing size around the original square (with a period of 2 pixels), alternating colors from a predefined color palette.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the pixel\u0027s position and color.\n    # 2. Draw concentric squares around the pixel.\n\n    # 1. Extract the pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # Prepare the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[pixel_x, pixel_y] = pixel_color  # Set the center pixel\n\n    # 2. Draw concentric squares\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]  # Predefined colors for squares\n    square_size = 1  # Start with 1 pixel square\n    color_index = 0  # To alternate colors\n\n    while True:\n        # The top-left and bottom-right corners of the square\n        top_left_x = pixel_x - square_size\n        top_left_y = pixel_y - square_size\n        bottom_right_x = pixel_x + square_size\n        bottom_right_y = pixel_y + square_size\n        \n        # Check if we are still within the grid boundaries\n        if (top_left_x \u003c 0 or top_left_y \u003c 0 or \n            bottom_right_x \u003e= output_grid.shape[0] or \n            bottom_right_y \u003e= output_grid.shape[1]):\n            break  # Stop if the next square goes out of bounds\n\n        # Draw the square using the current color\n        square_color = colors[color_index % len(colors)]\n        \n        # Draw the top and bottom sides\n        draw_line(output_grid, x=top_left_x, y=top_left_y, direction=(1, 0), color=square_color, length=square_size*2)\n        draw_line(output_grid, x=top_left_x, y=bottom_right_y, direction=(1, 0), color=square_color, length=square_size*2)\n        \n        # Draw the left and right sides\n        draw_line(output_grid, x=top_left_x, y=top_left_y, direction=(0, 1), color=square_color, length=square_size*2)\n        draw_line(output_grid, x=bottom_right_x, y=top_left_y, direction=(0, 1), color=square_color, length=square_size*2)\n\n        # Increase square size and change color for the next square\n        square_size += 2  # Increase size for the next square\n        color_index += 1  # Move to next color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the color for the center pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the pixel anywhere in the grid\n    x = np.random.randint(0, width)\n    y = np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/104/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/104/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/104/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/104/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/104/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/104/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/104/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/104/images/train_output_2.png"}]}, "index": 104, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color, lines, distance\n\n# description:\n# In the input, you will see a grid with two colored pixels: one blue pixel and one orange pixel.\n# To make the output, draw a vertical green line from the blue pixel to the orange pixel. \n# Then, draw another vertical green line from the orange pixel to the bottom of the grid. \n# Finally, draw a horizontal green line from the blue pixel to the right edge of the grid.\n\ndef main(input_grid):\n    # Make output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the index of the blue pixel\n    blue = np.where(input_grid == Color.BLUE)\n    blue_x, blue_y = blue[0][0], blue[1][0]\n\n    # Get the index of the orange pixel\n    orange = np.where(input_grid == Color.ORANGE)\n    orange_x, orange_y = orange[0][0], orange[1][0]\n\n    # Draw the vertical green line from the blue pixel to the orange pixel\n    if blue_y \u003c orange_y:\n        draw_line(output_grid, blue_x, blue_y, end_x=orange_x, end_y=orange_y, color=Color.GREEN)\n    else:\n        draw_line(output_grid, blue_x, blue_y, end_x=orange_x, end_y=orange_y, color=Color.GREEN)\n\n    # Draw the vertical green line from the orange pixel to the bottom of the grid\n    draw_line(output_grid, orange_x, orange_y, length=None, color=Color.GREEN, direction=(0, 1))\n\n    # Draw the horizontal green line from the blue pixel to the right edge of the grid\n    draw_line(output_grid, blue_x, blue_y, length=input_grid.shape[1] - blue_y - 1, color=Color.GREEN, direction=(1, 0))\n\n    return output_grid\n\ndef generate_input():\n    # Make a black grid as the background\n    n = np.random.randint(6, 15)\n    m = np.random.randint(6, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select random position for the blue pixel\n    blue_x = np.random.randint(0, n)\n    blue_y = np.random.randint(0, m)\n    grid[blue_x, blue_y] = Color.BLUE\n\n    # Select random position for the orange pixel\n    orange_x = np.random.randint(0, n)\n    orange_y = np.random.randint(0, m)\n    # Ensure the orange pixel is not in the same column as the blue pixel\n    while orange_y == blue_y:\n        orange_x = np.random.randint(0, n)\n        orange_y = np.random.randint(0, m)\n    grid[orange_x, orange_y] = Color.ORANGE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/105/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/105/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/105/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/105/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/105/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/105/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/105/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/105/images/train_output_2.png"}]}, "index": 105, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, alignment, color transformation\n\n# description:\n# In the input you will see a grid with several multicolor objects. Each object is defined by its boundary of a specific color.\n# To make the output, translate each object so that it is aligned with the bottom edge of the grid and change its color to a specified target color.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all connected components (objects) in the input grid.\n    # 2. For each object, determine its bounding box.\n    # 3. Translate each object downwards so that its bottom edge aligns with the bottom edge of the output grid.\n    # 4. Change the color of each object to the target color.\n\n    # Find all objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=Color.BLACK)\n    \n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Get the output height\n    output_height = output_grid.shape[0]\n\n    # Process each object\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n        \n        # Create a cropped version of the object\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Calculate the offset to translate the object to the bottom of the output grid\n        translate_y = output_height - height - y\n        translated_sprite = translate(sprite, x=0, y=translate_y, background=Color.BLACK)\n        \n        # Change the color of the object to a specified target color (e.g., Color.RED)\n        translated_sprite[translated_sprite != Color.BLACK] = Color.RED\n        \n        # Blit the translated sprite onto the output grid\n        output_grid = blit_object(output_grid, translated_sprite, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with several multicolor objects\n    grid_len = np.random.randint(8, 15)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Create a random number of objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Randomly generate the size of the object\n        sprite_width, sprite_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        \n        # Generate a sprite with a random color\n        object_color = np.random.choice(list(Color.NOT_BLACK))\n        sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[object_color], density=0.5)\n\n        # Randomly place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n        grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/106/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/106/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/106/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/106/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/106/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/106/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/106/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/106/images/train_output_2.png"}]}, "index": 106, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reflection, vertical mirroring\n\n# description:\n# In the input you will see a grid with a pattern of colors and a black border. \n# To make the output, reflect the pattern vertically (mirror it) and place the mirrored pattern next to the original pattern.\n\ndef main(input_grid):\n    # Extract the pattern from the input grid (assuming a black border)\n    pattern = input_grid[1:-1, 1:-1]  # Remove the black border\n\n    # Reflect the pattern vertically\n    mirrored_pattern = pattern[::-1, :]\n\n    # Create the output grid\n    output_height, output_width = pattern.shape\n    output_grid = np.full((output_height, output_width * 2), Color.BLACK)\n\n    # Place the original pattern on the left\n    output_grid[:, :output_width] = pattern\n\n    # Place the mirrored pattern on the right\n    output_grid[:, output_width:] = mirrored_pattern\n\n    return output_grid\n\ndef generate_input():\n    # Create a random pattern of colors with a black border\n    n = np.random.randint(3, 6)  # height of the pattern\n    m = np.random.randint(3, 6)  # width of the pattern\n    pattern = random_sprite(n, m, density=1.0, color_palette=Color.NOT_BLACK)\n\n    # Create an output grid with a black border\n    grid = np.full((n + 2, m + 2), Color.BLACK)  # Add 2 for the border\n\n    # Place the pattern in the center of the grid\n    grid[1:-1, 1:-1] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/107/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/107/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/107/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/107/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/107/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/107/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/107/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/107/images/train_output_2.png"}]}, "index": 107, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity, color transformation, stacking\n\n# description:\n# In the input, you will see a grid with several colored pixels scattered across the grid. To make the output, make all the colored pixels fall to the bottom of the grid like gravity is pulling them. If multiple colored pixels fall into the same column, they will stack on top of each other, and their color will change to yellow upon stacking.\n\ndef main(input_grid):\n    # Create an output grid initialized with the background color (black)\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    width, height = input_grid.shape\n\n    # Process each column to let colored pixels fall\n    for x in range(width):\n        # Keep track of the current height for stacking\n        current_height = height - 1\n        \n        # Iterate from the bottom to the top of the column\n        for y in range(height - 1, -1, -1):\n            if input_grid[x, y] != Color.BLACK:\n                # When a colored pixel is found, place it at the current height\n                output_grid[x, current_height] = Color.YELLOW  # Change color to yellow upon stacking\n                current_height -= 1  # Move up to the next stack position\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with random colored pixels scattered throughout\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly determine how many colored pixels to add\n    num_pixels = np.random.randint(5, 20)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=True)\n\n    # Scatter the colored pixels randomly in the grid\n    for color in colors:\n        x = np.random.randint(0, width)\n        y = np.random.randint(0, height)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/108/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/108/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/108/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/108/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/108/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/108/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/108/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/108/images/train_output_2.png"}]}, "index": 108, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, rectangle detection\n\n# description:\n# In the input, you will see a grid with several colored rectangles on a black background. Each rectangle is filled with a single color.\n# To create the output, invert the colors of the rectangles only, meaning that if a rectangle is filled with a certain color, it will be replaced by a different color, chosen from a pre-defined set that represents the inverted colors.\n\ndef main(input_grid):\n    # Define the color inversion mapping\n    color_inversion_map = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.RED,\n        Color.BLUE: Color.ORANGE,\n        Color.ORANGE: Color.BLUE,\n        Color.YELLOW: Color.PINK,\n        Color.PINK: Color.YELLOW,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.TEAL,\n        Color.GREY: Color.GREY,  # Grey remains grey\n        Color.BLACK: Color.BLACK   # Black remains black\n    }\n    \n    # Find all connected components in the grid, treating black as background\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # For each object (rectangle), invert its color\n    for obj in objects:\n        # Get the first color of the object (all pixels should have the same color)\n        original_color = object_colors(obj, background=Color.BLACK)[0]\n        \n        # Get the inverted color from the mapping\n        inverted_color = color_inversion_map[original_color]\n        \n        # Fill the corresponding area in the output grid with the inverted color\n        obj[obj == original_color] = inverted_color\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_rectangles = np.random.randint(1, 6)  # Generate between 1 and 5 rectangles\n\n    for _ in range(num_rectangles):\n        # Generate random dimensions for the rectangle\n        rect_width = np.random.randint(2, 6)\n        rect_height = np.random.randint(2, 6)\n\n        # Choose a random color for the rectangle (excluding black)\n        rect_color = np.random.choice(list(Color.NOT_BLACK))\n\n        try:\n            # Find random free location for the rectangle\n            x, y = random_free_location_for_sprite(grid, np.full((rect_height, rect_width), rect_color), background=Color.BLACK)\n        except ValueError:\n            continue  # Skip if no location found\n\n        # Draw the rectangle in the chosen color\n        sprite = np.full((rect_height, rect_width), rect_color)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/109/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/109/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/109/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/109/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/109/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/109/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/109/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/109/images/train_output_2.png"}]}, "index": 109, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color inversion\n\n# description:\n# In the input you will see a colored shape on a black background. \n# To make the output, rotate the shape 90 degrees clockwise and invert its color \n# (change red to blue, green to teal, etc.).\n\ndef main(input_grid):\n    # Detect the shape in the input grid\n    shape_components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    assert len(shape_components) == 1, \"There should be exactly one colored shape\"\n\n    # Extract the shape\n    shape = shape_components[0]\n    \n    # Rotate the shape 90 degrees clockwise\n    rotated_shape = np.rot90(shape, -1)  # Rotate clockwise\n\n    # Initialize the output grid with a black background\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Invert the colors of the shape\n    color_inversion_map = {\n        Color.RED: Color.BLUE,\n        Color.BLUE: Color.RED,\n        Color.GREEN: Color.TEAL,\n        Color.TEAL: Color.GREEN,\n        Color.YELLOW: Color.GREY,\n        Color.GREY: Color.YELLOW,\n        Color.PINK: Color.ORANGE,\n        Color.ORANGE: Color.PINK,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.TEAL,\n    }\n\n    # Create a new shape with inverted colors\n    inverted_shape = np.copy(rotated_shape)\n    for color in color_inversion_map:\n        inverted_shape[rotated_shape == color] = color_inversion_map[color]\n\n    # Blit the inverted shape onto the output grid\n    x, y = object_position(shape, background=Color.BLACK)\n    blit_sprite(output_grid, inverted_shape, x=x, y=y)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random sprite (shape) on a black background\n    n = np.random.randint(3, 6)  # Height of the shape\n    m = np.random.randint(3, 6)  # Width of the shape\n    grid = np.full((10, 10), Color.BLACK)  # Create a 10x10 black grid\n\n    # Create a random sprite\n    shape = random_sprite(n, m, density=0.7, color_palette=Color.NOT_BLACK)\n\n    # Place the shape randomly on the grid\n    x, y = random_free_location_for_sprite(grid, shape)\n    blit_sprite(grid, shape, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/110/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/110/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/110/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/110/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/110/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/110/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/110/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/110/images/train_output_2.png"}]}, "index": 110, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation, circular rotation\n\n# description:\n# In the input, you will see a grid with a single colored pixel.\n# To create the output, generate a circular pattern around the colored pixel with the same color, \n# and rotate it 45 degrees counter-clockwise.\n\ndef main(input_grid):\n    # Extract the single colored pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n    \n    # Define the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # Define the size of the circular pattern\n    radius = 3  # You can change this value for different sizes\n\n    # Draw the circular pattern around the pixel\n    for angle in range(0, 360, 45):\n        # Convert angle to radians\n        rad = np.radians(angle)\n        # Calculate the x, y offsets using polar coordinates\n        offset_x = int(radius * np.cos(rad))\n        offset_y = int(radius * np.sin(rad))\n        # Position to place the pixel in the output grid\n        output_x = pixel_x + offset_x\n        output_y = pixel_y + offset_y\n        \n        # Check if the position is within grid boundaries\n        if 0 \u003c= output_x \u003c output_grid.shape[0] and 0 \u003c= output_y \u003c output_grid.shape[1]:\n            output_grid[output_x, output_y] = pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose one color\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the pixel on the grid\n    x, y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/111/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/111/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/111/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/111/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/111/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/111/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/111/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/111/images/train_output_2.png"}]}, "index": 111, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color transformation, object detection\n\n# description:\n# In the input, you will see a grid with various circular objects of different colors, surrounded by a background color.\n# To create the output, change the color of each circular object to a new color based on their original color:\n# red -\u003e blue, green -\u003e yellow, blue -\u003e red, yellow -\u003e green.\n# If an object is not one of these colors, it will remain unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all circular objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    # Define color mapping\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN\n    }\n\n    # Change colors based on the mapping\n    for obj in objects:\n        current_color = object_colors(obj)[0]  # Get the color of the object\n        new_color = color_map.get(current_color, current_color)  # Get the new color or keep it unchanged\n        obj[obj != Color.BLACK] = new_color  # Change color of the object\n\n        # Place the modified object back into the output grid\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Define possible colors for the objects\n    object_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n\n    # Generate a random number of circular objects\n    num_objects = np.random.randint(3, 6)\n    \n    for _ in range(num_objects):\n        while True:\n            # Create a circular sprite with one of the object colors\n            radius = np.random.randint(1, 3)  # Random radius for the circle\n            sprite = draw_circle(radius, color_palette=[np.random.choice(object_colors)])\n            \n            # Attempt to place the sprite onto the grid\n            try:\n                x, y = random_free_location_for_sprite(grid, sprite, padding=radius)\n                grid = blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n                break  # Break if placement was successful\n            except ValueError:\n                continue  # Try again if placement failed\n\n    return grid\n\ndef draw_circle(radius, color_palette):\n    \"\"\" Helper function to create a circular sprite. \"\"\"\n    size = radius * 2 + 1\n    circle = np.full((size, size), Color.BLACK)  # Create a black grid\n    y, x = np.ogrid[-radius:radius + 1, -radius:radius + 1]\n    mask = x**2 + y**2 \u003c= radius**2  # Create a circular mask\n    circle[mask] = color_palette[0]  # Fill circle with color\n    return circle", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/112/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/112/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/112/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/112/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/112/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/112/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/112/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/112/images/train_output_2.png"}]}, "index": 112, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color propagation\n\n# description:\n# In the input you will see a grid with a mix of colored pixels, including red, blue, and green pixels.\n# To make the output:\n# 1. If a red pixel is present, duplicate the entire grid and fill it with red pixels.\n# 2. If a blue pixel is present, duplicate the entire grid and fill it with blue pixels.\n# 3. If a green pixel is present, duplicate the entire grid and fill it with green pixels.\n# The order of these transformations is such that if multiple colored pixels are present, the last color in the order of red \u003e blue \u003e green will determine the final output color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Check for the presence of colored pixels\n    has_red = np.any(input_grid == Color.RED)\n    has_blue = np.any(input_grid == Color.BLUE)\n    has_green = np.any(input_grid == Color.GREEN)\n\n    # Determine the final color based on the presence of red, blue, and green pixels\n    if has_red:\n        output_grid.fill(Color.RED)\n    elif has_blue:\n        output_grid.fill(Color.BLUE)\n    elif has_green:\n        output_grid.fill(Color.GREEN)\n\n    # Scale the output grid by a factor of 2\n    output_grid = scale_sprite(output_grid, 2)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a random grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels in the grid\n    colors_to_place = [Color.RED, Color.BLUE, Color.GREEN]\n    num_pixels = np.random.randint(1, 10)\n\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(colors_to_place)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/113/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/113/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/113/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/113/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/113/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/113/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/113/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/113/images/train_output_2.png"}]}, "index": 113, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# concentric patterns, radial expansion\n\n# description:\n# In the input you will see a grid with a single colored pixel. \n# To create the output, expand concentric circles outward from the colored pixel, coloring the pixels in each circle with the same color as the original pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the location of the colored pixel.\n    # 2. Draw concentric circles around that pixel.\n\n    # Find the colored pixel\u0027s position\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    center_x, center_y = colored_pixel_locations[0]\n\n    # Get the color of the pixel\n    color = input_grid[center_x, center_y]\n\n    # Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Draw concentric circles\n    max_radius = min(center_x, center_y, input_grid.shape[0] - center_x - 1, input_grid.shape[1] - center_y - 1)\n    for radius in range(max_radius + 1):\n        # Draw a circle at the current radius\n        for angle in range(0, 360, 10):  # 10 degrees step for the circle\n            radian = np.deg2rad(angle)\n            x = int(center_x + radius * np.cos(radian))\n            y = int(center_y + radius * np.sin(radian))\n            if 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:\n                output_grid[x, y] = color\n    \n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(5, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose a color for the single pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Place a single colored pixel at a random location\n    center_x = np.random.randint(1, width - 1)\n    center_y = np.random.randint(1, height - 1)\n    grid[center_x, center_y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/114/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/114/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/114/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/114/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/114/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/114/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/114/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/114/images/train_output_2.png"}]}, "index": 114, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# direction, lines, circles\n\n# description:\n# In the input, you will see several circular objects of the same color that are facing different directions. \n# The goal is to find the directions of the circles and draw lines that represent the paths they would have taken in those directions.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    for obj in objects:\n        # Find the bounding box of the object\n        x, y, w, h = bounding_box(obj)\n\n        # Crop the object to extract the sprite\n        sprite = crop(obj)\n\n        # Find the color of the object\n        color = np.unique(obj[obj != Color.BLACK])[0]\n\n        # Calculate the center of the circle\n        center = (x + w // 2, y + h // 2)\n\n        # For a circle, we can determine the direction by checking the positions of the colored pixels around the center\n        # We can use the average distance of colored pixels from the center to determine the direction\n        colored_pixels = np.argwhere(sprite != Color.BLACK)\n        if colored_pixels.size == 0:\n            continue  # Skip if no colored pixels\n\n        mean_position = np.mean(colored_pixels, axis=0)\n\n        # Calculate the direction vector from the center to the mean position\n        direction_vector = np.array(mean_position) - np.array(center)\n        direction = np.sign(direction_vector).astype(int)\n\n        # Draw a line in the direction the circle is facing from the center\n        draw_line(output_grid, center[0], center[1], length=None, color=color, direction=direction)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose the color of the circles\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Create circles by placing them randomly on the grid\n    for _ in range(np.random.randint(3, 6)):\n        # Create a circle sprite\n        radius = np.random.randint(1, 3)\n        diameter = 2 * radius + 1\n        circle = np.zeros((diameter, diameter), dtype=int)\n\n        # Draw a circle by filling the pixels within the radius\n        for i in range(diameter):\n            for j in range(diameter):\n                if (i - radius) ** 2 + (j - radius) ** 2 \u003c= radius ** 2:\n                    circle[i, j] = color\n\n        # Place the circle in a random free location with 1 cell padding\n        x, y = random_free_location_for_sprite(grid, circle, padding=1)\n        blit_sprite(grid, circle, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/115/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/115/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/115/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/115/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/115/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/115/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/115/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/115/images/train_output_2.png"}]}, "index": 115, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object counting, pixel color mapping\n\n# description:\n# In the input you will see a grid with multiple colored objects. Each object has a unique color and consists of multiple pixels.\n# To make the output, count the number of pixels for each object and create a histogram-like representation where each unique color in the input is represented by a single pixel in the output grid.\n# The pixel\u0027s position in the output grid corresponds to the order of appearance of the colors in the input (from left to right, top to bottom).\n\ndef main(input_grid):\n    # Step 1: Find connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n\n    # Step 2: Create a dictionary to count the pixels of each color\n    color_count = {}\n    \n    for obj in objects:\n        # Get the unique color in the object\n        unique_colors = np.unique(obj)\n        for color in unique_colors:\n            if color != Color.BLACK:  # Ignore background\n                if color in color_count:\n                    color_count[color] += np.sum(obj == color)\n                else:\n                    color_count[color] = np.sum(obj == color)\n\n    # Step 3: Create the output grid based on the color counts\n    # The output grid will be a single row with pixels representing the colors\n    output_grid = np.full((1, len(color_count)), Color.BLACK)\n\n    # Step 4: Fill the output grid with colors based on their counts\n    for idx, (color, count) in enumerate(color_count.items()):\n        output_grid[0, idx] = color  # Place color in the output based on its index\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid and randomly place several colored objects\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Random number of objects\n    num_objects = np.random.randint(5, 10)\n    colors_used = set()\n\n    for _ in range(num_objects):\n        # Random size for the sprite\n        sprite_height = np.random.randint(1, 4)\n        sprite_width = np.random.randint(1, 4)\n\n        # Choose a random color ensuring it\u0027s unique\n        color = np.random.choice([c for c in Color.NOT_BLACK if c not in colors_used])\n        colors_used.add(color)\n\n        # Generate the sprite\n        sprite = random_sprite(sprite_height, sprite_width, color_palette=[color], density=1.0)\n\n        # Attempt to place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=4)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            continue  # Skip if no free location was found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/116/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/116/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/116/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/116/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/116/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/116/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/116/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/116/images/train_output_2.png"}]}, "index": 116, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, horizontal and vertical line drawing\n\n# description:\n# In the input, you will see a grid with colored pixels arranged in a grid-like pattern. \n# The output grid will contain a line for each row of colored pixels, where each line\u0027s color matches the color of the corresponding row in the input.\n# If a row contains multiple colors, the output will only take the leftmost color of that row.\n\ndef main(input_grid):\n    # Create an output grid with one pixel for each row of the input grid\n    num_rows, num_cols = input_grid.shape\n    output_grid = np.full((num_rows, 1), Color.BLACK)\n\n    for y in range(num_rows):\n        # Extract the colors from the row, ignoring the black color\n        row_colors = input_grid[y, :]\n        non_black_colors = [color for color in row_colors if color != Color.BLACK]\n\n        # If there are non-black colors, take the leftmost one\n        if non_black_colors:\n            output_grid[y, 0] = non_black_colors[0]\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid of size n x m with random colors\n    n, m = np.random.randint(3, 10), np.random.randint(3, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose some colors\n    colors = np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(1, 5), replace=False)\n\n    # Fill the grid with random colored rows\n    for y in range(n):\n        for x in range(m):\n            if np.random.rand() \u003c 0.5:  # 50% chance to fill a pixel with a color\n                grid[y, x] = np.random.choice(colors)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/117/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/117/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/117/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/117/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/117/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/117/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/117/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/117/images/train_output_2.png"}]}, "index": 117, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# expansion, color change\n\n# description:\n# In the input you will see one or more circles of different colors, each surrounded by a border of a single pixel width.\n# To make the output, swap the color between the circle and its border, \n# then extend the border outward in all directions by the radius of the original circle, \n# filling the new area with the border\u0027s original color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the circles and their borders\n    circles = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n\n    for circle in circles:\n        # Get the bounding box of the circle\n        x, y, width, height = bounding_box(circle, background=Color.BLACK)\n        \n        # Identify the color of the border (assumed to be the pixel surrounding the circle)\n        # The border can be found by checking the pixels around the circle\n        border_color = Color.BLACK\n        circle_color = Color.BLACK\n        \n        for i in range(x-1, x+width+1):\n            for j in range(y-1, y+height+1):\n                if (i \u003e= 0 and i \u003c input_grid.shape[0] and j \u003e= 0 and j \u003c input_grid.shape[1]):\n                    if input_grid[i, j] != Color.BLACK and circle_color == Color.BLACK:\n                        circle_color = input_grid[i, j]\n                    elif input_grid[i, j] != Color.BLACK and input_grid[i, j] != circle_color:\n                        border_color = input_grid[i, j]\n        \n        # Swap the colors of the circle and the border\n        output_grid[output_grid == circle_color] = Color.BLACK  # Remove circle color\n        output_grid[output_grid == border_color] = circle_color  # Set border as circle color\n        output_grid[circle == Color.BLACK] = border_color  # Set the area to border color\n\n        # Calculate radius of the circle (half of the width or height)\n        radius = width // 2\n        \n        # Extend the border outward\n        extended_border_area = np.full((radius, radius), border_color)\n        for dx in range(-radius, radius + 1):\n            for dy in range(-radius, radius + 1):\n                if dx**2 + dy**2 \u003c= radius**2:  # Circle equation\n                    new_x, new_y = x + dx, y + dy\n                    if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                        output_grid[new_x, new_y] = border_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a background grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly decide the number of circles\n    num_circles = np.random.randint(1, 4)\n\n    for _ in range(num_circles):\n        radius = np.random.randint(3, 6)  # Random radius for the circle\n        circle_color = np.random.choice(Color.NOT_BLACK)\n\n        # Create the circle sprite\n        circle_sprite = np.zeros((radius * 2 + 1, radius * 2 + 1), dtype=int)\n        for dx in range(-radius, radius + 1):\n            for dy in range(-radius, radius + 1):\n                if dx**2 + dy**2 \u003c= radius**2:\n                    circle_sprite[dx + radius, dy + radius] = circle_color\n        \n        # Place the circle sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, circle_sprite, padding=1)\n            blit_sprite(grid, circle_sprite, x=x, y=y)\n        except ValueError:\n            continue  # If no space, try again\n        \n        # Draw the border around the circle\n        border_sprite = np.full((circle_sprite.shape[0] + 2, circle_sprite.shape[1] + 2), Color.BLACK)\n        border_sprite[1:-1, 1:-1] = circle_sprite\n        \n        # Add border to the grid\n        blit_sprite(grid, border_sprite, x=x-1, y=y-1)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/118/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/118/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/118/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/118/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/118/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/118/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/118/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/118/images/train_output_2.png"}]}, "index": 118, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, single colored pixel\n\n# description:\n# In the input you will see a grid with a non-black background and a single colored pixel. \n# To make the output, move the colored pixel up by 1 pixel and draw a red outline around the original pixel\u0027s position.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the colored pixel from the input grid\n    # 2. Move the pixel one pixel up\n    # 3. Draw a red outline around the original pixel\u0027s position\n\n    # 1. Extract the pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # 2. Move the pixel one pixel up\n    output_grid = input_grid.copy()\n    if pixel_y \u003e 0:  # Ensure we don\u0027t go out of bounds\n        output_grid[pixel_x, pixel_y - 1] = pixel_color\n        output_grid[pixel_x, pixel_y] = Color.BLACK  # Clear the original position\n\n    # 3. Draw a red outline around the original pixel\u0027s position\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if (dx != 0 or dy != 0):  # Skip the pixel itself\n                if 0 \u003c= pixel_x + dx \u003c output_grid.shape[0] and 0 \u003c= pixel_y + dy \u003c output_grid.shape[1]:\n                    output_grid[pixel_x + dx, pixel_y + dy] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 30, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose one color for the pixel\n    color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.RED])\n\n    # Randomly place the pixel on the grid, avoiding the top row to ensure it can move up\n    x, y = np.random.randint(0, width), np.random.randint(1, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/119/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/119/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/119/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/119/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/119/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/119/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/119/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/119/images/train_output_2.png"}]}, "index": 119, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flipping, mirroring, pattern repetition\n\n# description:\n# In the input you will see a grid with a checkerboard pattern of colors. \n# To make the output, flip the checkerboard pattern horizontally, and then place it above the original pattern.\n\ndef main(input_grid):\n    # Take the input pattern\n    pattern = input_grid\n\n    # Flip the pattern horizontally\n    flipped_pattern = np.fliplr(pattern)\n\n    # Create output grid: height is doubled to accommodate the original and flipped pattern\n    output_grid = np.full((pattern.shape[0] * 2, pattern.shape[1]), Color.BLACK)\n\n    # Place the original pattern in the bottom half\n    blit_sprite(output_grid, pattern, x=0, y=pattern.shape[0])\n\n    # Place the flipped pattern in the top half\n    blit_sprite(output_grid, flipped_pattern, x=0, y=0)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random checkerboard pattern\n    n = np.random.randint(5, 10)  # Height of the grid\n    m = np.random.randint(5, 10)  # Width of the grid\n    grid = np.full((n, m), Color.BLACK)\n\n    # Decide colors for the checkerboard pattern\n    color1 = np.random.choice(Color.NOT_BLACK)\n    color2 = np.random.choice(Color.NOT_BLACK)\n    while color1 == color2:  # Ensure colors are different\n        color2 = np.random.choice(Color.NOT_BLACK)\n    \n    # Fill the grid with a checkerboard pattern\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 2 == 0:\n                grid[i, j] = color1\n            else:\n                grid[i, j] = color2\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/120/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/120/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/120/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/120/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/120/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/120/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/120/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/120/images/train_output_2.png"}]}, "index": 120, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, shape transformation\n\n# description:\n# In the input, you will see a grid with several colored shapes. Each shape is defined by a unique color,\n# and the shapes are separated by a black background. To create the output, you need to transform the input grid\n# so that each shape is replaced by a single pixel representing its color, placed in the center of the original shape.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find connected components in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Prepare the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Iterate over each detected object (shape)\n    for obj in objects:\n        # Get the centroid of the shape\n        y_coords, x_coords = np.where(obj != Color.BLACK)\n        if len(y_coords) \u003e 0 and len(x_coords) \u003e 0:\n            center_y = np.mean(y_coords).astype(int)\n            center_x = np.mean(x_coords).astype(int)\n            # Get the color of the object\n            color = object_colors(obj, background=Color.BLACK)[0]\n            # Place the color in the center of the output grid\n            output_grid[center_y, center_x] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Set the grid size\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of shapes\n    num_shapes = np.random.randint(3, 7)\n    colors_used = set()\n\n    for _ in range(num_shapes):\n        # Randomly choose a color that hasn\u0027t been used yet\n        color = np.random.choice(Color.NOT_BLACK, replace=False)\n\n        # Randomly generate the dimensions of the shape\n        shape_height, shape_width = np.random.randint(2, 6), np.random.randint(2, 6)\n\n        # Create a sprite for the shape\n        sprite = random_sprite(shape_height, shape_width, density=0.5, color_palette=[color])\n\n        # Randomly find a free location to place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n        colors_used.add(color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/121/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/121/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/121/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/121/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/121/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/121/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/121/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/121/images/train_output_2.png"}]}, "index": 121, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, adjacency, pairwise comparison\n\n# description:\n# In the input, you will see a grid containing several colored squares, each square is either colored or black (background).\n# Each colored square has a neighbor of the same color that is adjacent either horizontally or vertically.\n# To make the output, change every colored square to the color of its adjacent square if it is different. \n# If a square has no adjacent colored square, it retains its original color.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Create an output grid initialized to the input grid\n    # 2. Iterate through the grid and check each square for its neighbors\n    # 3. If an adjacent square has a different color, change the color of the current square to that of the adjacent square\n\n    output_grid = input_grid.copy()\n\n    # Get dimensions of the grid\n    rows, cols = output_grid.shape\n\n    for x in range(rows):\n        for y in range(cols):\n            current_color = output_grid[x, y]\n            if current_color == Color.BLACK:\n                continue  # Skip background squares\n            \n            # Check neighbors\n            neighbors = []\n            # Check left\n            if y \u003e 0:\n                neighbors.append(output_grid[x, y - 1])\n            # Check right\n            if y \u003c cols - 1:\n                neighbors.append(output_grid[x, y + 1])\n            # Check up\n            if x \u003e 0:\n                neighbors.append(output_grid[x - 1, y])\n            # Check down\n            if x \u003c rows - 1:\n                neighbors.append(output_grid[x + 1, y])\n            \n            # If any neighbor is a different color, change current square\u0027s color\n            new_color = None\n            for neighbor_color in neighbors:\n                if neighbor_color != current_color and neighbor_color != Color.BLACK:\n                    new_color = neighbor_color\n                    break\n            \n            # If we found a new color, change it\n            if new_color is not None:\n                output_grid[x, y] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with colored squares and a black background\n    rows, cols = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.full((rows, cols), Color.BLACK)\n\n    # Random number of colored squares\n    n_colored_squares = np.random.randint(5, 20)\n    for _ in range(n_colored_squares):\n        # Random color\n        color = random.choice(Color.NOT_BLACK)\n        # Random position\n        x, y = np.random.randint(0, rows), np.random.randint(0, cols)\n\n        # Place the square only if the position is black (background)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = color\n            \n            # Ensure at least one adjacent square has the same color\n            neighbors = []\n            # Check left\n            if y \u003e 0:\n                neighbors.append((x, y - 1))\n            # Check right\n            if y \u003c cols - 1:\n                neighbors.append((x, y + 1))\n            # Check up\n            if x \u003e 0:\n                neighbors.append((x - 1, y))\n            # Check down\n            if x \u003c rows - 1:\n                neighbors.append((x + 1, y))\n            \n            # Randomly choose one neighbor to also color the same\n            if neighbors:\n                nx, ny = random.choice(neighbors)\n                if grid[nx, ny] == Color.BLACK:\n                    grid[nx, ny] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/122/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/122/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/122/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/122/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/122/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/122/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/122/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/122/images/train_output_2.png"}]}, "index": 122, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color transformation\n\n# description:\n# In the input you will see a grid with several colored shapes. Each shape can be a triangle, square, or circle, and they will be filled with different colors. \n# To create the output, you should identify the shapes and replace the triangles with yellow, squares with green, and circles with blue.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Identify connected components in input grid\n    background_color = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background_color)\n\n    for obj in objects:\n        # Crop the object from the grid\n        sprite = crop(obj, background=background_color)\n\n        # Determine the shape based on its pixel configuration\n        # Count the number of pixels in each row and column\n        height, width = sprite.shape\n        row_sums = np.sum(sprite != background_color, axis=1)\n        col_sums = np.sum(sprite != background_color, axis=0)\n\n        # Determine if the shape is triangle, square, or circle\n        if np.any(row_sums == 1) and np.any(row_sums == height):  # A triangle should have one side with only one pixel\n            new_color = Color.YELLOW\n        elif np.all(row_sums == height) and np.all(col_sums == width):  # A square will fill its bounding box completely\n            new_color = Color.GREEN\n        elif np.all(np.logical_or(row_sums == 1, col_sums == 1)):  # A circle will have low pixel counts\n            new_color = Color.BLUE\n        else:\n            continue  # If it doesn\u0027t match any shape, skip it\n\n        # Color the object with the new color\n        sprite[sprite != background_color] = new_color\n        blit_sprite(output_grid, sprite=sprite, x=object_position(obj)[0], y=object_position(obj)[1])\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m with random shapes\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    shape_types = [\u0027triangle\u0027, \u0027square\u0027, \u0027circle\u0027]\n    num_shapes = np.random.randint(5, 15)\n\n    for _ in range(num_shapes):\n        shape_type = random.choice(shape_types)\n        if shape_type == \u0027triangle\u0027:\n            # Create a simple triangle shape\n            height = np.random.randint(3, 6)\n            base_width = height * 2 - 1\n            triangle = np.full((height, base_width), Color.BLACK)\n            for i in range(height):\n                triangle[i, height - 1 - i:height - 1 + i + 1] = Color.RED\n\n            # Place the triangle on the grid\n            x, y = random_free_location_for_sprite(grid, triangle, background=Color.BLACK)\n            blit_sprite(grid, triangle, x=x, y=y)\n\n        elif shape_type == \u0027square\u0027:\n            # Create a simple square shape\n            square_size = np.random.randint(3, 6)\n            square = np.full((square_size, square_size), Color.RED)\n            x, y = random_free_location_for_sprite(grid, square, background=Color.BLACK)\n            blit_sprite(grid, square, x=x, y=y)\n\n        elif shape_type == \u0027circle\u0027:\n            # Create a simple circle shape using a filled mask\n            radius = np.random.randint(2, 4)\n            circle = np.full((radius * 2 + 1, radius * 2 + 1), Color.BLACK)\n            for i in range(circle.shape[0]):\n                for j in range(circle.shape[1]):\n                    if (i - radius) ** 2 + (j - radius) ** 2 \u003c= radius ** 2:\n                        circle[i, j] = Color.RED\n\n            x, y = random_free_location_for_sprite(grid, circle, background=Color.BLACK)\n            blit_sprite(grid, circle, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/123/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/123/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/123/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/123/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/123/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/123/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/123/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/123/images/train_output_2.png"}]}, "index": 123, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mixing, spreading\n\n# description:\n# In the input, you will see a blue object and a red object close together on a black background.\n# To make the output, mix the colors of the blue and red objects to create a purple object, and spread it out in a circular pattern around the original positions of the blue and red objects.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the blue and red objects\n    # 2. Create a new purple object by mixing the colors of blue and red\n    # 3. Spread the purple object in a circular pattern around the original positions of blue and red objects\n\n    # 1. Find the blue and red objects\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=True)\n    blue_objects = [obj for obj in objects if Color.BLUE in object_colors(obj, background=Color.BLACK)]\n    red_objects = [obj for obj in objects if Color.RED in object_colors(obj, background=Color.BLACK)]\n\n    assert len(blue_objects) == 1, \"There should be exactly one blue object\"\n    assert len(red_objects) == 1, \"There should be exactly one red object\"\n\n    blue_object = blue_objects[0]\n    red_object = red_objects[0]\n\n    # 2. Create a new purple object (we\u0027ll consider it as a blend of red and blue)\n    purple_object = np.full_like(blue_object, Color.MAROON)  # Use maroon as a stand-in for purple\n\n    # 3. Spread the purple object in a circular pattern around the original positions\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Get the positions of the blue and red objects\n    blue_x, blue_y = object_position(blue_object, background=Color.BLACK, anchor=\u0027center\u0027)\n    red_x, red_y = object_position(red_object, background=Color.BLACK, anchor=\u0027center\u0027)\n\n    # Place the purple object in a circular pattern around the original positions\n    radius = 3  # Define the radius of spread\n    for dx in range(-radius, radius + 1):\n        for dy in range(-radius, radius + 1):\n            if dx**2 + dy**2 \u003c= radius**2:  # Circle equation\n                if 0 \u003c= blue_x + dx \u003c output_grid.shape[0] and 0 \u003c= blue_y + dy \u003c output_grid.shape[1]:\n                    output_grid[blue_x + dx, blue_y + dy] = Color.MAROON\n                if 0 \u003c= red_x + dx \u003c output_grid.shape[0] and 0 \u003c= red_y + dy \u003c output_grid.shape[1]:\n                    output_grid[red_x + dx, red_y + dy] = Color.MAROON\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a black background and randomly place a blue and a red object close to each other.\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place the blue object\n    blue_sprite = random_sprite(3, 3, color_palette=[Color.BLUE])\n    x1, y1 = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, blue_sprite, x1, y1, background=Color.BLACK)\n\n    # Place the red object close to the blue object\n    red_sprite = random_sprite(3, 3, color_palette=[Color.RED])\n    x2, y2 = x1 + np.random.choice([-1, 0, 1]), y1 + np.random.choice([-1, 0, 1])  # Place it adjacent\n    blit_sprite(grid, red_sprite, x2, y2, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/124/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/124/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/124/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/124/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/124/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/124/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/124/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/124/images/train_output_2.png"}]}, "index": 124, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color correspondence, mirroring\n\n# description:\n# In the input you will see a grid with two distinct patterns of colored pixels. Each pattern is separated by a row of black pixels.\n# The patterns are composed of blue and yellow pixels. To make the output, you should mirror each pattern vertically and then \n# replace the corresponding colored pixels in the output grid with the colors from the input patterns. \n# The output grid should maintain the same dimensions as the input grid.\n\ndef main(input_grid):\n    # Detect the connected components (patterns) in the input grid\n    objects = detect_objects(grid=input_grid, colors=[Color.BLUE, Color.YELLOW], monochromatic=False, connectivity=8)\n\n    # Initialize the output grid as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    for obj in objects:\n        # Crop the pattern from the input grid\n        pattern = crop(obj, background=Color.BLACK)\n\n        # Mirror the pattern vertically\n        mirrored_pattern = np.flipud(pattern)\n\n        # Find the bounding box of the original pattern\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n\n        # Place the mirrored pattern in the corresponding location in the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=mirrored_pattern, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Set the size of the grid\n    n, m = 8, 6\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the colors for the patterns\n    colors = [Color.BLUE, Color.YELLOW]\n    \n    # Generate two distinct patterns separated by a row of black pixels\n    for i in range(2):\n        # Create a random pattern of the selected color\n        pattern_color = np.random.choice(colors)\n        pattern = random_sprite(n=3, m=3, density=0.5, color_palette=[pattern_color], background=Color.BLACK)\n\n        # Define the position of the pattern in the grid\n        x = i * 4  # Leave a row of black pixels separating the patterns\n        y = 1\n\n        # Place the pattern in the grid\n        grid = blit_sprite(grid=grid, sprite=pattern, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/125/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/125/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/125/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/125/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/125/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/125/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/125/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/125/images/train_output_2.png"}]}, "index": 125, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, grid transformation\n\n# description:\n# The input is a grid where each column is of the same color. \n# To make the output, change each color according to the following mapping:\n# green -\u003e blue, blue -\u003e red, red -\u003e yellow, yellow -\u003e green, \n# teal -\u003e pink, pink -\u003e maroon, maroon -\u003e orange, orange -\u003e teal\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Performs color mapping\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n    \n# Constructing the color map\ncolor_map = {\n    Color.GREEN: Color.BLUE, \n    Color.BLUE: Color.RED, \n    Color.RED: Color.YELLOW, \n    Color.YELLOW: Color.GREEN,\n    Color.TEAL: Color.PINK, \n    Color.PINK: Color.MAROON, \n    Color.MAROON: Color.ORANGE, \n    Color.ORANGE: Color.TEAL\n}\n\ndef generate_input():\n    # Create a grid of arbitrary size with each column having a single color\n    n = np.random.randint(5, 15)  # number of rows\n    m = np.random.randint(5, 15)  # number of columns\n    grid = np.full((n, m), Color.BLACK)\n\n    # Fill each column with a random color from the color_map keys\n    for j in range(m):\n        grid[:, j] = random.choice(list(color_map.keys()))\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/126/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/126/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/126/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/126/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/126/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/126/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/126/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/126/images/train_output_2.png"}]}, "index": 126, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation, flipping, overlaying\n\n# description:\n# In the input you will see a grid with concentric circular wave patterns.\n# To make the output, you should flip the input grid horizontally and place it beneath the original pattern,\n# then overlay the flipped input grid on top of the original pattern with a slight offset.\n\ndef main(input_grid):\n    # Get the size of the input grid\n    input_height, input_width = input_grid.shape\n\n    # Create the output grid\n    output_grid = np.full((input_height + input_height // 2, input_width), Color.BLACK)\n\n    # Copy the original input grid to the output\n    blit_sprite(output_grid, input_grid, x=0, y=0)\n\n    # Flip the input grid horizontally\n    flipped_input = np.fliplr(input_grid)\n\n    # Overlay the flipped input grid with an offset\n    blit_sprite(output_grid, flipped_input, x=0, y=input_height // 2)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid for concentric wave patterns\n    width, height = 10, 10\n    grid = np.full((height, width), Color.BLACK)\n\n    # Create concentric waves\n    num_waves = np.random.randint(3, 6)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_waves, replace=False)\n\n    for i in range(num_waves):\n        color = colors[i]\n        radius = i + 1\n        for j in range(radius):\n            # Draw the wave as a circle of a certain thickness\n            draw_line(grid, j, radius - 1 - j, end_x=j, end_y=height - radius + j, color=color)  # left vertical\n            draw_line(grid, width - 1 - j, radius - 1 - j, end_x=width - 1 - j, end_y=height - radius + j, color=color)  # right vertical\n            draw_line(grid, j, radius - 1 - j, end_x=width - 1 - j, end_y=radius - 1 - j, color=color)  # top horizontal\n            draw_line(grid, j, height - radius + j, end_x=width - 1 - j, end_y=height - radius + j, color=color)  # bottom horizontal\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/127/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/127/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/127/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/127/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/127/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/127/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/127/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/127/images/train_output_2.png"}]}, "index": 127, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color removal, uniqueness\n\n# description:\n# In the input, you will see a grid filled with several colored objects, each consisting of a unique shape. \n# To create the output, find the object whose shape is the most unique (has the most pixels) and extract it from the grid.\n# All other pixels should be turned black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a blank output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Step 1: Find all connected components (objects) in the grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Step 2: Identify the most unique object by its area (number of pixels)\n    largest_object = max(objects, key=lambda obj: np.count_nonzero(obj))\n\n    # Step 3: Extract the largest unique object and place it in the output grid\n    output_grid[largest_object \u003e 0] = largest_object[largest_object \u003e 0]  # Take the color of the largest object\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = random.randint(10, 20), random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define a random number of objects to place in the grid\n    num_objects = random.randint(2, 5)\n    colors = random.sample(Color.NOT_BLACK, num_objects)\n\n    for color in colors:\n        # Randomly generate dimensions for each object\n        height, width = random.randint(2, 5), random.randint(2, 5)\n        object_sprite = random_sprite(height, width, density=0.5, color_palette=[color])\n\n        # Find a free location to place the object in the grid\n        x, y = random_free_location_for_sprite(grid, object_sprite, background=Color.BLACK)\n        blit_sprite(grid, object_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/128/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/128/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/128/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/128/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/128/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/128/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/128/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/128/images/train_output_2.png"}]}, "index": 128, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# quadrant division, color mapping\n\n# description:\n# In the input you will see a large multicolored object divided into four quadrants by black separators.\n# Each quadrant has a distinct color that is used to fill a larger rectangular area in the output grid.\n# To make the output, split the object into four equal parts and change the color of each part to match the color of the corresponding quadrant in the input.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the separators to divide the input into four quadrants\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == Color.BLACK):\n            x_separator = i\n            break\n    for i in range(input_grid.shape[1]):\n        if np.all(input_grid[:, i] == Color.BLACK):\n            y_separator = i\n            break\n\n    # Define the quadrants\n    quadrants = [\n        input_grid[:x_separator, :y_separator],  # Top-left\n        input_grid[:x_separator, y_separator:],  # Top-right\n        input_grid[x_separator:, :y_separator],  # Bottom-left\n        input_grid[x_separator:, y_separator:]   # Bottom-right\n    ]\n\n    # Extract the color of each quadrant\n    quadrant_colors = [np.unique(quadrant[quadrant != Color.BLACK]) for quadrant in quadrants]\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Fill the output grid with the corresponding colors from each quadrant\n    for i, quadrant in enumerate(quadrants):\n        if len(quadrant_colors[i]) == 1:  # Ensure there is a single color in the quadrant\n            color = quadrant_colors[i][0]\n            output_grid[i // 2 * (x_separator): (i // 2 + 1) * (x_separator),\n                         (i % 2) * (y_separator): (i % 2 + 1) * (y_separator)] = color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with a large multicolored object divided into quadrants\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly determine sizes for the quadrants\n    x_size = np.random.randint(5, n // 2)\n    y_size = np.random.randint(5, m // 2)\n\n    # Generate colors for the quadrants\n    colors = random.sample(Color.NOT_BLACK, 4)\n\n    # Fill the quadrants with colors and add black separators\n    grid[:x_size, :y_size] = colors[0]  # Top-left\n    grid[:x_size, y_size:2*y_size] = colors[1]  # Top-right\n    grid[x_size:2*x_size, :y_size] = colors[2]  # Bottom-left\n    grid[x_size:2*x_size, y_size:2*y_size] = colors[3]  # Bottom-right\n\n    # Add black separators\n    grid[x_size, :] = Color.BLACK\n    grid[:, y_size] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/129/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/129/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/129/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/129/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/129/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/129/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/129/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/129/images/train_output_2.png"}]}, "index": 129, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, symmetry\n\n# description:\n# In the input, you will see a grid with various colored shapes. Each shape has a unique color and is symmetrically positioned on one side of a vertical line. \n# To make the output, reflect each shape across the vertical line and fill in the corresponding area on the opposite side with the same color.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    \n    # Determine the vertical line of reflection (middle column)\n    mid_x = input_grid.shape[1] // 2\n    \n    # Find objects in the left half of the grid\n    left_half = input_grid[:, :mid_x]\n    \n    # Find connected components in the left half\n    objects = find_connected_components(left_half, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        \n        # Crop the object\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Reflect the sprite horizontally\n        reflected_sprite = np.fliplr(sprite)\n\n        # Determine position to place the reflected sprite in the right half\n        placement_x = x  # Same y-coordinate\n        placement_y = mid_x + (mid_x - (x + w))  # Mirroring the position\n\n        # Place the reflected sprite in the output grid\n        blit_sprite(output_grid, reflected_sprite, x=placement_x, y=placement_y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define colors\n    possible_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON]\n    \n    # Randomly generate shapes in the left half of the grid\n    for _ in range(np.random.randint(2, 5)):\n        # Random size for the shape\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n        # Create a sprite with a random color\n        sprite_color = np.random.choice(possible_colors)\n\n        # Generate random sprite\n        shape = random_sprite(n=w, m=h, density=0.5, color_palette=[sprite_color], background=Color.BLACK)\n\n        # Randomly place the sprite in the left half\n        x, y = np.random.randint(0, n), np.random.randint(0, m // 2 - h)\n        blit_sprite(grid, shape, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/130/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/130/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/130/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/130/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/130/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/130/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/130/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/130/images/train_output_2.png"}]}, "index": 130, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swapping, pixel manipulation\n\n# description:\n# In the input you will see a grid with colored pixels. To make the output grid, you should swap the colors of each pixel with the color of the pixel to its right.\ndef main(input_grid):\n    # Create a copy of the input grid to store the output\n    output_grid = input_grid.copy()\n    \n    # Get the dimensions of the grid\n    height, width = input_grid.shape\n    \n    # Iterate through each pixel in the grid\n    for y in range(height):\n        for x in range(width - 1):  # Avoid the last column, as it has no right neighbor\n            # Swap color with the pixel to the right\n            output_grid[y, x], output_grid[y, x + 1] = output_grid[y, x + 1], output_grid[y, x]\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(3, 10), np.random.randint(3, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select colors for the grid, ensuring not to use black\n    colors = np.random.choice(list(Color.NOT_BLACK), size=n*m, replace=True)\n    \n    # Fill the grid with the selected colors\n    grid[:] = colors.reshape(n, m)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/131/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/131/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/131/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/131/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/131/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/131/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/131/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/131/images/train_output_2.png"}]}, "index": 131, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, grid manipulation\n\n# description:\n# In the input, you will see a grid with several square objects of different colors.\n# To make the output, mirror all square objects horizontally and vertically, creating a new grid with these mirrored versions.\n\ndef main(input_grid):\n    # Detect connected components (objects) in the input grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, background=background, connectivity=4, monochromatic=False)\n\n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, background)\n\n    # For each object, mirror it and place it in the output grid\n    for obj in objects:\n        # Get the position of the object\n        obj_positions = np.argwhere(obj != background)\n\n        # Mirror the object horizontally and vertically\n        for x, y in obj_positions:\n            # Determine the new positions after mirroring\n            mirrored_x = input_grid.shape[0] - 1 - x  # Horizontal mirror\n            mirrored_y = input_grid.shape[1] - 1 - y  # Vertical mirror\n\n            # Set the color in the output grid\n            output_grid[mirrored_x, mirrored_y] = obj[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate an input grid with random square objects of different colors\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)  # Random grid size\n    grid = np.full((n, m), Color.BLACK)  # Initialize the grid to black\n\n    # Randomly create objects in the grid\n    num_objects = np.random.randint(3, 6)  # Number of objects\n    for _ in range(num_objects):\n        # Random size for each object\n        obj_height, obj_width = np.random.randint(2, 4), np.random.randint(2, 4)\n        obj_color = np.random.choice(Color.NOT_BLACK)  # Random color\n        obj = random_sprite(n=obj_height, m=obj_width, density=1, color_palette=[obj_color])\n\n        # Find a random position to place the object in the grid\n        x, y = random_free_location_for_sprite(grid, obj)\n        grid = blit_sprite(grid, obj, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/132/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/132/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/132/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/132/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/132/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/132/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/132/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/132/images/train_output_2.png"}]}, "index": 132, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel pattern growth, color directionality\n\n# description:\n# In the input, you will see a grid filled with colored pixels. Each colored pixel corresponds to a specific growth pattern:\n# - Yellow pixels grow upward (coloring the entire column above them).\n# - Maroon pixels grow downward (coloring the entire column below them).\n# - Blue pixels grow horizontally (coloring the entire row to the left and right).\n# The output grid will reflect these growth patterns based on the colored pixels in the input.\n\ndef main(input_grid):\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # Find the positions of each color\n    yellow_pixels = np.where(output_grid == Color.YELLOW)\n    maroon_pixels = np.where(output_grid == Color.MAROON)\n    blue_pixels = np.where(output_grid == Color.BLUE)\n\n    # Grow upward from yellow pixels\n    for x, y in zip(yellow_pixels[0], yellow_pixels[1]):\n        for i in range(y, -1, -1):  # Go upward\n            output_grid[i, x] = Color.YELLOW\n\n    # Grow downward from maroon pixels\n    for x, y in zip(maroon_pixels[0], maroon_pixels[1]):\n        for i in range(y, height):  # Go downward\n            output_grid[i, x] = Color.MAROON\n\n    # Grow horizontally from blue pixels\n    for x, y in zip(blue_pixels[0], blue_pixels[1]):\n        for i in range(0, width):  # Go horizontally\n            output_grid[y, i] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with dimensions between 5x5 and 10x10\n    width, height = np.random.randint(5, 11, size=2)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly choose the number of colored pixels (1 to 5)\n    num_pixels = np.random.randint(1, 6)\n    colors = np.random.choice([Color.YELLOW, Color.MAROON, Color.BLUE], size=num_pixels, replace=True)\n\n    # Place colored pixels in random locations\n    for color in colors:\n        while True:\n            x = np.random.randint(0, width)\n            y = np.random.randint(0, height)\n            if grid[y, x] == Color.BLACK:  # Ensure the spot is empty\n                grid[y, x] = color\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/133/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/133/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/133/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/133/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/133/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/133/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/133/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/133/images/train_output_2.png"}]}, "index": 133, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel pattern expansion, radial growth\n\n# description:\n# In the input you will see a grid with a pattern of colored pixels. \n# To make the output, you should expand the pattern outward in a radial manner, \n# where each colored pixel will grow into a 3x3 block of the same color. \n# The output grid should be the same size as the input grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all colored pixels in the input grid\n    # 2. For each colored pixel, expand it into a 3x3 block in the output grid\n    # 3. Ensure the output grid is filled correctly without going out of bounds\n\n    # Identify all colored pixels\n    colored_pixels = detect_objects(input_grid, colors=Color.NOT_BLACK, monochromatic=True, allowed_dimensions=[(1, 1)])\n\n    # Create output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Expand each colored pixel into a 3x3 block\n    for pixel in colored_pixels:\n        pixel_x, pixel_y = object_position(pixel, background=Color.BLACK)\n        pixel_color = object_colors(pixel)[0]\n\n        # Define the 3x3 block coordinates\n        for dx in range(-1, 2):  # -1, 0, 1\n            for dy in range(-1, 2):  # -1, 0, 1\n                new_x = pixel_x + dx\n                new_y = pixel_y + dy\n                \n                # Check bounds and fill the output grid\n                if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                    output_grid[new_x, new_y] = pixel_color\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid of size n x m with a black background\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place a random number of colored pixels in the grid\n    num_pixels = np.random.randint(1, 10)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=False)\n\n    # Randomly place colored pixels within the grid while ensuring some space\n    for color in colors:\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/134/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/134/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/134/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/134/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/134/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/134/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/134/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/134/images/train_output_2.png"}]}, "index": 134, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, mirroring, expansion\n\n# description:\n# In the input, you will see a grid with several colored pixels aligned in a row. \n# To create the output, you should mirror the row of colors vertically from the bottom of the row, \n# and expand the resulting colors to fill a square grid, where the size of the square grid is equal to the length of the input row.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the row of colors from the input grid.\n    # 2. Mirror the row of colors vertically.\n    # 3. Create an output grid and fill it with the mirrored colors.\n\n    # 1. Extract the row of colors\n    row_indices = np.any(input_grid != Color.BLACK, axis=1)\n    colors_row = input_grid[row_indices, :].flatten()\n\n    # Remove any black pixels, keeping only the colored pixels\n    colors_row = colors_row[colors_row != Color.BLACK]\n    \n    # 2. Mirror the row of colors vertically\n    mirrored_row = np.concatenate((colors_row, colors_row[::-1]))\n\n    # 3. Create the output grid and fill it with the mirrored colors\n    output_size = mirrored_row.shape[0]\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    for i in range(output_size):\n        output_grid[i, :] = mirrored_row[i % mirrored_row.size]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a row of colors\n    width = np.random.randint(3, 10)\n    grid = np.full((width, 1), Color.BLACK)\n\n    # Randomly choose colors for the row\n    colors = np.random.choice(Color.NOT_BLACK, size=width, replace=False)\n    for x in range(width):\n        # Randomly assign a color to each pixel with a certain probability\n        if np.random.rand() \u003c 0.7:\n            grid[x, 0] = colors[x]\n\n    # The grid is one column wide, but we can still process it as a 2D grid\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/135/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/135/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/135/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/135/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/135/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/135/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/135/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/135/images/train_output_2.png"}]}, "index": 135, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel detection, square placement, color filling\n\n# description:\n# In the input, you will see a grid with a single pixel of a different color surrounded by a background color.\n# To make the output, you should detect the pixel and create a 5x5 square of the same color centered on the pixel\u0027s location.\n\ndef main(input_grid):\n    # Identify the coordinates of the unique colored pixel\n    coords = np.argwhere(input_grid != Color.BLACK)  # Assuming background is black\n    if coords.size == 0:\n        return input_grid  # No colored pixel found, return original grid\n    \n    # Get the position of the colored pixel\n    x, y = coords[0]  # Taking the first found pixel\n    output_grid = np.zeros_like(input_grid)  # Create an output grid of the same shape\n\n    # Define the color of the detected pixel\n    pixel_color = input_grid[x, y]\n\n    # Place a 5x5 square of the detected color centered on the identified pixel\n    half_size = 2  # Since we want a 5x5 square\n    for i in range(-half_size, half_size + 1):\n        for j in range(-half_size, half_size + 1):\n            new_x, new_y = x + i, y + j\n            # Ensure we don\u0027t go out of bounds\n            if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                output_grid[new_x, new_y] = pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define available colors excluding black\n    available_colors = [color for color in Color.ALL_COLORS if color != Color.BLACK]\n\n    # Randomly select a color for the single pixel\n    single_color = np.random.choice(available_colors)\n\n    # Randomly place a single colored pixel in the grid\n    x, y = np.random.randint(n), np.random.randint(m)\n    grid[x, y] = single_color\n\n    # Fill the rest of the grid with the background color (black)\n    # This is already handled by the default initialization of the grid\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/136/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/136/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/136/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/136/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/136/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/136/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/136/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/136/images/train_output_2.png"}]}, "index": 136, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# sorting, color change, height, spacing\n\n# description:\n# In the input you will see a row of exactly 3 green bars of different heights, each starting at the bottom of the canvas, and each separated by 1 pixel.\n# Color the tallest one blue, the second tallest one red, and the shortest one yellow.\n\ndef main(input_grid):\n    # Extract the bars, each of which is a connected component\n    bars = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Sort the bars by height\n    bars = list(sorted(bars, key=lambda bar: np.sum(bar != Color.BLACK), reverse=True))\n\n    # Prepare a blank output grid\n    output_grid = input_grid.copy()\n\n    # Color the bars based on their height\n    if len(bars) \u003e= 3:\n        tallest_bar = bars[0]\n        tallest_bar_mask = tallest_bar != Color.BLACK\n        output_grid[tallest_bar_mask] = Color.BLUE\n\n        second_tallest_bar = bars[1]\n        second_tallest_bar_mask = second_tallest_bar != Color.BLACK\n        output_grid[second_tallest_bar_mask] = Color.RED\n\n        shortest_bar = bars[2]\n        shortest_bar_mask = shortest_bar != Color.BLACK\n        output_grid[shortest_bar_mask] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of size 9x9\n    n, m = 9, 9\n    grid = np.zeros((n, m), dtype=int)\n\n    # Pick 3 distinct heights (can\u0027t reuse the same height)\n    heights = random.sample(range(1, 9), 3)\n\n    # Draw the bars, separated by 1 pixel\n    for i, height in enumerate(heights):\n        grid[n - height:, 1 + i * 2] = Color.GREEN  # Placing bars in the second column, ensure separation\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/137/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/137/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/137/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/137/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/137/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/137/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/137/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/137/images/train_output_2.png"}]}, "index": 137, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, mirroring, horizontal symmetry\n\n# description:\n# In the input you will see a grid with a pattern on the left side and a different pattern on the right side.\n# The two patterns are symmetric along a vertical axis.\n# To make the output, you should mirror the left pattern onto the right side of the grid.\n\ndef main(input_grid):\n    # Determine the width and height of the input grid\n    width, height = input_grid.shape\n    \n    # Calculate the midpoint for mirroring\n    midpoint = width // 2\n\n    # Extract the left pattern from the input grid\n    left_pattern = input_grid[:, :midpoint]\n\n    # Create the output grid by concatenating the left pattern and its mirrored version\n    mirrored_pattern = np.fliplr(left_pattern)\n    output_grid = np.concatenate((left_pattern, mirrored_pattern), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random height for the grid\n    height = np.random.randint(3, 6)\n    \n    # Generate a random width for the left pattern (ensuring there\u0027s space for mirroring)\n    left_pattern_width = np.random.randint(3, 6)\n    \n    # The total grid width will be double the left pattern width for mirroring\n    total_width = left_pattern_width * 2\n    \n    # Create a grid filled with black color\n    grid = np.full((height, total_width), Color.BLACK)\n\n    # Select a color for the left pattern\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Fill the left pattern randomly, ensuring symmetry with the right side\n    for i in range(height):\n        for j in range(left_pattern_width):\n            if np.random.rand() \u003e 0.5:  # Randomly decide to color a pixel\n                grid[i, j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/138/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/138/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/138/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/138/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/138/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/138/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/138/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/138/images/train_output_2.png"}]}, "index": 138, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input, you will see a grid with a green circular object in the center.\n# To make the output, rotate the green circular object 90 degrees clockwise and change its color to blue.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find the green circular object in the grid\n    object_color = Color.GREEN\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background)\n    \n    # Assuming there is exactly one green circular object\n    assert len(objects) == 1\n    green_object = objects[0]\n    \n    # Get the bounding box of the object and crop it\n    x, y, w, h = bounding_box(green_object, background=background)\n    sprite = crop(green_object, background=Color.BLACK)\n\n    # Change its color to blue\n    sprite[sprite == object_color] = Color.BLUE\n\n    # Rotate the sprite 90 degrees clockwise\n    sprite = np.rot90(sprite, -1)\n\n    # Blit the transformed sprite onto the output grid at the same position\n    blit_sprite(output_grid, sprite=sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a green circular object in the center of the grid\n    object_color = Color.GREEN\n    radius = np.random.randint(2, 5)\n    center_x, center_y = n // 2, m // 2\n\n    # Draw a circle\n    for i in range(n):\n        for j in range(m):\n            if (i - center_x) ** 2 + (j - center_y) ** 2 \u003c= radius ** 2:\n                grid[i, j] = object_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/139/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/139/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/139/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/139/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/139/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/139/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/139/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/139/images/train_output_2.png"}]}, "index": 139, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, mirroring\n\n# description:\n# In the input grid, you will see a complex shape created with colored pixels. The shape is contained within a rectangular area of colored pixels against a black background.\n# To create the output grid, reflect the shape across the vertical centerline of the grid, creating a mirror image of the shape on the right side of the grid.\n\ndef main(input_grid):\n    # 1. Create the output grid with the same dimensions as the input grid\n    output_grid = input_grid.copy()\n\n    # 2. Calculate the center of the grid\n    center_x = input_grid.shape[1] // 2\n\n    # 3. Reflect the left half of the input grid across the vertical centerline\n    for x in range(center_x):\n        for y in range(input_grid.shape[0]):\n            output_grid[y, input_grid.shape[1] - 1 - x] = input_grid[y, x]\n\n    return output_grid\n\ndef generate_input():\n    # Randomly generate a grid with a complex shape\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Create a random shape that fills a portion of the grid\n    shape_width = np.random.randint(3, width // 2)\n    shape_height = np.random.randint(3, height)\n    \n    # Randomly choose the position for the shape\n    start_x = np.random.randint(0, width - shape_width)\n    start_y = np.random.randint(0, height - shape_height)\n\n    # Fill the shape with random colors\n    colors = np.random.choice(Color.NOT_BLACK, size=shape_width * shape_height)\n    for i in range(shape_width):\n        for j in range(shape_height):\n            grid[start_y + j, start_x + i] = colors[j * shape_width + i]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/140/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/140/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/140/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/140/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/140/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/140/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/140/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/140/images/train_output_2.png"}]}, "index": 140, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern, horizontal repetition\n\n# description:\n# In the input you will see a grid with a single colored pixel in the leftmost column.\n# To make the output, move the colored pixel to the right one pixel and draw a green line from the pixel to the right edge of the grid.\n# Finally, repeat the green line by repeating it vertically up/down with a period of 2 pixels.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the pixel from the input grid\n    # 2. Move the pixel one pixel to the right\n    # 3. Draw a green line from the pixel to the right edge of the grid, repeating it vertically up/down with a period of 2 pixels\n\n    # 1. Extract the pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # 2. Move the pixel one pixel to the right\n    output_grid = input_grid.copy()\n    output_grid[pixel_x + 1, pixel_y] = pixel_color\n    output_grid[pixel_x, pixel_y] = Color.BLACK\n\n    # 3. Draw the horizontal line from the pixel to the right edge\n    for x in range(pixel_x + 1, output_grid.shape[0]):\n        output_grid[x, pixel_y] = Color.GREEN\n\n    # Repeat the line vertically up/down with a period of 2 pixels\n    for y in range(pixel_y, output_grid.shape[1]):\n        if y % 2 == 0:  # Draw on even rows\n            output_grid[pixel_x + 1, y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 30, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose one color\n    color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.GREEN])\n\n    # Randomly place the pixel in the leftmost column\n    x = np.random.randint(0, width - 1)\n    grid[0, x] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/141/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/141/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/141/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/141/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/141/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/141/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/141/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/141/images/train_output_2.png"}]}, "index": 141, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color shifting\n\n# description:\n# In the input, you will see a grid filled with randomly colored pixels on a black background.\n# The colors can include red, yellow, green, and blue.\n# To make the output:\n# 1. For each red pixel, change its color to yellow.\n# 2. For each yellow pixel, change its color to green.\n# 3. For each green pixel, change its color to blue.\n# 4. For each blue pixel, change its color back to red.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Color mapping according to rules specified\n    color_mapping = {\n        Color.RED: Color.YELLOW,\n        Color.YELLOW: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.RED\n    }\n\n    # Iterate through the grid and apply the color changes\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] in color_mapping:\n                output_grid[x, y] = color_mapping[input_grid[x, y]]\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly fill the grid with red, yellow, green, and blue pixels\n    num_pixels = np.random.randint(1, n * m // 2)  # Fill some of the grid\n    available_colors = [Color.RED, Color.YELLOW, Color.GREEN, Color.BLUE]\n\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/142/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/142/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/142/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/142/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/142/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/142/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/142/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/142/images/train_output_2.png"}]}, "index": 142, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flipping, stacking\n\n# description:\n# In the input you will see a grid with a vertical stack of colored blocks.\n# To make the output, flip each block horizontally and stack them vertically in the output grid.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all the connected components (blocks) in the input grid\n    blocks = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    current_y = 0  # Starting position for stacking vertically\n    for block in blocks:\n        # Crop the block from the grid\n        sprite = crop(block, background=Color.BLACK)\n\n        # Flip the block horizontally\n        flipped_sprite = np.fliplr(sprite)\n\n        # Place the flipped block in the output grid\n        blit_sprite(output_grid, flipped_sprite, x=0, y=current_y)\n\n        # Update the position for the next block\n        current_y += flipped_sprite.shape[1]  # Move down by the height of the flipped block\n\n    return output_grid\n\ndef generate_input():\n    # Create a vertical stack of blocks in the grid\n    block_height = np.random.randint(3, 6)\n    n_blocks = np.random.randint(2, 6)\n    grid_width = 5\n    grid_height = block_height * n_blocks\n\n    # Create a black grid\n    grid = np.full((grid_width, grid_height), Color.BLACK)\n\n    colors = np.random.choice(list(Color.NOT_BLACK), size=n_blocks)\n\n    for i in range(n_blocks):\n        # Generate a random block with a specific height\n        block_color = colors[i]\n        block_sprite = random_sprite(grid_width, block_height, density=1.0, color_palette=[block_color])\n        \n        # Place the block in the correct position\n        blit_sprite(grid, block_sprite, x=0, y=i * block_height)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/143/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/143/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/143/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/143/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/143/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/143/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/143/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/143/images/train_output_2.png"}]}, "index": 143, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color inversion, grid manipulation\n\n# description:\n# In the input you will see a pattern of colored pixels. \n# To make the output, reflect the pattern across the vertical axis, \n# and invert the colors (e.g. red-\u003egreen, green-\u003ered, blue-\u003eyellow, yellow-\u003eblue).\n\ndef main(input_grid):\n    # Define the color inversion mapping\n    color_map = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.RED,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE,\n        Color.GREY: Color.PINK,\n        Color.PINK: Color.GREY,\n        Color.ORANGE: Color.TEAL,\n        Color.TEAL: Color.ORANGE,\n        Color.MAROON: Color.BLACK,\n        Color.BLACK: Color.MAROON\n    }\n    \n    # Reflect the pattern across the vertical axis\n    reflected_pattern = input_grid[:, ::-1]\n    \n    # Invert the colors in the reflected pattern\n    output_grid = np.copy(reflected_pattern)\n    for color in color_map:\n        output_grid[reflected_pattern == color] = color_map[color]\n    \n    return output_grid\n\ndef generate_input():\n    # Randomly create an input grid with colored pixels\n    n, m = np.random.randint(5, 10, size=2)\n    grid = random_sprite(n, m, density=0.7, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/144/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/144/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/144/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/144/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/144/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/144/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/144/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/144/images/train_output_2.png"}]}, "index": 144, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color transformation\n\n# description:\n# In the input, you will see a grid with various colored objects. \n# To make the output, transform the objects according to their symmetry: \n# - Objects with horizontal symmetry will be colored blue, \n# - Objects with vertical symmetry will be colored pink, \n# - Objects with both horizontal and vertical symmetry will be colored red.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    \n    # Find all the colored objects in the grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background)\n    \n    for obj in objects:\n        # Crop the object and check for symmetry\n        x, y, w, h = bounding_box(obj, background=background)\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Check for horizontal symmetry\n        horizontal_symmetry = np.array_equal(sprite, np.flipud(sprite))\n        # Check for vertical symmetry\n        vertical_symmetry = np.array_equal(sprite, np.fliplr(sprite))\n\n        # Determine the new color based on symmetry\n        if horizontal_symmetry and vertical_symmetry:\n            new_color = Color.RED\n        elif horizontal_symmetry:\n            new_color = Color.BLUE\n        elif vertical_symmetry:\n            new_color = Color.PINK\n        else:\n            continue  # No symmetry, skip\n\n        # Color the sprite with the new color\n        sprite[sprite != background] = new_color\n        blit_sprite(output_grid, sprite=sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # The object color can be any color except black\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly place a few objects in the grid\n    for _ in range(random.randint(3, 6)):\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n\n        # Generate a random sprite (object) with the object color\n        sprite = random_sprite(w, h, color_palette=[object_color], density=0.5)\n\n        # Randomly place the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            continue  # If no space is found, skip\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/145/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/145/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/145/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/145/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/145/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/145/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/145/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/145/images/train_output_2.png"}]}, "index": 145, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation, pattern mapping\n\n# description:\n# In the input, you will see a small pattern of pixels forming a flower-like shape in one color.\n# To make the output, transform the pattern by rotating it 180 degrees and changing its color to blue.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the connected components (the flower pattern) in the input grid\n    flower_pattern = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n    \n    # Create output grid initialized to background color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Process each flower pattern\n    for pattern in flower_pattern:\n        # Get the coordinates of the pattern\n        pattern_x, pattern_y = object_position(pattern, background=Color.BLACK)\n\n        # Rotate the pattern 180 degrees\n        rotated_pattern = np.rot90(pattern, 2)  # 180 degrees rotation\n\n        # Change the color to blue\n        rotated_pattern[rotated_pattern != Color.BLACK] = Color.BLUE\n        \n        # Blit the rotated pattern into the output grid\n        blit_sprite(output_grid, rotated_pattern, x=pattern_x, y=pattern_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random flower-like sprite\n    n, m = np.random.randint(3, 6), np.random.randint(3, 6)\n    flower_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Create a flower-like shape with a central area and petal-like extensions\n    flower_pattern = np.zeros((n, m), dtype=int)\n    center_x, center_y = n // 2, m // 2\n    \n    # Create flower center\n    flower_pattern[center_x, center_y] = flower_color\n    \n    # Create petals (extending out from the center)\n    petal_positions = [(center_x - 1, center_y), (center_x + 1, center_y), \n                       (center_x, center_y - 1), (center_x, center_y + 1)]\n    \n    for x, y in petal_positions:\n        flower_pattern[x, y] = flower_color\n    \n    # Randomly place the flower in a larger grid\n    grid_width, grid_height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((grid_width, grid_height), Color.BLACK)\n    \n    # Find a free location to place the flower\n    x, y = random_free_location_for_sprite(grid, flower_pattern, background=Color.BLACK)\n    blit_sprite(grid, flower_pattern, x, y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/146/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/146/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/146/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/146/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/146/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/146/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/146/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/146/images/train_output_2.png"}]}, "index": 146, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, color replacement\n\n# description:\n# In the input, you will see a grid with several colored pixels arranged in a 2x2 format. \n# Below each 2x2 block of colors, there is a row of colors. \n# To create the output, replace each 2x2 color block with the corresponding color from the row below it.\n\ndef main(input_grid):\n    # Create the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    rows, cols = input_grid.shape\n\n    # Iterate over every 2x2 block in the grid\n    for row in range(0, rows - 1, 3):  # Step by 3 to account for the row below each block\n        for col in range(0, cols - 1, 2):  # Step by 2 for the 2x2 blocks\n            # Get the color from the row below the block\n            color_below = input_grid[row + 2, col]\n\n            # Replace the 2x2 block with the color from the row below it\n            output_grid[row:row + 2, col:col + 2] = color_below\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random colors\n    rows = np.random.randint(6, 12)  # Ensure there\u0027s enough height for blocks and rows below\n    cols = np.random.randint(4, 8)    # Ensure there\u0027s enough width for 2x2 blocks\n    grid = np.zeros((rows, cols), dtype=int)\n\n    # Fill the grid with random colors\n    colors = np.random.choice(Color.NOT_BLACK, size=5, replace=False)  # Choose 5 different colors\n\n    # Fill the grid with 2x2 blocks of random colors\n    for row in range(0, rows - 1, 3):  # Leave space for the row below\n        for col in range(0, cols - 1, 2):  # 2x2 blocks\n            color = np.random.choice(colors)\n            grid[row:row + 2, col:col + 2] = color\n\n    # Fill the row below the blocks with random colors\n    for col in range(0, cols, 1):\n        grid[row + 2, col] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/147/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/147/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/147/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/147/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/147/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/147/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/147/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/147/images/train_output_2.png"}]}, "index": 147, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, shrinking, objects\n\n# description:\n# In the input you will see a large multicolor object, and a few small rectangles. Each rectangle has a few colored pixels sprinkled inside it. The background is NOT black.\n# To make the output: \n# 1. Remove the large object from the input \n# 2. Place copies of the small rectangle centered on top of the colored pixels sprinkled inside the large object \n# 3. The small rectangle has pointy things sticking out of it. Shrink each pointy thing inward until it hits the center of the large object.\n\ndef main(input_grid):\n    # Step 1: Identify the background color\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    input_grid[input_grid == background_color] = Color.BLACK\n\n    # Step 2: Find the large object and remove it\n    objects = find_connected_components(input_grid, monochromatic=False)\n    large_object = max(objects, key=lambda x: np.count_nonzero(x))\n    input_grid[large_object != Color.BLACK] = Color.BLACK\n\n    # Step 3: Crop the large object to use its center for pointy things\n    large_object_center = (large_object.shape[0] // 2, large_object.shape[1] // 2)\n\n    # Step 4: Identify small rectangles \n    output_grid = np.copy(input_grid)\n    rectangles = find_connected_components(input_grid, monochromatic=False)\n    for rectangle in rectangles:\n        if np.count_nonzero(rectangle) \u003c 5:  # Threshold for small rectangles\n            colored_pixels = np.argwhere(rectangle != Color.BLACK)\n            for x, y in colored_pixels:\n                # Center the rectangle on the colored pixel\n                rect_x, rect_y = x - rectangle.shape[0] // 2, y - rectangle.shape[1] // 2\n                blit_sprite(output_grid, rectangle, rect_x, rect_y, background=Color.BLACK)\n                # Step 5: Shrink pointy things inward \n                shrink_pointy_things(output_grid, rectangle, large_object_center, rect_x, rect_y)\n\n    # Step 6: Restore the original background color\n    output_grid[output_grid == Color.BLACK] = background_color\n\n    return output_grid\n\ndef shrink_pointy_things(grid, rectangle, center, rect_x, rect_y):\n    # Identify pointy positions in the rectangle\n    pointy_positions = get_pointy_positions(rectangle)\n    for px, py in pointy_positions:\n        direction_x = center[0] - (rect_x + px)\n        direction_y = center[1] - (rect_y + py)\n        draw_line(grid, rect_x + px, rect_y + py, direction=(np.sign(direction_x), np.sign(direction_y)), color=rectangle[px, py])\n\ndef get_pointy_positions(rectangle):\n    \"\"\"Returns the positions of the pointy things sticking out of the rectangle.\"\"\"\n    edge_indices = get_edge_indices(rectangle)\n    pointy_positions = [ (x, y) for (x, y) in edge_indices if rectangle[x, y] != Color.BLACK and\n                         all(rectangle[x + dx, y + dy] == Color.BLACK for dx in [-1, 1] for dy in [-1, 1]) ]\n    return pointy_positions\n\ndef get_edge_indices(sprite):\n    \"\"\"Returns a list of all the (i,j) locations of the edge pixels\"\"\"\n    edge_indices = []\n    for x in range(sprite.shape[0]):\n        for y in range(sprite.shape[1]):\n            if sprite[x, y] != Color.BLACK:\n                edge_indices.append((x, y))\n    return edge_indices\n\ndef generate_input():\n    background_color = random.choice(Color.NOT_BLACK)\n    small_rectangle_color = random.choice([color for color in Color.NOT_BLACK if color != background_color])\n    \n    # Create a large object\n    large_object = random_sprite(10, 10, color_palette=Color.NOT_BLACK)\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Place the large object\n    x, y = random_free_location_for_sprite(grid, large_object)\n    blit_sprite(grid, large_object, x, y)\n\n    # Create small rectangles with colored pixels inside\n    n_rectangles = np.random.randint(1, 4)\n    for _ in range(n_rectangles):\n        rect_width, rect_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        small_rectangle = np.full((rect_width, rect_height), small_rectangle_color)\n        for _ in range(np.random.randint(1, 5)):\n            x_mark, y_mark = np.random.randint(1, rect_width - 1), np.random.randint(1, rect_height - 1)\n            small_rectangle[x_mark, y_mark] = random.choice(Color.NOT_BLACK)\n        \n        x, y = random_free_location_for_sprite(grid, small_rectangle, padding=1)\n        blit_sprite(grid, small_rectangle, x, y)\n\n    # Change the background\n    grid[grid == Color.BLACK] = background_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/148/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/148/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/148/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/148/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/148/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/148/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/148/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/148/images/train_output_2.png"}]}, "index": 148, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, cropping, color transformation\n\n# description:\n# In the input, you will see several colored objects in a grid, with exactly one object touching a teal pixel.\n# To create the output, find the object that is touching the teal pixel, crop it, and change its color to match the color of the teal pixel.\n\ndef main(input_grid):\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Identify the teal pixel and its color\n    teal_pixel = detect_objects(grid=input_grid, colors=[Color.TEAL], connectivity=8, monochromatic=True)[0]\n    teal_pixel_color = Color.BLACK  # Default color (background)\n    \n    # Check the surrounding pixels to get the actual color of the teal pixel\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            x, y = np.where(teal_pixel == Color.TEAL)[0][0] + dx, np.where(teal_pixel == Color.TEAL)[1][0] + dy\n            if 0 \u003c= x \u003c input_grid.shape[0] and 0 \u003c= y \u003c input_grid.shape[1]:\n                if input_grid[x, y] != Color.TEAL and input_grid[x, y] != Color.BLACK:\n                    teal_pixel_color = input_grid[x, y]\n\n    # Detect which object is touching the teal pixel\n    for obj in objects:\n        if contact(object1=obj, object2=teal_pixel):\n            # Crop the object and change its color to match the teal pixel color\n            cropped_obj = crop(obj, background=Color.BLACK)\n            cropped_obj[cropped_obj != Color.BLACK] = teal_pixel_color\n            return cropped_obj\n\n    return np.zeros_like(input_grid)  # In case no object touches the teal pixel\n\ndef generate_input():\n    # Create a grid of size 10x10 with several colored objects and one teal pixel touching one of them\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the objects and the number of objects\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.TEAL]\n    num_objects = np.random.randint(2, 5)\n\n    # Place the objects in the grid\n    for i in range(num_objects):\n        obj_color = random.choice(available_colors)\n        # Create a random object\n        sprite = random_sprite(n=3, m=3, density=0.5, color_palette=[obj_color])\n        \n        # Place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8)\n        except ValueError:\n            continue\n        \n        # Add the object to the grid\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        \n        # If it\u0027s the first object, we will add a teal pixel next to it\n        if i == 0:\n            # Ensure the teal pixel touches the object\n            grid[x + 1, y] = Color.TEAL\n            grid[x + 1, y + 1] = obj_color  # Ensure it\u0027s the same color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/149/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/149/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/149/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/149/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/149/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/149/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/149/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/149/images/train_output_2.png"}]}, "index": 149, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping based on position\n\n# description:\n# The input is a grid where each column can have a different color, and there may be gaps (black pixels).\n# To make the output, change each color according to the following mapping based on its column index:\n# - If the column index is even: blue -\u003e red, yellow -\u003e green\n# - If the column index is odd: red -\u003e blue, green -\u003e yellow\n# Any black pixels remain unchanged.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Perform color mapping based on column index\n    for col in range(input_grid.shape[1]):\n        for row in range(input_grid.shape[0]):\n            color = input_grid[row, col]\n            if col % 2 == 0:  # Even column\n                if color == Color.BLUE:\n                    output_grid[row, col] = Color.RED\n                elif color == Color.YELLOW:\n                    output_grid[row, col] = Color.GREEN\n            else:  # Odd column\n                if color == Color.RED:\n                    output_grid[row, col] = Color.BLUE\n                elif color == Color.GREEN:\n                    output_grid[row, col] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n\n    # Fill columns with random colors, ensuring some columns are left black\n    for col in range(m):\n        if np.random.rand() \u003e 0.3:  # 70% chance to add color to this column\n            for row in range(n):\n                grid[row, col] = np.random.choice([Color.BLUE, Color.RED, Color.YELLOW, Color.GREEN])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/150/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/150/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/150/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/150/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/150/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/150/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/150/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/150/images/train_output_2.png"}]}, "index": 150, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, rotation, color correspondence, grid manipulation\n\n# description:\n# In the input you will see a grid with a pattern and a colored pixel as an indicator.\n# To make the output, you should rotate the pattern 90 degrees clockwise if the indicator is blue,\n# or 90 degrees counter-clockwise if the indicator is yellow.\n\ndef main(input_grid):\n    # Detect the continuous object in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n    pattern = None\n    indicator = None\n\n    # Find out the pattern and the pixel indicator\n    for obj in objects:\n        cropped_obj = crop(grid=obj, background=Color.BLACK)\n        if cropped_obj.shape == (1, 1):\n            indicator = obj\n        else:\n            pattern = cropped_obj\n\n    assert pattern is not None and indicator is not None, \"Missing pattern or indicator\"\n\n    # Determine the rotation based on the indicator color\n    if np.any(indicator == Color.BLUE):\n        # Rotate pattern 90 degrees clockwise\n        rotated_pattern = np.rot90(pattern, k=-1)  # k=-1 for clockwise\n    elif np.any(indicator == Color.YELLOW):\n        # Rotate pattern 90 degrees counter-clockwise\n        rotated_pattern = np.rot90(pattern, k=1)  # k=1 for counter-clockwise\n    else:\n        raise ValueError(\"Indicator color must be blue or yellow\")\n\n    # Create output grid and place the rotated pattern in its original position\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    pattern_x, pattern_y = object_position(pattern, background=Color.BLACK)\n    output_grid = blit_sprite(grid=output_grid, sprite=rotated_pattern, x=pattern_x, y=pattern_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = 8, 8\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select the indicator color and generate a pattern\n    indicator_color = np.random.choice([Color.BLUE, Color.YELLOW])\n    pattern_colors = [Color.GREEN, Color.RED, Color.TEAL, Color.ORANGE]\n    pattern_color = np.random.choice(pattern_colors)\n\n    # Create a small pattern (3x3) with a center pixel\n    pattern = np.full((3, 3), Color.BLACK)\n    pattern[1, 1] = pattern_color  # Center pixel\n    pattern[0, 0] = pattern_color\n    pattern[2, 2] = pattern_color\n\n    # Place the indicator in the grid\n    indicator_position = (np.random.randint(0, n), np.random.randint(0, m))\n    grid[indicator_position] = indicator_color\n\n    # Place the pattern in the grid at a random free location\n    x, y = random_free_location_for_sprite(grid=grid, sprite=pattern, padding=1, padding_connectivity=4)\n    grid = blit_sprite(grid=grid, sprite=pattern, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/151/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/151/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/151/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/151/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/151/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/151/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/151/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/151/images/train_output_2.png"}]}, "index": 151, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, scaling, color preservation\n\n# description:\n# In the input you will see a grid with various colored objects. Each object is a contiguous block of colors on a black background.\n# To produce the output, detect the largest object, scale it up to fill the entire grid, and maintain its original colors.\n\ndef main(input_grid):\n    # 1. Extract the objects from the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # 2. Identify the largest object based on area\n    object_areas = [np.sum(obj != Color.BLACK) for obj in objects]\n    largest_area_index = np.argmax(object_areas)\n    largest_object = objects[largest_area_index]\n\n    # 3. Scale the largest object to fill the output grid\n    scaled_object = scale_sprite(crop(largest_object, background=Color.BLACK), factor=int(np.ceil(np.sqrt(np.prod(input_grid.shape)) / np.sqrt(np.sum(largest_object != Color.BLACK)))))\n\n    # 4. Create an output grid and blit the scaled object onto it\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    blit_sprite(output_grid, scaled_object, 0, 0, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of objects\n    num_objects = np.random.randint(3, 8)\n    for _ in range(num_objects):\n        # Generate a random size for the object\n        obj_height, obj_width = np.random.randint(1, 5), np.random.randint(1, 5)\n        sprite = random_sprite(obj_height, obj_width, density=0.5, color_palette=list(Color.NOT_BLACK), background=Color.BLACK)\n\n        # Find a random free location for this object in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/152/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/152/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/152/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/152/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/152/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/152/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/152/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/152/images/train_output_2.png"}]}, "index": 152, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stacking, color darkening\n\n# description:\n# In the input, you will see a grid filled with colored lines on a black background. The colors of the lines will be lighter shades of the original colors. \n# To create the output, take the input grid and stack the lines on top of each other, starting from the bottom of the grid. \n# Each line in the output should have the same color as in the input, but darker.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the height of the grid\n    height = input_grid.shape[0]\n\n    # Iterate through each column in the grid\n    for column in range(input_grid.shape[1]):\n        # Find the y-coordinates of the colored lines\n        line_coordinates = np.where(input_grid[:, column] != Color.BLACK)[0]\n        \n        # If there are lines in this column\n        if line_coordinates.size \u003e 0:\n            # Start stacking from the bottom\n            stack_height = height - 1\n\n            # Iterate through each line found in reverse order (from bottom to top)\n            for y in reversed(line_coordinates):\n                # Get the color of the line\n                line_color = input_grid[y, column]\n                \n                # Darken the color (This is a simple way to darken colors; you could use a more sophisticated method)\n                darkened_color = darken_color(line_color)\n\n                # Set the stacked color in the output grid\n                output_grid[stack_height, column] = darkened_color\n                \n                # Move the stack height up for the next line\n                stack_height -= 1\n\n    return output_grid\n\ndef darken_color(color):\n    \"\"\"Darkens a color by reducing its value.\"\"\"\n    # Assuming colors are represented as integers where 1-10 represent different colors\n    # Darkening can be done by reducing the color index\n    if color == Color.RED:\n        return Color.MAROON\n    elif color == Color.GREEN:\n        return Color.TEAL\n    elif color == Color.BLUE:\n        return Color.GREY\n    elif color == Color.YELLOW:\n        return Color.ORANGE\n    elif color == Color.PINK:\n        return Color.GREY\n    elif color == Color.ORANGE:\n        return Color.GREY\n    elif color == Color.TEAL:\n        return Color.GREY\n    elif color == Color.MAROON:\n        return Color.GREY\n    elif color == Color.GREY:\n        return Color.GREY\n    else:\n        return Color.BLACK\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Random number of lines to create\n    num_lines = np.random.randint(3, 10)\n\n    # Randomly choose colors for the lines\n    colors = np.random.choice(list(Color.NOT_BLACK), size=num_lines, replace=True)\n\n    # Draw lines in random columns\n    for color in colors:\n        col = np.random.randint(m)\n        row_start = np.random.randint(n)\n        length = np.random.randint(1, n - row_start)  # Ensure the line fits in the grid\n        draw_line(grid, x=col, y=row_start, length=length, color=color, direction=(0, 1))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/153/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/153/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/153/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/153/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/153/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/153/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/153/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/153/images/train_output_2.png"}]}, "index": 153, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\n\n# concepts:\n# counting, symmetry detection, color replacement\n\n# description:\n# In the input, you will see a grid with a mix of colors, but it contains a symmetric pattern around the center. \n# To make the output, identify the center color and replace the other colors with the center color in a mirrored pattern \n# around the center of the grid. If the grid has no center (i.e., even dimensions), the output will be a grid filled with the center color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n    center_color = input_grid[n // 2, m // 2]\n\n    # Create the output grid initialized to the center color\n    output_grid = np.full_like(input_grid, center_color)\n\n    # Fill the mirrored pattern around the center\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] != center_color:\n                # Calculate mirrored positions\n                mirrored_i = n - 1 - i\n                mirrored_j = m - 1 - j\n                output_grid[mirrored_i, mirrored_j] = center_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose colors from available colors\n    available_colors = list(Color.NOT_BLACK)\n    center_color = random.choice(available_colors)\n\n    # Fill the grid with colors, ensuring the center color appears multiple times\n    for i in range(n):\n        for j in range(m):\n            if (i == n // 2 and j == m // 2) or (random.random() \u003c 0.5):\n                grid[i, j] = center_color\n            else:\n                grid[i, j] = random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/154/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/154/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/154/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/154/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/154/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/154/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/154/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/154/images/train_output_2.png"}]}, "index": 154, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# object extraction, color inversion, contact\n\n# description:\n# In the input you will see a grid with colored objects, one of which is touching a gray pixel.\n# To make the output grid, select the object that is touching the gray pixel, invert its color, \n# and place it in the center of the output grid.\n\ndef main(input_grid):\n    # Detect all gray pixels in the input grid\n    gray_pixels = detect_objects(grid=input_grid, colors=[Color.GRAY], connectivity=8, monochromatic=True)\n\n    # Detect all colored objects in the input grid\n    colored_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=8)\n\n    # Find the object that is touching any gray pixel\n    for gray_pixel in gray_pixels:\n        for obj in colored_objects:\n            if contact(object1=obj, object2=gray_pixel, connectivity=4):\n                # Invert the color of the detected object\n                inverted_object = np.copy(obj)\n                unique_colors = object_colors(obj, background=Color.BLACK)\n                inverted_color = [c for c in Color.NOT_BLACK if c not in unique_colors]\n                \n                # Invert colors\n                for color in unique_colors:\n                    if color in inverted_color:\n                        inverted_object[inverted_object == color] = inverted_color[0]\n                \n                # Crop the inverted object and place it in the center of the output grid\n                output_grid = np.full(input_grid.shape, Color.BLACK)  # Start with a black grid\n                cropped_inverted_object = crop(inverted_object, background=Color.BLACK)\n                \n                # Find center position for placing the cropped object\n                center_x = (output_grid.shape[0] - cropped_inverted_object.shape[0]) // 2\n                center_y = (output_grid.shape[1] - cropped_inverted_object.shape[1]) // 2\n                \n                # Place the inverted object in the center\n                blit_sprite(output_grid, cropped_inverted_object, center_x, center_y, background=Color.BLACK)\n                return output_grid\n\n    return np.full(input_grid.shape, Color.BLACK)  # If no object is found, return black grid\n\ndef generate_input():\n    # Generate a 10x10 grid with several colored objects and one gray pixel\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Create random objects\n    num_objects = np.random.randint(2, 5)\n    colors_used = set()\n    \n    for _ in range(num_objects):\n        # Create a random colored object\n        color = random.choice([c for c in Color.NOT_BLACK if c not in colors_used and c != Color.GRAY])\n        colors_used.add(color)\n        \n        # Create a sprite of random size and density\n        sprite = random_sprite(n=np.random.randint(2, 5), m=np.random.randint(2, 5), color_palette=[color], density=0.5)\n        \n        # Find a free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # Skip if no free location is found\n    \n    # Add one gray pixel touching one of the objects\n    gray_location_found = False\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] != Color.BLACK and not gray_location_found:\n                grid[i, j] = Color.GRAY  # Place gray pixel\n                gray_location_found = True\n                break\n        if gray_location_found:\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/155/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/155/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/155/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/155/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/155/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/155/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/155/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/155/images/train_output_2.png"}]}, "index": 155, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# expanding, object alignment, proportional scaling\n\n# description:\n# In the input you will see a colored object on a black background.\n# To produce the output grid, expand the object to fill the entire grid,\n# maintaining the proportions and alignment of the original object.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the colored object in the input grid.\n    # 2. Calculate the bounding box of the object.\n    # 3. Determine the scaling factors based on the grid size and the object\u0027s size.\n    # 4. Expand the object to fill the entire grid while maintaining proportions.\n\n    # 1. Detect the colored object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    assert len(objects) == 1, \"exactly one object expected\"\n    original_object = objects[0]\n\n    # 2. Calculate the bounding box of the object\n    x, y, w, h = bounding_box(original_object)\n\n    # Get the output grid size\n    grid_height, grid_width = input_grid.shape\n\n    # 3. Calculate the scaling factors\n    scale_x = grid_width / w\n    scale_y = grid_height / h\n    scale = min(scale_x, scale_y)  # Maintain proportions\n\n    # 4. Create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Expand the object by placing it in the center of the output grid\n    expanded_width = int(w * scale)\n    expanded_height = int(h * scale)\n    expanded_object = np.full((expanded_height, expanded_width), Color.BLACK)\n\n    # Copy the original object into the expanded object\n    for i in range(h):\n        for j in range(w):\n            if original_object[i, j] != Color.BLACK:\n                # Calculate the position in the expanded object\n                new_i = int(i * scale)\n                new_j = int(j * scale)\n                expanded_object[new_i, new_j] = original_object[i, j]\n\n    # Center the expanded object in the output grid\n    start_x = (grid_width - expanded_width) // 2\n    start_y = (grid_height - expanded_height) // 2\n    blit_object(output_grid, expanded_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly select the size of the colored object\n    obj_width = np.random.randint(2, 6)\n    obj_height = np.random.randint(2, 6)\n\n    # Create a colored object with random color\n    colors = Color.NOT_BLACK  # All colors except black\n    color = np.random.choice(colors)\n\n    colored_object = np.full((obj_height, obj_width), color)\n\n    # Find a random position to place the colored object\n    x, y = random_free_location_for_sprite(grid, colored_object, background=Color.BLACK, padding=1)\n    blit_sprite(grid, colored_object, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/156/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/156/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/156/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/156/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/156/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/156/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/156/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/156/images/train_output_2.png"}]}, "index": 156, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color change\n\n# description:\n# In the input, you will see a grid with a colored pattern. \n# If the pattern is symmetric along both the x-axis and y-axis, change its color to maroon. \n# If the pattern is not symmetric in either direction, change its color to yellow. \n# If it is only symmetric in one direction, change its color to orange.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n    \n    # Check symmetry along the x-axis\n    symmetric_x = np.all(input_grid[:height // 2] == input_grid[height - height // 2:][::-1])\n    \n    # Check symmetry along the y-axis\n    symmetric_y = np.all(input_grid[:, :width // 2] == input_grid[:, width - width // 2:][:, ::-1])\n    \n    # Determine output color based on symmetry\n    if symmetric_x and symmetric_y:\n        output_color = Color.MAROON\n    elif not symmetric_x and not symmetric_y:\n        output_color = Color.YELLOW\n    else:\n        output_color = Color.ORANGE\n    \n    # Create output grid filled with the determined color\n    output_grid = np.full(input_grid.shape, output_color)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the grid\n    height = np.random.randint(3, 6)\n    width = np.random.randint(3, 6)\n    \n    # Create a random grid with some colors\n    grid = random_sprite(n=height, m=width, density=0.5, color_palette=Color.NOT_BLACK, symmetry=None)\n    \n    # Introduce some symmetry or non-symmetry based on random choice\n    if np.random.choice([True, False]):\n        # Enforce symmetry along both axes\n        if height % 2 == 1 and width % 2 == 1:\n            middle_row = height // 2\n            middle_col = width // 2\n            grid[middle_row, middle_col] = grid[middle_row, middle_col]  # Center pixel remains the same\n            grid[0:middle_row, 0:middle_col] = grid[middle_row+1:, middle_col+1:][::-1, ::-1]\n        elif height % 2 == 1:\n            middle_row = height // 2\n            grid[middle_row, :] = grid[middle_row, :]  # Center row remains the same\n            grid[0:middle_row, :] = grid[middle_row+1:, :][::-1]\n        elif width % 2 == 1:\n            middle_col = width // 2\n            grid[:, middle_col] = grid[:, middle_col]  # Center column remains the same\n            grid[:, 0:middle_col] = grid[:, middle_col+1:][:, ::-1]\n        else:\n            # Even dimensions, mirror entire grid\n            grid = np.concatenate((grid, grid[::-1, :]), axis=0)\n            grid = np.concatenate((grid, grid[:, ::-1]), axis=1)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/157/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/157/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/157/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/157/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/157/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/157/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/157/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/157/images/train_output_2.png"}]}, "index": 157, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object rotation, symmetry\n\n# description:\n# In the input, you will see a pattern formed by colored pixels. \n# To make the output, you will first rotate the pattern 90 degrees clockwise, \n# then create a mirror image of the rotated pattern.\n\ndef main(input_grid):\n    # Step 1: Rotate the input pattern 90 degrees clockwise\n    rotated_pattern = np.rot90(input_grid, k=-1)  # k=-1 for clockwise rotation\n\n    # Step 2: Create a mirror image of the rotated pattern\n    mirrored_pattern = rotated_pattern[:, ::-1]  # Flip horizontally\n\n    return mirrored_pattern\n\ndef generate_input():\n    # Create a random pattern of varying colors\n    n = np.random.randint(3, 8)  # Random height\n    m = np.random.randint(3, 8)  # Random width\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/158/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/158/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/158/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/158/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/158/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/158/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/158/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/158/images/train_output_2.png"}]}, "index": 158, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color transformation\n\n# description:\n# In the input you will see a grid with several colored objects.\n# To create the output, scale each object by a factor of 2, and invert the colors:\n# - red to green\n# - green to blue\n# - blue to red\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all colored objects in the input grid.\n    # 2. Scale each object by a factor of 2.\n    # 3. Invert the colors of the scaled objects.\n    # 4. Blit the transformed objects onto the output grid.\n\n    # Detect all colored objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    scale_factor = 2\n    color_inversion = {Color.RED: Color.GREEN, Color.GREEN: Color.BLUE, Color.BLUE: Color.RED}\n\n    for obj in objects:\n        # Get the position of each colored object and crop it to produce a sprite\n        x, y = object_position(obj, background=Color.BLACK, anchor=\"upper left\")\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Scale the sprite by `scale_factor`\n        scaled_sprite = scale_sprite(sprite, scale_factor)\n\n        # Invert colors in the scaled sprite\n        for original_color, new_color in color_inversion.items():\n            scaled_sprite[scaled_sprite == original_color] = new_color\n\n        # Blit the scaled and color-inverted sprite onto the output grid\n        blit_sprite(output_grid, scaled_sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Colors we will use for the objects\n    colors = [Color.RED, Color.GREEN, Color.BLUE]\n\n    # Randomly create and place objects in the grid\n    for _ in range(np.random.randint(3, 6)):\n        # Generate a random sprite\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=colors, density=0.3, symmetry=\"not_symmetric\")\n\n        # Try to place the sprite in a random free location\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            pass  # Ignore if unable to place\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/159/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/159/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/159/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/159/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/159/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/159/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/159/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/159/images/train_output_2.png"}]}, "index": 159, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, radial gradient\n\n# description:\n# In the input you will see a single colored pixel located anywhere on the grid.\n# To create the output, generate a radial gradient that transitions from grey at the center (the pixel\u0027s location) to the color of the pixel as it moves outward, filling the entire grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the colored pixel in the input grid\n    colored_pixel = np.argwhere(input_grid != Color.BLACK)\n\n    # There should be exactly one colored pixel\n    assert len(colored_pixel) == 1\n\n    # Get the position and color of the colored pixel\n    x, y = colored_pixel[0]\n    color = input_grid[x, y]\n\n    # Prepare the output grid\n    output_grid = np.full(input_grid.shape, Color.GREY)\n\n    # Get the dimensions of the grid\n    rows, cols = output_grid.shape\n\n    # Create the radial gradient\n    for i in range(rows):\n        for j in range(cols):\n            # Calculate the distance from the colored pixel\n            distance = np.sqrt((x - i) ** 2 + (y - j) ** 2)\n            # Normalize distance to a scale from 0 to 1\n            max_distance = np.sqrt((x - 0) ** 2 + (y - 0) ** 2) + np.sqrt((x - (rows - 1)) ** 2 + (y - (cols - 1)) ** 2)\n            ratio = min(distance / max_distance, 1)  # Clamp the ratio to 1\n            \n            # Set the color in the output grid based on the ratio\n            output_grid[i, j] = color if ratio \u003e= 0.5 else Color.GREY  # Change color based on distance\n            \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a location for the colored pixel\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    # Choose a random color that is not black or grey\n    color = random.choice(Color.NOT_BLACK)\n    \n    # Set the colored pixel\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/160/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/160/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/160/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/160/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/160/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/160/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/160/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/160/images/train_output_2.png"}]}, "index": 160, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, object detection\n\n# description:\n# In the input you will see a grid containing a single colored object on a black background.\n# To make the output, detect the object and reflect it along the y-axis, placing the reflected object to the right of the original.\n\ndef main(input_grid):\n    # Detect the colored object in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8)\n    assert len(objects) == 1, \"There should be exactly one colored object.\"\n    original_object = objects[0]\n\n    # Prepare the output grid\n    height, width = original_object.shape\n    output_grid = np.full((height, width * 2), Color.BLACK)\n\n    # Copy the original object to the left side of the output grid\n    output_grid[:, :width] = original_object\n\n    # Reflect the original object along the y-axis and place it to the right\n    reflected_object = original_object[:, ::-1]\n    output_grid[:, width:] = reflected_object\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a single colored object on a black background\n    width, height = 5, 5\n    grid = np.full((height, width), Color.BLACK)\n\n    # Generate a random colored object\n    object_sprite = random_sprite(n=np.random.randint(2, 4), \n                                   m=np.random.randint(2, 4), \n                                   color_palette=[np.random.choice(Color.NOT_BLACK)], \n                                   symmetry=\"not_symmetric\", \n                                   background=Color.BLACK)\n\n    # Randomly place the colored object in the grid, ensuring it fits\n    x, y = random_free_location_for_sprite(grid, object_sprite, border_size=0)\n    blit_sprite(grid, object_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/161/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/161/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/161/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/161/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/161/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/161/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/161/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/161/images/train_output_2.png"}]}, "index": 161, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color separation, grid manipulation, pixel shifting\n\n# description:\n# In the input, you will see a grid filled with colored squares. Each square can be of any color and can have different sizes.\n# To make the output, you need to shift each square away from its center in the direction of its color. The color should be retained, but the squares should be moved outwards, leaving their original position empty (which will be filled with black).\n\ndef main(input_grid):\n    # Step 1: Find all connected components (squares) in the input grid\n    square_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Prepare the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    for square in square_objects:\n        # Step 2: Get the bounding box of the current square\n        x, y, w, h = bounding_box(square)\n        \n        # Step 3: Calculate the center of the square\n        center_x = x + w // 2\n        center_y = y + h // 2\n\n        # Step 4: Determine the direction to shift based on the color\n        color = input_grid[x, y]  # Assuming color is consistent for the square\n        shift_direction = np.array([1, 1])  # Default shift down and right\n        \n        # Determine shift direction based on the color\n        if color == Color.RED:\n            shift_direction = np.array([-1, 0])  # Up\n        elif color == Color.GREEN:\n            shift_direction = np.array([0, -1])  # Left\n        elif color == Color.BLUE:\n            shift_direction = np.array([0, 1])   # Right\n        elif color == Color.YELLOW:\n            shift_direction = np.array([1, 0])    # Down\n        \n        # Step 5: Shift each pixel of the square outwards\n        for dx in range(w):\n            for dy in range(h):\n                if 0 \u003c= x + dx \u003c output_grid.shape[0] and 0 \u003c= y + dy \u003c output_grid.shape[1]:\n                    output_grid[x + dx + shift_direction[0], y + dy + shift_direction[1]] = square[dx, dy]\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with random colored squares of varying sizes\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly decide how many squares to create\n    num_squares = np.random.randint(3, 6)\n\n    for _ in range(num_squares):\n        # Random size for the square\n        square_size = np.random.randint(1, 5)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Random location to place the square\n        x = np.random.randint(0, width - square_size)\n        y = np.random.randint(0, height - square_size)\n\n        # Place the square in the grid\n        for dx in range(square_size):\n            for dy in range(square_size):\n                if 0 \u003c= x + dx \u003c width and 0 \u003c= y + dy \u003c height:\n                    grid[x + dx, y + dy] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/162/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/162/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/162/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/162/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/162/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/162/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/162/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/162/images/train_output_2.png"}]}, "index": 162, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection\n\n# description:\n# In the input you will see a grid with a small colored object on one side.\n# To make the output, reflect the object across the centerline of the grid, creating a symmetrical pattern.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n    \n    # Determine the centerline for reflection\n    center_line_x = width // 2\n\n    # Create the output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Reflect the object across the centerline\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        reflected_x = center_line_x + (center_line_x - x)\n        if 0 \u003c= reflected_x \u003c width:\n            output_grid[reflected_x, y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random width and height\n    grid = np.full((random.choice(range(15, 30+1)), random.choice(range(15, 30+1))), Color.BLACK)\n\n    # Generate a small object on one side of the grid\n    sprite = random_sprite(range(3, 6), range(3, 6), \n                           color_palette=[random.choice(Color.NOT_BLACK)], \n                           symmetry=\"not_symmetric\")    \n\n    # Randomly place the object on the left side of the grid\n    x_position = random.choice(range(0, grid.shape[0] - sprite.shape[0] - 1))\n    y_position = random.choice(range(0, grid.shape[1] - sprite.shape[1] - 1))\n    blit_sprite(grid, sprite, x_position, y_position)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/163/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/163/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/163/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/163/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/163/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/163/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/163/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/163/images/train_output_2.png"}]}, "index": 163, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern expansion, color mapping, grid transformation\n\n# description:\n# In the input, you will see a grid with a vertical pattern of colored pixels on the left side.\n# To create the output, replicate the vertical pattern horizontally across the entire grid, such that each color from the vertical pattern populates an entire row in the output grid.\n\ndef main(input_grid):\n    # Extract the colors from the left column\n    colors = input_grid[:, 0]\n    width, height = input_grid.shape\n\n    # Create the output grid with the same height and a width that accommodates the colors\n    output_grid = np.full((height, width), Color.BLACK)\n\n    # Fill each row of the output grid with the corresponding color from the left column\n    for y in range(height):\n        output_grid[y, :] = colors[y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random height for the grid\n    height = np.random.randint(5, 10)\n    \n    # Create a grid that will hold one column of colors\n    grid = np.zeros((height, 1), dtype=int)\n\n    # Randomly choose the colors for the vertical pattern\n    colors = np.random.choice(list(Color.NOT_BLACK), size=height, replace=False)\n\n    # Fill the left column of the grid with the selected colors\n    grid[:, 0] = colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/164/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/164/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/164/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/164/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/164/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/164/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/164/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/164/images/train_output_2.png"}]}, "index": 164, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color inversion\n\n# description:\n# The input is a grid with a single colored object. \n# To make the output, rotate the object 180 degrees and invert its color:\n# - If the color is red, change it to pink\n# - If green, change it to green\n# - If blue, change it to yellow\n# - If pink, change it to red\n# - If green, change it to green\n# - If yellow, change it to blue\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the single colored object in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1\n    colored_object = objects[0]\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Rotate the object 180 degrees\n    rotated_object = np.rot90(colored_object, k=2)\n\n    # Invert the color of the rotated object\n    inverted_colors = {\n        Color.RED: Color.PINK,\n        Color.GREEN: Color.GREEN,\n        Color.BLUE: Color.YELLOW,\n        Color.PINK: Color.RED,\n        Color.GREEN: Color.GREEN,\n        Color.YELLOW: Color.BLUE\n    }\n    for x in range(rotated_object.shape[0]):\n        for y in range(rotated_object.shape[1]):\n            if rotated_object[x, y] in inverted_colors:\n                rotated_object[x, y] = inverted_colors[rotated_object[x, y]]\n\n    # Blit the inverted, rotated object onto the output grid\n    output_grid = blit_object(output_grid, rotated_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random sprite of a single color\n    grid_size = np.random.randint(5, 10)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Choose a random color for the object\n    color_options = [Color.RED, Color.GREEN, Color.BLUE, Color.PINK, Color.GREEN, Color.YELLOW]\n    chosen_color = np.random.choice(color_options)\n    \n    # Create a random sprite of the chosen color\n    sprite_size = np.random.randint(1, 4)  # Size of the colored object\n    sprite = random_sprite(n=sprite_size, m=sprite_size, color_palette=[chosen_color], density=1.0)\n\n    # Find a random free location for the sprite in the grid\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    blit_sprite(grid, sprite=sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/165/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/165/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/165/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/165/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/165/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/165/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/165/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/165/images/train_output_2.png"}]}, "index": 165, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid partition, color filling, color extraction\n\n# description:\n# In the input, there are several rectangular sections separated by gray bars. Each section contains a single colored pixel at its center.\n# To create the output, fill each section with the color of the pixel it contains. Sections outside the boundaries of the grid should remain black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Identify the divider color, which separates the sections\n    divider_color = Color.GRAY\n\n    # Find connected components based on the divider color\n    regions = find_connected_components(grid=output_grid, background=divider_color, monochromatic=False)\n\n    # Fill each region with the color of the pixel it contains\n    for region in regions:\n        # Extract the color from the center pixel of the region\n        center_x, center_y = object_position(region, background=divider_color, anchor=\u0027center\u0027)\n        region_color = output_grid[center_x, center_y]\n\n        # Fill the entire region with the identified color\n        output_grid[region != divider_color] = region_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the base configuration of the grid separated by gray lines\n    region_size = np.random.randint(5, 8)  # Size of each rectangular section\n    grid_size = 3  # Number of sections in each direction\n\n    # Size of the grid is region size times the number of regions plus dividers\n    n, m = region_size * grid_size + (grid_size - 1), region_size * grid_size + (grid_size - 1)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n\n    # Draw dividers\n    for i in range(region_size, n, region_size + 1):\n        draw_line(grid=grid, x=i, y=0, color=Color.GRAY, direction=(0, 1))\n        draw_line(grid=grid, x=0, y=i, color=Color.GRAY, direction=(1, 0))\n\n    # Fill sections with colors\n    for x in range(0, n, region_size + 1):\n        for y in range(0, m, region_size + 1):\n            # Randomly choose a color for the center pixel\n            color = np.random.choice(Color.NOT_BLACK)\n            # Place the color in the center of the region\n            center_x = x + region_size // 2\n            center_y = y + region_size // 2\n            grid[center_x, center_y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/166/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/166/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/166/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/166/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/166/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/166/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/166/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/166/images/train_output_2.png"}]}, "index": 166, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, color transformation\n\n# description:\n# In the input grid, you will see a black background with a single colored pixel. \n# To produce the output, you should create a symmetrical reflection of the colored pixel across the center of the grid, \n# and fill the reflected positions with the same color.\n\ndef main(input_grid):\n    # Get the dimensions of the grid\n    height, width = input_grid.shape\n    output_grid = input_grid.copy()\n\n    # Find the coordinates of the single colored pixel\n    colored_pixel = np.argwhere(input_grid != Color.BLACK)\n    \n    if colored_pixel.size == 0:\n        return output_grid  # No colored pixel found, return the original grid\n    \n    x, y = colored_pixel[0]  # Get the first (and only) colored pixel position\n    color = input_grid[x, y]\n\n    # Compute the reflected position\n    reflected_x = height - 1 - x\n    reflected_y = width - 1 - y\n\n    # Fill the reflected position with the same color\n    output_grid[reflected_x, reflected_y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 5x5 and 20x20\n    length = random.randint(5, 20)\n    grid = np.full((length, length), Color.BLACK)\n\n    # Randomly choose a location for a single colored pixel\n    x = random.randint(0, length - 1)\n    y = random.randint(0, length - 1)\n\n    # Randomly choose a color from the available colors (excluding black)\n    color = random.choice(Color.NOT_BLACK)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/167/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/167/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/167/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/167/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/167/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/167/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/167/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/167/images/train_output_2.png"}]}, "index": 167, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# occlusion, color restoration\n\n# description:\n# In the input you will see a grid with a central pattern partially occluded by black pixels. \n# To make the output, remove the occluding black pixels to reveal the original pattern, \n# while restoring the occluded pixels to match their nearest non-black neighbors.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Create a copy of the input grid for the output\n    # 2. Identify non-black pixels and their positions\n    # 3. For each black pixel, check the nearest non-black pixel to restore its color\n\n    output_grid = np.copy(input_grid)\n\n    # Get the coordinates of the non-black pixels\n    non_black_coords = np.argwhere(input_grid != Color.BLACK)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if output_grid[x, y] == Color.BLACK:\n                # Find the nearest non-black pixel using L1 distance (Manhattan distance)\n                distances = np.abs(non_black_coords[:, 0] - x) + np.abs(non_black_coords[:, 1] - y)\n                nearest_color_coord = non_black_coords[np.argmin(distances)]\n                output_grid[x, y] = input_grid[nearest_color_coord[0], nearest_color_coord[1]]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random size and black background\n    w, h = np.random.randint(10, 25, size=2)\n    grid = np.full((w, h), Color.BLACK)\n\n    # Generate a random pattern\n    pattern_color = np.random.choice(Color.NOT_BLACK)\n    pattern = random_sprite(np.random.randint(3, 8), np.random.randint(3, 8), color_palette=[pattern_color], density=1)\n\n    # Place the pattern in the grid\n    x, y = random_free_location_for_sprite(grid, pattern)\n    blit_sprite(grid, pattern, x, y)\n\n    # Create occlusions by randomly placing black pixels over the pattern\n    n_occlusions = np.random.randint(5, 15)\n    for _ in range(n_occlusions):\n        x_occlude, y_occlude = np.random.randint(w), np.random.randint(h)\n        grid[x_occlude, y_occlude] = Color.BLACK\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/168/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/168/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/168/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/168/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/168/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/168/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/168/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/168/images/train_output_2.png"}]}, "index": 168, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, color, objects\n\n# description:\n# In the input you will see gray objects on a black background. \n# To create the output, count the number of pixels in each object and color the object yellow if it has four pixels, green if it has five pixels, and orange if it has eight pixels.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the objects in the input grid\n    objects = find_connected_components(input_grid)\n\n    # Count the number of pixels in each object and color them accordingly\n    for obj in objects:\n        num_pixels = np.sum(obj == Color.GREY)\n        if num_pixels == 4:\n            color = Color.YELLOW\n        elif num_pixels == 5:\n            color = Color.GREEN\n        elif num_pixels == 8:\n            color = Color.ORANGE\n        else:\n            color = Color.GREY\n        output_grid[obj == Color.GREY] = color\n\n    return output_grid\n\ndef generate_input():\n    # Make a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Make a random number of sprites\n    num_sprites = np.random.randint(3, 6)\n    for _ in range(num_sprites):\n        sprite = random_sprite(np.random.randint(1, 5), np.random.randint(1, 5), symmetry=\"not_symmetric\", color_palette=[Color.GREY])\n        # Make sure the sprite has four, five, or eight pixels\n        while np.sum(sprite == Color.GREY) not in {4, 5, 8}:\n            sprite = random_sprite(np.random.randint(1, 5), np.random.randint(1, 5), symmetry=\"not_symmetric\", color_palette=[Color.GREY])\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/169/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/169/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/169/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/169/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/169/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/169/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/169/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/169/images/train_output_2.png"}]}, "index": 169, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation, reflection\n\n# description:\n# In the input, you will see a grid containing a single pattern that represents a flower-like shape.\n# To create the output, you should take that flower pattern, reflect it across both the vertical and horizontal axes,\n# and place the original and reflected patterns in a new grid to form a larger flower shape.\n\ndef main(input_grid):\n    # Extract the original pattern\n    original_pattern = input_grid\n    \n    # Reflect the pattern horizontally and vertically\n    reflected_pattern_h = np.flipud(original_pattern)  # Reflect vertically\n    reflected_pattern_v = np.fliplr(original_pattern)  # Reflect horizontally\n    reflected_pattern_hv = np.flipud(np.fliplr(original_pattern))  # Reflect both horizontally and vertically\n\n    # Create the output grid by arranging the original and reflected patterns\n    output_grid = np.zeros((original_pattern.shape[0] * 2, original_pattern.shape[1] * 2), dtype=int)\n    output_grid[:original_pattern.shape[0], :original_pattern.shape[1]] = original_pattern\n    output_grid[:original_pattern.shape[0], original_pattern.shape[1]:] = reflected_pattern_v\n    output_grid[original_pattern.shape[0]:, :original_pattern.shape[1]] = reflected_pattern_h\n    output_grid[original_pattern.shape[0]:, original_pattern.shape[1]:] = reflected_pattern_hv\n\n    return output_grid\n\ndef generate_input():\n    # Create a random flower-like pattern\n    # Flower patterns can be symmetric, so we will use random symmetry in generating them\n    n, m = np.random.randint(5, 8), np.random.randint(5, 8)\n    grid = random_sprite(n, m, density=0.5, symmetry=\"mirror\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/170/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/170/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/170/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/170/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/170/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/170/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/170/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/170/images/train_output_2.png"}]}, "index": 170, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, occlusion\n\n# description:\n# In the input you will see a grid containing green pixels that is almost vertically symmetric, except that some parts are missing (colored in black).\n# To make the output grid, fill in the missing parts of the object to make it vertically symmetric.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the vertical symmetry of the object.\n    # 2. For each colored pixel, calculate its mirror position.\n    # 3. If the mirror position is black, fill it with the color of the original pixel.\n\n    output_grid = np.copy(input_grid)\n\n    # Find the vertical symmetry\n    symmetries = detect_mirror_symmetry(input_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n\n    # For each colored pixel, apply the symmetry\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    for x, y in colored_pixels:\n        for mirror in symmetries:\n            # Get the mirrored position\n            mirrored_x, mirrored_y = mirror.apply(x, y)\n\n            # Fill in the missing pixel\n            if output_grid[mirrored_x, mirrored_y] == Color.BLACK:\n                output_grid[mirrored_x, mirrored_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium-sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a vertical symmetric sprite\n    sprite = random_sprite(np.random.randint(5, n-2), np.random.randint(5, m-2), density=0.5, symmetry=\u0027vertical\u0027, color_palette=[Color.GREEN])\n\n    # Randomly obscure parts of the sprite to break symmetry\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if sprite[i, j] != Color.BLACK and np.random.random() \u003c 0.3:  # 30% chance to obscure\n                sprite[i, j] = Color.BLACK\n\n    # Place the sprite on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/171/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/171/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/171/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/171/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/171/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/171/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/171/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/171/images/train_output_2.png"}]}, "index": 171, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, spiral, color alternation\n\n# description:\n# In the input you will see a single green line that connects to the top of the grid.\n# To make the output, you should draw a spiral pattern outward from the green line.\n# The pattern is expanded in a spiral manner, alternating colors between green and yellow.\n# The spiral should extend outward from the green line, filling the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Parse the input to find the green line\n    # 2. Draw a spiral pattern outward from the green line\n    # 3. Alternate colors between green and yellow\n\n    # 1. Parse the input\n    line = find_connected_components(input_grid, monochromatic=True)[0]\n    line_x, line_y, width, height = bounding_box(line)\n\n    # Colors for the spiral pattern\n    color1 = Color.GREEN\n    color2 = Color.YELLOW\n\n    # Create output grid\n    output_grid = np.copy(input_grid)\n\n    # 2. Draw a spiral pattern starting from the green line\n    cur_color = color1\n    x, y = line_x, line_y\n\n    # Spiral parameters\n    steps = 1  # Number of steps to take in the current direction\n    direction = 0  # Start with moving right\n    dx = [1, 0, -1, 0]  # Right, Down, Left, Up\n    dy = [0, 1, 0, -1]\n\n    # Place the initial line point\n    output_grid[x, y] = cur_color\n\n    # Continue spiraling\n    while True:\n        for _ in range(2):  # Two sides for each step length\n            for _ in range(steps):\n                x += dx[direction]\n                y += dy[direction]\n                if 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:\n                    output_grid[x, y] = cur_color\n                else:\n                    return output_grid  # Stop if out of bounds\n\n            # Alternate color\n            cur_color = color2 if cur_color == color1 else color1\n            direction = (direction + 1) % 4  # Change direction\n\n        steps += 1  # Increase the number of steps for the next round\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly generate one green line connecting to the top\n    length = np.random.randint(3, height - 1)\n\n    # Randomly choose one position to start the line\n    x = np.random.randint(0, width)\n    line_color = Color.GREEN\n    draw_line(grid=grid, x=x, y=0, direction=(0, 1), length=length, color=line_color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/172/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/172/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/172/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/172/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/172/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/172/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/172/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/172/images/train_output_2.png"}]}, "index": 172, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, centering\n\n# description:\n# In the input, you will see a single object in a black grid. To make the output, rotate the object 90 degrees clockwise and place it in the center of the grid.\n\ndef main(input_grid):\n    # Step 1: Crop the object from the input grid\n    object_sprite = crop(input_grid, background=Color.BLACK)\n    \n    # Step 2: Rotate the object 90 degrees clockwise\n    rotated_sprite = np.rot90(object_sprite, k=-1)  # k=-1 for 90 degrees clockwise\n\n    # Step 3: Create an output grid\n    output_height, output_width = input_grid.shape\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Step 4: Calculate position to place the rotated sprite in the center of the output grid\n    center_x = (output_height - rotated_sprite.shape[0]) // 2\n    center_y = (output_width - rotated_sprite.shape[1]) // 2\n\n    # Step 5: Blit the rotated sprite onto the output grid\n    blit_sprite(output_grid, rotated_sprite, x=center_x, y=center_y)\n\n    return output_grid\n\ndef generate_input():\n    # Randomly generate a sprite within a certain size (3x3 to 5x5)\n    sprite_size = np.random.randint(3, 6)\n    sprite = random_sprite(sprite_size, sprite_size, density=1.0)\n    \n    # Create a black grid\n    grid_size = 7  # Fixed size for simplicity, can be changed to randomize\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly place the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/173/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/173/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/173/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/173/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/173/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/173/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/173/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/173/images/train_output_2.png"}]}, "index": 173, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# edge detection, color replacement, object counting\n\n# description:\n# In the input, you will see several colored objects on a black background.\n# To create the output, count the number of edges of each object and replace the color of each object with the color that corresponds to its edge count in the following order: \n# 0 edges - red, 1 edge - green, 2 edges - blue, 3 edges - yellow, 4 or more edges - teal.\n\ndef count_edges(obj):\n    \"\"\"\n    Count the number of edges in a binary object.\n    An edge is defined as a transition from background to foreground in the grid.\n    \"\"\"\n    edges = 0\n    for x in range(obj.shape[0]):\n        for y in range(obj.shape[1]):\n            if obj[x, y] != Color.BLACK:\n                # Check four possible edge neighbors\n                if x \u003e 0 and obj[x-1, y] == Color.BLACK:  # Up\n                    edges += 1\n                if x \u003c obj.shape[0]-1 and obj[x+1, y] == Color.BLACK:  # Down\n                    edges += 1\n                if y \u003e 0 and obj[x, y-1] == Color.BLACK:  # Left\n                    edges += 1\n                if y \u003c obj.shape[1]-1 and obj[x, y+1] == Color.BLACK:  # Right\n                    edges += 1\n    return edges\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (objects)\n    objects = find_connected_components(input_grid)\n\n    # Define color mapping based on edge count\n    color_mapping = {\n        0: Color.RED,\n        1: Color.GREEN,\n        2: Color.BLUE,\n        3: Color.YELLOW\n    }\n\n    for obj in objects:\n        if np.count_nonzero(obj != Color.BLACK) \u003e 0:  # Ensure it\u0027s a non-empty object\n            edge_count = count_edges(obj)\n            # Determine the color based on the number of edges\n            new_color = color_mapping.get(edge_count, Color.TEAL)  # Default to teal for 4 or more edges\n            output_grid[obj != Color.BLACK] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black 10x10 grid as the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random number of sprites (objects)\n    num_sprites = np.random.randint(3, 7)\n    for _ in range(num_sprites):\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=Color.NOT_BLACK)\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            continue  # If no space, skip this sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/174/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/174/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/174/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/174/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/174/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/174/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/174/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/174/images/train_output_2.png"}]}, "index": 174, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color swap\n\n# description:\n# In the input you will see a pattern with two different colors. \n# To make the output, detect any 2x2 square objects within the pattern where all four pixels are the same color, \n# and swap their color with the other color present in the pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Identify the colors present in the input grid\n    unique_colors = np.unique(input_grid)\n    if Color.BLACK in unique_colors:\n        unique_colors = unique_colors[unique_colors != Color.BLACK]\n    \n    # Assuming there are exactly two colors in the input, we will swap them\n    if len(unique_colors) != 2:\n        raise ValueError(\"The input grid must contain exactly two colors.\")\n\n    color_a, color_b = unique_colors\n\n    # Scan for 2x2 squares of color_a and replace them with color_b and vice versa\n    for x in range(input_grid.shape[0] - 1):\n        for y in range(input_grid.shape[1] - 1):\n            # Check if the 2x2 block is a single color\n            if (input_grid[x, y] == input_grid[x + 1, y] == \n                input_grid[x, y + 1] == input_grid[x + 1, y + 1] == color_a):\n                output_grid[x:x + 2, y:y + 2] = color_b\n            elif (input_grid[x, y] == input_grid[x + 1, y] == \n                  input_grid[x, y + 1] == input_grid[x + 1, y + 1] == color_b):\n                output_grid[x:x + 2, y:y + 2] = color_a\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size 10x10 with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define two colors to use in the pattern\n    color1, color2 = np.random.choice(list(Color.NOT_BLACK), size=2, replace=False)\n\n    # Randomly scatter the two colors in a way that forms 2x2 squares\n    for _ in range(np.random.randint(2, 6)):  # Create between 2 to 5 squares\n        square_color = np.random.choice([color1, color2])\n        square_position_x = np.random.randint(0, n - 1)\n        square_position_y = np.random.randint(0, m - 1)\n        \n        # Make sure not to overlap with existing squares\n        if (grid[square_position_x:square_position_x + 2, square_position_y:square_position_y + 2] == 0).all():\n            grid[square_position_x:square_position_x + 2, square_position_y:square_position_y + 2] = square_color\n\n    # Scatter some single pixels of each color to add complexity\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == 0:  # Only place if the spot is empty\n            grid[x, y] = np.random.choice([color1, color2])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/175/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/175/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/175/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/175/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/175/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/175/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/175/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/175/images/train_output_2.png"}]}, "index": 175, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color mirroring\n\n# description:\n# In the input, you will see a grid with a set of colors on one side (left or top). \n# To create the output, mirror the colors across a vertical or horizontal axis, \n# creating a symmetric pattern. If the left side is colored, mirror it to the right side. \n# If the top side is colored, mirror it to the bottom side.\n\ndef main(input_grid):\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid filled with black\n    output_grid = np.full((n, m), Color.BLACK)\n    \n    # Check if we have a non-black left side to mirror\n    left_colored = np.any(input_grid[:, :m // 2] != Color.BLACK)\n    \n    if left_colored:\n        # Mirror from left to right\n        output_grid[:, :m // 2] = input_grid[:, :m // 2]\n        output_grid[:, m // 2:] = np.fliplr(input_grid[:, :m // 2])\n    \n    # Check if we have a non-black top side to mirror\n    top_colored = np.any(input_grid[:n // 2, :] != Color.BLACK)\n    \n    if top_colored:\n        # Mirror from top to bottom\n        output_grid[:n // 2, :] = input_grid[:n // 2, :]\n        output_grid[n // 2:, :] = np.flipud(input_grid[:n // 2, :])\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size (5 to 10) with black background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly decide whether to fill the left or top part\n    fill_left = np.random.choice([True, False])\n    \n    if fill_left:\n        # Fill the left half with random colors\n        for i in range(n):\n            for j in range(m // 2):\n                grid[i, j] = np.random.choice(Color.NOT_BLACK)\n    else:\n        # Fill the top half with random colors\n        for i in range(n // 2):\n            for j in range(m):\n                grid[i, j] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/176/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/176/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/176/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/176/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/176/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/176/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/176/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/176/images/train_output_2.png"}]}, "index": 176, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color mapping\n\n# description:\n# In the input you will see a rectangular grid with a mix of colors. The output should be a grid that mirrors the input grid horizontally, but with a specific color mapping:\n# - Red becomes Blue\n# - Green becomes Yellow\n# - Blue becomes Red\n# - Yellow becomes Green\n# Other colors remain unchanged.\n\ndef main(input_grid):\n    # Create a mapping for color transformation\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN\n    }\n\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n\n    # Initialize output grid with the same shape\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # Fill the output grid with mirrored colors and apply the color mapping\n    for y in range(m):\n        for x in range(n):\n            # Get the mirrored position\n            mirrored_x = n - 1 - x\n            \n            # Get the color from the input grid\n            original_color = input_grid[x][y]\n            # Apply the color mapping if it exists\n            output_color = color_map.get(original_color, original_color)\n\n            # Assign the mapped color to the mirrored position in the output grid\n            output_grid[mirrored_x][y] = output_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 5x5 and 10x10\n    n = np.random.randint(5, 11)\n    m = np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors, allowing for specific colors\n    available_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW,\n                        Color.GREY, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON]\n    \n    for i in range(n):\n        for j in range(m):\n            grid[i][j] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/177/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/177/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/177/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/177/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/177/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/177/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/177/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/177/images/train_output_2.png"}]}, "index": 177, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color reversal\n\n# description:\n# In the input you will see a grid of colored pixels. To make the output, rotate the entire grid 180 degrees and reverse the color of each pixel.\n# If the pixel is black, change it to orange and vice versa.\n\ndef main(input_grid):\n    # Create an output grid that will store the transformed colors\n    output_grid = np.empty_like(input_grid)\n\n    # Get the dimensions of the input grid\n    rows, cols = input_grid.shape\n\n    # Process each pixel in the input grid\n    for r in range(rows):\n        for c in range(cols):\n            # Determine the new position after a 180 degree rotation\n            new_r = rows - 1 - r\n            new_c = cols - 1 - c\n\n            # Reverse the color: if black (0), change to orange (1) and vice versa\n            if input_grid[r, c] == Color.BLACK:\n                output_grid[new_r, new_c] = Color.ORANGE\n            elif input_grid[r, c] == Color.ORANGE:\n                output_grid[new_r, new_c] = Color.BLACK\n            else:\n                # For all other colors, simply copy them to the new position\n                output_grid[new_r, new_c] = input_grid[r, c]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random colors and a uniform background\n    width, height = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Fill the grid with random colors (excluding black and orange)\n    for r in range(width):\n        for c in range(height):\n            if np.random.rand() \u003e 0.5:  # Randomly decide to place a color or leave it black\n                grid[r, c] = np.random.choice([color for color in Color.NOT_BLACK if color != Color.ORANGE])\n    \n    # Randomly place some orange pixels\n    for _ in range(np.random.randint(1, 6)):\n        grid[np.random.randint(width), np.random.randint(height)] = Color.ORANGE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/178/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/178/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/178/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/178/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/178/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/178/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/178/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/178/images/train_output_2.png"}]}, "index": 178, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# stacking, transparency, color blending\n\n# description:\n# In the input you will see several overlapping colored squares. Each square has a certain transparency level.\n# To create the output, stack the squares on top of each other while blending the colors based on their transparency levels,\n# resulting in a smooth gradient effect where colors combine according to their overlap.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all squares in the input grid.\n    # 2. For each square, determine its position and color.\n    # 3. Create a new output grid and blend colors based on overlaps using the transparency.\n    \n    # 1. Extract the square objects from the input grid\n    square_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Initialize output grid with a transparent background\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. Stack and blend colors based on transparency\n    for square in square_objects:\n        x, y, w, h = bounding_box(square)\n        square_color = square[square != Color.BLACK][0]  # Get color of the square\n        transparency = 0.5  # Assume a fixed transparency level for this puzzle\n        \n        # Blend the square into the output grid\n        for i in range(w):\n            for j in range(h):\n                if square[i, j] != Color.BLACK:\n                    # Calculate the blended color (simple alpha blending)\n                    existing_color = output_grid[x + i, y + j]\n                    if existing_color != Color.BLACK:\n                        # Blend colors (simple average for demonstration)\n                        blended_color = (\n                            int((existing_color[0] * (1 - transparency)) + (square_color[0] * transparency)),\n                            int((existing_color[1] * (1 - transparency)) + (square_color[1] * transparency)),\n                            int((existing_color[2] * (1 - transparency)) + (square_color[2] * transparency))\n                        )\n                        output_grid[x + i, y + j] = blended_color\n                    else:\n                        output_grid[x + i, y + j] = square_color  # If empty, just place the color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with random colored squares overlapping\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    num_squares = np.random.randint(3, 7)  # Number of squares\n    colors = random.sample(list(Color.NOT_BLACK), num_squares)\n\n    for color in colors:\n        square_size = np.random.randint(2, 5)  # Random size for the square\n        square = np.full((square_size, square_size), color)\n\n        # Random position to place the square\n        x = np.random.randint(0, width - square_size)\n        y = np.random.randint(0, height - square_size)\n\n        # Place the square on the grid (allowing overlap)\n        blit_sprite(grid, square, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/179/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/179/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/179/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/179/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/179/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/179/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/179/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/179/images/train_output_2.png"}]}, "index": 179, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object detection\n\n# description:\n# In the input you will see a grid with differently colored circular objects (either red, blue, or green).\n# To generate the output, change all blue objects to green, and all green objects to red.\ndef main(input_grid):\n    # Copy the input grid to preserve the original\n    output_grid = np.copy(input_grid)\n\n    # Detect all colored objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    # Transform colors based on the rules\n    for obj in objects:\n        if np.any(obj == Color.BLUE):\n            # Change blue objects to green\n            obj[obj == Color.BLUE] = Color.GREEN\n        if np.any(obj == Color.GREEN):\n            # Change green objects to red\n            obj[obj == Color.GREEN] = Color.RED\n\n        # Place the transformed object back into the output grid\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 15x15 grid\n    grid = np.full((15, 15), Color.BLACK)\n\n    # Randomly scatter red, blue, and green circular objects\n    colors = [Color.RED, Color.BLUE, Color.GREEN]\n    for _ in range(np.random.randint(5, 10)):\n        # Generate a random sprite (circular object)\n        sprite = random_sprite(np.random.randint(3, 5), np.random.randint(3, 5), color_palette=[np.random.choice(colors)], symmetry=\u0027not_symmetric\u0027, density=0.5)\n\n        # Try to randomly place the sprite onto the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            pass  # Ignore if there\u0027s no space to place the sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/180/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/180/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/180/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/180/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/180/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/180/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/180/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/180/images/train_output_2.png"}]}, "index": 180, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, size-based transformation, color mapping\n\n# description:\n# In the input you will see a grid with various colored components on a black background.\n# To make the output, detect the connected components of colors. Color components with 5 or more pixels blue, \n# components with 3 or 4 pixels orange, and those with 2 pixels yellow. \n# Components with 1 pixel will remain their original color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Find all connected components in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Process each component based on its size\n    for component in components:\n        # Count the number of pixels in the component\n        num_pixels = np.sum(component != Color.BLACK)\n\n        # Determine the color based on the size\n        if num_pixels \u003e= 5:\n            new_color = Color.BLUE\n        elif num_pixels in [3, 4]:\n            new_color = Color.ORANGE\n        elif num_pixels == 2:\n            new_color = Color.YELLOW\n        else:\n            new_color = component[0, 0]  # Original color for single pixel components\n            \n        # Color the component in the output grid\n        output_grid[component != Color.BLACK] = new_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize the grid with black background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random number of colored components\n    num_components = np.random.randint(5, 10)\n    available_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK, Color.ORANGE]\n    \n    for _ in range(num_components):\n        # Generate a random size for the component\n        size = np.random.randint(1, 7)  # Size between 1 and 6\n\n        # Create a random component sprite\n        component = random_sprite(size, size, symmetry=None, color_palette=[random.choice(available_colors)])\n        \n        # Find a random free location to place the component\n        try:\n            x, y = random_free_location_for_sprite(grid, component, padding=1)\n            blit_sprite(grid, component, x=x, y=y)\n        except ValueError:\n            # If no free location, skip this component\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/181/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/181/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/181/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/181/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/181/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/181/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/181/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/181/images/train_output_2.png"}]}, "index": 181, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, largest component detection\n\n# description:\n# In the input you will see several rectangular objects of different colors. The task is to identify the largest rectangle and rotate it 180 degrees around its center point.\n\ndef main(input_grid):\n    # 1. Detect the objects in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # 2. Identify the largest object based on area\n    largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # 3. Crop the largest object to obtain its sprite\n    sprite = crop(largest_object, background=Color.BLACK)\n    \n    # Get the center of the sprite for rotation\n    center_x, center_y = sprite.shape[0] // 2, sprite.shape[1] // 2\n\n    # 4. Rotate the sprite 180 degrees around its center point\n    rotated_sprite = np.rot90(np.rot90(sprite))\n\n    # 5. Create an output grid and blit the rotated sprite\n    output_grid = input_grid.copy()\n    x, y = object_position(largest_object, background=Color.BLACK)\n    \n    # Clear the area where the largest object was\n    for dx in range(sprite.shape[0]):\n        for dy in range(sprite.shape[1]):\n            if input_grid[x + dx, y + dy] != Color.BLACK:\n                output_grid[x + dx, y + dy] = Color.BLACK\n\n    # Blit the rotated sprite back onto the grid\n    blit_sprite(output_grid, rotated_sprite, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with several colored rectangles\n    width, height = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate a random number of rectangles\n    num_rectangles = np.random.randint(3, 6)\n    colors = list(Color.NOT_BLACK)\n\n    for _ in range(num_rectangles):\n        # Random dimensions for the rectangle\n        rect_width, rect_height = np.random.randint(2, 6), np.random.randint(2, 6)\n        color = np.random.choice(colors)\n\n        # Random position for the rectangle\n        x = np.random.randint(0, width - rect_width)\n        y = np.random.randint(0, height - rect_height)\n\n        # Draw the rectangle\n        for dx in range(rect_width):\n            for dy in range(rect_height):\n                grid[x + dx, y + dy] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/182/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/182/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/182/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/182/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/182/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/182/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/182/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/182/images/train_output_2.png"}]}, "index": 182, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# horizontal lines, vertical lines, single colored pixel\n\n# description:\n# In the input, you will see a grid with a single colored pixel on a black background.\n# To create the output, draw a vertical line from the colored pixel to the bottom of the grid and a horizontal line from the colored pixel to the right edge of the grid.\n\ndef main(input_grid):\n    # Find the position of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n    \n    # Get the color from the colored pixel\n    color = input_grid[x, y]\n\n    # Create an output grid initialized to the input grid\n    output_grid = input_grid.copy()\n\n    # Draw the vertical line downwards\n    draw_line(output_grid, x, y, length=None, color=color, direction=(1, 0))\n\n    # Draw the horizontal line to the right\n    draw_line(output_grid, x, y, length=None, color=color, direction=(0, 1))\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random size\n    width, height = np.random.randint(5, 20, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Randomly place a colored pixel on the grid\n    color = np.random.choice(Color.NOT_BLACK)\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/183/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/183/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/183/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/183/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/183/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/183/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/183/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/183/images/train_output_2.png"}]}, "index": 183, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color changing\n\n# description:\n# In the input you will see a grid with a blue square. To create the output, scale the square to three times its size and change its color to yellow.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the blue square object in the input grid\n    # 2. Scale the square to three times its size\n    # 3. Change the color of the scaled square to yellow\n    # 4. Blit the scaled yellow square back to the output grid\n\n    # 1. Detect the blue square in the input grid\n    blue_square = detect_objects(input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    assert len(blue_square) == 1, \"There should be exactly one blue square\"\n    blue_square = list(blue_square)[0]\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. Get the bounding box of the blue square and crop it\n    x, y, w, h = bounding_box(blue_square)\n    sprite = crop(blue_square, background=Color.BLACK)\n\n    # 3. Scale the sprite by a factor of 3\n    scale_factor = 3\n    scaled_sprite = scale_sprite(sprite, scale_factor)\n\n    # 4. Change the color of the scaled sprite to yellow\n    scaled_sprite[scaled_sprite != Color.BLACK] = Color.YELLOW\n\n    # Calculate the new position to blit the scaled sprite onto the output grid\n    new_x = x * scale_factor\n    new_y = y * scale_factor\n\n    # Blit the yellow scaled square onto the output grid\n    blit_sprite(output_grid, scaled_sprite, new_x, new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a blue square in a random position\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define the size of the blue square\n    square_size = np.random.randint(2, 5)\n\n    # Create the blue square\n    blue_square = np.full((square_size, square_size), Color.BLUE)\n\n    # Randomly find a position to place the blue square\n    try:\n        x, y = random_free_location_for_sprite(grid=grid, sprite=blue_square, background=Color.BLACK)\n        blit_sprite(grid, blue_square, x, y, background=Color.BLACK)\n    except ValueError:\n        # If there\u0027s no space, regenerate the input\n        return generate_input()\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/184/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/184/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/184/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/184/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/184/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/184/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/184/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/184/images/train_output_2.png"}]}, "index": 184, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, object manipulation\n\n# description:\n# In the input you will see a black grid with a single colored line. \n# To make the output, rotate the colored line 45 degrees counterclockwise \n# while maintaining its original position and color.\n\ndef main(input_grid):\n    # Find the position of the colored line\n    line_color = [color for color in Color.NOT_BLACK if np.any(input_grid == color)][0]\n    line_locations = np.argwhere(input_grid == line_color)\n    \n    # Ensure there\u0027s only one line\n    assert len(line_locations) \u003e 0\n    line_pixels = line_locations[:, 0], line_locations[:, 1]\n    \n    # Create an output grid\n    output_grid = input_grid.copy()\n    \n    # Prepare to rotate the line 45 degrees counterclockwise\n    rotation_matrix = np.array([[np.cos(np.pi/4), -np.sin(np.pi/4)],\n                                 [np.sin(np.pi/4), np.cos(np.pi/4)]])\n    \n    # Draw the new rotated line in the output grid\n    for (x, y) in zip(*line_pixels):\n        # Rotate each point in the direction of the line\n        new_coords = rotation_matrix @ np.array([x, y])\n        new_x, new_y = int(round(new_coords[0])), int(round(new_coords[1]))\n        \n        # Ensure new coordinates are within bounds and color the new position\n        if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n            output_grid[new_x, new_y] = line_color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Draw a colored line in a random position\n    line_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Random starting point for the line\n    start_x, start_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    line_length = np.random.randint(3, 8)\n    \n    # Draw a line either vertically or horizontally\n    if np.random.choice([True, False]):\n        # Vertical line\n        draw_line(grid, start_x, start_y, length=line_length, direction=(1, 0), color=line_color)\n    else:\n        # Horizontal line\n        draw_line(grid, start_x, start_y, length=line_length, direction=(0, 1), color=line_color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/185/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/185/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/185/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/185/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/185/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/185/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/185/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/185/images/train_output_2.png"}]}, "index": 185, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, color swapping\n\n# description:\n# In the input, you will see a grid filled with colored pixels and a distinct gray border surrounding a region. \n# To create the output, you need to mirror the colors in the inner region across the vertical centerline of the grid.\n# The color on the left should be swapped with the color on the right.\n\ndef main(input_grid):\n    # Identify the borders and the inner region\n    height, width = input_grid.shape\n    assert np.all(input_grid[0, :] == Color.GRAY) and np.all(input_grid[height - 1, :] == Color.GRAY), \"Top and bottom borders must be gray.\"\n    assert np.all(input_grid[:, 0] == Color.GRAY) and np.all(input_grid[:, width - 1] == Color.GRAY), \"Left and right borders must be gray.\"\n\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Work within the inner region, excluding the borders\n    for x in range(1, height - 1):\n        for y in range(1, width - 1):\n            # Get the color from the left side\n            left_color = input_grid[x, y]\n            # Calculate the mirrored position\n            mirrored_y = width - 1 - y\n            # Set the color at the mirrored position to be the left color\n            output_grid[x, mirrored_y] = left_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random colors with a gray border\n    height = np.random.randint(10, 20)\n    width = np.random.randint(10, 20)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Draw the gray border\n    grid[0, :] = Color.GRAY\n    grid[height - 1, :] = Color.GRAY\n    grid[:, 0] = Color.GRAY\n    grid[:, width - 1] = Color.GRAY\n\n    # Fill the inner region with random colors\n    for x in range(1, height - 1):\n        for y in range(1, width - 1):\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)  # Avoid gray for the inner area\n            \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/186/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/186/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/186/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/186/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/186/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/186/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/186/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/186/images/train_output_2.png"}]}, "index": 186, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# staircase pattern, counting\n\n# description:\n# In the input you will see a single orange pixel.\n# To make the output, draw a staircase from the orange pixel to the upper right and lower left with a step size equal to the number of orange pixels in the input.\n\ndef main(input_grid):\n    # Find the location of the orange pixel\n    orange_pixel_coords = np.argwhere(input_grid == Color.ORANGE)\n    if len(orange_pixel_coords) == 0:\n        return input_grid  # No orange pixel found, return original\n\n    orange_x, orange_y = orange_pixel_coords[0]\n\n    # staircase color\n    staircase_color = Color.GRAY\n\n    # we are going to draw on top of the input\n    output_grid = input_grid.copy()\n    width, height = input_grid.shape\n\n    # Step size is equal to the number of orange pixels\n    step_size = len(orange_pixel_coords)\n\n    # Draw stairs from the orange pixel\n    # Draw staircase to the upper right\n    x, y = orange_x, orange_y\n    while x \u003c width and y \u003e= 0:\n        draw_line(output_grid, x, y, length=step_size, color=staircase_color, direction=(1, -1))\n        y -= step_size\n        x += step_size\n\n    # Draw staircase to the lower left\n    x, y = orange_x, orange_y\n    while x \u003e= 0 and y \u003c height:\n        draw_line(output_grid, x, y, length=step_size, color=staircase_color, direction=(-1, 1))\n        y += step_size\n        x -= step_size\n\n    # Ensure that the original orange pixel remains unchanged\n    output_grid[orange_x, orange_y] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Generate grid\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly place one orange pixel on the grid\n    # Ensure the pixel is not on the border\n    x, y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    grid[x, y] = Color.ORANGE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/187/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/187/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/187/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/187/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/187/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/187/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/187/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/187/images/train_output_2.png"}]}, "index": 187, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern, rotation\n\n# description:\n# In the input you will see a grid with a square pattern. To make the output, you should rotate the square pattern 45 degrees.\n\ndef main(input_grid):\n    # Calculate the bounding box of the square pattern\n    object_bounds = bounding_box(input_grid)\n    x, y, width, height = object_bounds\n\n    # Create an output grid that is large enough to contain the rotated square\n    output_size = int(np.ceil(np.sqrt(2) * max(width, height)))  # Diagonal length of the square\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # Crop the square pattern from the input grid\n    square_pattern = crop(input_grid)\n\n    # Rotate the square pattern 45 degrees (which is equivalent to a 90 degree rotation followed by a flip)\n    # We will create a new grid for the rotated pattern\n    rotated_pattern = np.zeros((output_size, output_size), dtype=int)\n\n    # Calculate the center of the input square pattern\n    center_x, center_y = object_position(square_pattern, background=Color.BLACK, anchor=\u0027center\u0027)\n\n    # For each pixel in the square pattern, compute the new position in the rotated grid\n    for i in range(square_pattern.shape[0]):\n        for j in range(square_pattern.shape[1]):\n            if square_pattern[i, j] != Color.BLACK:\n                # Original coordinates\n                original_x = i - center_x\n                original_y = j - center_y\n\n                # Rotate 45 degrees (transform to new coordinates)\n                new_x = int(original_x - original_y + output_size // 2)\n                new_y = int(original_x + original_y + output_size // 2)\n\n                # Place the pixel in the new grid\n                if 0 \u003c= new_x \u003c output_size and 0 \u003c= new_y \u003c output_size:\n                    rotated_pattern[new_x, new_y] = square_pattern[i, j]\n\n    # Place the rotated pattern into the center of the output grid\n    blit_sprite(output_grid, rotated_pattern, x=0, y=0, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random square pattern of random size and colors\n    n = m = np.random.randint(3, 6)  # Square pattern of size 3 to 5\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/188/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/188/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/188/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/188/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/188/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/188/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/188/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/188/images/train_output_2.png"}]}, "index": 188, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input you will see a grid with a colored object. \n# To make the output, you should rotate the object by 90 degrees clockwise and change its color to blue.\n\ndef main(input_grid):\n    # Step 1: Find the colored object\n    background_color = Color.BLACK\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n    \n    assert len(objects) == 1, \"There should be exactly one colored object.\"\n    colored_object = objects[0]\n\n    # Step 2: Rotate the object 90 degrees clockwise\n    rotated_object = np.rot90(colored_object, k=-1)  # k=-1 for 90 degrees clockwise\n\n    # Step 3: Change the color to blue\n    rotated_object[rotated_object != background_color] = Color.BLUE\n\n    # Step 4: Create output grid\n    output_grid = np.full(input_grid.shape, background_color)\n\n    # Step 5: Blit the rotated and colored object onto the output grid\n    blit_object(output_grid, rotated_object, background=background_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size between 5x5 and 10x10 with a black background\n    grid_size = np.random.randint(5, 11)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a random sprite with a random size between 2x2 and 4x4\n    sprite_width = np.random.randint(2, 5)\n    sprite_height = np.random.randint(2, 5)\n    sprite_colors = [Color.RED, Color.GREEN, Color.YELLOW, Color.ORANGE]\n\n    # Create a random sprite with the chosen colors\n    sprite = random_sprite(n=sprite_height, m=sprite_width, color_palette=sprite_colors, density=1.0)\n\n    # Find a random free location for the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/189/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/189/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/189/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/189/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/189/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/189/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/189/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/189/images/train_output_2.png"}]}, "index": 189, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color extraction\n\n# description:\n# In the input you will see a grid containing a colored shape and a background color.\n# The task is to extract the shape by identifying the connected components of the colored pixels,\n# and then rotate the shape 90 degrees clockwise before placing it in the output grid.\n\ndef main(input_grid):\n    # Find connected components of the non-background pixels\n    components = find_connected_components(input_grid, background=Color.BLACK)\n    \n    # Assuming there\u0027s only one main component (the colored shape)\n    if len(components) == 0:\n        return np.full(input_grid.shape, Color.BLACK)  # Return a black grid if no shape found\n\n    # Take the first component (the shape)\n    shape = components[0]\n    \n    # Get the bounding box of the shape\n    x, y, w, h = bounding_box(shape)\n    \n    # Crop the shape from the input grid\n    cropped_shape = crop(shape)\n    \n    # Rotate the shape 90 degrees clockwise\n    rotated_shape = np.rot90(cropped_shape, k=-1)\n    \n    # Create an output grid with the same dimensions as the input\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Calculate position to place the rotated shape in the output grid\n    output_x = x\n    output_y = y\n    \n    # Blit the rotated shape onto the output grid\n    output_grid = blit_sprite(output_grid, rotated_shape, x=output_x, y=output_y)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Randomly generate a shape (non-black color)\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    \n    # Draw a random shape in the grid\n    for _ in range(np.random.randint(5, 15)):\n        x = np.random.randint(0, n - shape_height)\n        y = np.random.randint(0, m - shape_width)\n        for i in range(shape_height):\n            for j in range(shape_width):\n                if np.random.rand() \u003e 0.5:  # Randomly fill part of the shape\n                    grid[x + i, y + j] = shape_color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/190/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/190/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/190/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/190/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/190/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/190/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/190/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/190/images/train_output_2.png"}]}, "index": 190, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# inversion, color changing, triangular patterns\n\n# description:\n# In the input you will see a grid with a triangle pattern of one color.\n# To make the output, you should invert that triangle (flip it upside down), \n# and change its color to green.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n    output_grid = np.full((height, width), Color.BLACK)\n\n    # Find the apex of the triangle; assume the triangle is pointing downwards and is filled\n    for y in range(height):\n        for x in range(width):\n            if input_grid[y, x] != Color.BLACK:\n                # Determine the height of the triangle\n                triangle_height = 0\n                while (y + triangle_height \u003c height and \n                       all(input_grid[y + triangle_height, x - triangle_height : x + triangle_height + 1] == input_grid[y, x])):\n                    triangle_height += 1\n                \n                # Invert the triangle and change its color to green\n                for i in range(triangle_height):\n                    for j in range(-i, i + 1):\n                        if 0 \u003c= y + triangle_height - 1 - i \u003c height and 0 \u003c= x + j \u003c width:\n                            output_grid[y + triangle_height - 1 - i, x + j] = Color.GREEN\n                break\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 5x5 and 20x20\n    length = np.random.randint(5, 21)\n    grid = np.full((length, length), Color.BLACK)\n\n    # Randomly choose a position to start the triangle\n    apex_x = np.random.randint(0, length)\n    apex_y = np.random.randint(0, length // 2)  # Ensure the apex is in the upper half for a downward triangle\n\n    # Random color for the triangle\n    triangle_color = np.random.choice(Color.NOT_BLACK)\n\n    # Draw a filled triangle downward\n    for height in range(1, length - apex_y):\n        if apex_x - height \u003e= 0 and apex_x + height \u003c length:\n            grid[apex_y + height - 1, apex_x - height:apex_x + height + 1] = triangle_color\n        else:\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/191/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/191/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/191/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/191/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/191/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/191/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/191/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/191/images/train_output_2.png"}]}, "index": 191, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels in the left half.\n# To make the output, reflect the pattern from the left half of the input to the right half of the output grid, maintaining symmetry.\n\ndef main(input_grid):\n    # Determine the shape of the input grid\n    height, width = input_grid.shape\n    \n    # Create an output grid with the same height and double the width\n    output_grid = np.full((height, width * 2), Color.BLACK)\n\n    # Copy the left half of the input grid to the left half of the output grid\n    output_grid[:, :width] = input_grid\n\n    # Reflect the left half to the right half\n    output_grid[:, width:] = np.fliplr(input_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the height and width of the grid\n    height = np.random.randint(5, 10)\n    width = np.random.randint(4, 8)\n\n    # Create a grid with the specified height and width, starting with a black background\n    grid = np.full((height, width), Color.BLACK)\n\n    # Select a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly generate a pattern in the left half of the grid\n    for i in range(height):\n        for j in range(width):\n            if np.random.rand() \u003e 0.5:  # 50% chance to color a pixel\n                grid[i, j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/192/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/192/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/192/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/192/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/192/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/192/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/192/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/192/images/train_output_2.png"}]}, "index": 192, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, symmetry\n\n# description:\n# In the input, you will see a grid with several colored squares. Each square has a unique color. \n# To make the output, reflect each square about the center of the grid and change its color based on its original position. \n# If a square is in the top half of the grid, it should turn green after reflection; if it is in the bottom half, it should turn blue.\n# Squares on the horizontal center line should turn yellow, regardless of their original color.\n\ndef main(input_grid):\n    # Get the dimensions of the grid\n    height, width = input_grid.shape\n    \n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Iterate through each pixel in the input grid\n    for x in range(height):\n        for y in range(width):\n            color = input_grid[x, y]\n            # Calculate the reflected position\n            reflected_x = height - 1 - x\n\n            # Determine the new color based on the original position\n            if x \u003c height // 2:\n                new_color = Color.GREEN\n            elif x \u003e height // 2:\n                new_color = Color.BLUE\n            else:\n                new_color = Color.YELLOW\n\n            # Set the color in the output grid at the reflected position\n            output_grid[reflected_x, y] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random size\n    height, width = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly place colored squares in the grid\n    num_squares = np.random.randint(1, 10)\n    colors = list(Color.NOT_BLACK)  # All colors except black\n\n    for _ in range(num_squares):\n        color = np.random.choice(colors)\n        # Choose random position for the square, ensuring it fits within the grid\n        x, y = np.random.randint(0, height), np.random.randint(0, width)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/193/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/193/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/193/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/193/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/193/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/193/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/193/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/193/images/train_output_2.png"}]}, "index": 193, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern transformation, mirroring, color swapping\n\n# description:\n# In the input you will see a grid with a symmetrical pattern where the left half is a mirrored version of the right half.\n# To make the output, you should swap the colors of the left half with the colors of the right half, maintaining the original structure.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n    \n    # Create the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Ensure the grid width is even for symmetry\n    if width % 2 != 0:\n        raise ValueError(\"Input grid width must be even to have a symmetrical pattern.\")\n\n    # Calculate the midpoint\n    mid = width // 2\n\n    # Swap the colors between the left and right halves\n    left_half = output_grid[:, :mid]\n    right_half = output_grid[:, mid:]\n\n    # Create a temporary variable to hold the colors of the left half\n    temp = np.copy(left_half)\n    output_grid[:, :mid] = right_half\n    output_grid[:, mid:] = temp\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate size for the grid\n    height = np.random.randint(5, 10)\n    width = np.random.randint(6, 12) * 2  # Ensure width is even\n\n    # Create a grid filled with a background color\n    grid = np.full((height, width), Color.BLACK)\n\n    # Define a random color palette for the pattern\n    colors = np.random.choice(Color.NOT_BLACK, size=4, replace=False)\n\n    # Generate the left half of the pattern\n    for i in range(height):\n        for j in range(width // 2):\n            grid[i, j] = np.random.choice(colors)\n\n    # Mirror the left half to create the right half\n    for i in range(height):\n        for j in range(width // 2):\n            grid[i, width - 1 - j] = grid[i, j]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/194/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/194/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/194/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/194/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/194/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/194/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/194/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/194/images/train_output_2.png"}]}, "index": 194, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, cropping, object detection\n\n# description:\n# In the input you will see a grid with several colored shapes. \n# To make the output, identify the largest shape, rotate it 180 degrees, and place it in the center of the grid. \n# All other shapes should be removed.\n\ndef main(input_grid):\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Identify the largest object by area\n    largest_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # Rotate the largest object 180 degrees\n    rotated_object = np.rot90(largest_object, k=2)\n\n    # Create an output grid initialized to the background\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Get the dimensions of the rotated object\n    h, w = rotated_object.shape\n\n    # Calculate the center position to place the rotated object\n    center_x = (output_grid.shape[0] - h) // 2\n    center_y = (output_grid.shape[1] - w) // 2\n\n    # Blit the rotated object onto the output grid at the center position\n    blit_sprite(output_grid, rotated_object, x=center_x, y=center_y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate colored shapes\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        # Create a random sprite (shape)\n        shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        shape = random_sprite(shape_width, shape_height, density=0.5, symmetry=\"not_symmetric\", background=Color.BLACK)\n\n        # Find a random free location for the shape\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n\n        # Blit the shape onto the grid\n        blit_sprite(grid, shape, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/195/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/195/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/195/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/195/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/195/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/195/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/195/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/195/images/train_output_2.png"}]}, "index": 195, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shifting, wrapping, object size\n\n# description:\n# In the input you will see a grid containing several colored objects. Each object is represented as a block of contiguous pixels of the same color. The task is to shift each object upwards by its height (the number of rows it occupies). If an object reaches the top border of the grid, it should wrap around and continue from the bottom.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all connected components (objects) in the input grid.\n    # 2. For each object, determine its height.\n    # 3. Shift the object upwards by its height, wrapping it around if necessary.\n    # 4. Create an output grid and place the shifted objects in it.\n\n    # Extract objects from the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n    \n    # Determine the output grid size\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for obj in objects:\n        # Get the position and size of the object\n        obj_height = obj.shape[0]\n        obj_y, obj_x = object_position(obj)\n        \n        # Calculate the new position after shifting upwards\n        new_y = (obj_y - obj_height) % output_grid.shape[0]\n        \n        # Place the object in the output grid at the new position\n        blit_object(output_grid, translate(obj, 0, -obj_height), background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random objects\n    n, m = np.random.randint(5, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of objects\n    num_objects = np.random.randint(2, 5)\n    \n    for _ in range(num_objects):\n        # Define random size for the object\n        obj_height = np.random.randint(1, 4)\n        obj_width = np.random.randint(1, 4)\n        \n        # Create a randomly colored object\n        color = np.random.choice(Color.NOT_BLACK)\n        obj = np.full((obj_height, obj_width), color)\n\n        # Find a free location for the object\n        x, y = random_free_location_for_sprite(grid, obj, padding=0)\n        \n        # Blit the object to the grid\n        blit_sprite(grid, obj, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/196/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/196/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/196/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/196/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/196/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/196/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/196/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/196/images/train_output_2.png"}]}, "index": 196, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, flipping, object placement\n\n# description:\n# In the input, you will see a 5x5 grid. The center cell contains a multicolored object, while the corners contain four distinct colors. The objective is to flip the object in the center vertically and place it in each of the corner cells, one at a time, while maintaining the original colors of the corners.\n\ndef main(input_grid):\n    # Extract the center object\n    center_object = input_grid[2:3, 2:3]  # The center is at (2, 2)\n    \n    # Crop the center object, which is a 1x1 grid\n    template_sprite = crop(center_object, background=Color.BLACK)\n\n    # Create the output grid based on the input\n    output_grid = input_grid.copy()\n\n    # Flip the object vertically\n    flipped_sprite = np.flipud(template_sprite)\n\n    # Place the flipped object in each corner of the grid\n    corners = [(0, 0), (0, 4), (4, 0), (4, 4)]\n    for corner in corners:\n        x, y = corner\n        blit_sprite(output_grid, flipped_sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 5x5 grid with distinct corner colors and a random center object\n    grid = np.full((5, 5), Color.BLACK)\n\n    # Set the corner colors\n    corner_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n    for i, color in enumerate(corner_colors):\n        x, y = (i // 2) * 4, (i % 2) * 4  # Top-left, Top-right, Bottom-left, Bottom-right\n        grid[x, y] = color\n\n    # Create a random center object (1x1 in this case)\n    center_color = np.random.choice([c for c in Color.NOT_BLACK if c not in corner_colors])\n    grid[2, 2] = center_color  # Place a random color in the center\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/197/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/197/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/197/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/197/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/197/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/197/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/197/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/197/images/train_output_2.png"}]}, "index": 197, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color inversion\n\n# description:\n# In the input you will see a grid with a certain pattern of colored pixels.\n# If a pixel is red, it should be reflected across the vertical axis of the grid.\n# If a pixel is green, it should be inverted to blue (green becomes blue).\n# All other colors should remain unchanged.\n\ndef main(input_grid):\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n    # Prepare an output grid\n    output_grid = input_grid.copy()\n\n    # Reflect red pixels across the vertical axis\n    for x in range(n):\n        for y in range(m):\n            if input_grid[x, y] == Color.RED:\n                # Reflecting across the vertical axis\n                output_grid[x, m - 1 - y] = Color.RED\n\n    # Invert green pixels to blue\n    for x in range(n):\n        for y in range(m):\n            if input_grid[x, y] == Color.GREEN:\n                output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid of random size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly sprinkle red, green, and some other colors\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.ORANGE]\n    for _ in range(np.random.randint(10, 30)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/198/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/198/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/198/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/198/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/198/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/198/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/198/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/198/images/train_output_2.png"}]}, "index": 198, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel shifting, color blending\n\n# description:\n# In the input you will see a grid with several colored pixels scattered across it.\n# To make the output, you should shift each colored pixel one step to the right and blend the colors \n# of any overlapping pixels, using a simple averaging method. The output grid should maintain the same size as the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the dimensions of the input grid\n    rows, cols = input_grid.shape\n\n    # Perform the shifting and blending\n    for x in range(rows):\n        for y in range(cols):\n            current_color = input_grid[x, y]\n            if current_color != Color.BLACK:\n                # Calculate the new position (shift right)\n                new_x, new_y = x, (y + 1) % cols\n\n                # If there\u0027s already a color in the new position, blend the colors\n                if output_grid[new_x, new_y] != Color.BLACK:\n                    # Blend the colors by averaging them\n                    blended_color = average_colors(output_grid[new_x, new_y], current_color)\n                    output_grid[new_x, new_y] = blended_color\n                else:\n                    # If the new position is empty, just move the color\n                    output_grid[new_x, new_y] = current_color\n    \n    return output_grid\n\ndef average_colors(color1, color2):\n    # Convert colors to numpy array for averaging\n    color1_array = np.array([int(c) for c in color1.split(\u0027,\u0027)])\n    color2_array = np.array([int(c) for c in color2.split(\u0027,\u0027)])\n    \n    # Average the colors and return as a string representation\n    average_color = (color1_array + color2_array) // 2\n    return \u0027,\u0027.join(map(str, average_color))\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate a grid size\n    n, m = np.random.randint(5, 12), np.random.randint(5, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a random number of colored pixels\n    num_pixels = np.random.randint(5, 20)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=num_pixels, replace=True)\n\n    # Randomly scatter the colored pixels in the grid\n    for color in colors:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/199/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/199/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/199/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/199/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/199/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/199/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/199/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/199/images/train_output_2.png"}]}, "index": 199, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, expanding, geometric patterns\n\n# description:\n# In the input you will see some colored triangles, each of which is 3 pixels tall, 3 pixels wide, and has a single pixel in the center of the triangle that is a different color.\n# Make the output by growing the triangle by 1 pixel north/south/east/west, and growing the center pixel by 2 pixels along each of the 4 diagonals.\n\ndef main(input_grid):\n    # Extract the triangles from the input grid\n    triangles = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    for triangle in triangles:\n        # Find the bounding box of the triangle\n        x, y, w, h = bounding_box(triangle)\n        center_x, center_y = x + 1, y + 1  # Center of a 3x3 triangle\n\n        # Extract the relevant colors\n        center_color = triangle[center_x, center_y]\n        triangle_color = triangle[triangle != Color.BLACK][0]\n\n        # Grow the triangle by expanding its bounds (north, south, east, west)\n        for output_x in range(x-1, x+w+2):  # Extends w+2 to account for 1 pixel growth on both sides\n            for output_y in range(y-1, y+h+2):  # Extends h+2 to account for 1 pixel growth on both sides\n                # Skip if out of bounds\n                if output_x \u003c 0 or output_y \u003c 0 or output_x \u003e= input_grid.shape[0] or output_y \u003e= input_grid.shape[1]:\n                    continue\n                \n                # Grow the triangle\n                if output_x == center_x or output_y == center_y:  # North/South/East/West growth\n                    output_grid[output_x, output_y] = triangle_color\n                \n                # Grow the center diagonally\n                if (output_x - center_x) == (output_y - center_y) or (output_x - center_x) == (center_y - output_y):\n                    output_grid[output_x, output_y] = center_color\n\n    return output_grid\n\n\ndef generate_input():\n    input_grid = np.zeros((20, 20), dtype=int)\n\n    # Create 2 triangles\n    for triangle_number in range(2):\n        # Create a separate triangle sprite\n        triangle = np.zeros((3, 3), dtype=int)\n        triangle_color, center_color = random.sample(list(Color.NOT_BLACK), 2)\n        \n        # Define the triangle shape\n        triangle[0, 1] = triangle_color  # Top\n        triangle[1, 0] = triangle_color  # Left\n        triangle[1, 1] = center_color    # Center\n        triangle[1, 2] = triangle_color  # Right\n        triangle[2, 1] = triangle_color  # Bottom\n\n        # Find a free place on the grid\n        x, y = random_free_location_for_sprite(input_grid, triangle)\n\n        # Blit the triangle to the canvas\n        blit_sprite(input_grid, triangle, x, y)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/200/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/200/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/200/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/200/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/200/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/200/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/200/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/200/images/train_output_2.png"}]}, "index": 200, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color blending, resizing\n\n# description:\n# In the input you will see a large multicolor object and a smaller monochromatic shape.\n# To make the output, the multicolor object should be resized to match the dimensions of the monochromatic shape, \n# and then blended with the monochromatic shape, where the colors of the multicolor object will be used to replace the monochromatic color.\n# The output should retain the shape of the monochromatic object but with the colors from the multicolor object.\n\ndef main(input_grid):\n    # Step 1: Identify the large multicolor object and the smaller monochromatic shape\n    objects = find_connected_components(input_grid, monochromatic=False)\n    monochromatic_object = None\n    multicolor_object = None\n    \n    for obj in objects:\n        colors = set(object_colors(obj, background=Color.BLACK))\n        if len(colors) == 1 and Color.BLACK not in colors:\n            monochromatic_object = obj\n        elif len(colors) \u003e 1:\n            multicolor_object = obj\n    \n    assert monochromatic_object is not None, \"There should be one monochromatic object.\"\n    assert multicolor_object is not None, \"There should be one multicolor object.\"\n\n    # Step 2: Get the bounding box of the monochromatic object\n    mono_x, mono_y, mono_w, mono_h = bounding_box(monochromatic_object)\n    monochromatic_sprite = monochromatic_object[mono_x:mono_x + mono_w, mono_y:mono_y + mono_h]\n\n    # Step 3: Resize the multicolor object to match the dimensions of the monochromatic shape\n    multicolor_sprite = crop(multicolor_object, background=Color.BLACK)\n    resized_multicolor_sprite = scale_sprite(multicolor_sprite, mono_w // multicolor_sprite.shape[1])\n\n    # Step 4: Create the output grid and blend colors\n    output_grid = np.full_like(monochromatic_sprite, Color.BLACK)\n    for i in range(monochromatic_sprite.shape[0]):\n        for j in range(monochromatic_sprite.shape[1]):\n            if monochromatic_sprite[i, j] != Color.BLACK:\n                # Blend colors: replace monochromatic color with the color from the multicolor sprite\n                output_grid[i, j] = resized_multicolor_sprite[i, j] if resized_multicolor_sprite[i, j] != Color.BLACK else monochromatic_sprite[i, j]\n    \n    return output_grid\n\ndef generate_input():\n    # Create a multicolor object and a monochromatic shape\n    multicolor_sprite = random_sprite(np.random.randint(3, 5), np.random.randint(3, 5), density=0.7, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n    monochromatic_color = np.random.choice(list(Color.NOT_BLACK))\n    monochromatic_sprite = random_sprite(np.random.randint(5, 7), np.random.randint(5, 7), density=1.0, color_palette=[monochromatic_color], background=Color.BLACK)\n\n    # Make sure the monochromatic object is a solid color\n    assert len(set(monochromatic_sprite.flatten())) == 1, \"Monochromatic object must have only one color.\"\n\n    # Create a large enough grid to fit both objects\n    grid_size = max(multicolor_sprite.shape[0], monochromatic_sprite.shape[0]) + 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly place the multicolor sprite and the monochromatic sprite\n    x1, y1 = random_free_location_for_sprite(grid, multicolor_sprite, background=Color.BLACK)\n    blit_sprite(grid, multicolor_sprite, x=x1, y=y1)\n\n    x2, y2 = random_free_location_for_sprite(grid, monochromatic_sprite, background=Color.BLACK)\n    blit_sprite(grid, monochromatic_sprite, x=x2, y=y2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/201/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/201/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/201/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/201/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/201/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/201/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/201/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/201/images/train_output_2.png"}]}, "index": 201, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# patterns, rotation, positioning\n\n# description:\n# In the input, you will see a pattern of pixels in the top left corner of the grid.\n# To make the output, rotate the pattern 90 degrees clockwise and place it in the top right corner of the grid.\n\ndef main(input_grid):\n    # Find the top left pattern by cropping the grid\n    # Assuming the pattern is in the top left corner and bounded by black pixels\n    height, width = input_grid.shape\n    pattern = crop(input_grid)\n    \n    # Rotate the pattern 90 degrees clockwise\n    rotated_pattern = np.rot90(pattern, -1)\n\n    # Create output grid\n    output_grid = np.full((height, width), Color.BLACK)\n\n    # Place the original pattern in the top left corner\n    blit_sprite(output_grid, pattern, x=0, y=0)\n\n    # Place the rotated pattern in the top right corner\n    blit_sprite(output_grid, rotated_pattern, x=0, y=width - rotated_pattern.shape[1])\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a random pattern in the top left corner\n    height = np.random.randint(5, 10)\n    width = np.random.randint(5, 10)\n    \n    grid = np.full((height, width), Color.BLACK)\n\n    # Define the size of the pattern\n    pattern_height = np.random.randint(2, height // 2)\n    pattern_width = np.random.randint(2, width // 2)\n\n    # Create a random color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the top left corner with the pattern\n    for i in range(pattern_height):\n        for j in range(pattern_width):\n            grid[i, j] = color if np.random.rand() \u003c 0.5 else Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/202/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/202/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/202/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/202/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/202/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/202/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/202/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/202/images/train_output_2.png"}]}, "index": 202, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, rotation\n\n# description:\n# In the input, you will see a pattern that is rotated by a certain angle. \n# The goal is to rotate the pattern back to its original orientation and then \n# replicate that original pattern in all four quadrants of the output grid.\n\ndef main(input_grid):\n    # Create an output grid that is large enough to fit the pattern in all four quadrants\n    n, m = input_grid.shape\n    output_grid = np.full((n * 2, m * 2), Color.BLACK)\n\n    # Rotate the input grid back to its original orientation\n    # Since the input is a rotated pattern, we will assume it is rotated 90 degrees for this problem\n    original_pattern = np.rot90(input_grid, k=-1)\n\n    # Place the original pattern in all four quadrants of the output grid\n    output_grid[0:n, 0:m] = original_pattern  # Top-left\n    output_grid[0:n, m:2*m] = original_pattern  # Top-right\n    output_grid[n:2*n, 0:m] = original_pattern  # Bottom-left\n    output_grid[n:2*n, m:2*m] = original_pattern  # Bottom-right\n\n    return output_grid\n\ndef generate_input():\n    # Create a random pattern of a size between 3x3 and 6x6\n    n, m = np.random.randint(3, 7), np.random.randint(3, 7)\n    \n    # Generate a random sprite with random colors (not black)\n    sprite = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n    \n    # Rotate the sprite randomly (90 degrees, 180 degrees, or 270 degrees)\n    rotations = np.random.randint(1, 4)\n    rotated_sprite = np.rot90(sprite, k=rotations)\n\n    return rotated_sprite", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/203/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/203/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/203/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/203/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/203/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/203/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/203/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/203/images/train_output_2.png"}]}, "index": 203, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation\n\n# description:\n# In the input, you will see a grid with black and green squares. \n# Rotate the grid 90 degrees clockwise and change all green squares to yellow in the output.\n\ndef main(input_grid):\n    # Initialize output grid with the same size as input\n    n, m = input_grid.shape\n    output_grid = np.zeros((m, n), dtype=int)  # New shape after rotation\n\n    # Rotate the grid 90 degrees clockwise and change green to yellow\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] == Color.GREEN:\n                output_grid[j, n - 1 - i] = Color.YELLOW\n            else:\n                output_grid[j, n - 1 - i] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with black and green squares\n    n, m = np.random.randint(3, 10), np.random.randint(3, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with black (background) and some green squares\n    density = 0.3  # 30% of the grid will be green\n    for x in range(n):\n        for y in range(m):\n            if np.random.rand() \u003c density:\n                grid[x, y] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/204/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/204/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/204/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/204/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/204/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/204/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/204/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/204/images/train_output_2.png"}]}, "index": 204, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flipping, rotation\n\n# description:\n# In the input you will see a grid with a pattern of colored pixels. \n# To make the output, you should first flip the grid vertically, and then rotate it 90 degrees clockwise.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Flip the input grid vertically\n    # 2. Rotate the flipped grid 90 degrees clockwise to create the output\n\n    # 1. Flip the input grid vertically\n    flipped_input = np.flipud(input_grid)\n\n    # 2. Rotate the flipped grid 90 degrees clockwise\n    output_grid = np.rot90(flipped_input, k=-1)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select a color for the pattern\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a random pattern in the grid\n    # For simplicity, we\u0027ll create a horizontal stripe pattern\n    for x in range(1, width - 1):\n        if np.random.rand() \u003e 0.5:  # Randomly decide to color this pixel or not\n            grid[x, np.random.randint(1, height - 1)] = color\n            \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/205/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/205/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/205/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/205/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/205/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/205/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/205/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/205/images/train_output_2.png"}]}, "index": 205, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connectivity, color matching\n\n# description:\n# In the input you will see a series of teal pixels and two 2x2 yellow squares on a black background.\n# If the two 2x2 yellow squares are connected by a path of teal pixels, then output a 1x1 yellow grid, \n# otherwise, output a 1x1 black grid. \n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.zeros((1,1), dtype=int)\n\n    # get just the yellow squares\n    yellow_squares = np.zeros_like(input_grid)\n    yellow_squares[input_grid == Color.YELLOW] = Color.YELLOW\n\n    # get all components that are connected, regardless of color\n    connected_components = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n\n    # check each connected component to see if it contains both yellow squares\n    for connected_component in connected_components:\n        # if it contains both yellow squares, output yellow grid\n        if np.all(connected_component[yellow_squares == Color.YELLOW] == Color.YELLOW):         \n            output_grid[:,:] = Color.YELLOW\n            return output_grid\n\n    # if none of the connected components contain both yellow squares, output black grid\n    output_grid[:,:] = Color.BLACK\n    return output_grid\n\n\ndef generate_input():\n    # make a black grid first as background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # make a 2x2 yellow square sprite\n    yellow_square_sprite = np.full((2,2), Color.YELLOW, dtype=int)\n\n    # place a yellow square sprite at two random places on the grid\n    x1, y1 = random_free_location_for_sprite(grid, yellow_square_sprite, padding=1)\n    blit_sprite(grid, yellow_square_sprite, x1, y1)\n    x2, y2 = random_free_location_for_sprite(grid, yellow_square_sprite, padding=1)\n    blit_sprite(grid, yellow_square_sprite, x2, y2)\n\n    # check that the yellow squares do not touch\n    # if they do, then try again\n    if contact(object1=yellow_square_sprite, object2=yellow_square_sprite, x1=x1, y1=y1, x2=x2, y2=y2):\n        return generate_input()\n\n    # sprinkle teal pixels over the black parts of the grid so they cover roughly a third of it\n    for _ in range(n * m // 3):\n        x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n        # do not sprinkle teal pixels on top of yellow ones\n        if grid[x, y] != Color.YELLOW:\n            grid[x, y] = Color.TEAL\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/206/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/206/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/206/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/206/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/206/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/206/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/206/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/206/images/train_output_2.png"}]}, "index": 206, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, geometric transformation, grid manipulation\n\n# description:\n# In the input you will see a grid with a simple geometric shape, which consists of connected colored pixels.\n# To make the output, fill the shape with a checkerboard pattern of alternating colors,\n# and then scale the entire filled shape by a factor of 2.\n\ndef main(input_grid):\n    # Step 1: Detect the shape in the input grid\n    shape_components = find_connected_components(input_grid, monochromatic=False)\n\n    # Initialize the output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Define the checkerboard colors\n    color1 = Color.RED\n    color2 = Color.BLUE\n\n    # Step 2: Fill each detected shape with a checkerboard pattern\n    for shape in shape_components:\n        # Get the bounding box of the shape\n        bounding_box = crop(shape, background=Color.BLACK)\n        shape_height, shape_width = bounding_box.shape\n\n        # Fill the bounding box with a checkerboard pattern\n        for i in range(shape_height):\n            for j in range(shape_width):\n                if bounding_box[i, j] != Color.BLACK:  # Only fill non-background pixels\n                    if (i + j) % 2 == 0:\n                        output_grid[i, j] = color1\n                    else:\n                        output_grid[i, j] = color2\n\n    # Step 3: Scale the filled shape by a factor of 2\n    output_grid = scale_sprite(output_grid, factor=2)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    grid_size = np.random.randint(5, 10)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly create a shape in the grid\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_size = np.random.randint(3, 5)\n\n    # Create a simple geometric shape (a filled square)\n    start_x = np.random.randint(0, grid_size - shape_size)\n    start_y = np.random.randint(0, grid_size - shape_size)\n\n    for i in range(shape_size):\n        for j in range(shape_size):\n            grid[start_x + i, start_y + j] = shape_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/207/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/207/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/207/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/207/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/207/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/207/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/207/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/207/images/train_output_2.png"}]}, "index": 207, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel expansion, position-based transformation, color propagation\n\n# description:\n# In the input you will see a grid with a single colored pixel. \n# To make the output, you should expand the pixel into a square of the same color. \n# The size of the square should be based on the position of the pixel in the input grid.\n# Specifically, the size of the square should be determined by the pixel\u0027s row and column index: \n# if the pixel is at (x, y), the size of the square is (x + 1) * (y + 1).\n\ndef main(input_grid):\n    # 1. Find the single colored pixel in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True)\n    assert len(objects) == 1, \"exactly one colored pixel expected\"\n    colored_pixel = objects[0]\n    \n    # 2. Get the position of the colored pixel\n    x, y = object_position(colored_pixel, background=Color.BLACK)\n\n    # 3. Determine the size of the square based on the position\n    square_size = (x + 1) * (y + 1)\n\n    # 4. Create the output grid, starting as a black grid\n    output_grid_size = input_grid.shape[0] + square_size - 1\n    output_grid = np.full((output_grid_size, output_grid_size), Color.BLACK)\n\n    # 5. Create a square sprite of the same color as the pixel\n    color_of_pixel = input_grid[x, y]\n    square_sprite = np.full((square_size, square_size), color_of_pixel)\n\n    # 6. Place the square in the center of the output grid\n    start_x = (output_grid_size - square_size) // 2\n    start_y = (output_grid_size - square_size) // 2\n    blit_sprite(output_grid, square_sprite, x=start_x, y=start_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a single colored pixel\n    width, height = np.random.randint(5, 11, size=2)  # grid size between 5x5 and 10x10\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly place a single colored pixel\n    pixel_x = np.random.randint(0, width)\n    pixel_y = np.random.randint(0, height)\n    grid[pixel_x, pixel_y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/208/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/208/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/208/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/208/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/208/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/208/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/208/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/208/images/train_output_2.png"}]}, "index": 208, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, pattern detection\n\n# description:\n# The input is a grid containing various colored patterns. \n# To produce the output grid, change each color according to the following mapping:\n# green -\u003e yellow, blue -\u003e gray, red -\u003e pink, teal -\u003e maroon, and keep the same patterns.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Performs color mapping according to the specified rules\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n\n# Constructing the color map\ncolor_map = {\n    Color.GREEN: Color.YELLOW,\n    Color.BLUE: Color.GRAY,\n    Color.RED: Color.PINK,\n    Color.TEAL: Color.MAROON\n}\n\ndef generate_input():\n    # Define the grid size\n    n, m = 10, 10  # Size of the grid\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly fill the grid with colors and create some patterns\n    num_patterns = np.random.randint(3, 6)  # Number of different patterns to create\n\n    for _ in range(num_patterns):\n        # Randomly choose a color for the pattern from the mapping colors\n        color = np.random.choice(list(color_map.keys()))\n        # Random position and size for the pattern\n        x = np.random.randint(0, n - 3)\n        y = np.random.randint(0, m - 3)\n        pattern_height = np.random.randint(2, 5)\n        pattern_width = np.random.randint(2, 5)\n\n        # Draw a rectangular pattern of the chosen color\n        for i in range(pattern_height):\n            for j in range(pattern_width):\n                if x + i \u003c n and y + j \u003c m:  # Ensure we stay within bounds\n                    grid[x + i, y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/209/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/209/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/209/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/209/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/209/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/209/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/209/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/209/images/train_output_2.png"}]}, "index": 209, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color change\n\n# description:\n# In the input, you will see a grid with a yellow object. \n# To make the output grid, you should reflect the yellow object horizontally and change its color to green.\n\ndef main(input_grid):\n    # Find the yellow object in the input grid\n    yellow_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n    assert len(yellow_objects) == 1  # There should only be one yellow object\n\n    yellow_object = yellow_objects[0]\n    \n    # Make a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Reflect the yellow object horizontally\n    reflected_object = np.flip(yellow_object, axis=1)\n\n    # Change its color to green\n    reflected_object[reflected_object != Color.BLACK] = Color.GREEN\n\n    # Blit the reflected object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=reflected_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    grid_len = np.random.randint(4, 8)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Generate a yellow object randomly and place it on the grid\n    sprite_width, sprite_height = np.random.randint(1, grid_len), np.random.randint(1, grid_len)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.YELLOW], density=0.5)\n\n    # Find a random free location for the yellow object\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/210/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/210/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/210/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/210/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/210/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/210/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/210/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/210/images/train_output_2.png"}]}, "index": 210, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, color propagation, grid transformations\n\n# description:\n# In the input, there will be a grid with a single colored pixel in the middle. \n# To create the output, draw lines in the direction of the four cardinal points (up, down, left, right) from the colored pixel.\n# Each line should be filled with the color of the pixel until it hits the edge of the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the position of the colored pixel in the middle of the grid.\n    # 2. Draw lines extending from this pixel to the edges of the grid in all four cardinal directions.\n\n    # Find the colored pixel (which is the only non-black pixel)\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    colored_pixel_location = colored_pixel_locations[0]\n    colored_x, colored_y = colored_pixel_location\n\n    # Create the output grid\n    output_grid = input_grid.copy()\n\n    # Draw lines in all four cardinal directions\n    # Up\n    draw_line(output_grid, colored_x, colored_y, direction=(0, -1), color=input_grid[colored_x, colored_y])\n    # Down\n    draw_line(output_grid, colored_x, colored_y, direction=(0, 1), color=input_grid[colored_x, colored_y])\n    # Left\n    draw_line(output_grid, colored_x, colored_y, direction=(-1, 0), color=input_grid[colored_x, colored_y])\n    # Right\n    draw_line(output_grid, colored_x, colored_y, direction=(1, 0), color=input_grid[colored_x, colored_y])\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a random size and a black background\n    width, height = np.random.randint(5, 20, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Place a single colored pixel in the middle\n    color = np.random.choice(Color.NOT_BLACK)\n    input_grid[width // 2, height // 2] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/211/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/211/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/211/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/211/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/211/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/211/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/211/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/211/images/train_output_2.png"}]}, "index": 211, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel blending, radial expansion\n\n# description:\n# In the input, you will see a grid with scattered colored pixels. Each pixel should be expanded radially into a 5x5 square, where the center pixel retains its original color while the surrounding pixels blend into teal.\n# The output will be a grid where each colored pixel in the input has been transformed into a 5x5 square.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Create an output grid initialized to the background (black).\n    # 2. For each colored pixel in the input grid, create a 5x5 square in the output grid, with the center pixel retaining its color while the surrounding pixels gradually blend into teal.\n\n    output_grid = np.full(input_grid.shape, Color.BLACK, dtype=int)\n    square_size = 5\n    radius = square_size // 2\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] != Color.BLACK:  # If pixel is colored\n                # Create a 5x5 square in the output grid\n                for dx in range(-radius, radius + 1):\n                    for dy in range(-radius, radius + 1):\n                        if 0 \u003c= x + dx \u003c output_grid.shape[0] and 0 \u003c= y + dy \u003c output_grid.shape[1]:\n                            # Calculate the distance from the center\n                            dist = max(abs(dx), abs(dy))\n                            # Blend the color with teal based on distance\n                            if dist == 0:\n                                output_grid[x + dx, y + dy] = input_grid[x, y]  # Retain original color\n                            else:\n                                # Blend towards teal; the more distant, the more teal\n                                blend_ratio = 1 - (dist / radius)\n                                if blend_ratio \u003e 0:\n                                    # We will use a simple method: if blend_ratio is 0.5, we assume a mix of 50% original color and 50% teal.\n                                    # This is simplified to just setting it to teal for outer pixels.\n                                    output_grid[x + dx, y + dy] = Color.TEAL if dist \u003e 1 else input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid with size of n x m.\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Randomly scatter color pixels on the grid.\n    avaliable_colors = [c for c in Color.NOT_BLACK]\n    density = 0.2  # Density of colored pixels\n\n    # Randomly place colored pixels with given density\n    for x in range(n):\n        for y in range(m):\n            if np.random.rand() \u003c density:\n                grid[x, y] = np.random.choice(avaliable_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/212/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/212/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/212/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/212/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/212/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/212/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/212/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/212/images/train_output_2.png"}]}, "index": 212, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pattern extraction\n\n# description:\n# In the input you will see a grid containing several patterns. \n# The task is to find the patterns that are symmetric along the vertical axis, \n# and then extract and replicate these patterns in the output grid.\n\ndef main(input_grid):\n    # Create an empty output grid\n    output_height, output_width = input_grid.shape\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Find all connected components (patterns) in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Check each component for vertical symmetry\n    for component in components:\n        # Get the bounding box of the component\n        x, y, w, h = bounding_box(component)\n        cropped_component = crop(component)\n\n        # Check for vertical symmetry\n        if np.array_equal(cropped_component, np.fliplr(cropped_component)):\n            # If it\u0027s symmetric, blit it onto the output grid\n            blit_sprite(output_grid, cropped_component, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 2D grid with random dimensions\n    height, width = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly create some patterns in the grid\n    num_patterns = np.random.randint(2, 6)\n    for _ in range(num_patterns):\n        # Generate random pattern dimensions\n        pattern_height = np.random.randint(3, 6)\n        pattern_width = np.random.randint(3, 6)\n\n        # Create a random sprite with or without symmetry\n        sprite = random_sprite(n=pattern_height, m=pattern_width, \n                               color_palette=list(Color.NOT_BLACK), \n                               symmetry=np.random.choice([None, \u0027vertical\u0027]))\n        \n        # Determine a random position to place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/213/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/213/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/213/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/213/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/213/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/213/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/213/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/213/images/train_output_2.png"}]}, "index": 213, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape merging, color blending\n\n# description:\n# In the input you will see multiple shapes of various colors. The shapes can overlap, and they can be of different sizes and colors.\n# To make the output, blend the colors of overlapping shapes together, and merge the shapes into a single shape per color.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    \n    # Find all connected components that are non-black (the shapes)\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # A dictionary to hold merged colors\n    merged_colors = {}\n\n    for obj in objects:\n        # Get the color of the current object\n        color = obj[obj != Color.BLACK][0]  # Assuming monochromatic objects\n        mask = (obj != Color.BLACK)\n\n        # If this color is not in the merged_colors, initialize it\n        if color not in merged_colors:\n            merged_colors[color] = np.zeros_like(output_grid)\n\n        # Merge the current object into the corresponding merged color\n        merged_colors[color] = np.logical_or(merged_colors[color], mask)\n\n    # Now we need to fill the output grid with the merged shapes\n    for color, mask in merged_colors.items():\n        output_grid[mask] = color  # Fill the output grid with the color of the merged shape\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of shapes (between 3 and 6)\n    num_shapes = np.random.randint(3, 7)\n    colors = list(Color.NOT_BLACK)  # All colors except black\n\n    for _ in range(num_shapes):\n        # Random dimensions for the shape\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n\n        # Generate a random shape\n        shape = random_sprite(w, h, color_palette=colors, density=0.5, symmetry=\"not_symmetric\")\n\n        # Randomly place the shape on the grid\n        x, y = random_free_location_for_sprite(grid, shape, padding=1, border_size=1)\n        blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/214/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/214/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/214/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/214/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/214/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/214/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/214/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/214/images/train_output_2.png"}]}, "index": 214, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color connection, border tracing\n\n# description:\n# In the input, you will see a grid with a few colored pixels on its borders. To make the output, \n# draw a line that connects all the border pixels in the order they appear, starting from the top left and going clockwise. \n# The line should change color to match each pixel it passes.\n\ndef main(input_grid):\n    # Create an output grid initialized with the background color\n    output_grid = np.copy(input_grid)\n    \n    # Find the coordinates of all border pixels\n    border_pixels = []\n\n    # Check top and bottom rows\n    for col in range(input_grid.shape[1]):\n        if input_grid[0, col] != Color.BLACK:\n            border_pixels.append((0, col))\n        if input_grid[input_grid.shape[0] - 1, col] != Color.BLACK:\n            border_pixels.append((input_grid.shape[0] - 1, col))\n\n    # Check left and right columns (excluding corners already included)\n    for row in range(1, input_grid.shape[0] - 1):\n        if input_grid[row, 0] != Color.BLACK:\n            border_pixels.append((row, 0))\n        if input_grid[row, input_grid.shape[1] - 1] != Color.BLACK:\n            border_pixels.append((row, input_grid.shape[1] - 1))\n\n    # Draw lines connecting the border pixels in the order they were found\n    for i in range(len(border_pixels) - 1):\n        start_x, start_y = border_pixels[i]\n        end_x, end_y = border_pixels[i + 1]\n        draw_line(output_grid, start_x, start_y, end_x=end_x, end_y=end_y, color=input_grid[start_x, start_y])\n\n    # Also connect the last border pixel to the first to close the loop\n    start_x, start_y = border_pixels[-1]\n    end_x, end_y = border_pixels[0]\n    draw_line(output_grid, start_x, start_y, end_x=end_x, end_y=end_y, color=input_grid[start_x, start_y])\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place colored pixels on the borders\n    colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(4, 8), replace=False)\n\n    # Place colors on the top and bottom rows\n    for col in range(m):\n        if np.random.rand() \u003c 0.3:  # 30% chance to place a color\n            grid[0, col] = np.random.choice(colors)\n        if np.random.rand() \u003c 0.3:\n            grid[n - 1, col] = np.random.choice(colors)\n\n    # Place colors on the left and right columns (excluding corners)\n    for row in range(1, n - 1):\n        if np.random.rand() \u003c 0.3:\n            grid[row, 0] = np.random.choice(colors)\n        if np.random.rand() \u003c 0.3:\n            grid[row, m - 1] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/215/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/215/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/215/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/215/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/215/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/215/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/215/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/215/images/train_output_2.png"}]}, "index": 215, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color matching\n\n# description:\n# In the input you will see several patterned objects and a colored pixel. \n# To make the output, rotate each patterned object 90 degrees clockwise and change its color to match the colored pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the patterned objects and the colored pixel.\n    # 2. For each patterned object, rotate it 90 degrees clockwise.\n    # 3. Change the color of the rotated object to match the color of the identified pixel.\n    # 4. Blit the transformed objects onto the output grid.\n\n    # Extract objects and pixels\n    connected_components = find_connected_components(input_grid, monochromatic=False)\n    objects = [cc for cc in connected_components if np.count_nonzero(cc != Color.BLACK) \u003e 4]\n    pixels = [cc for cc in connected_components if np.count_nonzero(cc != Color.BLACK) == 1]\n\n    # If there are no pixels to match, return the input grid as is\n    if not pixels:\n        return input_grid\n\n    # Assume we take the first pixel found (as per the problem description)\n    pixel_color = object_colors(pixels[0])[0]\n\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for obj in objects:\n        # Rotate 90 degrees clockwise\n        rotated_obj = np.rot90(obj, k=-1)\n        \n        # Change color to match the pixel color\n        recolored_obj = np.copy(rotated_obj)\n        recolored_obj[recolored_obj != Color.BLACK] = pixel_color\n\n        # Determine position to blit the recolored object\n        obj_x, obj_y = object_position(obj, background=Color.BLACK)\n        blit_sprite(output_grid, recolored_obj, obj_x, obj_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with random patterned objects and a colored pixel\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create random patterned objects\n    num_objects = np.random.randint(1, 4)\n    for _ in range(num_objects):\n        sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=Color.NOT_BLACK, density=0.5)\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    # Add a colored pixel\n    pixel_color = np.random.choice(Color.NOT_BLACK)\n    pixel_position = np.random.randint(0, width), np.random.randint(0, height)\n    grid[pixel_position] = pixel_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/216/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/216/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/216/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/216/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/216/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/216/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/216/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/216/images/train_output_2.png"}]}, "index": 216, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pattern matching\n\n# description:\n# In the input, you will see a grid with a specific pattern (like a square or rectangle). \n# To make the output, invert the colors of the pattern and match it according to a given correspondence.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components to identify the pattern\n    components = find_connected_components(input_grid, background=Color.BLACK)\n    \n    # We assume there is only one pattern that needs to be inverted and matched\n    assert len(components) == 1, \"Exactly one pattern expected\"\n    pattern = components[0]\n\n    # Invert the colors of the pattern\n    inverted_pattern = np.vectorize(lambda color: invert_color(color))(pattern)\n\n    # Get the position of the pattern in the original grid\n    x_pattern, y_pattern = object_position(pattern)\n\n    # Place the inverted pattern back into the output grid\n    for x in range(pattern.shape[0]):\n        for y in range(pattern.shape[1]):\n            if pattern[x, y] != Color.BLACK:  # Only modify the non-background pixels\n                output_grid[x_pattern + x, y_pattern + y] = inverted_pattern[x, y]\n\n    return output_grid\n\ndef invert_color(color):\n    # Define the inversion mapping\n    inversion_map = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.RED,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE,\n        Color.PINK: Color.TEAL,\n        Color.TEAL: Color.PINK,\n        Color.ORANGE: Color.MAROON,\n        Color.MAROON: Color.ORANGE,\n        Color.GREY: Color.GREY,\n        Color.BLACK: Color.BLACK,\n    }\n    return inversion_map.get(color, color)  # Default to the original color if not found\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate grid dimensions\n    width, height = np.random.randint(8, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate a random pattern size\n    pattern_width, pattern_height = np.random.randint(3, 6, size=2)\n\n    # Randomly select a color for the pattern that\u0027s not black\n    pattern_color = random.choice(Color.NOT_BLACK)\n\n    # Create a random pattern in a subgrid\n    pattern = np.full((pattern_width, pattern_height), pattern_color)\n\n    # Randomly determine where to place the pattern in the grid\n    x_position = np.random.randint(0, width - pattern_width)\n    y_position = np.random.randint(0, height - pattern_height)\n\n    # Place the pattern in the grid\n    blit_sprite(grid, pattern, x=x_position, y=y_position)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/217/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/217/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/217/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/217/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/217/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/217/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/217/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/217/images/train_output_2.png"}]}, "index": 217, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirror, symmetry, tiling\n\n# description:\n# In the input, you will see a pattern on the left side of the grid. To make the output, mirror the pattern to the right side of the grid and tile the output vertically by duplicating the mirrored pattern below the original input pattern.\n\ndef main(input_grid):\n    # Create output grid dimensions\n    input_height, input_width = input_grid.shape\n    output_height = input_height * 2\n    output_width = input_width * 2\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Place the original input pattern in the output grid\n    blit_sprite(output_grid, input_grid, x=0, y=0)\n\n    # Mirror the input grid to the right\n    mirrored_input = np.fliplr(input_grid)\n    blit_sprite(output_grid, mirrored_input, x=input_width, y=0)\n\n    # Tile the original input pattern below\n    blit_sprite(output_grid, input_grid, x=0, y=input_height)\n\n    # Tile the mirrored pattern below\n    blit_sprite(output_grid, mirrored_input, x=input_width, y=input_height)\n\n    return output_grid\n\ndef generate_input():\n    # Randomly select pattern width and height\n    width = np.random.randint(3, 6)\n    height = np.random.randint(3, 6)\n\n    # Create a grid with a black background\n    grid = np.full((height, width), Color.BLACK)\n\n    # Draw a random pattern on the left side of the grid\n    color = np.random.choice(Color.NOT_BLACK)\n    for y in range(height):\n        for x in range(width):\n            if np.random.rand() \u003e 0.5:  # Randomly decide whether to color the pixel\n                grid[y, x] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/218/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/218/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/218/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/218/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/218/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/218/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/218/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/218/images/train_output_2.png"}]}, "index": 218, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, frequency analysis\n\n# description:\n# In the input, you will see a grid filled with different colored pixels. Each color represents a different object. \n# To make the output, find the most frequently occurring color in the grid and paint all pixels that are not this color with black. \n# The output should only show the pixels of the most frequent color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a blank grid to store the output.\n    # 2. Count the frequency of each color in the input grid.\n    # 3. Identify the most frequently occurring color.\n    # 4. Fill the output grid with the most frequent color, while others are set to black.\n\n    output_grid = np.zeros_like(input_grid)\n\n    # 2. Count the frequency of each color\n    color_counts = {color: np.count_nonzero(input_grid == color) for color in Color.NOT_BLACK}\n    \n    # 3. Identify the most frequently occurring color\n    most_frequent_color = max(color_counts, key=color_counts.get)\n\n    # 4. Fill the output grid\n    output_grid[input_grid == most_frequent_color] = most_frequent_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a black grid as a background.\n    # 2. Randomly choose a number of colors to fill the grid.\n    # 3. Randomly fill portions of the grid with these colors ensuring that at least one color is more frequent.\n\n    n, m = 10, 10  # dimensions of the grid\n    grid = np.zeros((n, m), dtype=int)\n\n    num_colors = np.random.randint(3, 7)  # number of distinct colors to use\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    # Randomly fill the grid while ensuring one color is more frequent\n    for _ in range(np.random.randint(10, 30)):  # number of colored pixels\n        color = np.random.choice(colors)\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n    \n    # Ensure at least one color is more frequent\n    frequent_color = np.random.choice(colors)\n    for _ in range(np.random.randint(5, 15)):  # additional pixels for the frequent color\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = frequent_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/219/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/219/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/219/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/219/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/219/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/219/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/219/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/219/images/train_output_2.png"}]}, "index": 219, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object splitting, color correspondence\n\n# description:\n# In the input you will see an 8x8 grid with a 4x4 blue sprite and a 2x2 sprite with 4 different colors separated by two orange lines.\n# To make the output grid, you should separate the 4x4 blue sprite into 4 2x2 sub-sprites and color them with the 4 different colors in the 2x2 sprite, with the same relative position.\n\ndef main(input_grid):\n    # Detect the color guide and blue pattern separated by orange lines.\n    sub_grids = find_connected_components(grid=input_grid, connectivity=4, monochromatic=False, background=Color.ORANGE)\n\n    # Initialize variables to store the found sprites\n    blue_pattern = None\n    color_guide = None\n\n    for sub_grid in sub_grids:\n        cropped_sub_grid = crop(grid=sub_grid, background=Color.ORANGE)\n\n        # Identify color guide and blue pattern\n        if np.all(cropped_sub_grid != Color.BLACK) and np.all(cropped_sub_grid != Color.BLUE):\n            color_guide = cropped_sub_grid\n        elif np.any(cropped_sub_grid == Color.BLUE):\n            blue_pattern = cropped_sub_grid\n\n    # Get dimensions to split the blue pattern into four 2x2 sections\n    width_blue, height_blue = blue_pattern.shape\n    width_blue_half, height_blue_half = width_blue // 2, height_blue // 2\n\n    # Color each 2x2 sub-sprite with the corresponding color from the color guide\n    blue_pattern[0:width_blue_half, 0:height_blue_half][blue_pattern[0:width_blue_half, 0:height_blue_half] == Color.BLUE] = color_guide[0, 0]\n    blue_pattern[width_blue_half:width_blue, 0:height_blue_half][blue_pattern[width_blue_half:width_blue, 0:height_blue_half] == Color.BLUE] = color_guide[1, 0]\n    blue_pattern[0:width_blue_half, height_blue_half:height_blue][blue_pattern[0:width_blue_half, height_blue_half:height_blue] == Color.BLUE] = color_guide[0, 1]\n    blue_pattern[width_blue_half:width_blue, height_blue_half:height_blue][blue_pattern[width_blue_half:width_blue, height_blue_half:height_blue] == Color.BLUE] = color_guide[1, 1]\n\n    output_grid = blue_pattern\n    return output_grid\n\ndef generate_input():\n    # Initialize the 8x8 grid with black color.\n    n, m = 8, 8\n    grid = np.zeros((n, m), dtype=int)\n\n    # Get available colors for the 2x2 sprite.\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.BLUE and c != Color.ORANGE]\n\n    # Generate the 4x4 blue sprite with random pattern.\n    blue_pattern = random_sprite(n=4, m=4, color_palette=[Color.BLUE], density=0.5)\n\n    # Get four different colors for the 2x2 sprite.\n    four_colors = random.sample(available_colors, 4)\n    color_guide = np.array([[four_colors[0], four_colors[1]], [four_colors[2], four_colors[3]]])\n\n    # Place the 4x4 blue sprite and the 2x2 sprite on the input grid.\n    grid = blit_sprite(grid=grid, sprite=blue_pattern, x=2, y=2, background=Color.BLACK)\n    grid = blit_sprite(grid=grid, sprite=color_guide, x=0, y=0, background=Color.BLACK)\n\n    # Place two orange lines that separate the 4x4 blue sprite and the 2x2 sprite.\n    draw_line(grid=grid, color=Color.ORANGE, x=0, y=2, direction=(1, 0))\n    draw_line(grid=grid, color=Color.ORANGE, x=2, y=0, direction=(0, 1))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/220/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/220/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/220/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/220/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/220/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/220/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/220/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/220/images/train_output_2.png"}]}, "index": 220, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input, you will see a square grid filled with various colors. \n# To make the output, rotate the grid 90 degrees clockwise, and change all colors to a specified color.\n\ndef main(input_grid):\n    # Rotate the input grid 90 degrees clockwise\n    rotated_grid = np.rot90(input_grid, k=-1)  # -1 for clockwise rotation\n\n    # Change all colors to a specified new color (for example, Color.YELLOW)\n    new_color = Color.YELLOW\n    output_grid = np.full(rotated_grid.shape, new_color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random square grid of random colors\n    n = np.random.randint(3, 8)  # Size of the square grid\n    grid = random_sprite(n, n, density=1, symmetry=None, color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/221/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/221/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/221/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/221/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/221/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/221/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/221/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/221/images/train_output_2.png"}]}, "index": 221, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, shape recognition\n\n# description:\n# The input consists of a black grid containing a few hollow squares of different colors. \n# Each square can have a varying number of small holes (1-4) within it. \n# To create the output grid, fill in the holes with the color of the square they are within.\n\ndef main(input_grid):\n    # Find the hollow squares using their colors\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Create an output grid to store the result\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # For each colored square, fill its holes with its respective color\n    for obj in objects:\n        # Get the color of the outer square\n        square_color = object_colors(obj, background=Color.BLACK)[0]\n\n        # Crop the object to find its interior (holes)\n        sprite = crop(obj, background=Color.BLACK)\n        \n        # Identify the holes\n        hole_mask = (sprite == Color.BLACK) \u0026 (object_interior(sprite, background=Color.BLACK))\n\n        # Fill in the holes with the square\u0027s color\n        sprite[hole_mask] = square_color\n\n        # Get location of the square to blit the possibly edited sprite back into the grid\n        x, y = object_position(obj, background=Color.BLACK)\n        blit_sprite(output_grid, sprite, x, y)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 10x10 black grid\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Add 2-4 colored squares, each with 1-4 holes\n    num_squares = np.random.randint(2, 5)\n    colors = np.random.choice(Color.NOT_BLACK, num_squares, replace=False)\n\n    for color in colors:\n        # Create a random square size between 3 and 6\n        square_size = np.random.randint(3, 7)\n        square = np.full((square_size, square_size), color)\n\n        try:\n            # Find a free location for the square\n            x, y = random_free_location_for_sprite(grid, square, padding=1)\n        except ValueError:\n            continue  # If a location isn\u0027t found, skip this square\n\n        # Blit the square onto the grid\n        blit(grid, square, x, y)\n\n        # Randomly create holes within the square\n        num_holes = np.random.randint(1, 5)\n        for _ in range(num_holes):\n            hole_size = np.random.randint(1, 3)  # holes of size 1 or 2\n            hole_x = np.random.randint(1, square_size - hole_size - 1)\n            hole_y = np.random.randint(1, square_size - hole_size - 1)\n            square[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK  # make the hole black\n\n        # Blit the modified square back to the grid\n        blit(grid, square, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/222/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/222/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/222/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/222/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/222/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/222/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/222/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/222/images/train_output_2.png"}]}, "index": 222, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# path drawing, obstacle avoidance, color change\n\n# description:\n# In the input, you will see a grid with a colored path and some obstacles. The path consists of consecutive colored pixels. \n# To make the output, change the color of the path pixels to a new color whenever the path meets an obstacle.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    \n    # Define the colors\n    obstacle_color = Color.TEAL\n    path_color = Color.GREEN\n    new_color = Color.MAROON  # New color to change the path to when it meets an obstacle\n\n    # Iterate through each pixel in the grid\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            # If the pixel is part of the path\n            if output_grid[x, y] == path_color:\n                # Check adjacent pixels for obstacles\n                if (x \u003e 0 and output_grid[x-1, y] == obstacle_color) or \\\n                   (x \u003c output_grid.shape[0] - 1 and output_grid[x+1, y] == obstacle_color) or \\\n                   (y \u003e 0 and output_grid[x, y-1] == obstacle_color) or \\\n                   (y \u003c output_grid.shape[1] - 1 and output_grid[x, y+1] == obstacle_color):\n                    output_grid[x, y] = new_color  # Change the path color to new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random dimensions\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter some obstacles on the grid\n    randomly_scatter_points(grid, color=Color.TEAL, density=0.3, background=Color.BLACK)\n\n    # Draw a colored path on the grid, avoiding obstacles\n    path_color = Color.GREEN\n    start_x, start_y = np.random.randint(1, n-1), np.random.randint(1, m-1)\n    \n    # Draw a simple path\n    x, y = start_x, start_y\n    direction = (1, 0)  # Start moving right\n    for _ in range(random.randint(5, 15)):\n        if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m and grid[x, y] != Color.TEAL:\n            grid[x, y] = path_color\n            # Randomly change direction\n            if np.random.rand() \u003c 0.3:\n                direction = (direction[1], direction[0] * -1)  # Change direction (turn right)\n            x += direction[0]\n            y += direction[1]\n        else:\n            break  # Stop if we hit an obstacle\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/223/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/223/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/223/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/223/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/223/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/223/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/223/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/223/images/train_output_2.png"}]}, "index": 223, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color inversion\n\n# description:\n# In the input, you will see a grid with a colored square object at its center.\n# To make the output grid, you should invert the colors of the object (changing each color to its complementary color) and place it at the same position.\n\ndef main(input_grid):\n    # Get the single object in the grid, which is the colored square\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1  # We expect exactly one object\n    colored_object = objects[0]\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Create a color inversion mapping for the 10 colors\n    color_inversion = {\n        Color.BLACK: Color.BLACK,\n        Color.BLUE: Color.YELLOW,\n        Color.RED: Color.GREY,\n        Color.GREEN: Color.MAROON,\n        Color.YELLOW: Color.BLUE,\n        Color.GREY: Color.RED,\n        Color.PINK: Color.GREEN,\n        Color.ORANGE: Color.TEAL,\n        Color.TEAL: Color.ORANGE,\n        Color.MAROON: Color.PINK,\n    }\n\n    # Invert the colors of the object\n    for x in range(colored_object.shape[0]):\n        for y in range(colored_object.shape[1]):\n            if colored_object[x, y] in color_inversion:\n                output_grid[x, y] = color_inversion[colored_object[x, y]]\n\n    # Blit the inverted color object back onto the same position in the output grid\n    x, y = object_position(colored_object, background=Color.BLACK, anchor=\"center\")\n    blit_object(output_grid, output_grid, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size between 5x5 and 10x10\n    grid_size = np.random.randint(5, 11)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Generate a colored square sprite of size between 2x2 and 4x4\n    sprite_size = np.random.randint(2, 5)\n    possible_colors = [color for color in Color.NOT_BLACK]\n    sprite = random_sprite(n=sprite_size, m=sprite_size, color_palette=possible_colors, density=1.0)\n\n    # Place the sprite at the center of the grid\n    start_x = (grid_size - sprite_size) // 2\n    start_y = (grid_size - sprite_size) // 2\n    blit_sprite(grid, sprite, x=start_x, y=start_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/224/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/224/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/224/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/224/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/224/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/224/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/224/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/224/images/train_output_2.png"}]}, "index": 224, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mixing, lines, intersection\n\n# description:\n# In the input, you will see a grid with two colored pixels: one maroon and one yellow. \n# To create the output, draw horizontal and vertical lines of the same colors as the pixels that intersect at the location of the pixels. \n# The intersection of the lines should be a mix of the colors of the intersecting lines, resulting in a red pixel at the intersection point.\n\ndef mix_colors(color1, color2):\n    # This function mixes two colors, given that the colors are represented as strings.\n    # In this puzzle, the mix of maroon and yellow results in red.\n    if {color1, color2} == {Color.MAROON, Color.YELLOW}:\n        return Color.RED\n    return color1  # default to returning one of the colors if not mixed\n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # get the index of the maroon pixel\n    maroon = np.where(input_grid == Color.MAROON)\n    x1, y1 = maroon[0][0], maroon[1][0]\n\n    # get the index of the yellow pixel\n    yellow = np.where(input_grid == Color.YELLOW)\n    x2, y2 = yellow[0][0], yellow[1][0]\n\n    # draw maroon vertical and horizontal lines\n    output_grid[x1, :] = Color.MAROON\n    output_grid[:, y1] = Color.MAROON\n\n    # draw yellow vertical and horizontal lines\n    output_grid[x2, :] = Color.YELLOW\n    output_grid[:, y2] = Color.YELLOW\n\n    # mix colors at the intersection of the lines\n    output_grid[x1, y2] = mix_colors(Color.MAROON, Color.YELLOW)\n    output_grid[x2, y1] = mix_colors(Color.YELLOW, Color.MAROON)\n\n    return output_grid\n\ndef generate_input():\n    # make a square black grid for the background first\n    n = m = np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # put a maroon pixel at a random point on the grid\n    maroon_x, maroon_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[maroon_x, maroon_y] = Color.MAROON\n\n    # put a yellow pixel at a random point on the grid but not in the same row or column as the maroon pixel\n    yellow_x, yellow_y = np.random.randint(0, n), np.random.randint(0, m)\n    while yellow_x == maroon_x or yellow_y == maroon_y:\n        yellow_x, yellow_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[yellow_x, yellow_y] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/225/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/225/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/225/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/225/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/225/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/225/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/225/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/225/images/train_output_2.png"}]}, "index": 225, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color transformation\n\n# description:\n# In the input you will see a monochromatic sprite that is surrounded by a border of a different color.\n# To create the output, reflect the sprite horizontally, then change the color of the entire sprite to match the border color.\n\ndef main(input_grid):\n    # Identify the sprite and its surrounding border\n    background = Color.BLACK\n    border_color = input_grid[0, 0]  # Assuming the border color is in the top-left corner\n    sprite = crop(input_grid, background=background)  # Crop the sprite from the input grid\n\n    # Reflect the sprite horizontally\n    reflected_sprite = sprite[:, ::-1]\n\n    # Change color of the reflected sprite to match the border color\n    reflected_sprite[reflected_sprite != background] = border_color\n\n    # Create the output grid\n    output_grid = input_grid.copy()\n    # Place the reflected sprite back into the output grid at the same position it was cropped from\n    x, y = object_position(sprite, background)\n    blit_sprite(output_grid, reflected_sprite, x, y, background=background)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the grid\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose a border color that is not black\n    border_color = np.random.choice(Color.NOT_BLACK)\n\n    # Draw a border around the grid\n    grid[0, :] = border_color\n    grid[-1, :] = border_color\n    grid[:, 0] = border_color\n    grid[:, -1] = border_color\n\n    # Create a monochromatic sprite in the center of the grid\n    sprite_color = np.random.choice(Color.NOT_BLACK)\n    sprite_size = np.random.randint(3, 6)\n    sprite = random_sprite(sprite_size, sprite_size, color_palette=[sprite_color], density=1.0)\n\n    # Place the sprite in the center of the grid\n    start_x = (width - sprite_size) // 2\n    start_y = (height - sprite_size) // 2\n    blit_sprite(grid, sprite, start_x, start_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/226/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/226/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/226/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/226/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/226/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/226/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/226/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/226/images/train_output_2.png"}]}, "index": 226, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# vertical translation, color transformation\n\n# description:\n# In the input you will see a grid consisting of a green sprite that is repeatedly translated vertically, forming a stack of the same sprite.\n# To make the output, expand the input to have height 10, and continue to repeatedly translate the sprite vertically. Change color to yellow.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the vertical translation of the green sprite.\n    # 2. Extend the grid to a height of 10.\n    # 3. Copy the sprite and its translations into the new grid.\n    # 4. Change the color from green to yellow.\n\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[], background=Color.BLACK)\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # Create the output grid with height 10\n    output_grid = np.full((10, input_grid.shape[1]), Color.BLACK)\n\n    # Copy all of the input pixels to the output, including their symmetric copies\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Compute the orbit into the output grid\n        for x2, y2 in orbit(output_grid, x, y, symmetries):\n            output_grid[x2, y2] = input_grid[x, y]\n    \n    # Change color from green to yellow\n    output_grid[output_grid == Color.GREEN] = Color.YELLOW\n\n    return output_grid\n\n\ndef generate_input():\n    # Grid is always 3x6\n    grid = np.zeros((3, 6), dtype=int)\n\n    # The input is always green\n    color = Color.GREEN\n\n    # Create a random sprite with a height between 2 and 5\n    height = random.randint(2, 5)\n    sprite = random_sprite(3, height, symmetry=\"not_symmetric\", color_palette=[color], density=0.4, connectivity=4)\n\n    # Tile the sprite vertically to create a stack\n    vertically_repeated = np.tile(sprite, (1, 100))  # \"infinitely\" tile\n    vertically_repeated = vertically_repeated[:, :grid.shape[1]]  # Crop to fit the grid\n    grid[:, :] = vertically_repeated  # Fill the grid\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/227/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/227/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/227/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/227/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/227/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/227/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/227/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/227/images/train_output_2.png"}]}, "index": 227, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, pixel mirroring\n\n# description:\n# In the input, you will see a grid consisting of a central pixel block that is surrounded by four differently-colored border pixels. \n# The output should transform the central pixel block\u0027s colors to match the corresponding border pixels.\n# The central block will then be mirrored about both the horizontal and vertical axes to fill the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Define the size of the grid and create an output grid of the same size\n    output_grid = np.copy(input_grid)\n\n    # Crop out the central pattern (assuming the border pixels are all non-black)\n    central_pattern = crop(output_grid)\n\n    # Get the colors of the border pixels\n    top_color = output_grid[0, 1]      # Top border pixel\n    bottom_color = output_grid[-1, 1]  # Bottom border pixel\n    left_color = output_grid[1, 0]     # Left border pixel\n    right_color = output_grid[1, -1]   # Right border pixel\n\n    # Change the color of the central pattern to match the corresponding border pixels\n    central_pattern[central_pattern == Color.BLACK] = Color.BLACK  # Keep background as is\n    central_pattern[:, 0] = left_color    # Left edge\n    central_pattern[:, -1] = right_color   # Right edge\n    central_pattern[0, :] = top_color      # Top edge\n    central_pattern[-1, :] = bottom_color   # Bottom edge\n\n    # Create the output grid with the mirrored patterns\n    mirrored_pattern = np.copy(central_pattern)\n    # Mirror vertically\n    mirrored_pattern = np.vstack([mirrored_pattern, np.flipud(mirrored_pattern)])\n    # Mirror horizontally\n    output_grid = np.hstack([mirrored_pattern, np.fliplr(mirrored_pattern)])\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define random sizes for the grid\n    n, m = random.randint(4, 8), random.randint(4, 8)\n    \n    # Create a blank grid\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate colors for the central pattern and the border pixels\n    border_colors = random.sample(Color.NOT_BLACK, 4)\n\n    # Create a central pattern with random colors\n    central_pattern_size = random.randint(2, min(n, m) - 2)  # Ensure there\u0027s space for borders\n    central_pattern = random_sprite(central_pattern_size, central_pattern_size, density=0.5)\n\n    # Place the central pattern in the grid with borders\n    grid[1:-1, 1:-1] = central_pattern\n\n    # Set the border colors\n    grid[0, 1] = border_colors[0]  # Top border\n    grid[-1, 1] = border_colors[1] # Bottom border\n    grid[1, 0] = border_colors[2]  # Left border\n    grid[1, -1] = border_colors[3] # Right border\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/228/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/228/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/228/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/228/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/228/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/228/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/228/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/228/images/train_output_2.png"}]}, "index": 228, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color shifting, mirroring, symmetry\n\n# description:\n# In the input, you will see a grid with various colors arranged in a symmetric pattern around a center axis.\n# To make the output, you should shift the colors away from the center axis along the axis of symmetry, \n# effectively mirroring and expanding the colors outward.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n    \n    # Create an output grid initialized to the background color\n    output_grid = np.full((height, width), Color.BLACK)\n\n    # Determine the axis of symmetry (horizontal or vertical)\n    if width % 2 == 0:\n        center_x = width // 2\n        for y in range(height):\n            for x in range(center_x):\n                color = input_grid[y, x]\n                if color != Color.BLACK:\n                    output_grid[y, center_x + x] = color\n                    output_grid[y, center_x - 1 - x] = color\n    else:\n        center_x = width // 2\n        for y in range(height):\n            for x in range(center_x + 1):\n                color = input_grid[y, x]\n                if color != Color.BLACK:\n                    output_grid[y, center_x + x] = color\n                    output_grid[y, center_x - x] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly choose the colors to be used\n    num_colors = np.random.randint(2, 5)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    # Fill the grid with colors in a symmetric pattern\n    for y in range(height):\n        for x in range((width + 1) // 2):  # Only fill half to ensure symmetry\n            if np.random.rand() \u003e 0.5:  # Randomly decide whether to fill\n                color = np.random.choice(colors)\n                grid[y, x] = color  # Fill left side\n                grid[y, width - 1 - x] = color  # Fill right side\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/229/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/229/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/229/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/229/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/229/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/229/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/229/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/229/images/train_output_2.png"}]}, "index": 229, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, positioning, color transformation\n\n# description:\n# In the input you will see a grid with a specific pattern of colored pixels.\n# To make the output grid, you should first scale the pattern by a factor of 2,\n# and then change the color of all pixels in the scaled pattern to a new specified color.\n\ndef main(input_grid):\n    # Detect all colored pixels in the input grid\n    pixel_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK,\n                                   monochromatic=True, connectivity=4)\n\n    # Determine the output grid size after scaling\n    output_height = input_grid.shape[0] * 2\n    output_width = input_grid.shape[1] * 2\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Scale each detected pixel and change its color\n    for obj in pixel_objects:\n        # Get the position of each colored pixel\n        x, y = object_position(obj, background=Color.BLACK, anchor=\"upper left\")\n        single_pixel_sprite = crop(obj, background=Color.BLACK)\n\n        # Scale the sprite by 2 times\n        scaled_sprite = scale_sprite(single_pixel_sprite, factor=2)\n\n        # Change the color of the scaled sprite to a new color (e.g., Color.RED)\n        scaled_sprite[scaled_sprite != Color.BLACK] = Color.RED\n\n        # Calculate the new position in the output grid\n        new_x = x * 2\n        new_y = y * 2\n\n        # Place the scaled and color-transformed sprite onto the output grid\n        output_grid = blit_sprite(output_grid, scaled_sprite, x=new_x, y=new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a pattern of colored pixels on a black background\n    grid_size = np.random.randint(5, 10)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly create a pattern in the grid\n    density = 0.3\n    colors = Color.NOT_BLACK\n    for x in range(grid_size):\n        for y in range(grid_size):\n            if np.random.rand() \u003c density:\n                grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/230/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/230/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/230/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/230/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/230/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/230/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/230/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/230/images/train_output_2.png"}]}, "index": 230, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation\n\n# description:\n# In the input, you will see two colored objects of different shapes. \n# The first object will be in blue and the second object in green. \n# To create the output, the first object should be rotated 90 degrees clockwise, \n# while the second object should be rotated 90 degrees counterclockwise. \n# Finally, the colors of the objects in the output should be inverted \n# (blue becomes yellow, green becomes red).\n\ndef main(input_grid):\n    # Create an output grid with the same shape as the input\n    output_grid = np.copy(input_grid)\n\n    # Define colors\n    blue_color = Color.BLUE\n    green_color = Color.GREEN\n    yellow_color = Color.YELLOW\n    red_color = Color.RED\n    background_color = Color.BLACK\n\n    # Find the two objects\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=background_color)\n\n    # Ensure there are exactly two objects\n    assert len(objects) == 2, \"Input must contain exactly two objects.\"\n\n    # Process the first object (blue)\n    first_object = [obj for obj in objects if blue_color in object_colors(obj, background=background_color)][0]\n    first_bbox = bounding_box(first_object, background=background_color)\n    first_sprite = crop(first_object, background=background_color)\n\n    # Rotate the first object by 90 degrees clockwise\n    rotated_first_sprite = np.rot90(first_sprite, k=-1)\n    first_x, first_y, _, _ = first_bbox\n\n    # Place the rotated first object in the output grid\n    blit_sprite(output_grid, sprite=rotated_first_sprite, x=first_x, y=first_y)\n\n    # Process the second object (green)\n    second_object = [obj for obj in objects if green_color in object_colors(obj, background=background_color)][0]\n    second_bbox = bounding_box(second_object, background=background_color)\n    second_sprite = crop(second_object, background=background_color)\n\n    # Rotate the second object by 90 degrees counterclockwise\n    rotated_second_sprite = np.rot90(second_sprite)\n    second_x, second_y, _, _ = second_bbox\n\n    # Place the rotated second object in the output grid\n    blit_sprite(output_grid, sprite=rotated_second_sprite, x=second_x, y=second_y)\n\n    # Color transformation: Blue -\u003e Yellow, Green -\u003e Red\n    output_grid[output_grid == blue_color] = yellow_color\n    output_grid[output_grid == green_color] = red_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a clean grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a blue object\n    blue_sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=[Color.BLUE])\n    x1, y1 = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK)\n    blit_sprite(grid, blue_sprite, x=x1, y=y1)\n\n    # Generate a green object\n    green_sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=[Color.GREEN])\n    x2, y2 = random_free_location_for_sprite(grid, green_sprite, background=Color.BLACK)\n    blit_sprite(grid, green_sprite, x=x2, y=y2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/231/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/231/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/231/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/231/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/231/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/231/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/231/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/231/images/train_output_2.png"}]}, "index": 231, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# containment, color matching, filling\n\n# description:\n# In the input, you will see several colored shapes (triangles and circles) on a black background.\n# Each shape contains a single pixel of a different color. The goal is to fill each shape with the color of the pixel inside it.\n# If a shape\u0027s pixel color is black, it should remain black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    for shape in shapes:\n        # Get the color of the pixel inside the shape\n        pixel_color = shape[shape != Color.BLACK]\n        \n        if len(pixel_color) \u003e 0:\n            # If there is a pixel color, fill the entire shape with that color\n            output_grid[shape != Color.BLACK] = pixel_color[0]  # only one color per shape\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), fill_value=Color.BLACK)\n\n    # Number of shapes to create\n    num_shapes = np.random.randint(3, 6)\n\n    for _ in range(num_shapes):\n        # Randomly choose a shape type (triangle or circle)\n        shape_type = np.random.choice([\u0027circle\u0027, \u0027triangle\u0027])\n        shape_color = np.random.choice(list(Color.NOT_BLACK))\n\n        # Create a random shape\n        if shape_type == \u0027circle\u0027:\n            radius = np.random.randint(1, 4)\n            center_x, center_y = np.random.randint(radius, n - radius), np.random.randint(radius, m - radius)\n            for x in range(center_x - radius, center_x + radius + 1):\n                for y in range(center_y - radius, center_y + radius + 1):\n                    if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                        grid[x, y] = shape_color\n            # Place a pixel inside the circle\n            grid[center_x, center_y] = np.random.choice(list(Color.NOT_BLACK))\n\n        elif shape_type == \u0027triangle\u0027:\n            height = np.random.randint(3, 6)\n            base_width = height * 2\n            start_x = np.random.randint(1, n - height - 1)\n            start_y = np.random.randint(1, m - base_width - 1)\n\n            # Draw triangle\n            for h in range(height):\n                for w in range(-h, h + 1):\n                    grid[start_x + h, start_y + w] = shape_color\n            \n            # Place a pixel inside the triangle\n            grid[start_x + height // 2, start_y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/232/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/232/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/232/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/232/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/232/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/232/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/232/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/232/images/train_output_2.png"}]}, "index": 232, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, scaling, color change\n\n# description:\n# In the input you will see a multicolored object with a distinctive shape. \n# To make the output, rotate the object by 90 degrees clockwise, upscale it by a factor of 2, \n# and change all blue pixels to green.\n\ndef main(input_grid):\n    # Step 1: Rotate the grid 90 degrees clockwise\n    rotated_grid = np.rot90(input_grid, -1)\n\n    # Step 2: Create a new grid with double the size of the rotated grid\n    output_grid = np.full((rotated_grid.shape[0] * 2, rotated_grid.shape[1] * 2), Color.BLACK)\n\n    # Step 3: Upscale the rotated grid by a factor of 2\n    for x in range(rotated_grid.shape[0]):\n        for y in range(rotated_grid.shape[1]):\n            color = rotated_grid[x, y]\n            # Fill a 2x2 area in the output grid\n            output_grid[x*2, y*2] = color\n            output_grid[x*2 + 1, y*2] = color\n            output_grid[x*2, y*2 + 1] = color\n            output_grid[x*2 + 1, y*2 + 1] = color\n\n    # Step 4: Change all blue pixels to green\n    output_grid[output_grid == Color.BLUE] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Create an empty grid with a random size\n    background = Color.BLACK\n    grid = np.full((random.randint(5, 15), random.randint(5, 15)), background)\n\n    # Generate a multicolored sprite (object) to place in the grid\n    sprite_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK]\n    sprite = random_sprite(random.randint(3, 6), random.randint(3, 6), color_palette=sprite_colors)\n\n    # Place the sprite randomly in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/233/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/233/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/233/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/233/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/233/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/233/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/233/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/233/images/train_output_2.png"}]}, "index": 233, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color alternation, horizontal lines, vertical lines\n\n# description:\n# In the input, you will see a grid with two colored pixels at the top left corner.\n# To make the output, draw horizontal lines alternating in color starting from the top of the grid,\n# and draw vertical lines of the same colors from the pixels downwards.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the two colored pixels.\n    # 2. Draw alternating horizontal lines across the grid.\n    # 3. Draw vertical lines from the two pixels downwards.\n\n    # 1. Identify the two colored pixels\n    background = Color.BLACK\n    pixels = find_connected_components(input_grid, monochromatic=True, background=background)\n\n    # Ensure we have exactly two pixels\n    if len(pixels) != 2:\n        raise ValueError(\"Input must contain exactly two colored pixels.\")\n\n    # Sort the pixels by their y-coordinate (top to bottom)\n    pixels.sort(key=lambda obj: object_position(obj, background=background)[1])\n\n    # Get the colors of the pixels\n    color1 = object_colors(pixels[0], background=background)[0]\n    color2 = object_colors(pixels[1], background=background)[0]\n\n    # Create the output grid\n    output_grid = np.full_like(input_grid, background)\n\n    # 2. Draw alternating horizontal lines\n    for y in range(output_grid.shape[1]):\n        color_to_draw = color1 if y % 2 == 0 else color2\n        draw_line(output_grid, x=0, y=y, direction=(1, 0), color=color_to_draw)\n\n    # 3. Draw vertical lines from the two pixels\n    for pixel in pixels:\n        x, y = object_position(pixel, background=background)\n        color = object_colors(pixel, background=background)[0]\n        draw_line(output_grid, x=x, y=y, direction=(0, 1), color=color)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid, ensuring there are exactly two colored pixels in the top left corner\n    width, height = np.random.randint(5, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose two distinct colors\n    colors = np.random.choice(Color.NOT_BLACK, size=2, replace=False)\n\n    # Place the first pixel at the top-left corner\n    grid[0, 0] = colors[0]\n    \n    # Place the second pixel in the next row, ensuring it\u0027s below the first pixel\n    grid[0, 1] = colors[1]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/234/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/234/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/234/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/234/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/234/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/234/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/234/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/234/images/train_output_2.png"}]}, "index": 234, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color mapping\n\n# description:\n# In the input, you will see a grid with a central pattern of different colors, surrounded by a border of black pixels. \n# The task is to identify the central pattern and create an output grid where the central pattern is filled with a \n# single color that matches the most frequent color in the original pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central pattern\n    output_grid = np.copy(input_grid)\n    central_pattern = crop(grid=input_grid, background=Color.BLACK)\n\n    # Find the most frequent color in the central pattern\n    unique, counts = np.unique(central_pattern, return_counts=True)\n    color_count = dict(zip(unique, counts))\n    most_frequent_color = max(color_count, key=color_count.get)\n\n    # Color the central pattern with the most frequent color\n    output_grid[output_grid != Color.BLACK] = most_frequent_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create random dimensions for the central pattern\n    n, m = random.randint(3, 10), random.randint(3, 10)\n\n    # Generate a random central pattern with multiple colors\n    central_colors = random.sample(Color.NOT_BLACK, 3)  # Choose 3 colors for the central pattern\n    central_pattern = random_sprite(n, m, color_palette=central_colors, density=0.5)\n\n    # Create a grid that has a black border around the central pattern\n    grid_size = (n + 2, m + 2)\n    grid = np.full(grid_size, Color.BLACK)\n\n    # Place the central pattern inside the grid\n    blit_sprite(grid=grid, sprite=central_pattern, x=1, y=1)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/235/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/235/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/235/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/235/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/235/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/235/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/235/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/235/images/train_output_2.png"}]}, "index": 235, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, color transformation\n\n# description:\n# In the input grid, you will see colored regions separated by a black background. \n# Each region is defined by its boundary pixels. \n# To produce the output, change the color of the boundary pixels of each region to a specified color, \n# while keeping the interior pixels unchanged.\n\ndef main(input_grid: np.ndarray, boundary_color: str = Color.BLACK) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)  \n\n    # Find all the connected components in the input grid\n    regions = find_connected_components(input_grid, background=boundary_color, monochromatic=False, connectivity=4)\n\n    # For each region, find its boundary and change it to the specified boundary color\n    for region in regions:\n        boundary = object_boundary(region, background=boundary_color)\n        output_grid[boundary] = boundary_color  # Change boundary pixels to specified color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the size of the grid\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate colors for regions\n    colors = np.random.choice(Color.NOT_BLACK, size=3, replace=False)\n\n    # Randomly scatter colored regions in the grid\n    for color in colors:\n        # Create a sprite (a colored region) and place it randomly in the grid\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[color])\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no free location, skip to the next color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/236/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/236/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/236/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/236/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/236/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/236/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/236/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/236/images/train_output_2.png"}]}, "index": 236, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color alteration\n\n# description:\n# In the input grid, you will see a colored object in the center, surrounded by a border of black pixels.\n# To make the output, rotate the colored object 90 degrees clockwise and change its color to blue.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the colored object (it\u0027s the only one in the center).\n    # 2. Rotate the object 90 degrees clockwise.\n    # 3. Change its color to blue.\n    \n    # 1. Find the colored object\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1\n    colored_object = objects[0]\n\n    # Get the color of the object\n    original_color = object_colors(colored_object)[0]\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 2. Rotate the object 90 degrees clockwise\n    rotated_object = np.rot90(colored_object, k=-1)  # k=-1 for clockwise rotation\n\n    # 3. Change its color to blue\n    rotated_object[rotated_object != Color.BLACK] = Color.BLUE\n\n    # Blit the rotated blue object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=rotated_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x n with a colored object in the center\n    grid_len = np.random.randint(4, 10)  # Size of the grid\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Create a colored object\n    object_size = np.random.randint(1, grid_len // 2)  # Size of the object\n    colored_object = random_sprite(n=object_size, m=object_size, color_palette=[Color.RED], density=1.0)\n\n    # Place the object in the center of the grid\n    x = (grid_len - object_size) // 2\n    y = (grid_len - object_size) // 2\n    grid = blit_sprite(grid, colored_object, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/237/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/237/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/237/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/237/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/237/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/237/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/237/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/237/images/train_output_2.png"}]}, "index": 237, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# directional movement, bouncing\n\n# description:\n# In the input you will see a single colored pixel on a black background.\n# To make the output, shoot the colored pixel diagonally down and to the left, having it reflect and bounce off the walls until it exits at the bottom of the grid.\n\ndef main(input_grid):\n    # 1. Find the location of the colored pixel\n    colored_pixel_x, colored_pixel_y = np.argwhere(input_grid != Color.BLACK)[0]\n\n    # 2. Initialize the direction as down and to the left\n    direction = (1, 1)  # dx = 1 (down), dy = 1 (left)\n\n    # Loop until the pixel exits the grid\n    while 0 \u003c= colored_pixel_x \u003c input_grid.shape[0] and 0 \u003c= colored_pixel_y \u003c input_grid.shape[1]:\n        stop_x, stop_y = draw_line(input_grid, colored_pixel_x, colored_pixel_y, direction=direction, color=input_grid[colored_pixel_x, colored_pixel_y])\n        \n        # If the pixel has not moved, we break to avoid infinite loops\n        if stop_x == colored_pixel_x and stop_y == colored_pixel_y:\n            break\n        \n        colored_pixel_x, colored_pixel_y = stop_x, stop_y\n        \n        # Bounce logic: change direction upon hitting the walls\n        if stop_x == input_grid.shape[0] - 1:  # hit bottom wall\n            direction = (-direction[0], direction[1])  # reverse vertical direction\n        if stop_y == 0:  # hit left wall\n            direction = (direction[0], -direction[1])  # reverse horizontal direction\n            \n    return input_grid\n\ndef generate_input():\n    # Create a grid with a single colored pixel\n    width, height = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((width, height), Color.BLACK)\n    # Place the colored pixel randomly in the grid\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/238/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/238/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/238/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/238/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/238/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/238/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/238/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/238/images/train_output_2.png"}]}, "index": 238, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, circles\n\n# description:\n# In the input, you will see a grid with several colored pixels on a black background.\n# To create the output, draw a circle for each colored pixel with a radius of 2 pixels, centered at the location of each colored pixel. \n# The circles should be colored the same as the pixel they are drawn around.\n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # get the coordinates of the colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # draw circles for each colored pixel\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        draw_circle(output_grid, x, y, radius=2, color=color)\n\n    return output_grid\n\ndef draw_circle(grid, center_x, center_y, radius, color):\n    # Draw a circle with the specified radius and color\n    for dx in range(-radius, radius + 1):\n        for dy in range(-radius, radius + 1):\n            if dx**2 + dy**2 \u003c= radius**2:  # Check if the point is within the circle\u0027s radius\n                x, y = center_x + dx, center_y + dy\n                if 0 \u003c= x \u003c grid.shape[0] and 0 \u003c= y \u003c grid.shape[1]:  # Ensure coordinates are within bounds\n                    grid[x, y] = color\n\ndef generate_input():\n    # make a 10x10 black grid for the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # randomly place a number of colored pixels\n    num_pixels = np.random.randint(5, 15)\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/239/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/239/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/239/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/239/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/239/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/239/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/239/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/239/images/train_output_2.png"}]}, "index": 239, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, duplication, grid transformation\n\n# description:\n# In the input you will see a row of colored pixels at the top of the grid.\n# To make the output, rotate this row of pixels 90 degrees clockwise and fill the rest of the grid with the rotated pattern.\n\ndef main(input_grid):\n    # Take the input row of pixels\n    row = input_grid[0, :]\n    \n    # Rotate the row 90 degrees clockwise\n    rotated_pattern = np.array([[row[i]] for i in range(len(row) - 1, -1, -1)])  # Create a column from the row\n    \n    # Create the output grid by duplicating the rotated pattern\n    output_grid = np.full((len(row), len(row)), Color.BLACK)  # Initialize the output grid with black background\n    output_grid[:, 0] = rotated_pattern.flatten()  # Fill the first column with the rotated pattern\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random row of colored pixels at the top of the grid\n    length = np.random.randint(3, 6)  # Random length of the row\n    colors = np.random.choice(Color.NOT_BLACK, size=length, replace=False)  # Random colors for the row\n    \n    # Create the input grid with a single row of colors at the top\n    grid = np.full((length, length), Color.BLACK)  # Create a grid of size length x length filled with black\n    grid[0, :length] = colors  # Fill the first row with the selected colors\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/240/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/240/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/240/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/240/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/240/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/240/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/240/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/240/images/train_output_2.png"}]}, "index": 240, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swap, grid transformation\n\n# description:\n# In the input, you will see a grid made up of two distinct colors arranged in a checkerboard pattern. \n# To create the output, swap the two colors in the entire grid.\n\ndef main(input_grid):\n    # Identify the unique colors present in the input grid\n    unique_colors = np.unique(input_grid)\n    \n    # Ensure there are exactly two distinct colors (excluding black)\n    assert len(unique_colors) == 2, \"Input grid must contain exactly two distinct colors.\"\n    \n    # Create an output grid by swapping the colors\n    output_grid = np.where(input_grid == unique_colors[0], unique_colors[1], unique_colors[0])\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with dimensions 8x8\n    n, m = 8, 8\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define two colors to be used in the checkerboard pattern\n    color1 = np.random.choice(Color.NOT_BLACK)\n    color2 = np.random.choice([c for c in Color.NOT_BLACK if c != color1])\n\n    # Fill the grid with a checkerboard pattern using the two colors\n    for i in range(n):\n        for j in range(m):\n            if (i + j) % 2 == 0:\n                grid[i, j] = color1\n            else:\n                grid[i, j] = color2\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/241/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/241/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/241/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/241/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/241/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/241/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/241/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/241/images/train_output_2.png"}]}, "index": 241, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, color replacement\n\n# description:\n# In the input you will see a grid with several colors. \n# To make the output grid, find the least common color in the grid and replace it with blue \n# while keeping the other colors the same.\n\ndef main(input_grid):\n    # Count the occurrences of each color in the grid\n    unique, counts = np.unique(input_grid, return_counts=True)\n    color_counts = dict(zip(unique, counts))\n\n    # Find the least common color (ignoring the background color)\n    least_common_color = min((color for color in color_counts if color != Color.BLACK), key=color_counts.get)\n\n    # Create output grid by replacing the least common color with blue\n    output_grid = np.where(input_grid == least_common_color, Color.BLUE, input_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random colors\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define possible colors (excluding black)\n    possible_colors = list(Color.ALL_COLORS)\n    possible_colors.remove(Color.BLACK)\n\n    # Randomly fill the grid with colors\n    num_colors = np.random.randint(1, len(possible_colors) + 1)\n    chosen_colors = np.random.choice(possible_colors, size=num_colors, replace=False)\n\n    # Fill the grid with chosen colors ensuring some colors are less frequent\n    for color in chosen_colors:\n        density = np.random.uniform(0.1, 0.4)  # Density of current color\n        num_color_pixels = int(density * n * m)\n        colored = 0\n        while colored \u003c num_color_pixels:\n            x = np.random.randint(0, n)\n            y = np.random.randint(0, m)\n            if grid[x, y] == Color.BLACK:\n                grid[x, y] = color\n                colored += 1\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/242/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/242/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/242/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/242/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/242/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/242/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/242/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/242/images/train_output_2.png"}]}, "index": 242, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, radial pattern generation\n\n# description:\n# In the input you will see a grid with a single colored pixel. \n# To make the output, generate a radial pattern using this color, creating concentric circles filled with that color, and the background should be black.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the single colored pixel\n    # 2. Generate concentric circles centered around that pixel\n\n    # 1. Find the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    colored_pixel_location = colored_pixel_locations[0]\n    center_x, center_y = colored_pixel_location\n\n    # 2. Generate concentric circles\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    radius = 0\n    while radius \u003c min(output_grid.shape) // 2:\n        y_indices, x_indices = np.ogrid[-center_x:output_grid.shape[0]-center_x, -center_y:output_grid.shape[1]-center_y]\n        mask = x_indices**2 + y_indices**2 \u003c= radius**2\n        output_grid[mask] = input_grid[center_x, center_y]\n        radius += 1\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a random size\n    width, height = np.random.randint(5, 30, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Place a single colored pixel in the grid (not black)\n    color = np.random.choice(Color.NOT_BLACK)\n    center_x, center_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    input_grid[center_x, center_y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/243/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/243/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/243/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/243/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/243/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/243/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/243/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/243/images/train_output_2.png"}]}, "index": 243, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# circular pattern generation, color propagation\n\n# description:\n# In the input, you will see a grid with a single colored pixel. \n# To create the output, generate a circular pattern around this pixel, \n# with each layer of the circle alternating colors based on the original pixel\u0027s color.\n# The first layer is the same color, the second layer is black, the third layer is the original color, and so on.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the colored pixel\n    colored_pixels = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, allowed_dimensions=[(1, 1)], monochromatic=True)\n    assert len(colored_pixels) == 1\n    center_pixel = colored_pixels[0]\n\n    # Get the position and color of the center pixel\n    center_x, center_y = object_position(center_pixel, background=Color.BLACK)\n    center_color = object_colors(center_pixel)[0]\n\n    # Create the output grid with a black background\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Create a circular pattern around the pixel\n    radius = 0\n    while True:\n        # Calculate the coordinates for the current radius\n        for dx in range(-radius, radius + 1):\n            for dy in range(-radius, radius + 1):\n                if dx**2 + dy**2 == radius**2:  # Check if it lies on the circle\u0027s circumference\n                    x = center_x + dx\n                    y = center_y + dy\n                    if 0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]:\n                        # Alternate colors based on the radius\n                        output_grid[x, y] = center_color if radius % 2 == 0 else Color.BLACK\n\n        # Break if no more pixels can be drawn (to avoid infinite loop)\n        if radius \u003e output_grid.shape[0] // 2 and radius \u003e output_grid.shape[1] // 2:\n            break\n        radius += 1\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose a color for the pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Place a single colored pixel somewhere in the grid\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/244/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/244/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/244/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/244/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/244/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/244/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/244/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/244/images/train_output_2.png"}]}, "index": 244, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# symmetry, pattern extraction, occlusion\n\n# description:\n# In the input you will see a grid with a symmetrical pattern that is partially occluded by randomly placed colored pixels.\n# To make the output grid, you should extract the symmetrical pattern by removing the occluding pixels and restoring the full symmetry.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find the center of the grid\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n\n    # Crop the grid to find the symmetrical pattern\n    pattern = crop(output_grid)\n    \n    # Create an empty grid for the symmetrical pattern\n    sym_grid = np.full_like(output_grid, Color.BLACK)\n\n    # Restore symmetry by placing the pattern in all quadrants\n    sym_grid[0:pattern.shape[0], 0:pattern.shape[1]] = pattern  # Top-left\n    sym_grid[0:pattern.shape[0], -pattern.shape[1]:] = pattern  # Top-right\n    sym_grid[-pattern.shape[0]:, 0:pattern.shape[1]] = pattern  # Bottom-left\n    sym_grid[-pattern.shape[0]:, -pattern.shape[1]:] = pattern  # Bottom-right\n\n    # Combine the symmetrical grid with the output grid, preserving occluded areas\n    output_grid[(output_grid != Color.BLACK)] = sym_grid[(output_grid != Color.BLACK)]\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define dimensions for the grid\n    n, m = random.randint(8, 12), random.randint(8, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a symmetrical pattern\n    pattern_size = random.randint(2, 5)\n    pattern_color = random.choice(Color.NOT_BLACK)\n    \n    # Create a simple symmetrical pattern\n    pattern = np.full((pattern_size, pattern_size), pattern_color)\n\n    # Randomly rotate the pattern to add variability\n    pattern = np.rot90(pattern, k=random.randint(0, 3))\n\n    # Place this pattern in the center of the grid\n    start_x, start_y = (n - pattern_size) // 2, (m - pattern_size) // 2\n    grid[start_x:start_x + pattern_size, start_y:start_y + pattern_size] = pattern\n\n    # Randomly add occluding pixels around the pattern\n    num_occluding_pixels = random.randint(5, 15)\n    for _ in range(num_occluding_pixels):\n        x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n        # Ensure not to place occluding pixels directly on the pattern\n        while grid[x, y] != Color.BLACK:\n            x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n        grid[x, y] = random.choice(Color.NOT_BLACK)  # Choose a random color for occlusion\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/245/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/245/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/245/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/245/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/245/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/245/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/245/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/245/images/train_output_2.png"}]}, "index": 245, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# coloring, area division\n\n# description:\n# In the input, you will see a grid with several colored shapes. Each shape is made of a single color.\n# The task is to color the shapes based on their area: \n# - shapes with area less than 5 should be colored blue,\n# - shapes with area between 5 and 10 should be colored pink,\n# - shapes with area greater than 10 should be colored red.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all colored shapes in the grid\n    shapes = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n\n    for shape in shapes:\n        # Calculate the area of the shape\n        area = np.sum(shape != Color.BLACK)\n\n        # Determine the new color based on area\n        if area \u003c 5:\n            new_color = Color.BLUE\n        elif 5 \u003c= area \u003c= 10:\n            new_color = Color.PINK\n        else:\n            new_color = Color.RED\n\n        # Color the shape with the new color\n        output_grid[shape != Color.BLACK] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate grid of size n x m\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # The colors for the shapes\n    shape_colors = random.sample(Color.NOT_BLACK, k=5)\n\n    # Randomly scatter shapes of varying sizes\n    for color in shape_colors:\n        # Random shape size\n        area = np.random.randint(1, 15)  # Max area for the shape\n        shape = np.zeros((n, m), dtype=int)\n        \n        # Randomly place a shape that occupies \u0027area\u0027 pixels\n        for _ in range(area):\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            shape[x, y] = color\n\n        # Blend the shape into the grid\n        grid = np.maximum(grid, shape)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/246/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/246/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/246/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/246/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/246/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/246/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/246/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/246/images/train_output_2.png"}]}, "index": 246, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, pattern recognition\n\n# description:\n# In the input, you will see a grid with a specific pattern of colored pixels. \n# To create the output, identify the following patterns:\n# 1. A solid block of teal (4x4) should be transformed into a block of pink.\n# 2. A solid block of yellow (4x4) should be transformed into a block of gray.\n# 3. A solid block of red (4x4) should be transformed into a block of blue.\n# 4. A solid block of green (4x4) should be transformed into a block of maroon.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Define the patterns and their corresponding color transformations\n    color_map = {\n        Color.TEAL: Color.PINK,\n        Color.YELLOW: Color.GRAY,\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.MAROON\n    }\n\n    # Loop through the grid and replace the patterns\n    for x in range(input_grid.shape[0] - 3):\n        for y in range(input_grid.shape[1] - 3):\n            block = input_grid[x:x + 4, y:y + 4]\n            for color, new_color in color_map.items():\n                if np.all(block == color):\n                    output_grid[x:x + 4, y:y + 4] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random colors\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define blocks of colors to place\n    colors_to_place = [Color.TEAL, Color.YELLOW, Color.RED, Color.GREEN]\n    \n    # Randomly place blocks of 4x4 colors\n    for color in colors_to_place:\n        x, y = np.random.randint(0, n - 3), np.random.randint(0, m - 3)\n        grid[x:x + 4, y:y + 4] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/247/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/247/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/247/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/247/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/247/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/247/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/247/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/247/images/train_output_2.png"}]}, "index": 247, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color progression, vertical lines\n\n# description:\n# In the input, you will see a grid with a single colored pixel on the top row.\n# To produce the output, draw vertical lines downward from the top pixel, changing the color along a predetermined progression (red to orange to yellow to green to blue to pink).\n# The output should have the same width as the input grid and extend the color progression down to the bottom.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the pixel from the input grid\n    # 2. Determine the color progression\n    # 3. Draw vertical lines downward from the top pixel, changing color along the progression\n\n    # 1. Extract the pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # 2. Determine the color progression\n    color_progression = [Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.BLUE, Color.PINK]\n    color_index = color_progression.index(pixel_color)\n    \n    # Create output grid\n    output_grid = np.copy(input_grid)\n\n    # 3. Draw vertical lines downward from the pixel\n    width, height = output_grid.shape\n    for y in range(pixel_y, height):\n        # Determine which color to use based on the progression\n        output_grid[pixel_x, y] = color_progression[color_index]\n        color_index = (color_index + 1) % len(color_progression)  # Loop through the colors\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 30, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose one color from the beginning of the progression\n    color = np.random.choice([Color.RED, Color.ORANGE])  # Only choose from the first two colors for variety\n\n    # Randomly place the pixel on the top row of the grid\n    x = np.random.randint(0, width)\n    grid[x, 0] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/248/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/248/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/248/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/248/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/248/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/248/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/248/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/248/images/train_output_2.png"}]}, "index": 248, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, symmetry\n\n# description:\n# In the input, you will see a grid with a single colored row filled with colored pixels.\n# To make the output, replicate this row below itself, mirroring the colors horizontally in the process.\n# The output will contain the original row on top, followed by the mirrored row below.\n\ndef main(input_grid):\n    # Get the original row\n    original_row = input_grid[0, :]\n\n    # Create an output grid\n    output_grid = np.copy(input_grid)\n\n    # Mirror the original row for the second row\n    mirrored_row = original_row[::-1]\n\n    # Fill the second row with the mirrored row\n    output_grid[1, :] = mirrored_row\n\n    return output_grid\n\ndef generate_input():\n    # Decide the length of the row\n    length = np.random.randint(3, 10)\n\n    # Select random colors to fill the row\n    colors = np.random.choice(list(Color.NOT_BLACK), length, replace=True)\n\n    # Create a grid with two rows\n    grid = np.zeros((2, length), dtype=int)\n\n    # Fill the top row with colors\n    grid[0, :] = colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/249/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/249/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/249/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/249/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/249/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/249/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/249/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/249/images/train_output_2.png"}]}, "index": 249, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object detection, translation\n\n# description:\n# In the input you will see a grid with a blue circle. \n# To make the output grid, you should move the blue circle to the center of the grid and change its color to yellow.\n\ndef main(input_grid):\n    # Identify the blue circle in the input grid\n    blue_circle = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=8)\n\n    assert len(blue_circle) == 1, \"There should be exactly one blue circle in the input grid.\"\n    blue_circle = blue_circle[0]\n\n    # Get the dimensions of the input grid\n    grid_height, grid_width = input_grid.shape\n\n    # Calculate the center of the grid\n    center_x, center_y = grid_height // 2, grid_width // 2\n\n    # Get the bounding box of the blue circle\n    x, y, w, h = bounding_box(blue_circle)\n\n    # Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Change the color of the blue circle to yellow\n    blue_circle[blue_circle != Color.BLACK] = Color.YELLOW\n\n    # Translate the blue circle to the center of the output grid\n    translated_circle = translate(blue_circle, x=center_x - (w // 2) - x, y=center_y - (h // 2) - y, background=Color.BLACK)\n\n    # Blit the translated yellow circle onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=translated_circle, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x n, where n is between 5 and 20\n    n = np.random.randint(5, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a blue circle sprite with a random radius (1 to 3)\n    radius = np.random.randint(1, 4)\n    circle_sprite = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n\n    # Fill the circle\n    for x in range(circle_sprite.shape[0]):\n        for y in range(circle_sprite.shape[1]):\n            if (x - radius) ** 2 + (y - radius) ** 2 \u003c= radius ** 2:\n                circle_sprite[x, y] = Color.BLUE\n\n    # Randomly place the circle sprite in the grid\n    try:\n        x, y = random_free_location_for_sprite(grid=grid, sprite=circle_sprite, border_size=1, padding=1)\n        blit_sprite(grid=grid, sprite=circle_sprite, x=x, y=y, background=Color.BLACK)\n    except:\n        return generate_input()  # Retry if there\u0027s no space\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/250/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/250/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/250/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/250/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/250/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/250/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/250/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/250/images/train_output_2.png"}]}, "index": 250, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern generation, outward expansion\n\n# description:\n# In the input you will see a grid with a single colored pixel.\n# To make the output, you should draw a square pattern outward from the pixel:\n# The pattern should expand outward in all four directions, coloring a square of size 3x3 at each step,\n# and it should stop when it reaches the border of the grid.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n\n    # Find the colored pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # Create the output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Draw the square pattern\n    step = 0\n    while True:\n        # Calculate the bounds of the square to be drawn\n        start_x = max(0, pixel_x - step)\n        end_x = min(height, pixel_x + step + 1)\n        start_y = max(0, pixel_y - step)\n        end_y = min(width, pixel_y + step + 1)\n\n        # Fill the square area with the pixel color\n        output_grid[start_x:end_x, start_y:end_y] = pixel_color\n\n        # Check if we reached the grid border\n        if end_x \u003e= height and end_y \u003e= width:\n            break\n        step += 1\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the grid between 5x5 and 20x20\n    length = np.random.randint(5, 20)\n    grid = np.full((length, length), Color.BLACK)\n\n    # Randomly choose a color for the pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the single colored pixel in the grid\n    x, y = np.random.randint(0, length), np.random.randint(0, length)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/251/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/251/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/251/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/251/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/251/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/251/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/251/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/251/images/train_output_2.png"}]}, "index": 251, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel transformation, color cycling, grid manipulation\n\n# description:\n# In the input you will see a grid filled with colored pixels. \n# To create the output grid, you should transform each pixel\u0027s color by cycling it through a predefined sequence: \n# blue -\u003e yellow -\u003e red -\u003e green -\u003e teal -\u003e maroon -\u003e gray -\u003e pink -\u003e orange -\u003e black -\u003e back to blue.\n\ndef main(input_grid):\n    # Define the color cycling sequence\n    color_cycle = [\n        Color.BLUE, Color.YELLOW, Color.RED, Color.GREEN,\n        Color.TEAL, Color.MAROON, Color.GREY, Color.PINK,\n        Color.ORANGE, Color.BLACK\n    ]\n    \n    # Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Create a mapping from color to its next color in the cycle\n    color_map = {color_cycle[i]: color_cycle[(i + 1) % len(color_cycle)] for i in range(len(color_cycle))}\n    \n    # Iterate over each pixel in the input grid\n    width, height = input_grid.shape\n    for x in range(width):\n        for y in range(height):\n            current_color = input_grid[x, y]\n            # Transform the current color to the next color in the cycle if it\u0027s not the background\n            if current_color != Color.BLACK:\n                output_grid[x, y] = color_map.get(current_color, current_color)  # Default to current color if not found\n            else:\n                output_grid[x, y] = Color.BLACK  # Keep background color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with colored pixels\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)  # Start with a black background\n\n    # Randomly decide the number of colored pixels\n    num_pixels = np.random.randint(5, 15)  # Generate between 5 to 15 colored pixels\n\n    # Randomly place the colored pixels in the grid\n    available_colors = Color.NOT_BLACK\n    for _ in range(num_pixels):\n        color = np.random.choice(available_colors)\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/252/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/252/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/252/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/252/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/252/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/252/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/252/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/252/images/train_output_2.png"}]}, "index": 252, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel pattern generation, color propagation\n\n# description:\n# In the input you will see a grid with colored pixels, each colored pixel can spread its color to the immediate neighbors (up, down, left, right).\n# To make the output, any pixel that is adjacent to a colored pixel (including diagonally) should take that color, but only if it is currently black.\n# This creates a \"spreading\" effect from the original colored pixels.\n\ndef main(input_grid):\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Loop through each pixel in the grid\n    for x in range(n):\n        for y in range(m):\n            # If the current pixel is colored, spread color to its neighbors\n            if input_grid[x, y] != Color.BLACK:\n                # Define the neighbors\u0027 coordinates\n                neighbors = [(x + dx, y + dy) for dx in (-1, 0, 1) for dy in (-1, 0, 1) if (dx != 0 or dy != 0)]\n                \n                for nx, ny in neighbors:\n                    # Check if the neighbor is within bounds\n                    if 0 \u003c= nx \u003c n and 0 \u003c= ny \u003c m:\n                        # If the neighbor is black, change its color to the current pixel\u0027s color\n                        if output_grid[nx, ny] == Color.BLACK:\n                            output_grid[nx, ny] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid of size n x m.\n    n, m = 20, 20\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels on the grid\n    available_colors = [c for c in Color.NOT_BLACK]\n    num_pixels = np.random.randint(5, 15)\n\n    for _ in range(num_pixels):\n        color = np.random.choice(available_colors)\n        pixel_sprite = np.full((1, 1), color)\n        \n        # Find a random free location for the colored pixel\n        try:\n            x, y = random_free_location_for_sprite(grid, pixel_sprite, border_size=0)\n            grid[x, y] = color\n        except ValueError:\n            continue\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/253/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/253/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/253/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/253/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/253/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/253/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/253/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/253/images/train_output_2.png"}]}, "index": 253, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern alteration, color change, alternating pattern\n\n# description:\n# In the input, you will see a grid with alternating red and blue stripes. \n# To create the output, you will change every second red stripe into a green stripe and every second blue stripe into an orange stripe.\n\ndef main(input_grid):\n    # Prepare an output grid that starts as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Loop through each row in the grid\n    for row in range(input_grid.shape[0]):\n        if row % 2 == 0:  # Even indexed rows (0, 2, 4, ...)\n            # Change every second red stripe to green\n            if np.all(input_grid[row] == Color.RED):\n                output_grid[row] = Color.GREEN\n        else:  # Odd indexed rows (1, 3, 5, ...)\n            # Change every second blue stripe to orange\n            if np.all(input_grid[row] == Color.BLUE):\n                output_grid[row] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random height and fixed width\n    height = np.random.randint(5, 15)\n    width = np.random.randint(10, 20)\n    grid = np.zeros((height, width), dtype=int)\n\n    # Fill the grid with alternating red and blue stripes\n    for row in range(height):\n        if row % 2 == 0:\n            grid[row] = Color.RED\n        else:\n            grid[row] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/254/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/254/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/254/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/254/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/254/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/254/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/254/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/254/images/train_output_2.png"}]}, "index": 254, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# object extraction, color counting\n\n# description:\n# In the input, you will see a grid filled with various colored objects scattered on a black background. Each object consists of a single color but may contain a mix of other colors. To make the output, find the object that contains the most unique colors (including the object\u2019s own color) and copy only that object to the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False, connectivity=4)\n\n    # Initialize variables to track the object with the most unique colors\n    max_unique_colors = 0\n    target_object = None\n\n    # Iterate through each object to count unique colors\n    for obj in objects:\n        unique_colors = set(np.unique(obj)) - {Color.BLACK}  # Exclude the background color\n        num_unique_colors = len(unique_colors)\n\n        # Check if this object has more unique colors than previously found\n        if num_unique_colors \u003e max_unique_colors:\n            max_unique_colors = num_unique_colors\n            target_object = obj\n\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # If a target object was found, copy it to the output grid\n    if target_object is not None:\n        blit_object(output_grid, target_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 grid as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of objects in the grid\n    num_objects = random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Randomly determine the dimensions of the object\n        width, height = random.randint(1, 3), random.randint(1, 3)\n        obj_color = random.choice(Color.NOT_BLACK)  # Choose a color that isn\u0027t black\n\n        # Create the object grid\n        object_grid = np.full((width, height), obj_color)\n\n        # Add random additional colors into the object\n        num_extra_colors = random.randint(1, 3)\n        for _ in range(num_extra_colors):\n            extra_color = random.choice([c for c in Color.NOT_BLACK if c != obj_color])\n            # Randomly place the extra color within the object grid\n            x, y = random.randint(0, width-1), random.randint(0, height-1)\n            object_grid[x, y] = extra_color\n\n        # Find a random free location for this object\n        x, y = random_free_location_for_sprite(grid, object_grid, background=Color.BLACK)\n        blit_sprite(grid, object_grid, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/255/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/255/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/255/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/255/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/255/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/255/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/255/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/255/images/train_output_2.png"}]}, "index": 255, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object placement, scaling, color matching\n\n# description:\n# In the input, you will see a small multicolored object and a larger area defined by a border of blue pixels. This area contains scattered colored pixels.\n# To make the output, rescale the small object so that it fits inside the blue bordered area, and translate it to cover as many of the scattered colored pixels as possible, matching colors wherever they overlap.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the blue bordered area and the small object\n    # 2. Rescale the small object to fit inside the blue area\n    # 3. Translate the rescaled object to cover colored pixels inside the blue area\n\n    # 1. Detect the blue bordered area (assumed to be the largest connected component of blue pixels)\n    blue_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n    blue_area = max(blue_objects, key=lambda obj: np.count_nonzero(obj == Color.BLUE))\n\n    # Crop the blue area to determine its bounds\n    x_min, x_max = np.where(blue_area.any(axis=1))[0][[0, -1]]\n    y_min, y_max = np.where(blue_area.any(axis=0))[0][[0, -1]]\n    blue_area_bounds = (x_min, x_max + 1, y_min, y_max + 1)\n\n    # 2. Find the small object (multicolored part) \n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    small_object = max(objects, key=lambda obj: np.count_nonzero(obj != Color.BLACK))\n    small_sprite = crop(small_object, background=Color.BLACK)\n\n    # Determine the size of the blue area\n    blue_area_height, blue_area_width = blue_area_bounds[1] - blue_area_bounds[0], blue_area_bounds[3] - blue_area_bounds[2]\n    \n    # Rescale the small object to fit within the blue area\n    best_sprite = None\n    best_coverage = 0\n    for scale in range(1, min(blue_area_height, blue_area_width) // min(small_sprite.shape) + 1):\n        scaled_sprite = scale_sprite(small_sprite, scale)\n        scaled_height, scaled_width = scaled_sprite.shape\n\n        # Check possible placements of the scaled sprite within blue area bounds\n        for x in range(blue_area_bounds[0], blue_area_bounds[1] - scaled_height + 1):\n            for y in range(blue_area_bounds[2], blue_area_bounds[3] - scaled_width + 1):\n                test_canvas = np.full_like(input_grid, Color.BLACK)\n                blit_sprite(test_canvas, scaled_sprite, x, y)\n\n                # Count the coverage of colored pixels\n                coverage = np.count_nonzero((input_grid != Color.BLACK) \u0026 (test_canvas != Color.BLACK) \u0026 (input_grid == test_canvas))\n                \n                if coverage \u003e best_coverage:\n                    best_coverage = coverage\n                    best_sprite = (x, y, scaled_sprite)\n    \n    # 3. Place the best scaled sprite found\n    if best_sprite:\n        x, y, best_scaled_sprite = best_sprite\n        output_grid = np.full_like(input_grid, Color.BLACK)\n        blit_sprite(output_grid, best_scaled_sprite, x, y)\n\n        # Copy the blue area to the output\n        output_grid[blue_area_bounds[0]:blue_area_bounds[1], blue_area_bounds[2]:blue_area_bounds[3]] = blue_area[blue_area_bounds[0]:blue_area_bounds[1], blue_area_bounds[2]:blue_area_bounds[3]]\n    \n        return output_grid\n\n    return input_grid  # In case no placement was found\n\ndef generate_input():\n    # Create a small multicolored object and a larger blue bordered area\n    background_color = random.choice(Color.NOT_BLACK)\n    \n    # Create the small object\n    small_sprite = random_sprite([2, 3, 4], [2, 3, 4], connectivity=8, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n\n    # Create a larger canvas for the blue area\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((width, height), background_color)\n\n    # Define the blue bordered area\n    border_width = 1\n    blue_border = np.full((width - 2 * border_width, height - 2 * border_width), Color.BLUE)\n    grid[border_width:-border_width, border_width:-border_width] = blue_border\n\n    # Place the small object in a random location\n    x, y = random_free_location_for_sprite(grid, small_sprite, background=background_color)\n    blit_sprite(grid, small_sprite, x, y, background=background_color)\n\n    # Randomly place scattered colored pixels inside the blue area\n    num_colored_pixels = np.random.randint(5, 15)\n    for _ in range(num_colored_pixels):\n        px, py = np.random.randint(border_width, width-border_width), np.random.randint(border_width, height-border_width)\n        grid[px, py] = random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/256/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/256/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/256/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/256/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/256/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/256/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/256/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/256/images/train_output_2.png"}]}, "index": 256, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, color change\n\n# description:\n# In the input you will see a grid with a single green object. \n# To make the output, translate the green object up by three pixels and color it red.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the green object (it\u0027s the only one)\n    # 2. Change its color to red\n    # 3. Translate it upward by 3 pixels\n\n    # Get the single green object\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1\n    green_object = objects[0]\n\n    # Make a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change its color to red\n    green_object[green_object != Color.BLACK] = Color.RED\n\n    # Translate it upward by 3 pixels\n    green_object = translate(green_object, x=0, y=-3, background=Color.BLACK)\n\n    # Blit the red object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=green_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_len = np.random.randint(4, 8)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Randomly generate the green object and place it on the grid.\n    sprite_width, sprite_height = np.random.randint(1, grid_len - 1), np.random.randint(1, grid_len - 1)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.GREEN], density=0.5)\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/257/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/257/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/257/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/257/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/257/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/257/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/257/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/257/images/train_output_2.png"}]}, "index": 257, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, placement, color matching\n\n# description:\n# In the input, you will see several small multicolored objects, and a larger multicolored canvas. \n# To make the output, take each small object and rotate it so that it matches the colors of the larger canvas. \n# After matching the colors, place the small objects on top of the canvas in such a way that they do not overlap and all colors are matched.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the larger canvas and the small objects.\n    # 2. For each small object, generate all possible rotations.\n    # 3. For each rotation, find a valid position on the canvas where the colors match.\n    # 4. Place the small object on the canvas.\n\n    # 1. Separate the canvas from the small objects\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    canvas = max(objects, key=lambda obj: np.count_nonzero(obj != Color.BLACK))  # Assuming the largest object is the canvas\n    small_objects = [obj for obj in objects if obj is not canvas]\n\n    # Initialize the output grid with the canvas\n    output_grid = np.copy(canvas)\n\n    # 2. For each small object, generate rotations\n    for small_object in small_objects:\n        sprite = crop(small_object)\n        sprite_variations = [sprite, np.rot90(sprite), np.rot90(sprite, k=2), np.rot90(sprite, k=3)]\n\n        # 3. Try to place each rotation on the canvas\n        for sprite_variation in sprite_variations:\n            # Check each possible position\n            for x in range(output_grid.shape[0] - sprite_variation.shape[0] + 1):\n                for y in range(output_grid.shape[1] - sprite_variation.shape[1] + 1):\n                    # Check if colors match where the object would be placed\n                    can_place = True\n                    for dx in range(sprite_variation.shape[0]):\n                        for dy in range(sprite_variation.shape[1]):\n                            if sprite_variation[dx, dy] != Color.BLACK:  # Only check non-transparent pixels\n                                if output_grid[x + dx, y + dy] != Color.BLACK and output_grid[x + dx, y + dy] != sprite_variation[dx, dy]:\n                                    can_place = False\n                                    break\n                        if not can_place:\n                            break\n\n                    if can_place:\n                        # Place the object on the canvas\n                        blit_sprite(output_grid, sprite_variation, x, y, background=Color.BLACK)\n                        break  # Break to the next small object once placed\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a larger canvas and a few small objects with colors that can match\n    canvas_width, canvas_height = np.random.randint(15, 30), np.random.randint(15, 30)\n    canvas = random_sprite(canvas_width, canvas_height, density=0.3, color_palette=Color.NOT_BLACK)\n\n    # Create small objects\n    n_small_objects = np.random.randint(2, 5)\n    small_objects = []\n    for _ in range(n_small_objects):\n        small_object = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.5, color_palette=Color.NOT_BLACK)\n        small_objects.append(small_object)\n\n    # Create the input grid\n    input_width, input_height = canvas.shape[0] + 5, canvas.shape[1] + 5  # Slightly larger than the canvas\n    grid = np.full((input_width, input_height), Color.BLACK)\n\n    # Place the canvas in the grid\n    x, y = random_free_location_for_sprite(grid, canvas, padding=1, border_size=1)\n    blit_sprite(grid, canvas, x, y)\n\n    # Place small objects at random positions\n    for small_object in small_objects:\n        x, y = random_free_location_for_sprite(grid, small_object, padding=1, border_size=1)\n        blit_sprite(grid, small_object, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/258/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/258/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/258/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/258/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/258/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/258/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/258/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/258/images/train_output_2.png"}]}, "index": 258, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, rotation, counting\n\n# description:\n# In the input, you will see a 10x10 black grid with a red diagonal line from the top left to the bottom right. The rest of the grid is black. There are H yellow pixels placed randomly in the grid. To create the output, rotate the diagonal line 90 degrees clockwise and change the yellow pixels to blue.\n\ndef main(input_grid):\n    # create an output grid, initially black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # find the coordinates of the yellow pixels\n    yellow_coords = np.argwhere(input_grid == Color.YELLOW)\n\n    # Change yellow pixels to blue\n    for (x, y) in yellow_coords:\n        output_grid[x, y] = Color.BLUE\n\n    # The red diagonal line coordinates\n    for i in range(10):\n        output_grid[i, 9 - i] = Color.RED  # Rotate the diagonal 90 degrees clockwise\n\n    return output_grid\n\ndef generate_input():\n    # create a 10x10 black grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # draw the red diagonal line from top left to bottom right\n    for i in range(10):\n        grid[i, i] = Color.RED\n\n    # randomly add yellow pixels, ensuring they do not overlap with the red diagonal\n    num_yellow = np.random.randint(1, 6)  # Randomly choose how many yellow pixels to place\n    yellow_positions = set()\n\n    while len(yellow_positions) \u003c num_yellow:\n        x = np.random.randint(0, 10)\n        y = np.random.randint(0, 10)\n        if (x, y) not in yellow_positions and (x, y) not in [(i, i) for i in range(10)]:\n            yellow_positions.add((x, y))\n            grid[x, y] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/259/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/259/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/259/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/259/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/259/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/259/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/259/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/259/images/train_output_2.png"}]}, "index": 259, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape recognition, color transformation\n\n# description:\n# In the input grid, each object is formed by a specific color arranged in a certain shape. \n# The goal is to identify objects based on their shape, which is determined by the number of pixels they occupy. \n# If an object has a rectangular shape (width \u00d7 height), it should be colored green if its area is greater than 6 pixels, \n# and orange if its area is 6 pixels or less. \n# For any non-rectangular shapes, color them blue.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (objects) in the input grid\n    objects = find_connected_components(input_grid)\n\n    for obj in objects:\n        # Count the number of pixels in the object\n        num_pixels = np.sum(obj != Color.BLACK)\n        # Get the shape of the object\n        shape = np.argwhere(obj != Color.BLACK)\n        \n        # Check if the object is rectangular\n        if len(shape) \u003e 0:\n            min_x, min_y = np.min(shape, axis=0)\n            max_x, max_y = np.max(shape, axis=0)\n            width = max_x - min_x + 1\n            height = max_y - min_y + 1\n            \n            # Check if it forms a rectangle\n            if num_pixels == width * height:\n                # It\u0027s rectangular\n                if num_pixels \u003e 6:\n                    output_grid[obj != Color.BLACK] = Color.GREEN\n                else:\n                    output_grid[obj != Color.BLACK] = Color.ORANGE\n            else:\n                # It\u0027s not rectangular\n                output_grid[obj != Color.BLACK] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid filled with black\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a number of objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Randomly create either a rectangular or non-rectangular shape\n        if np.random.rand() \u003e 0.5:\n            # Create a rectangular object\n            width = np.random.randint(1, 5)\n            height = np.random.randint(1, 5)\n            sprite = random_sprite(n=height, m=width, density=1, color_palette=[Color.GREY])\n            \n            # Place the object in the grid\n            try:\n                x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n                blit_sprite(grid, sprite, x, y)\n            except ValueError:\n                pass  # If no space, skip placing this object\n        else:\n            # Create a non-rectangular shape\n            sprite = random_sprite(n=np.random.randint(1, 4), m=np.random.randint(1, 4), density=0.5, color_palette=[Color.GREY])\n            try:\n                x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n                blit_sprite(grid, sprite, x, y)\n            except ValueError:\n                pass  # If no space, skip placing this object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/260/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/260/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/260/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/260/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/260/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/260/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/260/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/260/images/train_output_2.png"}]}, "index": 260, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern replication, color transformation\n\n# description:\n# In the input, you will see a grid containing a colored pattern that forms a rectangular shape.\n# The goal is to copy this pattern and replicate it multiple times in a checkerboard manner.\n# Each instance of the pattern should be transformed to a new color based on its row and column position:\n# - If the row index is even, use a blue color for the pattern.\n# - If the row index is odd, use a green color for the pattern.\n# The pattern should be laid out in a grid fashion, filling rows and columns based on the original shape.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Detect the original pattern\n    pattern_objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n    if not pattern_objects:\n        return input_grid  # Return the original grid if no patterns are found\n\n    # Assuming we take the first detected object as the pattern\n    pattern = pattern_objects[0]\n\n    # Get the bounding box of the original pattern\n    x, y, width, height = bounding_box(pattern)\n\n    # Create the output grid\n    output_height = height * 3  # Replicate the pattern 3 times vertically\n    output_width = width * 3     # Replicate the pattern 3 times horizontally\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n    \n    # Fill the output grid with the transformed pattern\n    for row in range(3):\n        for col in range(3):\n            # Determine the color based on the row index\n            current_color = Color.BLUE if row % 2 == 0 else Color.GREEN\n            \n            # Create a new sprite for the current pattern color\n            colored_pattern = np.full_like(pattern, current_color)\n            colored_pattern[pattern != Color.BLACK] = current_color\n            \n            # Calculate the position to place the pattern\n            pattern_x = col * width\n            pattern_y = row * height\n            \n            # Blit the colored pattern into the output grid\n            output_grid = blit_sprite(output_grid, colored_pattern, pattern_x, pattern_y)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random pattern size\n    height, width = np.random.randint(2, 5), np.random.randint(2, 5)\n    pattern_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Create a random pattern\n    pattern = random_sprite(n=height, m=width, density=0.5, color_palette=[pattern_color])\n    \n    # Create an empty grid to place the pattern\n    grid_height, grid_width = height + 2, width + 2\n    grid = np.zeros((grid_height, grid_width), dtype=int)\n    \n    # Place the pattern in the center of the grid\n    grid = blit_sprite(grid, pattern, 1, 1)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/261/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/261/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/261/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/261/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/261/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/261/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/261/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/261/images/train_output_2.png"}]}, "index": 261, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# border detection, filling colors\n\n# description:\n# In the input, you will see a grid with colored pixels and a black background. The outer border of the grid is colored with a specific color (not black).\n# To make the output, identify the color of the border and fill the entire grid (except the border) with that color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # 1. Identify the border color\n    border_color = None\n    \n    # Check the outer border pixels\n    top_row = input_grid[0, :]\n    bottom_row = input_grid[-1, :]\n    left_column = input_grid[:, 0]\n    right_column = input_grid[:, -1]\n    \n    # Collect the border colors\n    border_colors = set(top_row) | set(bottom_row) | set(left_column) | set(right_column)\n    \n    # Remove black from the set of border colors\n    border_colors.discard(Color.BLACK)\n    \n    # There should be exactly one border color\n    if len(border_colors) != 1:\n        raise ValueError(\"There should be exactly one border color.\")\n    \n    border_color = border_colors.pop()\n    \n    # 2. Create the output grid and fill it with the border color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # Fill the inner area with the border color\n    output_grid[1:-1, 1:-1] = border_color\n    \n    # 3. Set the border pixels\n    output_grid[0, :] = border_color\n    output_grid[-1, :] = border_color\n    output_grid[:, 0] = border_color\n    output_grid[:, -1] = border_color\n    \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of size n x m\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define a border color (not black)\n    border_color = random.choice(Color.NOT_BLACK)\n\n    # Set the border pixels\n    grid[0, :] = border_color\n    grid[-1, :] = border_color\n    grid[:, 0] = border_color\n    grid[:, -1] = border_color\n    \n    # Randomly scatter some colored pixels in the inner area (excluding the border)\n    inner_cells = [(i, j) for i in range(1, n-1) for j in range(1, m-1)]\n    random.shuffle(inner_cells)\n\n    # Fill some inner cells with random colors (not black or border color)\n    num_colored_pixels = np.random.randint(5, 15)\n    for _ in range(num_colored_pixels):\n        cell = inner_cells.pop()\n        grid[cell] = random.choice([color for color in Color.NOT_BLACK if color != border_color])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/262/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/262/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/262/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/262/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/262/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/262/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/262/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/262/images/train_output_2.png"}]}, "index": 262, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color shifting\n\n# description:\n# In the input you will see a grid of colored pixels. To make the output, rotate the grid 90 degrees clockwise, \n# and then shift the colors of the rotated grid according to a deterministic rule: \n# each color is replaced by the next color in a specific order, and the last color wraps around to the first.\n\ndef main(input_grid):\n    # Step 1: Rotate the grid 90 degrees clockwise\n    rotated_grid = np.rot90(input_grid, k=-1)  # k=-1 means 90 degrees clockwise\n\n    # Step 2: Create a mapping of colors to their successors\n    color_order = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.ORANGE, \n                   Color.PINK, Color.TEAL, Color.MAROON, Color.GREY, Color.BLACK]\n    \n    color_map = {color: color_order[(i + 1) % len(color_order)] for i, color in enumerate(color_order)}\n\n    # Step 3: Apply the color shifting transformation\n    output_grid = np.copy(rotated_grid)\n    for x in range(rotated_grid.shape[0]):\n        for y in range(rotated_grid.shape[1]):\n            output_grid[x, y] = color_map[rotated_grid[x, y]]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size between 4x4 and 6x6\n    n, m = np.random.randint(4, 7, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors (excluding black)\n    colors = np.random.choice(Color.NOT_BLACK, size=(n, m), replace=True)\n    grid[:, :] = colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/263/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/263/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/263/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/263/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/263/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/263/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/263/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/263/images/train_output_2.png"}]}, "index": 263, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# resizing, color transformation\n\n# description:\n# In the input, you will see a grid containing a single colored square.\n# To create the output, you need to:\n# 1. Resize the square to double its size, maintaining its proportions.\n# 2. Change its color to YELLOW.\n\ndef main(input_grid):\n    # Step 1: Find the square object in the input grid\n    square_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # The output grid is initialized with the same size as the input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    for square_obj in square_objects:\n        # Get the bounding box of the square\n        x, y, w, h = bounding_box(square_obj)\n\n        # Step 2: Resize the square to double its width and height\n        new_w, new_h = w * 2, h * 2\n        resized_square = np.full((new_h, new_w), Color.YELLOW)\n\n        # Step 3: Place the resized square in the center of the original square\u0027s position\n        upper_left_x = x - (new_w - w) // 2\n        upper_left_y = y - (new_h - h) // 2\n\n        # Blit the resized yellow square onto the output grid\n        blit_sprite(output_grid, resized_square, upper_left_x, upper_left_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width = np.random.randint(5, 15)\n    height = width\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the size of the square\n    square_size = np.random.randint(1, 5)\n    square_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create the square\n    square = np.full((square_size, square_size), square_color)\n\n    # Place the square on the grid\n    try:\n        x, y = random_free_location_for_sprite(grid=grid, sprite=square, background=Color.BLACK, padding=1, padding_connectivity=4, border_size=1)\n    except:\n        # If there is no space, regenerate the input\n        return generate_input()\n\n    blit_sprite(grid, square, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/264/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/264/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/264/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/264/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/264/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/264/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/264/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/264/images/train_output_2.png"}]}, "index": 264, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color correspondence, vertical stacking\n\n# description:\n# In the input, you will see a sequence of three different 3x3 patterns of gray pixels arranged vertically, separated by black intervals.\n# To make the output grid, you need to identify the color corresponding to each pattern: orange, blue, and red, \n# and color the corresponding column in the output grid with the corresponding color in the order from top to bottom.\n\ndef main(input_grid):\n    # Define the patterns for color correspondence\n    b, g = Color.BLACK, Color.GRAY\n    orange_pattern = np.array([[g, g, g], [g, g, g], [g, g, g]]).transpose()  # Empty 3x3\n    blue_pattern = np.array([[g, g, g], [g, b, b], [g, b, b]]).transpose()     # Blue block\n    red_pattern = np.array([[g, g, g], [b, g, b], [g, g, g]]).transpose()   # Red block\n\n    # Detect the 3x3 patterns of gray pixels with vertical arrangement\n    detect_patterns = detect_objects(grid=input_grid, colors=[Color.GRAY], connectivity=8, monochromatic=True)\n\n    # Get the bounding box of each pattern and crop the pattern\n    pattern_lists = []\n    for pattern in detect_patterns:\n        x, y, w, h = bounding_box(grid=pattern, background=Color.BLACK)\n        pattern_shape = crop(grid=pattern, background=Color.BLACK)\n        pattern_lists.append({\u0027x\u0027: x, \u0027y\u0027: y, \u0027pattern\u0027: pattern_shape})\n    pattern_lists = sorted(pattern_lists, key=lambda rec: rec[\u0027y\u0027])\n\n    # Find the corresponding color of each pattern from top to bottom\n    color_list = []\n    for pattern in pattern_lists:\n        cur_pattern = pattern[\u0027pattern\u0027]\n        if np.array_equal(cur_pattern, orange_pattern):\n            color_list.append(Color.ORANGE)\n        elif np.array_equal(cur_pattern, blue_pattern):\n            color_list.append(Color.BLUE)\n        elif np.array_equal(cur_pattern, red_pattern):\n            color_list.append(Color.RED)\n        else:\n            raise ValueError(\"Invalid pattern detected\")\n    column_number = len(color_list)\n\n    # Create the output grid and color the corresponding columns\n    output_grid = np.zeros((column_number, column_number), dtype=int)\n    for cnt, color in enumerate(color_list):\n        draw_line(grid=output_grid, color=color, x=cnt, y=0, direction=(0, 1))\n\n    return output_grid\n\ndef generate_input():\n    # There are three patterns of gray pixels with size 3x3 arranged vertically and separated by black intervals.\n    square_length = 3\n    square_number = 3\n\n    # Create different patterns by placing black pixels on the gray background.\n    b, g = Color.BLACK, Color.GRAY\n    orange_pattern = np.array([[g, g, g], [g, g, g], [g, g, g]]).transpose()  # Empty 3x3\n    blue_pattern = np.array([[g, g, g], [g, b, b], [g, b, b]]).transpose()     # Blue block\n    red_pattern = np.array([[g, g, g], [b, g, b], [g, g, g]]).transpose()   # Red block\n\n    # Calculate the size of the input grid.\n    n = square_length * square_number + square_number - 1\n    m = square_length\n\n    grid = np.zeros((n, m), dtype=int)\n\n    # Assign the color of each pattern.\n    available_colors = [Color.ORANGE, Color.BLUE, Color.RED]\n\n    # Randomly choose the three patterns represented by the given colors on the input grid.\n    color_list = np.random.choice(available_colors, size=square_number, replace=False)\n    \n    # Place the corresponding pattern on the input grid.\n    for square_num, color in enumerate(color_list):\n        y = square_num * (square_length + 1)\n        x = 0\n        # Each pattern corresponds to a different color: orange, blue, or red.\n        if color == Color.ORANGE:\n            grid[y:y+square_length, x:x+square_length] = orange_pattern\n        elif color == Color.BLUE:\n            grid[y:y+square_length, x:x+square_length] = blue_pattern\n        elif color == Color.RED:\n            grid[y:y+square_length, x:x+square_length] = red_pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/265/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/265/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/265/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/265/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/265/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/265/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/265/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/265/images/train_output_2.png"}]}, "index": 265, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation\n\n# description:\n# In the input you will see a grid with several colored objects.\n# To create the output, find all the objects that have an area of 4 and change their color to yellow.\n# All other objects should remain unchanged.\n\ndef main(input_grid):\n    # Extract all connected components from the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Change the color of objects with area 4 to yellow\n    for obj in objects:\n        if np.sum(obj != Color.BLACK) == 4:\n            # Change the color of the object to yellow\n            obj[obj != Color.BLACK] = Color.YELLOW\n            # Blit the modified object back to the output grid\n            output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid initialized with the background color (black)\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Randomly generate objects and place them into the grid until it is filled\n    # We want to ensure that there are some area 4 objects in the grid.\n    area_four_objects = 0\n\n    # First, place a couple of area 4 objects\n    for _ in range(2):\n        while True:\n            obj = random_sprite(2, 2, color_palette=[Color.GREEN])  # 2x2 objects have area 4\n            if np.sum(obj != Color.BLACK) == 4:\n                break\n        x, y = random_free_location_for_sprite(grid, obj, padding=1)\n        grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        area_four_objects += 1\n\n    # Now fill up the remaining space with random objects of varying sizes\n    while True:\n        width, height = np.random.randint(1, 5), np.random.randint(1, 5)\n        obj = random_sprite(width, height, color_palette=[Color.GREEN])\n\n        # Try to place the object. If we can\u0027t, we\u0027re done\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/266/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/266/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/266/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/266/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/266/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/266/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/266/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/266/images/train_output_2.png"}]}, "index": 266, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# tile placement, color matching, rotation\n\n# description:\n# In the input you will see a grid containing a large colored tile with spaces (holes) for smaller colored tiles. There are also scattered smaller colored tiles around the grid.\n# To make the output, place each smaller colored tile into a corresponding hole in the large tile so that the colors match perfectly. You can rotate the smaller tiles to fit them into the holes.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the large tile with holes and the smaller colored tiles\n    # 2. For each smaller tile, find a suitable hole in the large tile where it can fit by matching colors\n    # 3. Rotate the smaller tile as necessary to maximize coverage of the holes\n\n    # 1. Detect the large tile with holes and the smaller colored tiles\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=False)\n    large_tiles = [obj for obj in objects if np.count_nonzero(obj != Color.BLACK) \u003e 9]  # assume large tile is significantly larger\n    small_tiles = [obj for obj in objects if np.count_nonzero(obj != Color.BLACK) \u003c= 9]  # assume small tiles are smaller\n\n    assert len(large_tiles) == 1, \"There should be exactly one large tile with holes\"\n    large_tile = large_tiles[0]\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Crop to just the large tile\n    large_tile_cropped = crop(large_tile, background=Color.BLACK)\n\n    # 2. For each small tile, try to find a hole in the large tile\n    for small_tile in small_tiles:\n        small_tile_sprite = crop(small_tile, background=Color.BLACK)\n        possible_variations = [small_tile_sprite, \n                               np.rot90(small_tile_sprite), \n                               np.rot90(small_tile_sprite, k=2), \n                               np.rot90(small_tile_sprite, k=3)]\n\n        best_placement = None\n        best_color_matches = -1\n\n        for small_variation in possible_variations:\n            for x in range(large_tile_cropped.shape[0] - small_variation.shape[0] + 1):\n                for y in range(large_tile_cropped.shape[1] - small_variation.shape[1] + 1):\n                    # Test placing the small tile variation in the large tile\n                    test_grid = np.full_like(large_tile_cropped, Color.BLACK)\n                    blit_sprite(test_grid, small_variation, x, y)\n\n                    # Check if the placement matches the colors of the holes in the large tile\n                    color_matches = np.sum((test_grid == large_tile_cropped) \u0026 (large_tile_cropped != Color.BLACK))\n\n                    if color_matches \u003e best_color_matches:\n                        best_color_matches = color_matches\n                        best_placement = (x, y, small_variation)\n\n        if best_placement:\n            x, y, sprite = best_placement\n            blit_sprite(output_grid, sprite, x, y)\n\n    # Finally, copy the large tile with the small tiles placed into it\n    blit_object(output_grid, large_tile_cropped, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a large tile with holes and some smaller tiles\n    # The smaller tiles will be colored in a way that they can match the holes in the large tile.\n\n    # Create a large tile with holes\n    large_tile = random_sprite(10, 10, density=0.5, color_palette=Color.NOT_BLACK)\n    for _ in range(5):  # Create holes\n        x, y = np.random.randint(0, large_tile.shape[0]), np.random.randint(0, large_tile.shape[1])\n        large_tile[x, y] = Color.BLACK  # Make a hole\n\n    # Place the large tile on a blank grid\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Put the large tile onto the canvas\n    x, y = random_free_location_for_sprite(grid, large_tile, background=Color.BLACK)\n    blit_sprite(grid, large_tile, x, y)\n\n    # Generate small tiles that can fit into the holes\n    num_small_tiles = np.random.randint(3, 6)\n    for _ in range(num_small_tiles):\n        small_tile = random_sprite(3, 3, density=1.0, color_palette=Color.NOT_BLACK)\n        # Ensure the small tile has a color that matches the holes in the large tile\n        color_to_match = random.choice(Color.NOT_BLACK)\n        small_tile[np.random.rand(*small_tile.shape) \u003c 0.5] = color_to_match  # Make half the tile match the hole color\n\n        # Randomly place small tile\n        x, y = random_free_location_for_sprite(grid, small_tile, background=Color.BLACK)\n        blit_sprite(grid, small_tile, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/267/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/267/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/267/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/267/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/267/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/267/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/267/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/267/images/train_output_2.png"}]}, "index": 267, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, symmetry\n\n# description:\n# In the input you will see a pattern of colored squares. To make the output, you need to mirror the pattern vertically and horizontally, creating a symmetrical output.\n\ndef main(input_grid):\n    # Step 1: Create the mirrored version of the input grid\n    vertical_mirror = input_grid[:, ::-1]  # Mirror vertically\n    horizontal_mirror = input_grid[::-1, :]  # Mirror horizontally\n    \n    # Step 2: Combine the original, vertical, and horizontal mirrors to form a symmetrical output\n    output_grid = np.concatenate((input_grid, vertical_mirror, horizontal_mirror), axis=0)\n    \n    return output_grid\n\ndef generate_input():\n    # Randomly determine the size of the grid\n    n = np.random.randint(3, 6)  # Height\n    m = np.random.randint(3, 6)  # Width\n    \n    # Create a random sprite with a random color palette (excluding black)\n    grid = random_sprite(n, m, density=0.7, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/268/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/268/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/268/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/268/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/268/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/268/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/268/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/268/images/train_output_2.png"}]}, "index": 268, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, symmetry\n\n# description:\n# In the input, you will see a grid with a symmetric pattern of colored pixels.\n# To make the output, flip the pattern along the vertical axis and change each color to the opposite color on the color wheel.\n\ndef main(input_grid):\n    # The input pattern is symmetric\n    # Reflect the pattern along the vertical axis\n    reflected_pattern = input_grid[:, ::-1]\n    \n    # Create a mapping of colors to their opposite colors on the color wheel\n    color_wheel = [\n        Color.BLACK, Color.BLUE, Color.RED, Color.GREEN,\n        Color.YELLOW, Color.GREY, Color.PINK, Color.ORANGE,\n        Color.TEAL, Color.MAROON\n    ]\n    \n    # Create an opposite color mapping\n    opposite_color_mapping = {color: color_wheel[(i + 5) % len(color_wheel)] for i, color in enumerate(color_wheel)}\n\n    # Transform the reflected pattern to the opposite colors\n    output_grid = np.vectorize(opposite_color_mapping.get)(reflected_pattern)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the pattern, ensuring it\u0027s symmetric\n    n = np.random.randint(3, 8)  # height\n    m = np.random.randint(3, 8)  # width\n    grid = np.full((n, m), Color.BLACK)  # Initialize grid with black\n\n    # Create a symmetric pattern\n    for i in range(n):\n        for j in range(m // 2):\n            color = np.random.choice(Color.NOT_BLACK)\n            grid[i, j] = color\n            grid[i, m - j - 1] = color  # Mirror the color to maintain symmetry\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/269/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/269/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/269/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/269/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/269/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/269/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/269/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/269/images/train_output_2.png"}]}, "index": 269, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# replication, rotation, translation\n\n# description:\n# In the input you will see a grid with an object in the center. \n# To make the output, replicate the object 4 times and rotate each replica by 0, 90, 180, and 270 degrees, \n# arranging them in a 2x2 grid.\n\ndef main(input_grid):\n    # Step 1: Crop the object from the center of the input grid\n    object_sprite = crop(input_grid, background=Color.BLACK)\n\n    # Step 2: Initialize the output grid\n    output_grid_height = object_sprite.shape[0] * 2\n    output_grid_width = object_sprite.shape[1] * 2\n    output_grid = np.zeros((output_grid_height, output_grid_width), dtype=int)\n\n    # Step 3: Define the rotations\n    rotations = [0, 90, 180, 270]  # degrees\n    for i, angle in enumerate(rotations):\n        # Calculate the position in the output grid\n        x_offset = (i % 2) * object_sprite.shape[1]\n        y_offset = (i // 2) * object_sprite.shape[0]\n\n        # Rotate the sprite\n        if angle == 0:\n            rotated_sprite = object_sprite\n        elif angle == 90:\n            rotated_sprite = np.rot90(object_sprite, k=3)  # 90 degrees clockwise\n        elif angle == 180:\n            rotated_sprite = np.rot90(object_sprite, k=2)  # 180 degrees\n        elif angle == 270:\n            rotated_sprite = np.rot90(object_sprite, k=1)  # 270 degrees clockwise\n        \n        # Place the rotated sprite in the output grid\n        output_grid[y_offset:y_offset + rotated_sprite.shape[0], \n                    x_offset:x_offset + rotated_sprite.shape[1]] = rotated_sprite\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid with a random size\n    grid_size = np.random.randint(5, 10)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Create a random object (a sprite) in the center of the grid\n    object_size = np.random.randint(2, 4)  # Size of the object\n    object_sprite = random_sprite(n=object_size, m=object_size, density=1.0)\n\n    # Calculate the center position for the object\n    center_x = grid_size // 2 - object_size // 2\n    center_y = grid_size // 2 - object_size // 2\n\n    # Place the object in the center of the grid\n    blit_sprite(grid, object_sprite, x=center_x, y=center_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/270/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/270/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/270/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/270/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/270/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/270/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/270/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/270/images/train_output_2.png"}]}, "index": 270, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, color swapping\n\n# description:\n# In the input, you will see a grid with several shapes of four different colors. \n# The output grid will have the same shapes, but each color will be swapped with the next color \n# in the sequence: Red -\u003e Blue -\u003e Yellow -\u003e Green -\u003e Red.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n    \n    # Define the color transformation mapping\n    color_mapping = {\n        Color.RED: Color.BLUE,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.GREEN,\n        Color.GREEN: Color.RED\n    }\n    \n    # Find all the objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=Color.BLACK)\n    \n    for obj in objects:\n        # Get the colors in the current object\n        colors_in_object = object_colors(obj, background=Color.BLACK)\n        for color in colors_in_object:\n            if color in color_mapping:\n                # Change the color of the object in the output grid\n                output_grid[obj == color] = color_mapping[color]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define the colors to be used\n    colors = [Color.RED, Color.BLUE, Color.YELLOW, Color.GREEN]\n\n    # Randomly generate a number of shapes\n    for _ in range(np.random.randint(3, 6)):\n        # Create a random sprite shape\n        sprite_width, sprite_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape_color = np.random.choice(colors)\n        sprite = random_sprite(sprite_width, sprite_height, color_palette=[shape_color])\n        \n        # Randomly place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/271/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/271/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/271/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/271/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/271/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/271/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/271/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/271/images/train_output_2.png"}]}, "index": 271, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, size comparison, color matching\n\n# description:\n# In the input, you will see a grid with various colored objects. The task is to identify the largest object of a specific color (e.g., blue) \n# and create a new grid containing only that object, retaining its original size and shape. \n# If no object of the specified color is found, the output grid should be empty.\n\ndef main(input_grid):\n    # Specify the target color to look for\n    target_color = Color.BLUE\n\n    # Detect all objects of the target color\n    colored_objects = detect_objects(grid=input_grid, colors=[target_color], monochromatic=True, connectivity=4)\n\n    # Find the largest object among the detected objects\n    largest_object = None\n    largest_size = 0\n    \n    for obj in colored_objects:\n        size = np.sum(obj == target_color)\n        if size \u003e largest_size:\n            largest_size = size\n            largest_object = obj\n\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # If we found a largest object, blit it into the output grid\n    if largest_object is not None:\n        blit_object(output_grid, largest_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a random size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a few objects with random colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Randomly generate a sprite (3x3 to 5x5) with density of colors\n        sprite_size = np.random.randint(3, 6)\n        sprite = random_sprite(n=sprite_size, m=sprite_size, density=0.5)\n\n        # Randomly assign a color to the object (ensuring at least one is blue)\n        colors = [Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.PINK, Color.ORANGE]\n        # Ensure at least one object is blue\n        if _ == 0:\n            color_choice = Color.BLUE\n        else:\n            color_choice = random.choice(colors)\n\n        # Color the sprite\n        sprite[sprite != Color.BLACK] = color_choice\n\n        # Place the object in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/272/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/272/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/272/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/272/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/272/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/272/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/272/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/272/images/train_output_2.png"}]}, "index": 272, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, shape detection\n\n# description:\n# In the input, you will see a grid populated with various colored shapes (triangles or squares) drawn in green. \n# To produce the output, you should identify the square shapes and change their color to yellow, while the triangle shapes should remain unchanged.\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n    \n    square_color = Color.GREEN\n    new_square_color = Color.YELLOW\n    \n    # Find all connected components (shapes) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n        \n        # Check if the shape is a square (width should be equal to height)\n        if width == height:\n            # Change the color of the square to yellow\n            output_grid[x:x + width, y:y + height] = new_square_color\n            \n    return output_grid\n\ndef generate_input():\n    # Create the background grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    shape_num = np.random.randint(3, 6)  # Number of shapes to draw\n\n    for _ in range(shape_num):\n        shape_type = np.random.choice([\u0027square\u0027, \u0027triangle\u0027])\n        shape_color = Color.GREEN\n\n        if shape_type == \u0027square\u0027:\n            size = np.random.randint(2, 5)\n            square = np.full((size, size), shape_color)\n            x, y = random_free_location_for_sprite(grid, square, padding=1)\n            blit_sprite(grid, square, x=x, y=y)\n        elif shape_type == \u0027triangle\u0027:\n            triangle = np.array([[shape_color, shape_color, shape_color],\n                                 [Color.BLACK, shape_color, Color.BLACK],\n                                 [Color.BLACK, Color.BLACK, Color.BLACK]])\n            x, y = random_free_location_for_sprite(grid, triangle, padding=1)\n            blit_sprite(grid, triangle, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/273/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/273/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/273/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/273/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/273/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/273/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/273/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/273/images/train_output_2.png"}]}, "index": 273, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, resizing, diagonal lines\n\n# description:\n# In the input, you will see a grid with a row of colored blocks on the bottom and the right. \n# There is also a square in the top right that is not touching the other colors.\n# To make the output:\n# 1. Count the number of colors that aren\u0027t black.\n# 2. Enlarge every pixel in the input by a factor of the number of colors.\n# 3. Add diagonal yellow lines coming out of the corners of the square in the top right portion of the grid.\n\ndef main(input_grid):\n    # Step 1: Count the number of colors that aren\u0027t black\n    num_colors = len(set(input_grid.flatten())) - 1  # Subtracting 1 for black\n\n    # Step 2: Enlarge every pixel in the input by a factor of the number of colors\n    output_grid = np.repeat(np.repeat(input_grid, num_colors, axis=0), num_colors, axis=1)\n\n    # Step 3: Find the square in the output grid\n    objects = find_connected_components(output_grid, connectivity=8, monochromatic=False)\n    for obj in objects:\n        # The square is the only object not in the bottom right corner\n        if obj[-1, -1] == Color.BLACK:\n            square = obj\n            break\n    \n    # Find the bounding box of the square\n    x, y, w, h = bounding_box(square)\n\n    # Draw the diagonal yellow lines from the corners of the square\n    draw_line(output_grid, x - 1, y - 1, length=None, color=Color.YELLOW, direction=(-1, -1), stop_at_color=Color.NOT_BLACK)\n    draw_line(output_grid, x + w, y + h, length=None, color=Color.YELLOW, direction=(1, 1), stop_at_color=Color.NOT_BLACK)\n    draw_line(output_grid, x - 1, y + h, length=None, color=Color.YELLOW, direction=(-1, 1), stop_at_color=Color.NOT_BLACK)\n    draw_line(output_grid, x + w, y - 1, length=None, color=Color.YELLOW, direction=(1, -1), stop_at_color=Color.NOT_BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 5x5 black grid for the background\n    n = m = 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Pick the colors for the bottom and right of the grid\n    colors = list(Color.NOT_BLACK)\n\n    # Construct a random sequence of colors for the bottom and right of the grid\n    sequence = []\n    while len(sequence) \u003c 5:\n        # Select a color\n        color = np.random.choice(colors)\n        # Remove the color from the array of remaining colors\n        colors.remove(color)\n        length = np.random.randint(1, 6 - len(sequence))\n        sequence.extend([color] * length)\n\n    # Put the same sequence on the bottom and right of the grid\n    grid[-1, :] = sequence\n    grid[:, -1] = sequence\n\n    # Pick the color of the square\n    square_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Make the square\n    square_sprite = random_sprite(2, 2, density=1, color_palette=[square_color])\n\n    # Put the square on the grid so it doesn\u0027t touch the bottom or right\n    x, y = random_free_location_for_sprite(grid, square_sprite, padding=1)\n    blit_sprite(grid, square_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/274/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/274/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/274/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/274/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/274/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/274/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/274/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/274/images/train_output_2.png"}]}, "index": 274, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern frequency, color mapping\n\n# description:\n# In the input you will see a grid with several patterns of colored pixels.\n# To make the output, find the pattern that repeats the most and color it red, \n# the pattern that repeats the second most and color it blue, and so on, \n# mapping up to 10 colors based on their frequency.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Identify all connected components in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    \n    # Step 2: Count the frequencies of each unique pattern\n    pattern_counts = {}\n    \n    for component in components:\n        # Get the shape of the component\n        shape = component.shape\n        \n        # Convert the component to a tuple (for hashing)\n        pattern_tuple = tuple(component.flatten())\n        \n        # Count the occurrences of each pattern\n        if pattern_tuple in pattern_counts:\n            pattern_counts[pattern_tuple][\u0027count\u0027] += 1\n        else:\n            pattern_counts[pattern_tuple] = {\u0027count\u0027: 1, \u0027shape\u0027: shape}\n    \n    # Step 3: Sort patterns by frequency\n    sorted_patterns = sorted(pattern_counts.items(), key=lambda item: item[1][\u0027count\u0027], reverse=True)\n    \n    # Step 4: Prepare output grid\n    output_grid = np.zeros(input_grid.shape, dtype=int)\n    \n    # Step 5: Define color mapping\n    color_mapping = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, \n                     Color.TEAL, Color.PINK, Color.ORANGE, Color.MAROON, \n                     Color.GREY, Color.BLACK]\n    \n    # Step 6: Color the most frequent patterns in the output grid\n    for index, (pattern_tuple, info) in enumerate(sorted_patterns):\n        if index \u003e= len(color_mapping):\n            break\n        \n        color = color_mapping[index]\n        count = info[\u0027count\u0027]\n        \n        # Create a pattern from the tuple\n        pattern = np.array(pattern_tuple).reshape(info[\u0027shape\u0027])\n        \n        # Draw the colored pattern in the output grid\n        for x in range(input_grid.shape[0] - pattern.shape[0] + 1):\n            for y in range(input_grid.shape[1] - pattern.shape[1] + 1):\n                if np.array_equal(output_grid[x:x + pattern.shape[0], y:y + pattern.shape[1]], np.zeros(pattern.shape)):\n                    output_grid[x:x + pattern.shape[0], y:y + pattern.shape[1]] = pattern\n                    output_grid[x:x + pattern.shape[0], y:y + pattern.shape[1]][pattern \u003e 0] = color\n                    break  # Stop after coloring one instance of this pattern\n            else:\n                continue\n            break\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid with size n x m\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose the number of unique patterns to generate\n    num_patterns = np.random.randint(2, 5)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_patterns, replace=False)\n\n    # Generate random patterns and place them in the grid\n    for color in colors:\n        # Random size for the pattern\n        pattern_size = np.random.randint(2, 5)\n        pattern = random_sprite(pattern_size, pattern_size, density=0.5, color_palette=[color])\n        \n        # Random position to place the pattern\n        x_position = np.random.randint(0, n - pattern_size)\n        y_position = np.random.randint(0, m - pattern_size)\n\n        # Place the pattern into the grid\n        grid = blit_sprite(grid=grid, sprite=pattern, x=x_position, y=y_position, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/275/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/275/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/275/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/275/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/275/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/275/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/275/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/275/images/train_output_2.png"}]}, "index": 275, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, alignment, color matching\n\n# description:\n# In the input you will see a grid with various colored shapes, each shape has a distinct color and occupies a rectangular area.\n# To make the output, rotate each shape 90 degrees clockwise around its center, and then align the shapes so that their colors match in the same grid space.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all distinct shapes in the input grid along with their colors\n    # 2. Rotate each shape 90 degrees clockwise\n    # 3. Create a new output grid and align each rotated shape to match colors in the same grid space\n\n    # 1. Find the objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for obj in objects:\n        # Get the color of the current shape\n        color = object_colors(obj, background=Color.BLACK)[0]\n\n        # Crop the object to get the shape\n        shape = crop(obj, background=Color.BLACK)\n\n        # Rotate the shape 90 degrees clockwise\n        rotated_shape = np.rot90(shape, k=-1)  # k=-1 for 90 degrees clockwise\n\n        # Find the center of the shape to align it\n        center_x, center_y = object_position(obj, background=Color.BLACK, anchor=\u0027center\u0027)\n\n        # Calculate new position to align rotated shape\n        new_x = center_x - rotated_shape.shape[0] // 2\n        new_y = center_y - rotated_shape.shape[1] // 2\n\n        # Blit the rotated shape onto the output grid\n        blit_sprite(output_grid, rotated_shape, new_x, new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with randomly placed rectangular shapes of varying colors.\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_shapes = np.random.randint(3, 7)\n    for _ in range(num_shapes):\n        # Randomly select dimensions for the shape\n        shape_height, shape_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Choose a random free location to place the shape\n        x, y = random_free_location_for_sprite(grid, np.full((shape_height, shape_width), color), background=Color.BLACK)\n\n        # Draw the shape on the grid\n        blit_sprite(grid, np.full((shape_height, shape_width), color), x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/276/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/276/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/276/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/276/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/276/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/276/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/276/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/276/images/train_output_2.png"}]}, "index": 276, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, symmetry, rotation\n\n# description:\n# In the input, you will see a grid containing a set of colored pixels forming a symmetrical pattern.\n# To make the output, create a new grid where the input pattern is rotated 90 degrees clockwise and mirrored along the vertical axis.\n# The colors in the output should maintain their positions relative to the new orientation.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Rotate the input grid 90 degrees clockwise\n    # 2. Mirror the rotated grid along the vertical axis\n\n    # 1. Rotate the grid 90 degrees clockwise\n    rotated_grid = np.rot90(input_grid, k=-1)\n\n    # 2. Mirror the rotated grid along the vertical axis\n    output_grid = np.flip(rotated_grid, axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x n, where n is between 4 and 8\n    n = np.random.randint(4, 9)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Randomly create a symmetrical pattern\n    colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(2, 5), replace=False)\n\n    # Filling the center row and column to ensure symmetry\n    center = n // 2\n    for color in colors:\n        grid[center, np.random.choice(range(n))] = color  # Fill center row\n        grid[np.random.choice(range(n)), center] = color  # Fill center column\n\n    # Optionally fill the corners to enhance the symmetry\n    for color in colors:\n        grid[0, 0] = color\n        grid[0, n - 1] = color\n        grid[n - 1, 0] = color\n        grid[n - 1, n - 1] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/277/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/277/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/277/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/277/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/277/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/277/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/277/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/277/images/train_output_2.png"}]}, "index": 277, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, scaling\n\n# description:\n# In the input you will see a grid with a single colored object. \n# To make the output, rotate the object 90 degrees counterclockwise and then scale it by a factor of 2, filling the empty spaces with black.\n\ndef main(input_grid):\n    # Get the single colored object from the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one object\"\n    \n    # Crop the object to get its sprite representation\n    sprite = crop(objects[0], background=Color.BLACK)\n\n    # Rotate the sprite 90 degrees counterclockwise\n    rotated_sprite = np.rot90(sprite, k=1)\n\n    # Create a new output grid that is large enough to hold the scaled sprite\n    output_height, output_width = rotated_sprite.shape[0] * 2, rotated_sprite.shape[1] * 2\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Scale the rotated sprite by a factor of 2\n    for i in range(rotated_sprite.shape[0]):\n        for j in range(rotated_sprite.shape[1]):\n            color = rotated_sprite[i, j]\n            if color != Color.BLACK:\n                # Place the color in the 2x2 region in the output grid\n                output_grid[i*2, j*2] = color\n                output_grid[i*2, j*2 + 1] = color\n                output_grid[i*2 + 1, j*2] = color\n                output_grid[i*2 + 1, j*2 + 1] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random sprite of size n x m\n    n, m = np.random.randint(3, 6), np.random.randint(3, 6)\n    sprite = random_sprite(n, m, density=0.5, color_palette=Color.NOT_BLACK)\n\n    # Create a blank grid with a background color\n    grid_size = max(n, m) + 2  # Ensure some space around the sprite\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly place the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/278/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/278/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/278/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/278/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/278/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/278/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/278/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/278/images/train_output_2.png"}]}, "index": 278, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation\n\n# description:\n# In the input you will see a grid with an isolated blue pattern.\n# To make the output grid, you should find any single isolated blue objects with size of 1x1 and change them to green.\n\ndef main(input_grid):\n    # Detect all the blue objects in the grid, ignoring objects of other colors\n    blue_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n\n    # Convert 1x1 objects (isolated pixels) into green\n    output_grid = input_grid.copy()\n    for object in blue_objects:\n        x, y, length, width = bounding_box(object, background=Color.BLACK)\n        # Find out the single isolated blue object with size of 1x1 and change it to green.\n        if length == 1 and width == 1:\n            output_grid[x, y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    colored = 0\n    # Randomly scatter density of blue pixels on the grid.\n    density = 0.3\n    while colored \u003c density * n * m:\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = Color.BLUE\n            colored += 1\n\n    # Ensure there is at least one 1x1 single isolated blue object in the grid.\n    blue_objects = detect_objects(grid=grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    if not any(np.sum(object != Color.BLACK) == 1 for object in blue_objects):\n        return generate_input()\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/279/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/279/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/279/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/279/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/279/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/279/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/279/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/279/images/train_output_2.png"}]}, "index": 279, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bouncing, color change\n\n# description:\n# In the input you will see a single blue pixel on a black background.\n# To make the output, shoot the blue pixel diagonally down and to the left, having it reflect and bounce off the walls until it exits at the bottom of the grid.\n# Finally, change the pixel color to yellow.\n\ndef main(input_grid):\n    # 1. Find the location of the blue pixel\n    blue_pixel_x, blue_pixel_y = np.argwhere(input_grid == Color.BLUE)[0]\n\n    # 2. Set the initial direction to down-left (dx=-1, dy=1)\n    direction = (-1, 1)\n\n    # Output grid starts as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Loop until we fall out of the canvas\n    while 0 \u003c= blue_pixel_x \u003c input_grid.shape[0] and 0 \u003c= blue_pixel_y \u003c input_grid.shape[1]:\n        stop_x, stop_y = draw_line(output_grid, blue_pixel_x, blue_pixel_y, direction=direction, color=Color.BLUE)\n        # Terminate if we failed to make progress\n        if stop_x == blue_pixel_x and stop_y == blue_pixel_y:\n            break\n        blue_pixel_x, blue_pixel_y = stop_x, stop_y\n        # Change direction upon hitting the walls\n        if blue_pixel_x == 0:  # hit left wall\n            direction = (1, direction[1])  # bounce to right\n        elif blue_pixel_x == output_grid.shape[0] - 1:  # hit right wall\n            direction = (-1, direction[1])  # bounce to left\n    \n    # Change the color of the final position to yellow\n    output_grid[blue_pixel_x, blue_pixel_y] = Color.YELLOW\n    \n    return output_grid\n\ndef generate_input():\n    width, height = np.random.randint(5, 20), np.random.randint(10, 30)\n    grid = np.full((width, height), Color.BLACK)\n    grid[0, -1] = Color.BLUE  # Start with a blue pixel at the bottom right corner\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/280/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/280/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/280/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/280/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/280/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/280/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/280/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/280/images/train_output_2.png"}]}, "index": 280, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, concentric shapes, color expansion\n\n# description:\n# In the input you will see a grid filled with various colored pixels.\n# To make the output, for each colored pixel, create concentric squares around it with increasing side lengths. The colors of the squares correspond to the color of the original pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Create an output grid that is the same size as the input grid.\n    # 2. For each colored pixel in the input, draw concentric squares around it based on its color.\n\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    width, height = input_grid.shape\n    \n    # Loop through each pixel in the input grid\n    for x in range(width):\n        for y in range(height):\n            color = input_grid[x, y]\n            if color != Color.BLACK:\n                # Draw concentric squares with increasing size\n                square_size = 1\n                while True:\n                    # Calculate the coordinates for the square\n                    top_left_x = max(x - square_size, 0)\n                    top_left_y = max(y - square_size, 0)\n                    bottom_right_x = min(x + square_size, width - 1)\n                    bottom_right_y = min(y + square_size, height - 1)\n\n                    # Fill the square with the color\n                    output_grid[top_left_x:bottom_right_x + 1, top_left_y:top_left_y + 1] = color\n                    output_grid[top_left_x:bottom_right_x + 1, bottom_right_y:bottom_right_y + 1] = color\n                    output_grid[top_left_x:top_left_x + 1, top_left_y:bottom_right_y + 1] = color\n                    output_grid[bottom_right_x:bottom_right_x + 1, top_left_y:bottom_right_y + 1] = color\n                    \n                    # Increment the square size\n                    square_size += 1\n                    \n                    # Stop if the square exceeds the bounds of the grid\n                    if top_left_x == 0 and top_left_y == 0 and bottom_right_x == width - 1 and bottom_right_y == height - 1:\n                        break\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid filled with random colored pixels\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colored pixels\n    num_pixels = np.random.randint(1, 10)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=False)\n\n    for color in colors:\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/281/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/281/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/281/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/281/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/281/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/281/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/281/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/281/images/train_output_2.png"}]}, "index": 281, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# region expansion, directional growth, color mapping\n\n# description:\n# In the input you will see a grid with several colored regions. Each region has a pixel that serves as a direction indicator (a different color).\n# To make the output, you should expand the region in the direction of the indicator pixel while maintaining the color of the region. \n# The expansion should continue until it reaches the edge of the grid.\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Define colors\n    region_color = Color.GREEN\n    indicator_color = Color.RED\n    background = Color.BLACK\n\n    # Get all regions in the grid, assuming they may contain indicator pixels\n    objects = find_connected_components(input_grid, monochromatic=False, background=background)\n    \n    for obj in objects:\n        # Check if the object has an indicator pixel\n        if indicator_color in object_colors(obj, background):\n            # Find the position of the indicator pixel\n            for x, y in np.argwhere(obj == indicator_color):\n                break\n            \n            # Get the bounding box of the region\n            x_start, y_start, width, height = bounding_box(obj, background=background)\n            \n            # Determine the direction of expansion based on the indicator pixel\u0027s position\n            if x == x_start:  # Indicator on the left edge\n                for i in range(x_start, input_grid.shape[0]):\n                    output_grid[i, y] = region_color\n            elif x == x_start + width - 1:  # Indicator on the right edge\n                for i in range(x_start, -1, -1):\n                    output_grid[i, y] = region_color\n            elif y == y_start:  # Indicator on the top edge\n                for j in range(y_start, input_grid.shape[1]):\n                    output_grid[x, j] = region_color\n            elif y == y_start + height - 1:  # Indicator on the bottom edge\n                for j in range(y_start, -1, -1):\n                    output_grid[x, j] = region_color\n\n            # Fill in the original region color\n            output_grid[x_start:x_start + width, y_start:y_start + height] = region_color\n\n    return output_grid\n\ndef generate_input():\n    # Create the background grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    region_num = np.random.randint(2, 5)  # Number of regions\n    region_color = Color.GREEN\n    indicator_color = Color.RED\n\n    # Draw regions on the grid\n    for _ in range(region_num):\n        width, height = np.random.randint(3, 6), np.random.randint(3, 6)\n\n        # Randomly place one indicator pixel on one random border of the rectangle\n        x_coord = np.random.choice([0, width - 1])\n        y_coord = np.random.choice(range(height))\n\n        # Create a colored region\n        region = np.full((width, height), region_color)\n        region[x_coord, y_coord] = indicator_color\n\n        # Attempt to place the region on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, region, padding=1, padding_connectivity=4)\n        except:\n            return generate_input()\n\n        blit_sprite(grid, region, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/282/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/282/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/282/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/282/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/282/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/282/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/282/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/282/images/train_output_2.png"}]}, "index": 282, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, area filling, color correspondence\n\n# description:\n# In the input, you will see a grid with a specific pattern formed by yellow pixels surrounded by black pixels. \n# To make the output, you should fill the area enclosed by the yellow pixels with blue and red pixels. \n# If the upper left pixel of the yellow pattern is yellow, fill the area with blue pixels. \n# Otherwise, fill the area with red pixels.\n\ndef main(input_grid):\n    # Detect the yellow pattern in the input grid\n    yellow_patterns = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=8)\n    \n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for pattern in yellow_patterns:\n        # Get the bounding box of the yellow pattern\n        x, y, width, height = bounding_box(pattern, background=Color.BLACK)\n        yellow_area = crop(pattern, background=Color.BLACK)\n\n        # Check the color of the upper left corner of the yellow pattern\n        if yellow_area[0, 0] == Color.YELLOW:\n            fill_color = Color.BLUE  # Fill with blue if upper left is yellow\n        else:\n            fill_color = Color.RED   # Fill with red otherwise\n\n        # Fill the area enclosed by the yellow pattern with the determined fill color\n        for i in range(height):\n            for j in range(width):\n                if yellow_area[i, j] == Color.YELLOW:\n                    output_grid[x + i, y + j] = fill_color\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid size\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly decide whether to generate a yellow pattern\n    if np.random.choice([True, False]):\n        # Generate a yellow pattern in the grid\n        pattern_height = np.random.randint(2, 5)\n        pattern_width = np.random.randint(2, 5)\n\n        # Randomly select the starting position for the pattern\n        start_x = np.random.randint(0, n - pattern_height)\n        start_y = np.random.randint(0, m - pattern_width)\n\n        # Place the yellow pattern in the grid\n        for i in range(pattern_height):\n            for j in range(pattern_width):\n                grid[start_x + i, start_y + j] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/283/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/283/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/283/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/283/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/283/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/283/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/283/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/283/images/train_output_2.png"}]}, "index": 283, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, overlapping shapes\n\n# description:\n# In the input you will see several shapes in different colors on a black background. Some shapes will overlap each other. \n# To create the output grid, blend the colors of overlapping shapes according to the following rules:\n# - If two shapes overlap, the resulting color will be a mix of both colors (e.g., red + blue = purple).\n# - If a shape does not overlap with any other shape, its color remains unchanged.\n\ndef main(input_grid):\n    # Find all objects in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    # Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Iterate through all pixels in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # Get the current pixel color\n            current_color = input_grid[x, y]\n\n            # If the pixel is black, skip it\n            if current_color == Color.BLACK:\n                continue\n\n            # Check for overlapping colors\n            overlapping_colors = {current_color}\n            for obj in objects:\n                # Check if this pixel belongs to the current object\n                if obj[x, y] == current_color:\n                    # Get the colors of the object\n                    overlapping_colors.update(object_colors(obj, background=Color.BLACK))\n            \n            # Blend the overlapping colors into the output grid\n            blended_color = blend_colors(overlapping_colors)\n            output_grid[x, y] = blended_color\n\n    return output_grid\n\ndef blend_colors(colors):\n    # Simple color blending logic: average the RGB values (this is a simplified example)\n    color_map = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.PINK: (255, 192, 203),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.GREY: (128, 128, 128),\n        Color.BLACK: (0, 0, 0),\n    }\n\n    # Start with a black color (0, 0, 0)\n    r_total, g_total, b_total = 0, 0, 0\n    count = 0\n\n    for color in colors:\n        if color in color_map:\n            r, g, b = color_map[color]\n            r_total += r\n            g_total += g\n            b_total += b\n            count += 1\n    \n    if count == 0:\n        return Color.BLACK\n    \n    # Average the color values\n    blended_color = (r_total // count, g_total // count, b_total // count)\n    \n    # Map back to the closest color (this is a simplification)\n    return closest_color(blended_color)\n\ndef closest_color(rgb):\n    # This function returns the closest color in the Color enum based on RGB values\n    # For simplicity, we can just return Color.RED here; in reality, this would need to be implemented properly\n    return Color.RED\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create some random shapes with different colors\n    colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(3, 6), replace=False)\n\n    for color in colors:\n        # Create a random sprite\n        sprite_width, sprite_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        sprite = random_sprite(sprite_width, sprite_height, color_palette=[color])\n        \n        # Place the sprite in a random location on the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n        \n        # Randomly overlap the sprite with another one of the same or different color\n        if np.random.rand() \u003c 0.5:\n            overlap_color = np.random.choice(colors)\n            overlap_sprite = random_sprite(sprite_width, sprite_height, color_palette=[overlap_color])\n            overlap_x, overlap_y = random_free_location_for_sprite(grid, overlap_sprite)\n            blit_sprite(grid, overlap_sprite, overlap_x, overlap_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/284/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/284/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/284/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/284/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/284/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/284/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/284/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/284/images/train_output_2.png"}]}, "index": 284, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# overlap, color change, translation, collision detection\n\n# description:\n# In the input you will see a grid with several colored objects. For each object:\n# 1. Slide it in the direction of a wall until it completely overlaps another object (slide it as much as you can to do so)\n# 2. Change the color of the sliding object to match the color of the overlapped object\n# 3. Repeat the slide (by the same displacement vector) indefinitely until it falls off the canvas\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find all the objects in the grid, which are monochromatic connected components\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    output_grid = np.copy(input_grid)\n\n    for obj in objects:\n        # Find the edges of the object\n        coords = np.argwhere(obj != Color.BLACK)\n        if coords.size == 0:\n            continue\n\n        # Determine the bounding box of the object\n        min_x, min_y = coords.min(axis=0)\n        max_x, max_y = coords.max(axis=0)\n\n        # Check for possible displacement directions: up, down, left, right\n        displacement_vectors = [\n            (-(min_x + 1), 0),  # Slide up\n            (max_x + 1 - obj.shape[0], 0),  # Slide down\n            (0, -(min_y + 1)),  # Slide left\n            (0, max_y + 1 - obj.shape[1])   # Slide right\n        ]\n\n        for displacement_vector in displacement_vectors:\n            # Translate the object by the displacement vector\n            shifted_obj = translate(obj, displacement_vector[0], displacement_vector[1], background=Color.BLACK)\n\n            # Check if the translated object overlaps with any other object\n            for other_obj in objects:\n                if not np.array_equal(obj, other_obj):  # Avoid self-comparison\n                    if collision(object1=shifted_obj, object2=other_obj):\n                        # Change the color of the sliding object to match the overlapped object\n                        color_of_other_object = np.unique(other_obj[other_obj != Color.BLACK])[0]\n                        shifted_obj[shifted_obj != Color.BLACK] = color_of_other_object\n\n                        # Repeat the displacement indefinitely until it falls off the canvas\n                        for i in range(1, 10):\n                            displaced_shifted_obj = translate(shifted_obj, displacement_vector[0] * i, displacement_vector[1] * i, background=Color.BLACK)\n                            blit_object(output_grid, displaced_shifted_obj, background=Color.BLACK)\n\n                        break  # Move to the next object after processing this one\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid as the background\n    n, m = 21, 21\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random number of objects, between 3 and 6\n    num_objects = np.random.randint(3, 7)\n\n    for _ in range(num_objects):\n        # Create a random sprite with dimensions between 2x2 and 4x4\n        sprite_height = np.random.randint(2, 5)\n        sprite_width = np.random.randint(2, 5)\n        sprite = random_sprite(sprite_height, sprite_width, density=0.5)\n\n        # Randomly choose a color for the sprite\n        color = np.random.choice(Color.NOT_BLACK)\n        sprite[sprite != Color.BLACK] = color\n\n        # Find a random free location in the grid to place the sprite\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/285/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/285/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/285/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/285/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/285/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/285/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/285/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/285/images/train_output_2.png"}]}, "index": 285, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, distance calculation\n\n# description:\n# In the input, you will see a grid with objects represented as colored squares.\n# The goal is to draw a line from each object to the nearest edge of the grid, in the direction of the closest edge.\n# If multiple edges are equidistant, choose the topmost or leftmost edge.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components (colored objects) in the input grid\n    objects = find_connected_components(input_grid, connectivity=4)\n\n    # Get the dimensions of the grid\n    height, width = input_grid.shape\n\n    # For each object, find the nearest edge and draw a line towards it\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj)\n\n        # Get the color of the object\n        color = np.unique(obj[obj != Color.BLACK])[0]\n\n        # Calculate the distances to each edge\n        distance_to_top = y\n        distance_to_bottom = height - (y + h)\n        distance_to_left = x\n        distance_to_right = width - (x + w)\n\n        # Find the minimum distance and the corresponding direction\n        min_distance = min(distance_to_top, distance_to_bottom, distance_to_left, distance_to_right)\n\n        # Determine which edge is closest\n        if min_distance == distance_to_top:\n            draw_line(output_grid, x + w // 2, y, length=min_distance, direction=(0, -1), color=color)\n        elif min_distance == distance_to_bottom:\n            draw_line(output_grid, x + w // 2, y + h, length=min_distance, direction=(0, 1), color=color)\n        elif min_distance == distance_to_left:\n            draw_line(output_grid, x, y + h // 2, length=min_distance, direction=(-1, 0), color=color)\n        elif min_distance == distance_to_right:\n            draw_line(output_grid, x + w, y + h // 2, length=min_distance, direction=(1, 0), color=color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid as background\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Define the number of objects to create\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Randomly generate the size of the object\n        height = np.random.randint(1, 4)\n        width = np.random.randint(1, 4)\n        \n        # Create a colored sprite\n        color = np.random.choice(Color.NOT_BLACK)\n        sprite = np.full((height, width), color)\n\n        # Place the sprite in a random free location in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/286/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/286/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/286/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/286/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/286/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/286/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/286/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/286/images/train_output_2.png"}]}, "index": 286, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# spiral expansion, color cycling\n\n# description:\n# In the input, you will see a grid with a single colored pixel at the center.\n# To make the output, expand the pixel outward in a spiral pattern, cycling through the colors.\n# The spiral should grow, coloring each pixel with the next color in the cycle until the grid is filled.\n\ndef main(input_grid):\n    # Get the center of the grid\n    height, width = input_grid.shape\n    center_x, center_y = width // 2, height // 2\n\n    # Get the color of the center pixel\n    center_color = input_grid[center_y, center_x]\n\n    # Create the output grid initialized to black\n    output_grid = np.full((height, width), Color.BLACK)\n\n    # The colors to cycle through\n    color_cycle = list(Color.NOT_BLACK)\n    start_color_index = color_cycle.index(center_color)\n    \n    # Initialize the spiral\u0027s parameters\n    x, y = center_x, center_y\n    step = 1\n    direction = 0  # 0: right, 1: down, 2: left, 3: up\n\n    # Fill the output grid in a spiral pattern\n    for i in range(1, height * width):  # Max iterations\n        for _ in range(2):  # Each step has two segments of the same length\n            for _ in range(step):\n                if 0 \u003c= x \u003c width and 0 \u003c= y \u003c height:\n                    output_grid[y, x] = color_cycle[start_color_index % len(color_cycle)]\n                # Move in the current direction\n                if direction == 0:  # Right\n                    x += 1\n                elif direction == 1:  # Down\n                    y += 1\n                elif direction == 2:  # Left\n                    x -= 1\n                elif direction == 3:  # Up\n                    y -= 1\n            direction = (direction + 1) % 4  # Change direction\n        step += 1  # Increase the step size after two segments\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a black background\n    n = 9  # Fixed size for simplicity, can be randomized\n    m = 9\n    grid = np.full((n, m), Color.BLACK)\n\n    # Place a single colored pixel in the center of the grid\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n    grid[n // 2, m // 2] = center_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/287/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/287/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/287/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/287/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/287/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/287/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/287/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/287/images/train_output_2.png"}]}, "index": 287, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# repeated translation, non-black background, color propagation\n\n# description:\n# In the input, you will see a non-black background with a black object located somewhere in the grid. \n# To make the output, repeatedly translate the black object to the left until it reaches the edge of the grid, \n# and every time it moves, fill the translated position with the object\u0027s color.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color and the black object.\n    # 2. Translate the black object to the left while filling the new positions with its color.\n\n    # 1. Identify the background color\n    background = max(Color.ALL_COLORS, key=lambda color: np.sum(input_grid == color))\n    objects = find_connected_components(input_grid, connectivity=4, background=background, monochromatic=True)\n    \n    # Find the black object (assumed to be the only black component)\n    black_objects = [obj for obj in objects if object_colors(obj, background=background) == [Color.BLACK]]\n    assert len(black_objects) == 1  # There should be exactly one black object\n    black_object = black_objects[0]\n\n    # We will draw on top of the input grid, so let\u0027s copy the input grid\n    output_grid = input_grid.copy()\n\n    # 2. Translate the black object to the left until it hits the edge of the grid\n    x, y, width, height = bounding_box(black_object, background=background)\n\n    # Move as long as it\u0027s possible (not reaching the left edge)\n    while x \u003e 0:\n        # Translate the object to the left\n        translated_object = translate(black_object, -1, 0, background=background)\n        # Fill the new position with the black color\n        blit_sprite(output_grid, translated_object, x - 1, y, background=background)\n\n        # Update the bounding box for the next translation\n        x -= 1\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random background color (not black)\n    background_color = np.random.choice(Color.NOT_BLACK)\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    input_grid = np.full((width, height), background_color)\n\n    # Create a black object (e.g., a square)\n    black_width, black_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    black_sprite = random_sprite(black_width, black_height, color_palette=[Color.BLACK], background=background_color)\n\n    # Place the black object randomly in the grid\n    x, y = random_free_location_for_sprite(input_grid, black_sprite, background=background_color)\n    blit_sprite(input_grid, black_sprite, x, y, background=background_color)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/288/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/288/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/288/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/288/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/288/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/288/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/288/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/288/images/train_output_2.png"}]}, "index": 288, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object scaling, color manipulation\n\n# description:\n# In the input, you will see a grid with a single red square. \n# To make the output, scale the red square to twice its size in both dimensions and change its color to green.\n\ndef main(input_grid):\n    # Detect the red square in the grid.\n    red_square = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n\n    if not red_square:\n        return input_grid  # If there\u0027s no red square, return the original input\n\n    # Assuming there\u0027s only one red square found\n    original_square = red_square[0]\n    original_height, original_width = original_square.shape\n\n    # Create a scaled version of the red square (double its size)\n    scaled_height, scaled_width = original_height * 2, original_width * 2\n    scaled_square = np.full((scaled_height, scaled_width), Color.GREEN)\n\n    # Place the scaled square in the output grid\n    output_grid = input_grid.copy()\n    \n    # Find the position of the original red square\n    original_x, original_y = object_position(original_square, background=Color.BLACK)\n\n    # Blit the scaled green square onto the output grid\n    blit_sprite(output_grid, scaled_square, x=original_x, y=original_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a single red square\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly determine the size of the red square\n    square_size = np.random.randint(2, 4)  # Size can be 2x2 or 3x3\n\n    # Randomly place the red square in the grid\n    x = np.random.randint(0, grid_size - square_size)\n    y = np.random.randint(0, grid_size - square_size)\n\n    # Draw the red square\n    red_square = np.full((square_size, square_size), Color.RED)\n    blit_sprite(grid, red_square, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/289/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/289/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/289/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/289/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/289/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/289/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/289/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/289/images/train_output_2.png"}]}, "index": 289, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color counting, grid transformation, pixel manipulation\n\n# description:\n# In the input you will see a grid consisting of various colored pixels. \n# The goal is to create a new grid where each row represents a unique color from the input, \n# and the number of pixels of that color determines the length of the row. \n# Each pixel in the new grid should be filled with the corresponding color.\n\ndef main(input_grid):\n    # Step 1: Count the occurrences of each color\n    color_counts = {}\n    for color in input_grid.flatten():\n        if color != Color.BLACK:  # Exclude background\n            if color in color_counts:\n                color_counts[color] += 1\n            else:\n                color_counts[color] = 1\n\n    # Step 2: Create the output grid\n    output_height = len(color_counts)\n    output_width = max(color_counts.values())  # The longest row corresponds to the most frequent color\n    output_grid = np.full((output_height, output_width), Color.BLACK)  # Initialize with background color\n\n    # Step 3: Fill the output grid with colors based on their counts\n    for i, (color, count) in enumerate(color_counts.items()):\n        output_grid[i, :count] = color  # Fill the row with the color up to its count\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random colors\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)  # Random dimensions for the grid\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Randomly scatter colors across the grid\n    num_colors = np.random.randint(3, 7)  # Randomly choose how many colors to use\n    colors = np.random.choice(Color.NOT_BLACK, num_colors, replace=False)  # Pick unique colors\n\n    # Scatter the chosen colors in the grid\n    for color in colors:\n        density = np.random.uniform(0.1, 0.4)  # Density of the color\n        randomly_scatter_points(grid, color=color, density=density)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/290/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/290/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/290/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/290/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/290/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/290/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/290/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/290/images/train_output_2.png"}]}, "index": 290, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, sorting, color mapping\n\n# description:\n# In the input, you will see a grid filled with various colored shapes on a black background.\n# The goal is to count the number of shapes of each color, and then create an output grid that is filled with colors\n# in the order of their counts, starting with the color that has the highest count. \n# The output grid will have a height equal to the number of distinct colors and width of 1.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.full((0, 1), Color.BLACK)\n\n    # Find connected components (shapes) in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n\n    # Count colors\n    color_counts = {}\n    for obj in objects:\n        color = obj[0, 0]  # Assume monochromatic objects\n        if color in color_counts:\n            color_counts[color] += 1\n        else:\n            color_counts[color] = 1\n\n    # Sort colors by counts in descending order\n    sorted_colors = sorted(color_counts.keys(), key=lambda color: color_counts[color], reverse=True)\n\n    # Create the output grid\n    output_grid = np.full((len(sorted_colors), 1), Color.BLACK)\n    for i, color in enumerate(sorted_colors):\n        output_grid[i, 0] = color\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of shapes\n    num_shapes = np.random.randint(5, 15)\n    colors = np.random.choice(list(Color.NOT_BLACK), num_shapes, replace=True)\n\n    for i in range(num_shapes):\n        # Create random shapes with random sizes\n        shape_width = np.random.randint(1, 5)\n        shape_height = np.random.randint(1, 5)\n        shape = random_sprite(shape_height, shape_width, density=1, color_palette=[colors[i]])\n        \n        # Find a random free location to place the shape\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, padding=1)\n            blit_sprite(grid, shape, x, y)\n        except ValueError:\n            continue  # Skip if no space is available\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/291/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/291/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/291/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/291/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/291/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/291/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/291/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/291/images/train_output_2.png"}]}, "index": 291, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, shape extraction\n\n# description:\n# In the input you will see a shape in the center of the grid.\n# To make the output, you need to rotate the shape 90 degrees clockwise and place it in the output grid.\n# The output grid should include the original shape and the rotated shape side by side.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    input_width, input_height = input_grid.shape\n    \n    # Create an output grid that will hold the original shape and the rotated shape\n    output_width = input_width\n    output_height = input_height\n    output_grid = np.full((output_height, output_width * 2), Color.BLACK)\n\n    # Place the original shape in the left half of the output grid\n    blit_sprite(output_grid, input_grid, x=0, y=0)\n    \n    # Rotate the input grid 90 degrees clockwise\n    rotated_shape = np.rot90(input_grid, k=-1)\n\n    # Place the rotated shape in the right half of the output grid\n    blit_sprite(output_grid, rotated_shape, x=input_width, y=0)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    width, height = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Generate a random shape in the grid\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_width, shape_height = np.random.randint(1, 4), np.random.randint(1, 4)\n\n    # Randomly select a position to place the shape\n    start_x = np.random.randint(0, width - shape_width)\n    start_y = np.random.randint(0, height - shape_height)\n\n    # Fill in the shape within the grid\n    for x in range(start_x, start_x + shape_width):\n        for y in range(start_y, start_y + shape_height):\n            grid[x, y] = shape_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/292/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/292/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/292/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/292/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/292/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/292/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/292/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/292/images/train_output_2.png"}]}, "index": 292, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, reflection\n\n# description:\n# In the input, you will see colored 2x2 squares arranged in the grid. \n# To produce the output, you need to:\n# 1. Rotate each 2x2 square by 90 degrees clockwise.\n# 2. Reflect the rotated squares across the vertical axis.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all 2x2 squares in the grid.\n    # 2. Rotate each detected square 90 degrees clockwise.\n    # 3. Reflect the rotated square across the vertical axis.\n    # 4. Blit the transformed squares back onto the output grid.\n\n    # Step 1: Detect all 2x2 squares\n    square_objects = detect_objects(input_grid, colors=Color.NOT_BLACK,\n                                    allowed_dimensions=[(2, 2)], monochromatic=True)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    for square in square_objects:\n        # Step 2: Rotate the square 90 degrees clockwise\n        rotated_square = np.array([[square[1, 0], square[0, 0]],\n                                    [square[1, 1], square[0, 1]]])\n        \n        # Step 3: Reflect the rotated square across the vertical axis\n        reflected_square = np.array([[rotated_square[0, 1], rotated_square[0, 0]],\n                                      [rotated_square[1, 1], rotated_square[1, 0]]])\n\n        # Step 4: Blit the transformed square onto the output grid\n        x, y = object_position(square, background=Color.BLACK, anchor=\"upper left\")\n        blit_sprite(output_grid, reflected_square, x, y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size 10x10\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly scatter 2x2 squares on the grid\n    num_squares = np.random.randint(2, 5)\n    for _ in range(num_squares):\n        square_color = np.random.choice(Color.NOT_BLACK)\n        square = np.full((2, 2), square_color)\n\n        # Attempt to place the square on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=square, background=Color.BLACK, padding=0)\n        except ValueError:\n            continue  # Skip if no space is available\n\n        blit_sprite(grid, square, x, y, Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/293/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/293/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/293/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/293/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/293/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/293/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/293/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/293/images/train_output_2.png"}]}, "index": 293, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object recognition, rotation, placement\n\n# description:\n# In the input, you will see several colorful objects scattered around a black grid, each object having a colored pixel at its center and a unique color around it.\n# The task is to create an output grid where each object is placed such that its colored center aligns with the center of a new 5x5 output grid, which should also be centered around the middle of the original grid.\n# If an object doesn\u0027t have a colored pixel at the center, it will be ignored.\n# The output grid should be the smallest possible size that contains all the objects after they have been placed correctly, ideally 5x5.\n\ndef main(input_grid):\n    # Step 1: Extract the objects from the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Step 2: Filter out objects which have a colored pixel at the center\n    filtered_objects = []\n    for obj in objects:\n        if np.any(obj[1, 1] != Color.BLACK):  # Check the center pixel\n            filtered_objects.append(crop(obj, background=Color.BLACK))\n\n    # Step 3: Create the output grid\n    output_grid = np.full((5, 5), Color.BLACK)\n\n    # Step 4: Place each object into the output grid\n    for sprite in filtered_objects:\n        # Find the center pixel\u0027s color\n        center_color = sprite[1, 1]\n        \n        # Define the offset to place the sprite in the output grid\n        offset_x = 2 - 1  # Center of output grid minus center of sprite\n        offset_y = 2 - 1  # Center of output grid minus center of sprite\n\n        # Place the sprite in the output grid\n        blit_sprite(output_grid, sprite, offset_x, offset_y, background=Color.BLACK)\n\n    # Step 5: Crop the output grid to remove any unnecessary black space\n    output_grid = crop(output_grid, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a larger grid with colorful objects\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random number of objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Create a random sprite with a center colored pixel\n        sprite = random_sprite(n=3, m=3, density=0.5, color_palette=Color.NOT_BLACK)\n        sprite[1, 1] = random.choice(Color.NOT_BLACK)  # Ensure the center is colored\n\n        # Place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue  # If no space found, skip this sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/294/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/294/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/294/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/294/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/294/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/294/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/294/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/294/images/train_output_2.png"}]}, "index": 294, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, occlusion, reflection\n\n# description:\n# In the input, you will see a vertically symmetric pattern that is partially occluded by a black rectangle.\n# The output should be the completed symmetric pattern after removing the occluding rectangle.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the position of the black rectangle.\n    # 2. Detect the vertical symmetry of the pattern.\n    # 3. Fill in the occluded part of the pattern using the symmetry information.\n\n    occlusion_color = Color.BLACK\n    \n    # Step 1: Find the black rectangle and save where it is\n    black_rectangle_mask = (input_grid == occlusion_color)\n    rectangle_coords = np.argwhere(black_rectangle_mask)\n    \n    # Assuming the rectangle is just a block of black pixels, we can find its bounding box\n    if rectangle_coords.size == 0:\n        raise ValueError(\"No occlusion found\")\n    \n    min_x, min_y = rectangle_coords.min(axis=0)\n    max_x, max_y = rectangle_coords.max(axis=0)\n\n    # Step 2: Find the vertical symmetry of the input grid\n    mirrors = detect_mirror_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n\n    # Step 3: Fill in the missing parts by mirroring the visible pixels\n    output_grid = input_grid.copy()\n    \n    for x, y in np.argwhere(output_grid != occlusion_color):\n        for mirror in mirrors:\n            symmetric_x, symmetric_y = mirror.apply(x, y)\n            if output_grid[symmetric_x, symmetric_y] == occlusion_color:\n                output_grid[symmetric_x, symmetric_y] = output_grid[x, y]\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random sprite with vertical symmetry.\n    # 2. Tile it to create a larger symmetric pattern.\n    # 3. Occlude it with a black rectangle at a random location.\n\n    # Create a random sprite with vertical symmetry\n    w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n    sprite = random_sprite(w, h, symmetry=\u0027vertical\u0027, color_palette=Color.NOT_BLACK)\n\n    # Create a larger grid by tiling the sprite\n    horizontal_repetitions = np.random.randint(2, 4)\n    vertical_repetitions = np.random.randint(2, 4)\n    pattern = np.tile(sprite, (vertical_repetitions, horizontal_repetitions))\n\n    # Occlude the pattern with a black rectangle\n    w_occluder, h_occluder = np.random.randint(2, 4), np.random.randint(2, 4)\n    x_occluder = np.random.randint(0, pattern.shape[0] - w_occluder + 1)\n    y_occluder = np.random.randint(0, pattern.shape[1] - h_occluder + 1)\n    black_rectangle_sprite = np.full((w_occluder, h_occluder), Color.BLACK)\n    blit_sprite(pattern, black_rectangle_sprite, x_occluder, y_occluder, background=None)\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/295/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/295/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/295/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/295/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/295/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/295/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/295/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/295/images/train_output_2.png"}]}, "index": 295, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input you will see a grid with a single object of a certain color. \n# To make the output, rotate the object 90 degrees clockwise and change its color to red.\n\ndef main(input_grid):\n    # Step 1: Find the single object in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1  # Ensure there\u0027s exactly one object\n\n    original_object = objects[0]\n\n    # Step 2: Rotate the object 90 degrees clockwise\n    rotated_object = np.rot90(original_object, k=-1)  # k=-1 for clockwise rotation\n\n    # Step 3: Change the color of the rotated object to red\n    rotated_object[rotated_object != Color.BLACK] = Color.RED\n\n    # Step 4: Create an output grid and blit the modified object onto it\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    output_grid = blit_object(output_grid, rotated_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size between 4x4 and 8x8\n    grid_len = np.random.randint(4, 9)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Randomly generate a sprite of one color (e.g., teal) and place it on the grid\n    sprite_width, sprite_height = np.random.randint(1, grid_len - 1), np.random.randint(1, grid_len - 1)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.TEAL], density=1.0)\n    \n    # Find a random free location to place the sprite\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/296/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/296/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/296/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/296/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/296/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/296/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/296/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/296/images/train_output_2.png"}]}, "index": 296, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity, color matching, line drawing\n\n# description:\n# In the input, you will see a grid with scattered pixels of different colors. Each color corresponds to a group of pixels that are connected. \n# To make the output, for each pixel in the input grid, draw a line to the nearest pixel of the same color. \n# If there are multiple nearest pixels, the line should connect to the first one found in the order of traversal (top to bottom, left to right).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    height, width = input_grid.shape\n\n    # For each color, find the positions of its pixels\n    color_positions = {}\n    for x in range(height):\n        for y in range(width):\n            color = input_grid[x, y]\n            if color != Color.BLACK:\n                if color not in color_positions:\n                    color_positions[color] = []\n                color_positions[color].append((x, y))\n\n    # For each color, find connections to the nearest pixel of the same color\n    for color, positions in color_positions.items():\n        for (x, y) in positions:\n            # Find the nearest pixel of the same color\n            nearest = None\n            min_distance = float(\u0027inf\u0027)\n            for (nx, ny) in positions:\n                if (nx, ny) == (x, y):\n                    continue\n                distance = abs(nx - x) + abs(ny - y)  # Manhattan distance\n                if distance \u003c min_distance:\n                    min_distance = distance\n                    nearest = (nx, ny)\n            \n            # Draw a line to the nearest pixel found\n            if nearest:\n                draw_line(output_grid, x, y, end_x=nearest[0], end_y=nearest[1], color=color)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a background grid with random colors\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly pick a number of colors to scatter\n    num_colors = np.random.randint(3, 6)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    # Scatter each color in the grid\n    for color in colors:\n        density = np.random.uniform(0.1, 0.3)  # Varying density for each color\n        randomly_scatter_points(grid, color=color, density=density)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/297/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/297/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/297/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/297/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/297/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/297/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/297/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/297/images/train_output_2.png"}]}, "index": 297, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, growth patterns\n\n# description:\n# In the input you will see a grid with individual colored pixels, some of which are red or blue (those ones are special).\n# To make the output:\n# 1. For each red pixel, add purple pixels in its immediate diagonals (northeast, northwest, southeast, southwest).\n# 2. For each blue pixel, add orange pixels in its immediate neighbors (up, down, left, right).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.RED:\n                # put purple pixels in the diagonals\n                for dx in [-1, 1]:\n                    for dy in [-1, 1]:\n                        if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                            output_grid[x + dx, y + dy] = Color.PINK  # Using Color.PINK for purple\n            elif color == Color.BLUE:\n                # put orange pixels in the neighbors\n                for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                    if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                        output_grid[x + dx, y + dy] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    num_red, num_blue, num_other = np.random.randint(1, 5), np.random.randint(1, 5), np.random.randint(1, 5)\n\n    for _ in range(num_red):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.RED\n    \n    for _ in range(num_blue):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLUE\n    \n    for _ in range(num_other):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color not in [Color.RED, Color.BLUE]])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/298/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/298/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/298/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/298/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/298/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/298/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/298/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/298/images/train_output_2.png"}]}, "index": 298, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color counting, pixel expansion, grid transformation\n\n# description:\n# In the input, you will see a grid with colored pixels arranged in various patterns.\n# To make the output:\n# 1. Count the number of unique colors in the grid.\n# 2. Expand each pixel in the grid into a square of size equal to the count of unique colors.\n# 3. Fill the expanded squares in a new output grid.\n\ndef main(input_grid):\n    # Step 1: Count the number of unique colors (excluding black)\n    unique_colors = set(input_grid.flatten())\n    unique_colors.discard(Color.BLACK)\n    num_colors = len(unique_colors)\n\n    # Step 2: Create an output grid based on the number of unique colors\n    input_height, input_width = input_grid.shape\n    output_height = input_height * num_colors\n    output_width = input_width * num_colors\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Step 3: Expand each pixel in the input grid to a square of size num_colors\n    for y in range(input_height):\n        for x in range(input_width):\n            color = input_grid[y, x]\n            if color != Color.BLACK:\n                # Fill the corresponding square in the output grid\n                output_grid[y*num_colors:(y+1)*num_colors, x*num_colors:(x+1)*num_colors] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid\n    width, height = np.random.randint(5, 10, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colors\n    num_colors = np.random.randint(2, 6)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    # Fill the grid with random colors\n    for _ in range(np.random.randint(5, 15)):\n        x = np.random.randint(0, width)\n        y = np.random.randint(0, height)\n        grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/299/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/299/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/299/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/299/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/299/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/299/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/299/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/299/images/train_output_2.png"}]}, "index": 299, "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, color blending, obstacle avoidance\n\n# description:\n# In the input, you will see a grid containing several red and green pixels. \n# To make the output, draw a line from each red pixel to the nearest green pixel, avoiding any blue obstacles. \n# If there are multiple green pixels at the same distance, the red pixel should connect to the one with the smallest row index. \n# The output lines should be drawn in orange color.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find the positions of red and green pixels\n    red_pixels = np.argwhere(output_grid == Color.RED)\n    green_pixels = np.argwhere(output_grid == Color.GREEN)\n    \n    # Iterate through each red pixel\n    for red_x, red_y in red_pixels:\n        # Initialize variables to track the nearest green pixel\n        nearest_green = None\n        min_distance = float(\u0027inf\u0027)\n        \n        # Find the closest green pixel\n        for green_x, green_y in green_pixels:\n            # Calculate Manhattan distance\n            distance = abs(red_x - green_x) + abs(red_y - green_y)\n            if distance \u003c min_distance:\n                min_distance = distance\n                nearest_green = (green_x, green_y)\n            elif distance == min_distance:\n                # If distances are equal, choose the one with the smallest row index\n                if green_x \u003c nearest_green[0]:\n                    nearest_green = (green_x, green_y)\n\n        if nearest_green:\n            green_x, green_y = nearest_green\n            # Draw a line from the red pixel to the nearest green pixel\n            draw_line(output_grid, red_x, red_y, end_x=green_x, end_y=green_y, color=Color.ORANGE, stop_at_color=[Color.BLUE])\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter red and green pixels\n    randomly_scatter_points(grid, color=Color.RED, density=0.15)\n    randomly_scatter_points(grid, color=Color.GREEN, density=0.15)\n\n    # Randomly place blue obstacles\n    randomly_scatter_points(grid, color=Color.BLUE, density=0.2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/0/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/0/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/0/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/0/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/0/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/0/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/0/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/0/images/train_output_2.png"}]}, "index": 0, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, boundary detection, color mapping\n\n# description:\n# In the input grid, you will find a solid color rectangle that touches the boundary of the grid.\n# The task is to translate this rectangle in such a way that it moves away from the boundary\n# while maintaining its color. The new position should be determined by the largest\n# distance possible without going out of bounds, and the rectangle should be moved diagonally\n# towards the center of the grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Identify the color of the rectangle touching the boundary\n    boundary_colors = np.unique(input_grid[np.where((input_grid == Color.BLACK) == False)])\n    rectangle_color = None\n\n    # Find the color that touches the boundary\n    for color in boundary_colors:\n        if np.any(input_grid[0, :] == color) or np.any(input_grid[-1, :] == color) or \\\n           np.any(input_grid[:, 0] == color) or np.any(input_grid[:, -1] == color):\n            rectangle_color = color\n            break\n\n    if rectangle_color is None:\n        return input_grid  # No rectangle found\n\n    # Step 2: Extract the rectangle\n    rectangle = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    target_rectangle = [rect for rect in rectangle if np.any(rect == rectangle_color)]\n\n    if len(target_rectangle) == 0:\n        return input_grid  # No rectangle to move\n\n    # Step 3: Determine the largest possible translation towards the center\n    target_rect = target_rectangle[0]\n    x, y = object_position(target_rect, background=Color.BLACK, anchor=\u0027upper left\u0027)\n    width, height = target_rect.shape\n\n    # Calculate maximum translation distance\n    max_x_translation = (input_grid.shape[0] - width) - x\n    max_y_translation = (input_grid.shape[1] - height) - y\n\n    # Translate diagonally towards the center\n    translation_x = min(max_x_translation, (input_grid.shape[0] // 2) - x)\n    translation_y = min(max_y_translation, (input_grid.shape[1] // 2) - y)\n\n    # Step 4: Translate the rectangle and create the output grid\n    output_grid = input_grid.copy()\n    translated_rectangle = translate(target_rect, translation_x, translation_y, background=Color.BLACK)\n    blit_sprite(output_grid, translated_rectangle, x + translation_x, y + translation_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid filled with black background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a rectangle\u0027s size\n    rect_width, rect_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    rectangle_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly position the rectangle such that it touches the boundary\n    if np.random.choice([True, False]):  # Touching top or bottom\n        row_pos = 0 if np.random.choice([True, False]) else n - rect_height\n        grid[row_pos:row_pos + rect_height, :] = rectangle_color\n    else:  # Touching left or right\n        col_pos = 0 if np.random.choice([True, False]) else m - rect_width\n        grid[:, col_pos:col_pos + rect_width] = rectangle_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/1/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/1/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/1/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/1/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/1/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/1/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/1/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/1/images/train_output_2.png"}]}, "index": 1, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, pattern manipulation, color matching\n\n# description:\n# In the input, you will see a pattern composed of a small grid of colored pixels and a larger grid below it filled with a single color. \n# To make the output, you should scale the small grid by a factor of 2 and attempt to fit it into the larger grid. \n# The output should replace the original color of the larger grid with the colors from the scaled small grid wherever they overlap.\n\ndef main(input_grid):\n    # Step 1: Identify the small pattern and the larger grid\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    small_pattern = max(objects, key=lambda obj: obj.size)  # Assume the largest connected component is the small pattern\n    small_sprite = crop(small_pattern, background=Color.BLACK)\n\n    # Step 2: Scale the small pattern\n    scaled_sprite = scale_sprite(small_sprite, factor=2)\n\n    # Step 3: Create output grid based on the size of the larger grid\n    output_grid = input_grid.copy()\n\n    # Identify the position of the small pattern in the input grid\n    small_x, small_y = object_position(small_pattern, background=Color.BLACK)\n\n    # Step 4: Attempt to overlay the scaled pattern onto the output grid\n    for x in range(scaled_sprite.shape[0]):\n        for y in range(scaled_sprite.shape[1]):\n            input_x = small_x + x\n            input_y = small_y + y\n\n            # Only replace the pixels in the output grid if they are not black\n            if 0 \u003c= input_x \u003c output_grid.shape[0] and 0 \u003c= input_y \u003c output_grid.shape[1]:\n                if scaled_sprite[x, y] != Color.BLACK:\n                    output_grid[input_x, input_y] = scaled_sprite[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a small sprite and a large canvas to hold it\n    small_sprite_size = np.random.randint(2, 4)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=small_sprite_size, replace=False)\n\n    # Create a small random sprite with the chosen colors\n    small_sprite = np.random.choice(colors + [Color.BLACK], size=(small_sprite_size, small_sprite_size))\n\n    # Create a larger grid (at least 2x the size of the small sprite)\n    large_grid_size = small_sprite_size * 2\n    output_grid = np.full((large_grid_size, large_grid_size), Color.BLACK)\n\n    # Randomly place the small sprite in the larger grid\n    x, y = random_free_location_for_sprite(output_grid, small_sprite, background=Color.BLACK)\n    blit_sprite(output_grid, small_sprite, x, y)\n\n    return output_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/2/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/2/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/2/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/2/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/2/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/2/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/2/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/2/images/train_output_2.png"}]}, "index": 2, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, pattern generation, connection\n\n# description:\n# In the input you will see a grid containing a central symmetrical pattern that is drawn with two colors on either side of a vertical line.\n# To create the output, you need to connect the two sides of the pattern with a vertical line and then mirror the entire pattern horizontally along the central vertical line.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    height, width = input_grid.shape\n\n    # Create an output grid that\u0027s the same size as the input grid\n    output_grid = np.full((height, width), Color.BLACK)\n\n    # Identify the central vertical line\n    mid_col = width // 2\n\n    # Draw a vertical line connecting the two sides of the pattern\n    left_color = input_grid[:, mid_col - 1].max()\n    right_color = input_grid[:, mid_col].max()\n    \n    # Draw the vertical connection line\n    draw_line(output_grid, x=mid_col, y=0, direction=(0, 1), color=Color.YELLOW)\n\n    # Copy the original input grid to the output grid\n    output_grid = blit_sprite(output_grid, sprite=input_grid, x=0, y=0)\n\n    # Create the mirrored pattern\n    mirrored_pattern = np.fliplr(input_grid)\n\n    # Place the mirrored pattern on the output grid\n    blit_sprite(output_grid, sprite=mirrored_pattern, x=0, y=0)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a central symmetrical pattern\n    n = np.random.randint(5, 10)  # Height of the pattern\n    m = np.random.randint(5, 10)  # Width of the pattern (should be odd for symmetry)\n\n    # Create an empty grid\n    grid = np.full((n, m), Color.BLACK)\n\n    # Select two colors for the symmetrical pattern\n    left_color = np.random.choice(Color.NOT_BLACK)\n    right_color = np.random.choice([c for c in Color.NOT_BLACK if c != left_color])\n\n    # Fill the left side with one color and the right side with another\n    grid[:, :m//2] = left_color\n    grid[:, m//2:] = right_color\n\n    # Draw some patterns on each side to make it more interesting\n    for i in range(n):\n        if i % 2 == 0:  # For every other row, draw a line\n            draw_line(grid, x=0, y=i, length=m//2, color=left_color, direction=(1, 0))\n            draw_line(grid, x=m//2, y=i, length=m//2, color=right_color, direction=(1, 0))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/3/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/3/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/3/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/3/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/3/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/3/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/3/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/3/images/train_output_2.png"}]}, "index": 3, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color matching, object transformation, overlapping\n\n# description:\n# In the input, you will see a grid with a small object (a colored sprite) and several colored tags scattered around.\n# Your task is to match the colors of the object to the tags by moving, rotating, and scaling the object, covering as many tags as possible.\n# The output should contain the tags covered by the transformed object, with the object\u0027s color replacing the tags\u0027 colors.\n\ndef main(input_grid):\n    # Step 1: Detect the small object and the tags\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, background=background, monochromatic=False)\n    \n    # Identify the main object by detecting the one with the most variety of colors\n    main_object = max(objects, key=lambda obj: len(object_colors(obj, background=background)))\n    main_colors = object_colors(main_object, background=background)\n\n    output_grid = np.copy(input_grid)\n\n    # Step 2: Generate transformations of the main object\n    transformations = []\n    for scale in range(1, 5):  # Scale from 1 to 4\n        for rotation in range(4):  # Rotate 0 to 3 times (90 degrees)\n            transformed_object = np.rot90(scale_sprite(main_object, scale), rotation)\n            transformations.append(transformed_object)\n\n    # Step 3: Try to place each transformation on the grid\n    for transformed_object in transformations:\n        for x in range(output_grid.shape[0] - transformed_object.shape[0] + 1):\n            for y in range(output_grid.shape[1] - transformed_object.shape[1] + 1):\n                # Check if the transformed object can be placed\n                can_place = True\n                for dx in range(transformed_object.shape[0]):\n                    for dy in range(transformed_object.shape[1]):\n                        if transformed_object[dx, dy] != background:\n                            if output_grid[x + dx, y + dy] == background:\n                                continue\n                            elif output_grid[x + dx, y + dy] in main_colors:\n                                continue\n                            else:\n                                can_place = False\n                                break\n                    if not can_place:\n                        break\n                \n                # Place the transformed object if it can\n                if can_place:\n                    blit_sprite(output_grid, transformed_object, x, y, background=background)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid and place a small object and several colored tags\n    width, height = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a small object with multiple colors\n    object_sprite = random_sprite(n=[2, 3], m=[2, 3], density=1, color_palette=list(Color.NOT_BLACK), background=Color.BLACK)\n    x, y = random_free_location_for_sprite(grid, object_sprite, background=Color.BLACK)\n    blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n\n    # Add colored tags around\n    n_tags = np.random.randint(5, 15)\n    for _ in range(n_tags):\n        tag_color = np.random.choice(list(Color.NOT_BLACK))\n        tag = np.array([[tag_color]])\n        tag_x, tag_y = random_free_location_for_sprite(grid, tag, background=Color.BLACK)\n        blit_sprite(grid, tag, tag_x, tag_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/4/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/4/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/4/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/4/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/4/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/4/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/4/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/4/images/train_output_2.png"}]}, "index": 4, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, pattern filling, grid manipulation\n\n# description:\n# In the input you will see a pattern that consists of a series of colored squares within a bounding box. \n# The task is to fill the entire bounding box with a new color (chosen randomly from the available colors) \n# while retaining the original pattern inside it. The original colors within the bounding box should remain unchanged.\n\ndef main(input_grid):\n    # 1. Find the bounding box of the non-background pixels in the grid\n    x, y, width, height = bounding_box(input_grid, background=Color.BLACK)\n    \n    # 2. Create a new output grid, initially filled with the new color\n    output_grid = np.full(input_grid.shape, Color.YELLOW)  # Filling with yellow as a default new color\n    \n    # 3. Copy the original pattern inside the bounding box to the output grid\n    output_grid[x:x+height, y:y+width] = input_grid[x:x+height, y:y+width]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a pattern within the grid\n    pattern_width = np.random.randint(3, n // 2)\n    pattern_height = np.random.randint(3, m // 2)\n\n    # Create a random sprite to represent the pattern\n    sprite = random_sprite(pattern_width, pattern_height, density=0.5, symmetry=None, color_palette=Color.NOT_BLACK)\n\n    # Randomly place the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/5/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/5/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/5/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/5/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/5/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/5/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/5/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/5/images/train_output_2.png"}]}, "index": 5, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object placement, line drawing, color matching\n\n# description:\n# In the input, you will see a grid with a single green pixel and a single red pixel.\n# To make the output, draw a vertical line from the green pixel to the bottom of the grid\n# and a horizontal line from the red pixel to the right edge of the grid. \n# Finally, place a blue square (2x2 pixels) at the intersection of these two lines.\n\ndef main(input_grid):\n    # Make a copy of the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the positions of the green and red pixels\n    green_pixel = np.argwhere(input_grid == Color.GREEN)[0]\n    red_pixel = np.argwhere(input_grid == Color.RED)[0]\n\n    green_x, green_y = green_pixel\n    red_x, red_y = red_pixel\n\n    # Draw vertical line from the green pixel to the bottom of the grid\n    for y in range(green_y, output_grid.shape[0]):\n        output_grid[green_x, y] = Color.GREEN\n\n    # Draw horizontal line from the red pixel to the right edge of the grid\n    for x in range(red_x, output_grid.shape[1]):\n        output_grid[x, red_y] = Color.RED\n\n    # Place a blue 2x2 square at the intersection of the two lines\n    intersection_x = green_x\n    intersection_y = red_y\n    \n    # Ensure we don\u0027t go out of bounds when placing the blue square\n    if intersection_x + 1 \u003c output_grid.shape[0] and intersection_y + 1 \u003c output_grid.shape[1]:\n        blit_object(output_grid, np.full((2, 2), Color.BLUE), background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid as the background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place a green pixel\n    green_x, green_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[green_x, green_y] = Color.GREEN\n\n    # Randomly place a red pixel but not in the same row or column as the green pixel\n    red_x, red_y = np.random.randint(0, n), np.random.randint(0, m)\n    while red_x == green_x or red_y == green_y:\n        red_x, red_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[red_x, red_y] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/6/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/6/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/6/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/6/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/6/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/6/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/6/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/6/images/train_output_2.png"}]}, "index": 6, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation, sprite manipulation, mirroring\n\n# description:\n# In the input you will see a grid with a patterned design consisting of alternating colors.\n# To make the output grid, you should mirror the input grid horizontally, and then place the mirrored version below the original.\n# Finally, crop the output grid to only contain the necessary parts, ensuring that there is no overlap.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    input_width, input_height = input_grid.shape\n    \n    # Create an output grid that is double the height of the input grid\n    output_grid = np.full((input_width, input_height * 2), Color.BLACK)\n\n    # Place the original input grid in the top half of the output grid\n    blit_sprite(output_grid, input_grid, x=0, y=0)\n\n    # Flip the input grid horizontally\n    flipped_input = np.fliplr(input_grid)\n\n    # Place the flipped input grid in the bottom half of the output grid\n    blit_sprite(output_grid, flipped_input, x=0, y=input_height)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the grid with random dimensions\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose two colors for the pattern\n    color1, color2 = np.random.choice(list(Color.NOT_BLACK), size=2, replace=False)\n\n    # Create an alternating pattern\n    for x in range(width):\n        for y in range(height):\n            if (x + y) % 2 == 0:\n                grid[x, y] = color1\n            else:\n                grid[x, y] = color2\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/7/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/7/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/7/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/7/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/7/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/7/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/7/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/7/images/train_output_2.png"}]}, "index": 7, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, connected components, color transformation\n\n# description:\n# The input consists of a black grid with a few colored irregular shapes (connected components).\n# To produce the output grid, fill in the smallest colored shapes with green, and fill in the largest colored shapes with yellow.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # 1. Find all colored connected components (non-black)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # 2. Get the areas of each object\n    object_areas = [np.sum(obj != Color.BLACK) for obj in objects]\n\n    # 3. Find the smallest and largest areas\n    smallest_area = min(object_areas)\n    largest_area = max(object_areas)\n\n    # 4. Create a new output grid filled with black background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 5. Fill in the smallest and largest colored shapes with their respective colors\n    for obj in objects:\n        area = np.sum(obj != Color.BLACK)\n        if area == smallest_area:\n            obj[obj != Color.BLACK] = Color.GREEN  # Fill smallest with green\n        elif area == largest_area:\n            obj[obj != Color.BLACK] = Color.YELLOW  # Fill largest with yellow\n\n        # Blit the transformed object back onto the output grid\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size between 10x10 and 20x20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_shapes = np.random.randint(3, 8)  # Number of colored shapes\n\n    for _ in range(num_shapes):\n        # Random color for the shape\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Random size for the shape (width and height)\n        width = np.random.randint(3, 6)\n        height = np.random.randint(3, 6)\n\n        # Create a random shape with a filled rectangle\n        shape = np.full((width, height), color)\n        \n        # Randomly place the shape in the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n\n        # Blit the shape into the grid\n        blit_sprite(grid, shape, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/8/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/8/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/8/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/8/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/8/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/8/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/8/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/8/images/train_output_2.png"}]}, "index": 8, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, object placement, color manipulation\n\n# description:\n# In the input, you will see a small 3x3 blue object and a large green square that is a multiple of the size of the blue object.\n# The task is to scale the blue object to match the size of the green square and place it inside the green square.\n# Return just the green square (with the rescaled blue object placed inside it).\n\ndef main(input_grid):\n    # Step 1: Detect the large green square and the small blue object\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n    \n    # Step 2: Separate them into the green square and the blue object\n    for obj in objects:\n        sprite = obj\n        if Color.GREEN in object_colors(sprite):\n            green_square = sprite\n        elif Color.BLUE in object_colors(sprite):\n            blue_object = sprite\n            \n    # Step 3: Calculate the scaling factor\n    scale = (green_square.shape[0] - 2) // blue_object.shape[0]  # minus border pixels\n\n    # Step 4: Scale the blue object\n    scaled_blue_object = scale_sprite(blue_object, factor=scale)\n\n    # Step 5: Create the output grid and place the green square and the scaled blue object\n    output_grid = np.full(green_square.shape, Color.BLACK)\n    blit_sprite(output_grid, green_square, x=0, y=0, background=Color.BLACK)\n    blit_sprite(output_grid, scaled_blue_object, x=1, y=1, background=Color.BLACK)  # center the scaled object\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Initialize the grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)    \n\n    # Step 2: Create the small blue object and the large green square\n    small_object_size = 3\n    availabe_scales = range(2, 5)  # scaling factors for the green square\n    scale = np.random.choice(availabe_scales)\n\n    # Step 3: Create the green square frame\n    big_green_square = np.full((scale * small_object_size + 2, scale * small_object_size + 2), Color.GREEN)\n    big_green_square[1:-1, 1:-1] = Color.BLACK  # inner part is black\n\n    # Step 4: Randomly place the green square in the grid\n    x_square, y_square = random_free_location_for_sprite(grid, big_green_square)\n    grid = blit_sprite(grid, big_green_square, x=x_square, y=y_square, background=Color.BLACK)\n\n    # Step 5: Create the small blue object and place it in the grid\n    blue_object = np.full((small_object_size, small_object_size), Color.BLUE)\n    x, y = random_free_location_for_sprite(grid, blue_object)\n    grid = blit_sprite(grid, blue_object, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/9/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/9/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/9/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/9/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/9/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/9/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/9/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/9/images/train_output_2.png"}]}, "index": 9, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, object position, color mapping\n\n# description:\n# The input grid consists of a colored object (not black) in the upper half of the grid and a colored mirror indicator pixel in the lower half of the grid. \n# To produce the output grid, reflect the colored object across the center line of the grid to the lower half, and make the color of the reflected object match the color of the mirror indicator pixel.\n\ndef main(input_grid):\n    # Determine the background color (most common color)\n    background = max(Color.ALL_COLORS, key=lambda color: np.sum(input_grid == color))\n\n    # Find the colored object and mirror indicator pixel\n    objects = find_connected_components(input_grid, connectivity=8, background=background, monochromatic=False)\n    \n    # Separate the objects into the main object (upper half) and the indicator (lower half)\n    main_object = None\n    mirror_indicator = None\n\n    for obj in objects:\n        # Check the position of the object\n        obj_x, obj_y = object_position(obj, background=background, anchor=\"center\")\n        if obj_x \u003c input_grid.shape[0] // 2:  # Upper half\n            main_object = obj\n        else:  # Lower half\n            mirror_indicator = obj\n\n    assert main_object is not None and mirror_indicator is not None, \"Both main object and mirror indicator must be found.\"\n\n    # Get the color of the mirror indicator\n    mirror_color = input_grid[object_position(mirror_indicator, background=background, anchor=\"center\")]\n\n    # Create the output grid\n    output_grid = input_grid.copy()\n\n    # Reflect the main object across the center line\n    # Get the position of the main object\n    main_x, main_y = object_position(main_object, background=background, anchor=\"upper left\")\n    height, width = main_object.shape\n\n    # Calculate the new position for the reflected object\n    new_x = input_grid.shape[0] - main_x - height  # Reflect vertically\n    new_y = main_y  # Same horizontal position\n\n    # Create a reflected version of the main object\n    reflected_object = np.copy(main_object)\n    reflected_object[reflected_object != background] = mirror_color  # Change color to mirror color\n\n    # Blit the reflected object onto the output grid\n    blit_sprite(output_grid, reflected_object, x=new_x, y=new_y, background=background)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size between 10 and 20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a colored object in the upper half\n    object_height = np.random.randint(2, 5)\n    object_width = np.random.randint(2, 5)\n    color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(object_height, object_width, color_palette=[color], background=Color.BLACK)\n\n    # Place the object in the upper half, ensuring it fits\n    x = np.random.randint(0, n // 2 - object_height)\n    y = np.random.randint(0, m - object_width)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Generate a mirror indicator pixel in the lower half\n    mirror_color = np.random.choice(Color.NOT_BLACK)\n    indicator_x = np.random.randint(n // 2, n)\n    indicator_y = np.random.randint(0, m)\n    grid[indicator_x, indicator_y] = mirror_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/10/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/10/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/10/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/10/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/10/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/10/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/10/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/10/images/train_output_2.png"}]}, "index": 10, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# circular patterns, concentric circles\n\n# description:\n# In the input, you will see a grid with various colored circular patterns. The goal is to identify any circular patterns and draw concentric circles around their centers, \n# where the radius of the concentric circles will increase by 1 for each additional circle drawn. The circles will have the color blue.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    \n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n\n    for obj in objects:\n        # Check if the bounding box of the object forms a circular pattern\n        obj_x, obj_y, obj_width, obj_height = bounding_box(obj, background=Color.BLACK)\n        if obj_width == obj_height:  # Check for circular shape\n            # Calculate the center of the object\n            center_x = obj_x + obj_width // 2\n            center_y = obj_y + obj_height // 2\n            \n            # Draw concentric circles around the center of the circular pattern\n            for radius in range(1, 4):  # Draw 3 concentric circles\n                circle_sprite = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n                for x in range(-radius, radius + 1):\n                    for y in range(-radius, radius + 1):\n                        if x ** 2 + y ** 2 \u003c= radius ** 2:  # Check if inside the circle\n                            circle_sprite[y + radius, x + radius] = Color.BLUE\n                \n                # Blit the circle sprite to the output grid\n                x_offset = center_x - radius\n                y_offset = center_y - radius\n                output_grid = blit_sprite(output_grid, circle_sprite, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black 10x10 grid as background\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Randomly generate circular patterns\n    num_circles = np.random.randint(1, 5)\n    for _ in range(num_circles):\n        # Randomly choose a size for the circular pattern\n        radius = np.random.randint(2, 4)\n        circular_sprite = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n\n        # Fill the circular sprite with a random color\n        color = np.random.choice(Color.NOT_BLACK)\n        for x in range(-radius, radius + 1):\n            for y in range(-radius, radius + 1):\n                if x ** 2 + y ** 2 \u003c= radius ** 2:  # Check if inside the circle\n                    circular_sprite[y + radius, x + radius] = color\n        \n        # Place the circular sprite randomly on the grid\n        x, y = random_free_location_for_sprite(grid, circular_sprite, padding=1)\n        grid = blit_sprite(grid, circular_sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/11/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/11/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/11/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/11/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/11/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/11/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/11/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/11/images/train_output_2.png"}]}, "index": 11, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color tracking\n\n# description:\n# In the input, you will see a grid with multiple colored pixels. Among these, one pixel is designated as the \"anchor\" - this is indicated by a blue pixel.\n# To make the output, for every other colored pixel, you should draw a yellow line from that pixel towards the anchor pixel (the blue pixel) until it reaches the anchor.\n# If the line intersects with another colored pixel, it should stop at that pixel\u0027s position and change that pixel to orange.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Find the position of the anchor pixel (blue)\n    anchor_pos = np.argwhere(input_grid == Color.BLUE)\n    if anchor_pos.size == 0:\n        return output_grid  # No anchor found, return the original grid\n\n    anchor_x, anchor_y = anchor_pos[0]\n\n    # Iterate through the grid to find all colored pixels\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if (x, y) != (anchor_x, anchor_y) and input_grid[x, y] != Color.BLACK:\n                # Draw a line from (x, y) towards the anchor (anchor_x, anchor_y)\n                dx = np.sign(anchor_x - x)\n                dy = np.sign(anchor_y - y)\n\n                # Move towards the anchor\n                curr_x, curr_y = x, y\n                while (0 \u003c= curr_x \u003c input_grid.shape[0]) and (0 \u003c= curr_y \u003c input_grid.shape[1]):\n                    # Stop if we hit the anchor\n                    if (curr_x, curr_y) == (anchor_x, anchor_y):\n                        break\n\n                    # If we encounter another colored pixel, stop and change it to orange\n                    if output_grid[curr_x, curr_y] != Color.BLACK and (curr_x, curr_y) != (x, y):\n                        output_grid[curr_x, curr_y] = Color.ORANGE\n                        break\n\n                    # Move towards the anchor\n                    curr_x += dx\n                    curr_y += dy\n\n                # Finally color the pixel we started from with yellow if it is not already colored\n                if output_grid[x, y] != Color.ORANGE:\n                    output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter some colored pixels\n    num_pixels = np.random.randint(5, 15)\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.BLUE])\n        grid[x, y] = color\n    \n    # Place one blue pixel as the anchor\n    anchor_x, anchor_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[anchor_x, anchor_y] = Color.BLUE\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/12/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/12/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/12/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/12/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/12/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/12/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/12/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/12/images/train_output_2.png"}]}, "index": 12, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, holes, fitting, topology, counting\n\n# description:\n# In the input, you will see multiple blue rectangular objects, each with a black hole inside of it. \n# There are also several red objects that are exactly the same size as each hole. \n# To make the output, check if each red object perfectly fits inside the black hole inside a blue object. \n# If it does, place it inside the hole. If it doesn\u0027t, leave it where it is.\n\ndef main(input_grid):\n    # Parse, separating blue objects from other objects\n    blue_input = input_grid.copy()\n    blue_input[input_grid != Color.BLUE] = Color.BLACK\n    blue_objects = find_connected_components(blue_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Get the black regions (holes) inside the blue objects\n    interior_black_holes = [object_interior(obj, background=Color.BLACK) \u0026 (obj == Color.BLACK) for obj in blue_objects]\n\n    # Now we need to find red objects that might fit into these holes\n    red_input = input_grid.copy()\n    red_input[input_grid != Color.RED] = Color.BLACK\n    red_objects = find_connected_components(red_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    output_grid = np.copy(input_grid)\n\n    # Check if each red object can fit into a black hole\n    for red_obj in red_objects:\n        red_mask = red_obj != Color.BLACK\n        red_shape = red_obj.shape\n        \n        for black_hole_mask in interior_black_holes:\n            hole_shape = black_hole_mask.shape\n            \n            # Check if the shapes match\n            if red_shape == hole_shape:\n                # Remove the red object from its original location\n                output_grid[red_mask] = Color.BLACK\n                \n                # Place the red object into the black hole\n                black_hole_coords = np.argwhere(black_hole_mask)\n                if black_hole_coords.size \u003e 0:\n                    top_left_x, top_left_y = black_hole_coords[0]  # Get the position of the first pixel of the hole\n                    blit_sprite(output_grid, red_obj, top_left_x, top_left_y, background=Color.BLACK)\n                break  # Move to the next red object after placing it\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 25, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    n_blue_objects = np.random.randint(1, 4)\n    for _ in range(n_blue_objects):\n        blue_width, blue_height = np.random.randint(5, 8, size=2)\n        blue_sprite = np.full((blue_width, blue_height), Color.BLUE)\n\n        # Create a black hole inside the blue object\n        hole_width, hole_height = np.random.randint(1, blue_width-2), np.random.randint(1, blue_height-2)\n        hole_sprite = random_sprite(hole_width, hole_height, color_palette=[Color.BLACK], background=Color.BLUE, symmetry=\"not_symmetric\")\n\n        hole_x, hole_y = random_free_location_for_sprite(blue_sprite, hole_sprite, border_size=1, background=Color.BLUE)\n        blit_sprite(blue_sprite, hole_sprite, hole_x, hole_y, background=Color.BLUE)\n\n        # Place the blue object in the input grid\n        x, y = random_free_location_for_sprite(input_grid, blue_sprite, padding=1, border_size=1)\n        blit_sprite(input_grid, blue_sprite, x, y, background=Color.BLACK)\n\n        # Create a corresponding red object to fit into the hole\n        red_sprite = np.full((hole_width, hole_height), Color.RED)\n        x, y = random_free_location_for_sprite(input_grid, red_sprite, padding=1, border_size=1)\n        blit_sprite(input_grid, red_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/13/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/13/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/13/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/13/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/13/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/13/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/13/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/13/images/train_output_2.png"}]}, "index": 13, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, color expansion\n\n# description:\n# In the input grid, you will see several alternating colored stripes (horizontally or vertically) with repeated patterns.\n# To create the output grid, you should identify any translational symmetries, expand the grid to twice its height,\n# and repeat the original pattern in the new space while changing the colors.\n# The original colors should change to their complementary colors.\n# For example, blue becomes orange, red becomes teal, etc.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the translational symmetry in the input grid.\n    # 2. Create an output grid that is twice the height of the input grid.\n    # 3. Copy the original pattern into the new grid and apply color transformations.\n\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[], background=Color.BLACK)\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # Create the output grid with twice the height of the input grid\n    output_grid = np.full((2 * input_grid.shape[0], input_grid.shape[1]), Color.BLACK)\n\n    # Copy the input grid into the output grid and apply color transformations\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Copy original pixel to output\n        output_grid[x, y] = input_grid[x, y]\n\n        # Apply color transformation to the complementary color\n        transformed_color = transform_color(input_grid[x, y])\n        output_grid[x + input_grid.shape[0], y] = transformed_color\n    \n    return output_grid\n\ndef transform_color(color):\n    \"\"\"\n    Transform the color to its complementary color.\n    This is a simple mapping; feel free to expand or change based on your color palette.\n    \"\"\"\n    color_mapping = {\n        Color.BLUE: Color.ORANGE,\n        Color.RED: Color.TEAL,\n        Color.GREEN: Color.MAROON,\n        Color.YELLOW: Color.PINK,\n        Color.GREY: Color.YELLOW,  # Example mapping, can change as needed\n        # Add more mappings as necessary\n    }\n    \n    return color_mapping.get(color, color)  # Return the original color if no mapping exists\n\ndef generate_input():\n    # Generate a grid with random size\n    width = np.random.randint(8, 30)\n    height = np.random.randint(5, 15)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Decide on how many stripes to create\n    num_stripes = np.random.randint(2, 6)\n    \n    stripe_height = height // num_stripes\n    for i in range(num_stripes):\n        color = np.random.choice([Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW])\n        start_row = i * stripe_height\n        end_row = (i + 1) * stripe_height if i != num_stripes - 1 else height\n        grid[start_row:end_row, :] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/14/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/14/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/14/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/14/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/14/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/14/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/14/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/14/images/train_output_2.png"}]}, "index": 14, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, shape detection, color matching\n\n# description:\n# In the input grid, you will find several shapes of various colors. Two of the shapes will have the same geometric form but different sizes and colors. The output should include the smaller shape scaled up to the size of the larger shape, while retaining its original color.\n\ndef main(input_grid):\n    # Determine the background color\n    colors = np.unique(input_grid)\n    background = colors[np.argmax([np.sum(input_grid == c) for c in colors])]\n    object_colors = [c for c in colors if c != background]\n\n    # Extract objects by color\n    objects = []\n    for color in object_colors:\n        object_mask = np.copy(input_grid)\n        object_mask[input_grid != color] = background\n        objects.append(object_mask)\n\n    output_grid_candidates = []\n    \n    # Compare all pairs of objects\n    for i in range(len(objects)):\n        for j in range(i + 1, len(objects)):\n            obj1 = objects[i]\n            obj2 = objects[j]\n\n            # Get the shapes of the objects after cropping\n            shape1 = crop(obj1, background=background)\n            shape2 = crop(obj2, background=background)\n\n            # Compare sizes\n            if np.sum(shape1 != background) \u003c np.sum(shape2 != background):\n                # If shape1 is smaller, scale it to the size of shape2\n                scaled_shape = scale_sprite(shape1, factor=int(np.sqrt(np.sum(shape2 != background) / np.sum(shape1 != background))))\n                output_grid_candidates.append(scaled_shape)\n            elif np.sum(shape1 != background) \u003e np.sum(shape2 != background):\n                # If shape2 is smaller, scale it to the size of shape1\n                scaled_shape = scale_sprite(shape2, factor=int(np.sqrt(np.sum(shape1 != background) / np.sum(shape2 != background))))\n                output_grid_candidates.append(scaled_shape)\n\n    # Check if the generated input grid is valid\n    assert len(output_grid_candidates) == 1, f\"Should only have one output grid candidate, have {len(output_grid_candidates)}\"\n\n    # Create a grid to return the output\n    output_grid = np.full(input_grid.shape, background)\n    # Place the scaled shape in the output grid\n    output_grid[:output_grid_candidates[0].shape[0], :output_grid_candidates[0].shape[1]] = output_grid_candidates[0]\n\n    return output_grid\n\ndef generate_input():\n    # Create a background color and two distinct colors for our shapes\n    background, color1, color2 = np.random.choice(Color.NOT_BLACK, 3, replace=False)\n\n    # Create a grid with the background color\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), background)\n\n    # Generate two different sized sprites\n    n1, m1 = np.random.randint(3, 6), np.random.randint(3, 6)\n    n2, m2 = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    sprite1 = random_sprite(n=n1, m=m1, color_palette=[color1], background=background)\n    sprite2 = random_sprite(n=n2, m=m2, color_palette=[color2], background=background)\n\n    # Place the sprites in the grid\n    # Ensure the sprites do not overlap and are placed correctly\n    try:\n        x1, y1 = random_free_location_for_sprite(grid=grid, sprite=sprite1, background=background)\n        blit_sprite(grid=grid, sprite=sprite1, x=x1, y=y1)\n\n        x2, y2 = random_free_location_for_sprite(grid=grid, sprite=sprite2, background=background)\n        blit_sprite(grid=grid, sprite=sprite2, x=x2, y=y2)\n\n        # Check if the generated grid is valid\n        main(grid)\n    except:\n        return generate_input()\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/15/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/15/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/15/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/15/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/15/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/15/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/15/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/15/images/train_output_2.png"}]}, "index": 15, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision detection, moving objects, counting, color correspondence\n\n# description:\n# In the input, you will see a 10x10 grid filled with colored squares. Each square can contain 1-4 colors.\n# To create the output grid, you should move each colored square to the right until it touches the next square of the same color.\n# If a colored square doesn\u0027t have any square of the same color to the right, it should be removed from the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find connected components in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Move each square until it touches the next square of the same color\n    for obj in objects:\n        color = np.unique(obj[obj != Color.BLACK])[0]  # Get the color of the square\n        \n        # Check the bounding box of the object\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        \n        # Determine the furthest right position where we can place this object\n        furthest_x = x\n        for dx in range(1, input_grid.shape[1] - (x + w) + 1):  # Try to move to the right\n            new_x = x + dx\n            \n            # Create a translated version of the object\n            new_object_position = np.full_like(input_grid, Color.BLACK)\n            blit_sprite(new_object_position, obj, new_x, y, background=Color.BLACK)\n            \n            if not contact(object1=input_grid, object2=new_object_position, x2=new_x, y2=y):\n                furthest_x = new_x  # Update furthest position if it doesn\u0027t touch\n            \n            else:\n                break  # Stop if it touches any object\n\n        # Place the object in the output grid at the furthest position found\n        blit_sprite(output_grid, obj, furthest_x, y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    grid = np.full((10, 10), Color.BLACK)\n    num_squares = np.random.randint(5, 10)  # Randomly generating between 5 to 10 squares\n\n    for _ in range(num_squares):\n        # Create a random square of size 2x2 containing 1-4 colors\n        square_size = 2\n        square_colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(1, 5), replace=False)\n        square = random_sprite(square_size, square_size, density=1.0, color_palette=square_colors)\n\n        # Randomly find a free location for the square\n        x, y = random_free_location_for_sprite(grid, square, padding=1)\n        blit_sprite(grid, square, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/16/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/16/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/16/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/16/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/16/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/16/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/16/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/16/images/train_output_2.png"}]}, "index": 16, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, region coloring, pattern detection\n\n# description:\n# In the input, you will see a grid with a random pattern of two colors (red and blue) separated by black regions.\n# The task is to identify the connected regions of red and blue and to fill every second region starting from the first red region with green.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find connected components of red regions\n    red_regions = find_connected_components(input_grid == Color.RED, background=Color.BLACK)\n    # Find connected components of blue regions\n    blue_regions = find_connected_components(input_grid == Color.BLUE, background=Color.BLACK)\n\n    # Merge red and blue regions together to process every second region\n    combined_regions = red_regions + blue_regions\n\n    # Color every second region green starting from the first red region\n    for i, region in enumerate(combined_regions):\n        if i % 2 == 0:  # Color every second region\n            # Get a coordinate in the region to fill\n            x, y = np.where(region == True)\n            flood_fill(output_grid, x[0], y[0], Color.GREEN)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    height = np.random.randint(10, 21)\n    width = np.random.randint(10, 21)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly draw red and blue regions\n    for _ in range(np.random.randint(3, 7)):  # Random number of regions\n        color = np.random.choice([Color.RED, Color.BLUE])\n        # Generate random size for the region\n        region_height = np.random.randint(1, 5)\n        region_width = np.random.randint(1, 5)\n        # Random position for the region\n        x = np.random.randint(0, height - region_height)\n        y = np.random.randint(0, width - region_width)\n        \n        # Fill the region with the chosen color\n        for i in range(region_height):\n            for j in range(region_width):\n                grid[x + i, y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/17/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/17/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/17/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/17/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/17/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/17/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/17/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/17/images/train_output_2.png"}]}, "index": 17, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid transformation, bounding box, color inversion\n\n# description:\n# In the input, you\u0027ll see a grid containing a colored pattern (a collection of pixels).\n# To make the output, first, find the bounding box of the colored pixels, then invert the colors of the pixels within this bounding box.\n# Finally, replace the original grid with the transformed area, leaving the rest of the grid unchanged.\n\ndef main(input_grid):\n    # 1. Find the bounding box of the colored pixels\n    bounding_box = bounding_box_mask(input_grid, background=Color.BLACK)\n    \n    # 2. Create an output grid that is identical to the input grid\n    output_grid = input_grid.copy()\n\n    # 3. Invert the colors within the bounding box\n    for x in range(bounding_box.shape[0]):\n        for y in range(bounding_box.shape[1]):\n            if bounding_box[x, y]:\n                # Get the current color\n                current_color = input_grid[x, y]\n                # Invert the color: if it\u0027s not black, set it to black, otherwise set it to a random color\n                if current_color != Color.BLACK:\n                    output_grid[x, y] = Color.BLACK\n                else:\n                    output_grid[x, y] = Color.RED  # Example of replacing black with a specific color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly determine the number of colored pixels\n    num_colored_pixels = np.random.randint(1, width * height // 2)\n    \n    # Randomly color some pixels in the grid\n    for _ in range(num_colored_pixels):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/18/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/18/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/18/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/18/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/18/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/18/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/18/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/18/images/train_output_2.png"}]}, "index": 18, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, bounding box manipulation\n\n# description:\n# In the input you will see a grid with several colored shapes. Each shape consists of a single color except for a central pixel that is grey.\n# To make the output grid, you should translate each shape to the center of the grid, while maintaining the central grey pixel in the same relative position within its shape.\n# The output grid should be as small as possible, containing all the translated shapes.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all the objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Calculate the center of the output grid\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n        \n        # Crop the object to only get the relevant part\n        cropped_object = crop(obj, background=Color.BLACK)\n\n        # Find the position of the grey pixel in the cropped object\n        grey_pixel_position = np.argwhere(cropped_object == Color.GREY)[0]\n\n        # Calculate the translation offsets to center the object around the output grid center\n        translate_x = center_x - (y + grey_pixel_position[0])\n        translate_y = center_y - (x + grey_pixel_position[1])\n\n        # Translate the object\n        translated_object = translate(cropped_object, x=translate_x, y=translate_y, background=Color.BLACK)\n\n        # Blit the translated object onto the output grid\n        output_grid = blit_object(output_grid, translated_object, background=Color.BLACK)\n\n    # Crop the output grid to the smallest bounding box containing all objects\n    output_grid = crop(output_grid)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a number of shapes\n    for _ in range(np.random.randint(3, 6)):\n        # Generate a random shape with a grey center pixel\n        width, height = np.random.randint(3, 6), np.random.randint(3, 6)\n        shape = random_sprite(n=width, m=height, density=0.5, color_palette=[Color.RED], symmetry=\"not_symmetric\")\n        \n        # Set the center pixel to grey\n        center_x, center_y = width // 2, height // 2\n        shape[center_x, center_y] = Color.GREY\n\n        # Find a free location for this shape on the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=shape, padding=1)\n\n        # Blit the shape to the grid\n        blit_sprite(grid=grid, sprite=shape, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/19/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/19/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/19/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/19/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/19/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/19/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/19/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/19/images/train_output_2.png"}]}, "index": 19, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color correspondence, vertical and horizontal alignment, position detection\n\n# description:\n# In the input, you will see a grid consisting of colored pixels arranged in various shapes. \n# To create the output, fill a new grid based on the positions of the colored shapes. \n# If a shape is in the left half of the input grid, the corresponding position in the output grid should be filled with its color. \n# If a shape is in the right half of the input grid, the corresponding position in the output grid should be filled with the background color.\n\ndef main(input_grid):\n    # Create an output grid with the same shape as input but filled with background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n\n    # Iterate through each detected object\n    for obj in objects:\n        # Get the position of the object\n        x, y = object_position(obj, background=Color.BLACK, anchor=\"upper left\")\n        width, height = obj.shape\n\n        # Determine the horizontal center of the input grid\n        input_width = input_grid.shape[1]\n        mid_x = input_width // 2\n\n        # Check if the object is in the left or right half of the input grid\n        if x \u003c mid_x:\n            # Fill the corresponding area in the output grid with the object\u0027s color\n            blit_sprite(output_grid, obj, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Randomly create a number of objects\n    num_objects = np.random.randint(3, 7)\n    for _ in range(num_objects):\n        # Randomly select position and size for each object\n        obj_width = np.random.randint(1, 4)\n        obj_height = np.random.randint(1, 4)\n        x = np.random.randint(0, m - obj_width)\n        y = np.random.randint(0, n - obj_height)\n        \n        # Random color for the object\n        color = np.random.choice(Color.NOT_BLACK)\n        \n        # Draw the object in the grid\n        for i in range(obj_height):\n            for j in range(obj_width):\n                grid[y + i, x + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/20/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/20/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/20/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/20/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/20/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/20/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/20/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/20/images/train_output_2.png"}]}, "index": 20, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding boxes, transformations, color changing\n\n# description:\n# In the input, you will see a grid containing several green rectangles. \n# Each rectangle has a different width and height. \n# The goal is to transform the grid such that each rectangle is replaced with a red rectangle of the same size, \n# and then color the area that was previously occupied by the green rectangles in blue.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all green rectangles in the grid\n    green_objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n\n    for green_object in green_objects:\n        # Get the bounding box of the green object\n        x, y, w, h = bounding_box(green_object, background=Color.BLACK)\n\n        # Create a red rectangle of the same size\n        red_rectangle = np.full((w, h), Color.RED)\n\n        # Blit the red rectangle onto the output grid\n        blit_sprite(output_grid, red_rectangle, x, y, background=Color.BLACK)\n\n        # Color the area where the green rectangle was in blue\n        output_grid[x:x+w, y:y+h] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_rectangles = np.random.randint(3, 6)\n\n    for _ in range(num_rectangles):\n        width, height = np.random.randint(1, 5), np.random.randint(1, 5)\n        green_rectangle = np.full((width, height), Color.GREEN)\n\n        # Find a random free location to place the green rectangle\n        x, y = random_free_location_for_sprite(grid, green_rectangle, background=Color.BLACK)\n\n        # Blit the green rectangle onto the grid\n        blit_sprite(grid, green_rectangle, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/21/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/21/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/21/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/21/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/21/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/21/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/21/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/21/images/train_output_2.png"}]}, "index": 21, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel connection, border detection\n\n# description:\n# In the input you will see a grid with various colored pixels and black background.\n# To make the output, retain only the colored pixels that are connected to at least one other colored pixel.\n# This means that isolated colored pixels should be removed, leaving only groups of connected colors.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    for x, y in colored_pixels:\n        # Create an object for the current pixel\n        obj = np.full(input_grid.shape, Color.BLACK)\n        obj[x, y] = input_grid[x, y]\n\n        # Find the neighbors of this object\n        neighbors_mask = object_neighbors(obj, connectivity=4, background=Color.BLACK)\n\n        # Check if there are colored neighbors\n        if np.any(input_grid[neighbors_mask] != Color.BLACK):\n            # If it has at least one colored neighbor, keep this pixel\n            output_grid[x, y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colored pixels\n    num_pixels = np.random.randint(20, 50)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=True)\n\n    # Randomly place colored pixels in the grid\n    for color in colors:\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/22/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/22/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/22/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/22/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/22/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/22/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/22/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/22/images/train_output_2.png"}]}, "index": 22, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, boundary collision\n\n# description:\n# In the input you will see a set of colored pixels located in various spots on the grid.\n# To make the output, reflect each colored pixel across the nearest edge of the grid,\n# ensuring that each reflected pixel lands on the grid without going out of bounds.\n\ndef main(input_grid):\n    # Create an output grid that is a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    height, width = input_grid.shape\n\n    # Iterate through each pixel in the input grid\n    for x in range(height):\n        for y in range(width):\n            # Only process non-black pixels\n            if input_grid[x, y] != Color.BLACK:\n                # Reflect the pixel across the nearest edge\n                reflected_x = x\n                reflected_y = y\n                \n                # Reflect across the top edge\n                if x \u003c height // 2:\n                    reflected_x = -x - 1\n                # Reflect across the bottom edge\n                elif x \u003e= height // 2:\n                    reflected_x = height - 1 - x\n                \n                # Reflect across the left edge\n                if y \u003c width // 2:\n                    reflected_y = -y - 1\n                # Reflect across the right edge\n                elif y \u003e= width // 2:\n                    reflected_y = width - 1 - y\n\n                # Ensure the reflected coordinates are within bounds\n                reflected_x = max(0, min(height - 1, reflected_x))\n                reflected_y = max(0, min(width - 1, reflected_y))\n                \n                # Place the reflected pixel in the output grid\n                output_grid[reflected_x, reflected_y] = input_grid[x, y]\n\n    # Use blit_object to make sure all non-black pixels are drawn correctly\n    for x in range(height):\n        for y in range(width):\n            if output_grid[x, y] != Color.BLACK:\n                blit_object(output_grid, output_grid[x:y], background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid of random size between 10x10 and 15x15\n    height, width = np.random.randint(10, 16, size=2)\n    grid = np.zeros((height, width), dtype=int)\n\n    # Randomly decide how many colored pixels to generate\n    num_pixels = np.random.randint(5, 15)\n\n    # Place the colored pixels randomly within the grid\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, height), np.random.randint(0, width)\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.BLACK])\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/23/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/23/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/23/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/23/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/23/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/23/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/23/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/23/images/train_output_2.png"}]}, "index": 23, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirror symmetry, translation, background color change\n\n# description:\n# In the input, you will see a pattern with a designated color object surrounded by a specified background color.\n# To create the output, you need to mirror the main object across the vertical axis of symmetry \n# and then translate the mirrored object to cover the background area. Finally, change the background color.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the main object and the background.\n    # 2. Compute the axis of symmetry for mirroring.\n    # 3. Mirror the object across the axis of symmetry.\n    # 4. Translate the mirrored object to cover the background.\n    # 5. Change the background color in the output grid.\n\n    # 1. Identify objects\n    background_color = Color.BLACK\n    objects = find_connected_components(input_grid, connectivity=8, background=background_color)\n    assert len(objects) == 1, \"There should be exactly one main object\"\n    \n    main_object = objects[0]\n\n    # 2. Find the coordinates for the symmetry axis\n    x1, y1 = object_position(main_object, anchor=\"upper left\")\n    x2, y2 = object_position(main_object, anchor=\"lower right\")\n    \n    # Calculate the center of the object for mirroring\n    center_x = (x1 + x2) / 2\n    \n    # 3. Mirror the object across the vertical axis of symmetry\n    output_grid = np.full_like(input_grid, background_color)\n    \n    # Create a mirror symmetry object\n    symmetry = MirrorSymmetry(mirror_x=center_x, mirror_y=None)\n    \n    # 4. Mirror and place the object\n    for x, y in np.argwhere(main_object != background_color):\n        mirrored_x, mirrored_y = symmetry.apply(x, y)\n        if 0 \u003c= mirrored_x \u003c output_grid.shape[0] and 0 \u003c= mirrored_y \u003c output_grid.shape[1]:\n            output_grid[mirrored_x, mirrored_y] = main_object[x, y]\n    \n    # 5. Translate the mirrored object to cover the background\n    translated_object = translate(main_object, x=int(center_x) - x1, y=0, background=background_color)\n    for x, y in np.argwhere(translated_object != background_color):\n        output_grid[x, y] = translated_object[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid and add a main object with a specific color\n    grid = np.full((random.randint(15, 30), random.randint(15, 30)), Color.BLACK)\n    \n    # Generate the main object\n    object_color = random.choice(Color.NOT_BLACK)\n    main_object = random_sprite(random.randint(3, 6), random.randint(3, 6), color_palette=[object_color])\n\n    # Place the main object in the grid\n    x, y = random_free_location_for_sprite(grid, main_object, border_size=3)\n    grid = blit_sprite(grid, main_object, x, y)\n\n    # Randomly rotate the grid to create different orientations\n    grid = np.rot90(grid, random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/24/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/24/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/24/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/24/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/24/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/24/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/24/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/24/images/train_output_2.png"}]}, "index": 24, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# border detection, pattern transformation, pixel manipulation\n\n# description:\n# In the input, you will see a grid with various colored pixel shapes. Each shape has a border of black pixels.\n# To create the output grid, you should find the outer border of each shape, and then fill in the inner area with the same color as the border pixels.\n# Additionally, the black border itself should be removed from the output.\n\ndef main(input_grid):\n    # Step 1: Find connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    \n    # Create an output grid with the same shape as the input, initially filled with black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    for shape in shapes:\n        # Step 2: Detect the color of the shape\n        shape_color = object_colors(shape)[0]\n\n        # Step 3: Find the border pixels of the shape\n        border_mask = object_neighbors(shape, background=Color.BLACK)\n\n        # Step 4: Fill the inner area of the shape with the shape\u0027s color\n        for x in range(input_grid.shape[0]):\n            for y in range(input_grid.shape[1]):\n                if shape[x, y] == shape_color and not border_mask[x, y]:\n                    output_grid[x, y] = shape_color\n                elif border_mask[x, y]:\n                    output_grid[x, y] = shape_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random shapes\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n    \n    # Randomly create several shapes\n    num_shapes = np.random.randint(1, 5)  # Number of shapes to create\n    for _ in range(num_shapes):\n        shape_color = np.random.choice(Color.NOT_BLACK)\n        shape_size = np.random.randint(2, 5)\n\n        # Create a shape (e.g., a filled rectangle) with a black border\n        start_x = np.random.randint(0, width - shape_size)\n        start_y = np.random.randint(0, height - shape_size)\n\n        # Draw a shape with a black border\n        for x in range(shape_size):\n            for y in range(shape_size):\n                if x == 0 or x == shape_size - 1 or y == 0 or y == shape_size - 1:\n                    grid[start_x + x, start_y + y] = Color.BLACK\n                else:\n                    grid[start_x + x, start_y + y] = shape_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/25/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/25/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/25/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/25/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/25/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/25/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/25/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/25/images/train_output_2.png"}]}, "index": 25, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color boundary transformation\n\n# description:\n# In the input, you will see a grid with several colored shapes on a black background. Some of the shapes will touch the edges of the grid, while others will be fully surrounded by the black background. \n# To create the output grid, you should change the colors of the shapes that are fully surrounded (not touching the edges) to a new color, while keeping the colors of the boundary shapes unchanged.\n\ndef main(input_grid):\n    # Detect all connected components in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    output_grid = np.copy(input_grid)\n\n    # Define the new color for the surrounded shapes\n    new_color = Color.RED  # Change this to any color you\u0027d like to use for surrounded shapes\n\n    for component in components:\n        # Check if the component is touching the grid boundary\n        if not np.any(np.argwhere(component)[:, 0] == 0) and not np.any(np.argwhere(component)[:, 0] == input_grid.shape[0] - 1) and \\\n           not np.any(np.argwhere(component)[:, 1] == 0) and not np.any(np.argwhere(component)[:, 1] == input_grid.shape[1] - 1):\n            # If it is not touching the boundary, change its color to the new color\n            output_grid[component != Color.BLACK] = new_color\n            \n    return output_grid\n\ndef generate_input():\n    # Initialize a black grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter a few colored shapes on the grid, making sure some touch the boundary\n    shape_colors = random.sample(Color.NOT_BLACK, k=3)  # Choose 3 random colors for the shapes\n\n    # Create shapes and place them on the grid\n    for color in shape_colors:\n        for _ in range(np.random.randint(1, 4)):  # Create 1 to 3 shapes of each color\n            shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n            shape = np.full((shape_width, shape_height), color)\n            \n            # Place the shape on the grid, ensuring some are touching the boundary\n            if np.random.rand() \u003c 0.5:  # 50% chance to touch the boundary\n                x = np.random.choice([0, n - shape_width])  # Either top or bottom row\n                y = np.random.randint(0, m - shape_height)\n            else:\n                x, y = random_free_location_for_sprite(grid, shape, padding=1)\n                \n            blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/26/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/26/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/26/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/26/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/26/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/26/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/26/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/26/images/train_output_2.png"}]}, "index": 26, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, distance measurement\n\n# description:\n# In the input, you will see a grid with a black background and a few colored pixels scattered randomly.\n# The task is to draw lines from each colored pixel to the closest edge of the grid. \n# If the pixel is closer to the left or right edge, the line should go horizontally. \n# If the pixel is closer to the top or bottom edge, the line should go vertically. \n\ndef main(input_grid):\n    # Create a copy of the input grid to output the result\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    height, width = output_grid.shape\n\n    # Iterate through all pixels in the grid to find colored pixels\n    for x in range(height):\n        for y in range(width):\n            if output_grid[x, y] != Color.BLACK:  # Only consider colored pixels\n                # Determine the distances to each edge\n                distance_to_top = x\n                distance_to_bottom = height - 1 - x\n                distance_to_left = y\n                distance_to_right = width - 1 - y\n\n                # Determine which edge is closest\n                if distance_to_top \u003c= distance_to_bottom and distance_to_top \u003c= distance_to_left and distance_to_top \u003c= distance_to_right:\n                    # Closer to the top edge\n                    draw_line(output_grid, x, y, end_x=y, end_y=0, color=output_grid[x, y])\n                elif distance_to_bottom \u003c= distance_to_top and distance_to_bottom \u003c= distance_to_left and distance_to_bottom \u003c= distance_to_right:\n                    # Closer to the bottom edge\n                    draw_line(output_grid, x, y, end_x=y, end_y=height - 1, color=output_grid[x, y])\n                elif distance_to_left \u003c= distance_to_top and distance_to_left \u003c= distance_to_bottom and distance_to_left \u003c= distance_to_right:\n                    # Closer to the left edge\n                    draw_line(output_grid, x, y, end_x=0, end_y=x, color=output_grid[x, y])\n                else:\n                    # Closer to the right edge\n                    draw_line(output_grid, x, y, end_x=width - 1, end_y=x, color=output_grid[x, y])\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels on the grid\n    num_colored_pixels = np.random.randint(5, 15)\n    for _ in range(num_colored_pixels):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/27/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/27/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/27/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/27/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/27/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/27/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/27/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/27/images/train_output_2.png"}]}, "index": 27, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object translation, color transformation, grid manipulation\n\n# description:\n# In the input, you will see a grid containing a single red object and a grey outline around it.\n# To create the output, you should first change the color of the red object to blue,\n# then translate the object upward by two pixels while keeping the grey outline in place.\n\ndef main(input_grid):\n    # Find the single red object in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    red_objects = [obj for obj in objects if np.any(obj == Color.RED)]\n    \n    assert len(red_objects) == 1, \"There should be exactly one red object.\"\n    red_object = red_objects[0]\n\n    # Create a blank output grid with the same shape as the input\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change the color of the red object to blue\n    red_object[red_object != Color.BLACK] = Color.BLUE\n\n    # Translate the blue object upward by 2 pixels\n    translated_object = np.zeros_like(red_object)\n    for (x, y) in np.ndindex(red_object.shape):\n        if red_object[x, y] == Color.BLUE:\n            new_x = max(0, x - 2)  # Ensure it doesn\u0027t go out of bounds\n            translated_object[new_x, y] = Color.BLUE\n\n    # Blit the translated blue object onto the output grid\n    blit_object(output_grid, translated_object, background=Color.BLACK)\n\n    # Add the grey outline back in the original position\n    outline_x, outline_y, outline_width, outline_height = bounding_box(red_object)\n    output_grid[outline_x, outline_y:outline_y + outline_width] = Color.GREY\n    output_grid[outline_x + outline_height - 1, outline_y:outline_y + outline_width] = Color.GREY\n    output_grid[outline_x:outline_x + outline_height, outline_y] = Color.GREY\n    output_grid[outline_x:outline_x + outline_height, outline_y + outline_width - 1] = Color.GREY\n\n    return output_grid\n\ndef generate_input():\n    # Define the grid size\n    grid_size = np.random.randint(5, 10)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Create a random-sized red object\n    object_width = np.random.randint(1, grid_size - 2)\n    object_height = np.random.randint(1, grid_size - 2)\n    red_object = random_sprite(n=object_height, m=object_width, color_palette=[Color.RED], density=0.5)\n\n    # Place the red object in the grid with a grey outline\n    x, y = random_free_location_for_sprite(grid, red_object, border_size=1)\n    grid = blit_sprite(grid, red_object, x=x, y=y)\n\n    # Draw a grey outline around the red object\n    outline_x, outline_y, outline_width, outline_height = bounding_box(red_object)\n    grid[outline_x - 1:outline_x + outline_height + 1, outline_y - 1:outline_y + outline_width + 1] = Color.GREY\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/28/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/28/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/28/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/28/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/28/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/28/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/28/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/28/images/train_output_2.png"}]}, "index": 28, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, border detection, surrounding\n\n# description:\n# In the input, you will see a grid containing a single colored pixel surrounded by a black background. \n# The output should fill the area that is directly adjacent to the colored pixel with the same color.\n# If the colored pixel is already on the edge, then only the valid neighboring pixels should be filled.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Get the coordinates of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n    \n    # Get the color from the colored pixel\n    color = input_grid[x, y]\n\n    # Fill the neighboring pixels with the same color\n    neighbors = object_neighbors(input_grid, background=Color.BLACK, connectivity=4)\n    \n    # Fill the output grid with the color where there are neighbors\n    output_grid[neighbors] = color\n\n    # Set the original colored pixel in the output grid\n    output_grid[x, y] = color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size n x m with a black background\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place a single colored pixel in the grid\n    color = random.choice(list(Color.NOT_BLACK))\n    # Ensure the pixel is not on the border\n    x, y = np.random.randint(1, n-1), np.random.randint(1, m-1)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/29/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/29/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/29/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/29/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/29/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/29/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/29/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/29/images/train_output_2.png"}]}, "index": 29, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# drawing, filling, connected components\n\n# description:\n# In the input grid, you will see several disconnected gray shapes on a black background.\n# To create the output, draw a blue border around each gray shape and fill each shape with green.\n# Additionally, if a shape is surrounded by any gray shapes, fill it with yellow instead.\n\ndef main(input_grid):\n    # Step 1: Find all the gray shapes in the input grid\n    gray_shapes = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Step 2: Initialize the output grid with a black background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for shape in gray_shapes:\n        # Step 3: Draw a blue border around the gray shape\n        x, y, width, height = bounding_box(shape)\n        border_coordinates = [(x-1, y-1), (x+width, y-1), (x-1, y+height), (x+width, y+height)]\n        \n        # Draw top and bottom borders\n        draw_line(output_grid, x-1, y-1, x+width, y-1, color=Color.BLUE)\n        draw_line(output_grid, x-1, y+height, x+width, y+height, color=Color.BLUE)\n        \n        # Draw left and right borders\n        draw_line(output_grid, x-1, y-1, x-1, y+height, color=Color.BLUE)\n        draw_line(output_grid, x+width, y-1, x+width, y+height, color=Color.BLUE)\n\n        # Step 4: Fill the shape with green or yellow based on surrounding shapes\n        # Check for surrounding gray shapes\n        surrounding_shapes = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n        is_surrounded = any(np.any(shape == surrounding_shape) for surrounding_shape in surrounding_shapes if surrounding_shape is not shape)\n\n        # Fill with yellow if surrounded by gray shapes, otherwise fill with green\n        fill_color = Color.YELLOW if is_surrounded else Color.GREEN\n        shape[shape == Color.GREY] = fill_color  # Fill the shape with the chosen color\n\n        # Blit the filled shape back onto the output grid\n        blit_object(output_grid, shape, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Randomly generate gray shapes in the grid\n    # The number of shapes\n    num_shapes = np.random.randint(3, 6)\n\n    for _ in range(num_shapes):\n        # Generate a random sprite (shape) and place it on the grid\n        shape = random_sprite(n=list(range(2, 5)), m=list(range(2, 5)), density=0.5, color_palette=[Color.GREY])\n        \n        # Find a random free location for the shape\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n        \n        # Blit the shape onto the grid\n        grid = blit_sprite(grid, shape, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/30/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/30/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/30/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/30/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/30/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/30/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/30/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/30/images/train_output_2.png"}]}, "index": 30, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, boundary detection, filling\n\n# description:\n# In the input grid, you will see a shape made of colored pixels on a black background. \n# To produce the output, you need to find the boundary of the shape made by the colored pixels and fill the interior with a new color (orange).\n# The boundary pixels should remain unchanged.\n\ndef main(input_grid):\n    # Create an initial output grid based on input grid.\n    output_grid = input_grid.copy()\n\n    # Find the boundary of the colored pixels\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Fill the interior of the shape with orange\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # Check if the current pixel is not a boundary pixel and is not black\n            if not boundary_mask[x, y] and input_grid[x, y] != Color.BLACK:\n                output_grid[x, y] = Color.ORANGE\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a square grid of arbitrary size with a black background, size from 5x5 to 20x20\n    n = np.random.randint(5, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate a random shape with colored pixels\n    num_shapes = np.random.randint(1, 4)  # Number of shapes\n    for _ in range(num_shapes):\n        shape_width = np.random.randint(3, 7)\n        shape_height = np.random.randint(3, 7)\n        start_x = np.random.randint(0, n - shape_width)\n        start_y = np.random.randint(0, n - shape_height)\n\n        # Fill the shape area with a random color\n        color = np.random.choice(list(Color.NOT_BLACK))\n        for x in range(shape_width):\n            for y in range(shape_height):\n                if np.random.rand() \u003c 0.7:  # Randomly make some pixels colored\n                    grid[start_x + x, start_y + y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/31/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/31/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/31/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/31/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/31/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/31/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/31/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/31/images/train_output_2.png"}]}, "index": 31, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry restoration, color propagation\n\n# description:\n# In the input you will see a symmetric pattern of colors that has been partially occluded by a black rectangle.\n# The output should be the missing part of the pattern, filled in with the appropriate colors from the original symmetric pattern.\n# The output should have the same dimensions as the black rectangle, and restore the color symmetry.\n\ndef main(input_grid):\n    # Step 1: Identify the black rectangle that occludes part of the grid\n    occlusion_color = Color.BLACK\n    black_rectangle_mask = (input_grid == occlusion_color)\n\n    # Step 2: Detect the symmetries in the input grid (excluding the occlusion color)\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n\n    # Step 3: For each point in the black rectangle, find its symmetric points and restore the color\n    for occluded_x, occluded_y in np.argwhere(black_rectangle_mask):\n        for symmetric_x, symmetric_y in orbit(input_grid, occluded_x, occluded_y, symmetries):\n            if input_grid[symmetric_x, symmetric_y] != occlusion_color:\n                input_grid[occluded_x, occluded_y] = input_grid[symmetric_x, symmetric_y]\n                break\n\n    # Step 4: Extract the filled-in region that corresponds to the black rectangle\n    filled_in_region = np.full_like(input_grid, occlusion_color)\n    filled_in_region[black_rectangle_mask] = input_grid[black_rectangle_mask]\n    filled_in_region = crop(filled_in_region, background=occlusion_color)\n\n    return filled_in_region\n\ndef generate_input():\n    # Step 1: Create a random sprite\n    w, h = np.random.randint(2, 5, size=(2))\n    sprite = random_sprite(w, h, color_palette=Color.NOT_BLACK, density=1)\n\n    # Step 2: Tile the sprite to create a symmetric pattern\n    horizontal_repetitions, vertical_repetitions = np.random.randint(2, 5, size=(2))\n    pattern = np.tile(sprite, (horizontal_repetitions, vertical_repetitions))\n\n    # Step 3: Randomly occlude part of the pattern with a black rectangle\n    w_occluder, h_occluder = np.random.randint(2, 5, size=(2))\n    x_occluder, y_occluder = np.random.randint(0, pattern.shape[0] - w_occluder + 1), np.random.randint(0, pattern.shape[1] - h_occluder + 1)\n    black_rectangle_sprite = np.full((w_occluder, h_occluder), Color.BLACK)\n    blit_sprite(pattern, black_rectangle_sprite, x_occluder, y_occluder, background=None)\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/32/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/32/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/32/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/32/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/32/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/32/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/32/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/32/images/train_output_2.png"}]}, "index": 32, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, rotation, spatial transformation\n\n# description:\n# In the input grid, you will see a monochromatic pattern that is symmetric along the y-axis. \n# To make the output, rotate the pattern 90 degrees clockwise and maintain the symmetry.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the symmetric pattern along the y-axis.\n    # 2. Rotate the identified pattern 90 degrees clockwise.\n    # 3. Use blit_object to place the rotated pattern into the output grid.\n\n    # 1. Find connected components that are symmetric\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    assert len(objects) == 1, \"There should be exactly one symmetric object.\"\n    \n    symmetric_object = objects[0]\n    \n    # 2. Rotate the symmetric object 90 degrees clockwise\n    rotated_pattern = np.rot90(symmetric_object, k=-1)  # k = -1 for 90 degrees clockwise\n\n    # Create the output grid, which should have the same size as the input grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # 3. Use blit_object to place the rotated pattern into the output grid\n    blit_object(output_grid, rotated_pattern, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid of a symmetric monochromatic object\n    grid = np.full((np.random.randint(10, 20), np.random.randint(10, 20)), Color.BLACK)\n\n    # Generate a symmetric pattern\n    symmetric_sprite = random_sprite(range(3, 6), range(3, 6),\n                                     color_palette=[random.choice(Color.NOT_BLACK)], connectivity=4, \n                                     symmetry=\"vertical\")    \n\n    # Randomly place the symmetric object in the grid\n    x, y = random_free_location_for_sprite(grid, symmetric_sprite, background=Color.BLACK)\n    blit_sprite(grid, symmetric_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/33/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/33/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/33/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/33/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/33/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/33/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/33/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/33/images/train_output_2.png"}]}, "index": 33, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, object detection, color transformation\n\n# description:\n# In the input you will see a grid with a large blue frame and a small pattern in the center.\n# The output should be a new grid where the small pattern is scaled to fit inside the blue frame,\n# and the blue frame should be turned into green.\n\ndef main(input_grid):\n    # Detect the blue frame and the inner pattern\n    objects = detect_objects(input_grid, monochromatic=True, connectivity=8)\n    \n    # Initialize variables to store the frames and patterns\n    blue_frame = None\n    inner_pattern = None\n    \n    for obj in objects:\n        sprite = crop(obj, background=Color.BLACK)\n        colors = object_colors(sprite, background=Color.BLACK)\n        \n        if Color.BLUE in colors:\n            blue_frame = sprite\n        elif len(colors) \u003e 0:\n            inner_pattern = sprite\n    \n    # Calculate the scaling factor based on the size of the blue frame and the pattern\n    scale = (len(blue_frame) - 2) // len(inner_pattern)\n    \n    # Scale the inner pattern to fit into the blue frame\n    scaled_pattern = scale_sprite(inner_pattern, factor=scale)\n    \n    # Create the output grid, changing the blue frame to green\n    output_grid = np.full(blue_frame.shape, Color.BLACK)\n    output_grid[blue_frame == Color.BLUE] = Color.GREEN\n    \n    # Place the scaled pattern into the green frame\n    blit_sprite(output_grid, scaled_pattern, x=1, y=1, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a random size\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)    \n\n    # Create a blue frame around the grid\n    blue_frame_size = np.random.randint(3, 6) * 2 + 1  # Ensure it\u0027s odd to have a center\n    blue_frame = np.full((blue_frame_size, blue_frame_size), Color.BLUE)\n    blue_frame[1:-1, 1:-1] = Color.BLACK  # Inner part is black\n    \n    # Randomly place the blue frame in the grid\n    x_pos = np.random.randint(0, n - blue_frame_size)\n    y_pos = np.random.randint(0, m - blue_frame_size)\n    grid = blit_sprite(grid, blue_frame, x=x_pos, y=y_pos, background=Color.BLACK)\n\n    # Generate a small pattern inside the blue frame\n    inner_pattern_size = 3  # Fixed size for simplicity\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.BLUE]\n    random_color = np.random.choice(available_colors)\n\n    # Create a random pattern\n    inner_pattern = random_sprite(n=inner_pattern_size, m=inner_pattern_size, color_palette=[random_color], density=0.5)\n    \n    # Place the inner pattern in the center of the blue frame\n    center_x = x_pos + (blue_frame_size // 2) - (inner_pattern_size // 2)\n    center_y = y_pos + (blue_frame_size // 2) - (inner_pattern_size // 2)\n    grid = blit_sprite(grid, inner_pattern, x=center_x, y=center_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/34/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/34/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/34/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/34/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/34/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/34/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/34/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/34/images/train_output_2.png"}]}, "index": 34, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shapes, reflection, transformation\n\n# description:\n# In the input, you will see a grid consisting of various colored shapes.\n# The goal is to reflect each shape across the vertical axis of the grid and draw the mirrored shapes next to the originals.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (shapes) in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=Color.BLACK)\n\n    # Get the width of the input grid\n    input_width = input_grid.shape[1]\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj)\n\n        # Crop the object to extract the sprite\n        sprite = crop(obj)\n\n        # Calculate the position where the mirrored shape should be placed\n        mirror_x = input_width - (x + w)\n\n        # Use blit_sprite to place the mirrored sprite in the output grid\n        blit_sprite(output_grid, sprite, x=mirror_x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a blank grid\n    grid_width, grid_height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((grid_height, grid_width), Color.BLACK)\n\n    # Generate a number of random shapes\n    num_shapes = np.random.randint(3, 6)  # Number of shapes to create\n\n    for _ in range(num_shapes):\n        # Create a random shape (object)\n        shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Generate a random sprite\n        sprite = random_sprite(shape_width, shape_height, density=1, color_palette=[color])\n\n        # Find a random free position for the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n\n        # Blit the sprite onto the grid\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/35/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/35/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/35/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/35/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/35/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/35/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/35/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/35/images/train_output_2.png"}]}, "index": 35, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, connectivity, pattern drawing\n\n# description:\n# In the input, you will see a black grid with three colored pixels that form a triangle (one pixel at each vertex).\n# To make the output, you should fill the area inside the triangle formed by these pixels with a new color.\n# The pixels can be of any color, but the filled area should be a constant color (let\u0027s say blue).\n\ndef main(input_grid):\n    # 1. Find the three colored pixels that form the triangle.\n    colored_pixels = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n\n    # Ensure we have exactly three pixels\n    assert len(colored_pixels) == 3, \"The input must contain exactly three colored pixels forming a triangle.\"\n\n    # 2. Get the positions of the colored pixels\n    positions = [object_position(pixel, background=Color.BLACK) for pixel in colored_pixels]\n\n    # 3. Determine the bounding box of the triangle to limit the flood fill area\n    min_x = min(pos[0] for pos in positions)\n    max_x = max(pos[0] for pos in positions)\n    min_y = min(pos[1] for pos in positions)\n    max_y = max(pos[1] for pos in positions)\n\n    # 4. Create an output grid initialized to the input grid\n    output_grid = np.copy(input_grid)\n\n    # 5. Perform flood fill inside the bounding box, starting from one of the colored pixels\n    start_pixel = positions[0]\n    flood_fill(output_grid, start_pixel[0], start_pixel[1], Color.BLUE)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate the grid\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose three colors for the triangle vertices, ensuring they are distinct\n    colors = np.random.choice(Color.NOT_BLACK, size=3, replace=False)\n\n    # Randomly select three positions for the triangle vertices (ensuring they are distinct)\n    positions = set()\n    while len(positions) \u003c 3:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        positions.add((x, y))\n\n    # Place the colored pixels in the grid\n    for (x, y), color in zip(positions, colors):\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/36/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/36/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/36/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/36/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/36/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/36/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/36/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/36/images/train_output_2.png"}]}, "index": 36, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, bounding box, filling\n\n# description:\n# In the input, you will see a grid with a black background and a solid colored object in the center. \n# To make the output, first, find the bounding box of the colored object. \n# Then fill the area outside the bounding box with a new color while keeping the original color inside the bounding box unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find the bounding box of the colored object\n    # 2. Create a new grid filled with a new color\n    # 3. Copy the original object into the bounding box area of the new grid\n\n    # 1. Find the bounding box of the colored object\n    background = Color.BLACK\n    x, y, width, height = bounding_box(input_grid != background)\n\n    # 2. Create a new grid filled with a new color (for example, Color.BLUE)\n    output_grid = np.full_like(input_grid, Color.BLUE)\n\n    # 3. Copy the original object into the bounding box area of the new grid\n    output_grid[x:x+width, y:y+height] = input_grid[x:x+width, y:y+height]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Make a random grid with a solid colored object in the center\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose a color for the object that is not black\n    object_color = random.choice(Color.NOT_BLACK)\n\n    # Create a solid color object in the center\n    start_x = random.randint(2, 7)  # Ensure it fits within grid\n    start_y = random.randint(2, 7)  # Ensure it fits within grid\n    object_width = random.randint(2, 4)\n    object_height = random.randint(2, 4)\n\n    # Fill the object in the grid\n    grid[start_x:start_x+object_height, start_y:start_y+object_width] = object_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/37/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/37/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/37/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/37/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/37/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/37/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/37/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/37/images/train_output_2.png"}]}, "index": 37, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, topology, color transformation\n\n# description:\n# The input is a grid containing several colored squares, each having a \"hole\" represented by a contiguous black region of pixels.\n# To create the output, fill in the hole of each colored square with a color that corresponds to the original color of the square if the hole is a square.\n# If the hole is not a square, leave it as is.\n\ndef main(input_grid):\n    # Find all colored squares in the input grid (excluding black)\n    colored_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # For each colored square, check if it contains a square hole and fill it appropriately\n    for obj in colored_objects:\n        # Crop the object to analyze its content\n        sprite = crop(obj)\n        # Identify the interior of the object\n        hole_mask = (sprite == Color.BLACK) \u0026 (object_interior(sprite, background=Color.BLACK))\n        \n        # Check if the hole is square\n        def is_square(thing):\n            \"\"\"Determine if the thing is a square shape.\"\"\"\n            thing = crop(thing)\n            return np.sum(thing != Color.BLACK) == thing.shape[0] * thing.shape[1] and thing.shape[0] == thing.shape[1]\n\n        # Get the original object\u0027s color (assuming the object is monochromatic)\n        original_color = sprite[0, 0]  # Get the color of the top-left pixel\n        \n        if is_square(hole_mask):\n            # Fill the square hole with the original color\n            sprite[hole_mask] = original_color\n\n        # Get the location of the object in the original grid\n        x, y = object_position(obj, background=Color.BLACK)\n        # Blit the possibly modified sprite back to the output grid\n        blit_sprite(output_grid, sprite, x, y)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid that will contain colored squares with holes\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colored squares\n    num_squares = np.random.randint(2, 5)\n\n    for _ in range(num_squares):\n        # Random size for the square\n        size = np.random.randint(3, 6)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Try to find a random location for the square\n        try:\n            x, y = random_free_location_for_sprite(grid, np.full((size, size), color), padding=1)\n        except ValueError:\n            continue  # If no space found, skip to next iteration\n\n        # Place the colored square on the grid\n        blit_sprite(grid, np.full((size, size), color), x, y)\n\n        # Create a hole (contiguous black region) in the middle of the square\n        hole_size = np.random.randint(1, size - 1)\n        hole_x, hole_y = np.random.randint(1, size - hole_size), np.random.randint(1, size - hole_size)\n        grid[x + hole_x:x + hole_x + hole_size, y + hole_y:y + hole_y + hole_size] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/38/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/38/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/38/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/38/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/38/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/38/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/38/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/38/images/train_output_2.png"}]}, "index": 38, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, connections, noise filtering\n\n# description:\n# In the input you will see several colored pixels scattered across a black background. One color forms a closed boundary (like a simple polygon) while the others are random noise pixels. \n# To make the output, identify the closed boundary and fill it with a solid color. Noise pixels that touch the boundary should also be filled with the boundary color. \n# Noise pixels that do not touch the boundary should be erased.\n\ndef main(input_grid):\n    # Step 1: Find all connected components in the grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=Color.BLACK)\n\n    output_grid = np.copy(input_grid)\n\n    # Step 2: Identify the boundary color and fill the boundary\n    boundary_color = None\n    for obj in objects:\n        # Check if the object is a boundary (at least 4 pixels)\n        if np.sum(obj != Color.BLACK) \u003e= 4:\n            boundary_mask = object_neighbors(obj, connectivity=4, background=Color.BLACK)\n            if np.any(boundary_mask):\n                boundary_color = obj[obj != Color.BLACK][0]  # Get the color of the boundary\n                break\n\n    if boundary_color is not None:\n        # Step 3: Fill the boundary color and handle noise\n        for obj in objects:\n            obj_mask = obj != Color.BLACK\n            if np.sum(obj_mask) \u003e= 4:  # Only consider larger objects\n                neighbors = object_neighbors(obj, connectivity=4, background=Color.BLACK)\n                if np.any(neighbors):  # If neighbors exist\n                    output_grid[obj_mask] = boundary_color\n                else:  # If no neighbors, erase the noise\n                    output_grid[obj_mask] = Color.BLACK\n    \n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Generate a random color for the boundary\n    boundary_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a simple closed boundary\n    boundary_width, boundary_height = np.random.randint(5, 10), np.random.randint(5, 10)\n    x_start = np.random.randint(2, width - boundary_width - 2)\n    y_start = np.random.randint(2, height - boundary_height - 2)\n\n    # Draw a closed rectangle as the boundary\n    for x in range(x_start, x_start + boundary_width):\n        grid[x, y_start] = boundary_color\n        grid[x, y_start + boundary_height - 1] = boundary_color\n    for y in range(y_start, y_start + boundary_height):\n        grid[x_start, y] = boundary_color\n        grid[x_start + boundary_width - 1, y] = boundary_color\n\n    # Scatter noise pixels\n    noise_color = np.random.choice(Color.NOT_BLACK)\n    n_noise = np.random.randint(10, 20)\n    for _ in range(n_noise):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = noise_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/39/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/39/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/39/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/39/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/39/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/39/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/39/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/39/images/train_output_2.png"}]}, "index": 39, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, color blending, boundary detection\n\n# description:\n# In the input you will see a grid with a central pattern surrounded by a border of differently-colored pixels.\n# To make the output, you should extract the central pattern and change the colors of its pixels to match the average color of the surrounding border pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central pattern by detecting the surrounding border pixels\n    objects = find_connected_components(input_grid, monochromatic=False)\n    border_objects = [obj for obj in objects if object_colors(obj, background=Color.BLACK) != {Color.BLACK}]\n    \n    assert len(border_objects) \u003e 0, \"There should be at least one border object\"\n\n    # Determine the bounding box of the border\n    border_bbox = bounding_box(border_objects[0])\n    central_pattern = input_grid[border_bbox[0]+1:border_bbox[0]+border_bbox[2]-1, \n                                  border_bbox[1]+1:border_bbox[1]+border_bbox[3]-1]\n    \n    # Calculate the average color of the border pixels\n    border_colors = []\n    for obj in border_objects:\n        border_colors.extend(object_colors(obj, background=Color.BLACK))\n    \n    # Remove duplicates and count occurrences of each color\n    color_counts = {color: border_colors.count(color) for color in set(border_colors)}\n    # Get the average color, which we will use to color the central pattern\n    average_color = max(color_counts, key=color_counts.get)\n\n    # Create the output grid and fill the central pattern with the average color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[border_bbox[0]+1:border_bbox[0]+border_bbox[2]-1, \n                border_bbox[1]+1:border_bbox[1]+border_bbox[3]-1] = average_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid large enough to accommodate a central pattern and a surrounding border\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define the size of the central pattern\n    central_width, central_height = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    # Create a central pattern\n    central_pattern = random_sprite(central_width, central_height, density=0.5, \n                                     color_palette=list(Color.NOT_BLACK), background=Color.BLACK)\n\n    # Place the central pattern in the grid\n    x_center, y_center = np.random.randint(1, width - central_width - 1), np.random.randint(1, height - central_height - 1)\n    blit_sprite(grid, central_pattern, x=x_center, y=y_center)\n\n    # Create a border of differently-colored pixels\n    border_color = np.random.choice([color for color in Color.NOT_BLACK if color not in object_colors(central_pattern)])\n    \n    # Fill the border area\n    grid[x_center-1:x_center+central_width+1, y_center-1:y_center+central_height+1] = border_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/40/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/40/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/40/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/40/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/40/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/40/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/40/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/40/images/train_output_2.png"}]}, "index": 40, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, pattern matching, rectangular filling\n\n# description:\n# In the input you will see a non-black background with several colored squares and a larger gray rectangle.\n# To make the output, fill the gray rectangle with the colors of the squares that overlap with it, preserving the original positions of squares.\n\ndef main(input_grid):\n    # Identify the background color\n    background = max(Color.NOT_BLACK, key=lambda color: np.sum(input_grid == color))\n\n    # Detect the gray rectangle\n    gray_rectangle = detect_objects(grid=input_grid, colors=[Color.GRAY], monochromatic=True, connectivity=4)[0]\n    \n    # Get the bounding box of the gray rectangle\n    gray_x, gray_y, gray_w, gray_h = bounding_box(gray_rectangle)\n\n    # Create the output grid, initially filled with the background color\n    output_grid = np.full_like(input_grid, background)\n\n    # Detect colored squares in the input grid\n    colored_squares = detect_objects(grid=input_grid, monochromatic=True, connectivity=4, colors=Color.NOT_BLACK)\n    \n    for square in colored_squares:\n        # Get the position of the square\n        square_x, square_y, square_w, square_h = bounding_box(square)\n        \n        # Check for overlap with the gray rectangle\n        if (square_x \u003c gray_x + gray_w and square_x + square_w \u003e gray_x and\n            square_y \u003c gray_y + gray_h and square_y + square_h \u003e gray_y):\n            # Calculate the overlap area\n            overlap_x_start = max(square_x, gray_x)\n            overlap_y_start = max(square_y, gray_y)\n            overlap_x_end = min(square_x + square_w, gray_x + gray_w)\n            overlap_y_end = min(square_y + square_h, gray_y + gray_h)\n\n            # Fill the output grid with the color of the square in the overlap area\n            color = square[0, 0]  # Assuming square is monochromatic\n            for i in range(overlap_y_start, overlap_y_end):\n                for j in range(overlap_x_start, overlap_x_end):\n                    output_grid[i, j] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a non-black background and a gray rectangle\n    background_color = np.random.choice(Color.NOT_BLACK)\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), background_color)\n\n    # Draw a gray rectangle in the grid\n    rect_width, rect_height = np.random.randint(3, 7), np.random.randint(3, 7)\n    rect_x, rect_y = np.random.randint(0, width - rect_width), np.random.randint(0, height - rect_height)\n    gray_rectangle = np.full((rect_height, rect_width), Color.GRAY)\n    blit_sprite(grid, gray_rectangle, rect_x, rect_y, background=background_color)\n\n    # Randomly place colored squares in the grid\n    n_squares = np.random.randint(5, 10)\n    for _ in range(n_squares):\n        square_color = np.random.choice(Color.NOT_BLACK)\n        square_size = np.random.randint(1, 3)\n        square_sprite = np.full((square_size, square_size), square_color)\n        square_x, square_y = random_free_location_for_sprite(grid, square_sprite, background=background_color)\n        blit_sprite(grid, square_sprite, square_x, square_y, background=background_color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/41/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/41/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/41/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/41/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/41/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/41/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/41/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/41/images/train_output_2.png"}]}, "index": 41, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, translation, color change\n\n# description:\n# In the input you will see a grid with several blue objects scattered around. Each blue object is a cluster of connected pixels. \n# To make the output grid, you should move each blue object one pixel to the right and change its color to yellow. \n# Ensure that no two objects overlap after the translation.\n\ndef main(input_grid):\n    # Step 1: Extract all blue objects from the input grid\n    blue_objects = find_connected_components(input_grid, connectivity=8, monochromatic=True, background=Color.BLACK)\n    \n    # Step 2: Initialize an empty output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for blue_object in blue_objects:\n        # Step 3: Translate the blue object one pixel to the right\n        translated_object = translate(blue_object, x=1, y=0, background=Color.BLACK)\n\n        # Step 4: Change the color of the translated object to yellow\n        translated_object[translated_object != Color.BLACK] = Color.YELLOW\n\n        # Step 5: Check for collisions with existing objects in the output grid\n        if not collision(object1=output_grid, object2=translated_object):\n            # If no collision, blit the translated object onto the output grid\n            blit_object(output_grid, translated_object, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random dimensions\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate blue objects in the grid\n    num_objects = np.random.randint(2, 5)  # Generate between 2 to 4 blue objects\n    for _ in range(num_objects):\n        # Generate a sprite (object) with blue color\n        sprite = random_sprite(n=np.random.randint(2, 5), m=np.random.randint(2, 5), color_palette=[Color.BLUE], density=0.6)\n        \n        # Place the sprite randomly in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue  # Skip if no free location is found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/42/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/42/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/42/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/42/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/42/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/42/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/42/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/42/images/train_output_2.png"}]}, "index": 42, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, bounding box, connected components\n\n# description:\n# The input consists of a black grid divided by blue lines into multiple black rectangles. \n# In order to produce the output grid, fill in all the black rectangles that are at least 4x4 in size with orange, \n# while filling all the smaller rectangles with light green.\n\ndef main(input_grid):\n    # First, find all the black rectangles separated by blue lines\n    objects = find_connected_components(input_grid, background=Color.BLUE, connectivity=4)\n\n    # Create an output grid initialized to the input grid\n    output_grid = np.copy(input_grid)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj, background=Color.BLUE)\n\n        # Calculate the area of the rectangle\n        area = width * height\n\n        # Determine if it is a small or large rectangle\n        if width \u003e= 4 and height \u003e= 4:\n            # Fill large rectangles with orange\n            obj[obj == Color.BLACK] = Color.ORANGE\n        else:\n            # Fill smaller rectangles with light green\n            obj[obj == Color.BLACK] = Color.GREY\n\n        # Blit the modified object back into the output grid\n        blit_object(output_grid, obj, background=Color.BLUE)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_lines = np.random.randint(3, 15)\n\n    for i in range(num_lines):\n        # add a blue line to divide the grid somewhere\n        x, y = np.random.randint(2, n-1), np.random.randint(2, m-1)\n        # make sure we\u0027re not neighboring a blue line already\n        if Color.BLUE in [grid[x, y+1], grid[x, y-1], grid[x+1, y], grid[x-1, y]]:\n            continue\n\n        horizontal = np.random.choice([True, False])\n        if horizontal:\n            draw_line(grid, x, y, direction=(1, 0), color=Color.BLUE, stop_at_color=[Color.BLUE])\n            draw_line(grid, x-1, y, direction=(-1, 0), color=Color.BLUE, stop_at_color=[Color.BLUE])\n        else:\n            draw_line(grid, x, y, direction=(0, 1), color=Color.BLUE, stop_at_color=[Color.BLUE])\n            draw_line(grid, x, y-1, direction=(0, -1), color=Color.BLUE, stop_at_color=[Color.BLUE])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/43/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/43/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/43/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/43/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/43/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/43/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/43/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/43/images/train_output_2.png"}]}, "index": 43, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, circular pattern completion\n\n# description:\n# In the input, you will see a circular design that is partially complete. The design consists of pixels of different colors on a black background.\n# To make the output, find the center of the circular design and use the rotational symmetry to fill in missing pixels to complete the circular pattern.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the center of the circular design and find its symmetry.\n    # 2. Fill in missing pixels by rotating existing colored pixels around the center.\n\n    # Find the rotational symmetry\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Find the colored pixels (not black)\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Fill in missing parts by rotating existing colors\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        \n        # Loop over all rotations, going 90 degrees each time (so four times)\n        for i in range(1, 4):\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n\n            # Fill in the missing pixel if it is black\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n            else:\n                assert output_grid[rotated_x, rotated_y] == color, \"The pattern is not consistent with rotational symmetry\"\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a 20x20 grid\n    grid = np.zeros((20, 20), dtype=int)\n\n    # Create a circular sprite with some color pixels\n    radius = 8\n    center_x, center_y = 10, 10  # Center of the grid\n\n    for angle in range(0, 360, 30):  # Add pixels in a circular pattern\n        rad = np.radians(angle)\n        x = int(center_x + radius * np.cos(rad))\n        y = int(center_y + radius * np.sin(rad))\n\n        # Randomly fill the pixel with a color\n        if np.random.rand() \u003e 0.5:  # 50% chance to color the pixel\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly remove some pixels to create an incomplete design\n    for _ in range(15):  # Remove 15 random pixels\n        x, y = np.random.randint(0, 20), np.random.randint(0, 20)\n        grid[x, y] = Color.BLACK  # Set to black to simulate missing parts\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/44/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/44/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/44/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/44/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/44/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/44/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/44/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/44/images/train_output_2.png"}]}, "index": 44, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, merging, color transformation\n\n# description:\n# In the input you will see a grid with a grey rectangle and colored pixels scattered around it.\n# To make the output, move each colored pixel toward the grey rectangle until it touches. \n# If multiple colored pixels collide, they stack. Once they touch the grey rectangle, they merge into it, taking on the color of the pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the grey rectangle and colored pixels\n    # 2. Move each colored pixel towards the grey rectangle until they touch\n    # 3. Change the color of the pixel to grey upon touching, and merge it into the rectangle\n    \n    # Step 1: Find the grey object and other colored pixels\n    objects = find_connected_components(input_grid, connectivity=4)\n    grey_objects = [obj for obj in objects if Color.GREY in object_colors(obj)]\n    colored_objects = [obj for obj in objects if Color.GREY not in object_colors(obj)]\n\n    assert len(grey_objects) == 1, \"There should be exactly one grey rectangle\"\n    \n    grey_object = grey_objects[0]\n\n    # Create output grid starting as a black grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    blit_sprite(output_grid, grey_object, 0, 0)\n\n    # Step 2: Move the colored objects towards the grey rectangle\n    for colored_object in colored_objects:\n        # Move the colored object towards the grey rectangle until contact\n        moving = True\n        while moving:\n            # Check all possible displacements\n            possible_displacements = [(dx, dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1] if (dx, dy) != (0, 0)]\n            valid_displacements = []\n\n            for dx, dy in possible_displacements:\n                # Check potential new position\n                new_x = object_position(colored_object)[0] + dx\n                new_y = object_position(colored_object)[1] + dy\n                \n                # Check if the movement will cause contact with the grey rectangle\n                if contact(object1=translate(colored_object, dx, dy), object2=grey_object):\n                    valid_displacements.append((dx, dy))\n\n            if valid_displacements:\n                # Pick the first valid displacement and move\n                dx, dy = valid_displacements[0]\n                colored_object = translate(colored_object, dx, dy)\n                \n                # Stop moving if it has contacted the grey rectangle\n                if contact(object1=colored_object, object2=grey_object):\n                    # Change the color to grey to indicate merging\n                    colored_object[colored_object != Color.BLACK] = Color.GREY\n                    blit_sprite(output_grid, colored_object, 0, 0)  # Merge into grey rectangle\n                    moving = False\n            else:\n                moving = False  # No valid moves left, stop trying to move\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a grey rectangle and scattered colored pixels\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a horizontal grey rectangle in the middle\n    rectangle_y1 = height // 3\n    rectangle_y2 = 2 * height // 3\n    grid[:, rectangle_y1:rectangle_y2] = Color.GREY\n\n    # Scatter some colored pixels around the grey rectangle\n    for _ in range(np.random.randint(5, 15)):\n        random_color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.GREY])\n        pixel_sprite = np.full((1, 1), random_color)\n        x, y = random_free_location_for_sprite(grid, pixel_sprite, background=Color.BLACK)\n        blit_sprite(grid, pixel_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/45/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/45/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/45/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/45/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/45/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/45/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/45/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/45/images/train_output_2.png"}]}, "index": 45, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern translation, collision detection, grid manipulation\n\n# description:\n# In the input, you will see a grid with several colored shapes, each shape is a single color and consists of non-black pixels.\n# To create the output grid, translate each colored shape upwards until it collides with the pixel above it or the top edge of the grid.\n# The color of the shape should remain the same after translation.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # Find all connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    \n    # For each shape, attempt to translate it upwards until a collision occurs\n    for shape in shapes:\n        # Get the position and color of the shape\n        shape_x, shape_y = object_position(shape, background=Color.BLACK)\n        shape_color = object_colors(shape, background=Color.BLACK)[0]  # Assume monochromatic\n\n        # Try moving the shape upwards\n        while True:\n            # Check for potential new position (move up by one)\n            new_x, new_y = shape_x, shape_y - 1\n            \n            # Check if the new position is within the grid bounds\n            if new_y \u003c 0:\n                break  # Reached the top of the grid\n\n            # Check for collision with the current output grid\n            if collision(object1=output_grid, object2=shape, x1=shape_x, y1=shape_y, x2=new_x, y2=new_y):\n                break  # Collision detected, stop moving\n\n            # Move the shape to the new position in the output grid\n            blit_sprite(output_grid, shape, x=new_x, y=new_y, background=Color.BLACK)\n\n            # Update the current position to the new position\n            shape_x, shape_y = new_x, new_y\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a random size\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly determine how many shapes to create\n    num_shapes = np.random.randint(1, 5)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_shapes, replace=False)\n\n    for color in colors:\n        # Create a random shape of size between 1x1 and 4x4\n        shape_width, shape_height = np.random.randint(1, 5, size=2)\n        shape_sprite = np.full((shape_width, shape_height), color)\n\n        # Find a random location to place the shape, ensuring it fits in the grid\n        x, y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK)\n        blit_sprite(grid, shape_sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/46/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/46/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/46/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/46/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/46/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/46/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/46/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/46/images/train_output_2.png"}]}, "index": 46, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layer extraction, bounding box, color mapping\n\n# description:\n# In the input, you will see a grid of several layers of colored shapes, with each layer separated by a black background.\n# To produce the output, you need to extract the bounding box of each shape and fill the bounding box with its color,\n# ensuring that each shape retains its original color and is placed correctly in the output grid.\n\ndef main(input_grid):\n    # Create a blank output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all connected components (shapes) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8, background=Color.BLACK)\n\n    # Iterate through each shape\n    for obj in objects:\n        # Get the bounding box mask of the object\n        bbox_mask = bounding_box_mask(obj, background=Color.BLACK)\n        \n        # Determine the color of the shape\n        shape_color = np.unique(obj[bbox_mask])[0]\n\n        # Fill the bounding box area in the output grid with the shape\u0027s color\n        output_grid[bbox_mask] = shape_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Number of layers to add\n    num_layers = np.random.randint(3, 6)\n\n    # Randomly generate layers\n    for _ in range(num_layers):\n        # Generate a random shape (sprite) of random size\n        sprite_width, sprite_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        color = np.random.choice(Color.NOT_BLACK)\n        sprite = random_sprite(sprite_width, sprite_height, color_palette=[color], density=0.5)\n\n        # Randomly place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/47/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/47/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/47/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/47/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/47/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/47/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/47/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/47/images/train_output_2.png"}]}, "index": 47, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, radial pattern generation\n\n# description:\n# In the input you will see a grid with a single colored pixel.\n# To make the output grid, move the colored pixel one pixel down, \n# then create a radial pattern of alternating colors around the new pixel position. \n# The pattern should have a radius of 2 pixels and alternate between green and pink.\n\ndef main(input_grid):\n    # Step 1: Find the colored pixel in the input grid\n    colored_pixels = find_connected_components(input_grid, monochromatic=True)\n    assert len(colored_pixels) == 1\n    colored_pixel = colored_pixels[0]\n\n    # Step 2: Get the position and color of the pixel\n    pixel_x, pixel_y = object_position(colored_pixel)\n    pixel_color = object_colors(colored_pixel)[0]\n\n    # Step 3: Move the colored pixel down one pixel\n    output_grid = input_grid.copy()\n    new_pixel_y = pixel_y + 1\n    output_grid[pixel_x, new_pixel_y] = pixel_color\n    output_grid[pixel_x, pixel_y] = Color.BLACK  # Clear the original pixel position\n\n    # Step 4: Create a radial pattern around the new pixel position\n    radius = 2\n    colors = [Color.GREEN, Color.PINK]\n    \n    for r in range(1, radius + 1):  # For each radius from 1 to 2\n        for angle in range(0, 360, 90):  # Create points at 0, 90, 180, and 270 degrees\n            x_offset = int(r * np.cos(np.radians(angle)))\n            y_offset = int(r * np.sin(np.radians(angle)))\n\n            # Determine the color based on the radius\n            color_to_use = colors[r % len(colors)]\n            output_grid[pixel_x + x_offset, new_pixel_y + y_offset] = color_to_use\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose one color\n    color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.YELLOW])\n\n    # Randomly place the pixel on the grid, ensuring it can be moved down\n    x, y = np.random.randint(0, width - 1), np.random.randint(0, height - 2)  # Ensuring space to move down\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/48/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/48/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/48/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/48/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/48/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/48/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/48/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/48/images/train_output_2.png"}]}, "index": 48, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, translation\n\n# description:\n# In the input you will see a grid with a single colored square.\n# To make the output grid, you should rotate the square 90 degrees clockwise and translate it to the bottom-right corner of the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the square object in the grid\n    # 2. Rotate the square 90 degrees clockwise\n    # 3. Translate the rotated square to the bottom-right corner of the grid\n\n    # 1. Extract the square object\n    square_object = find_connected_components(input_grid, monochromatic=True)[0]\n    \n    # 2. Get the dimensions of the square and rotate it\n    rotated_square = np.rot90(square_object, -1)  # Rotate 90 degrees clockwise\n\n    # Create an output grid filled with the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 3. Find the position of the original square\n    orig_x, orig_y = object_position(square_object, background=Color.BLACK, anchor=\u0027upper left\u0027)\n    \n    # Determine the new position to place the rotated square in the bottom-right corner\n    new_x = output_grid.shape[0] - rotated_square.shape[0]\n    new_y = output_grid.shape[1] - rotated_square.shape[1]\n\n    # Blit the rotated square onto the output grid at the new position\n    output_grid = blit_sprite(output_grid, rotated_square, x=new_x, y=new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with a random size\n    grid_len = np.random.randint(5, 10)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Randomly create a square sprite with a size between 1 and 3\n    square_size = np.random.randint(1, 4)  # Size of the square\n    square = random_sprite(n=square_size, m=square_size, density=1.0, color_palette=[Color.RED])\n\n    # Randomly place the square in the grid, ensuring it fits\n    x, y = random_free_location_for_sprite(grid, square)\n    grid = blit_sprite(grid, square, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/49/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/49/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/49/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/49/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/49/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/49/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/49/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/49/images/train_output_2.png"}]}, "index": 49, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, color change, fitting objects\n\n# description:\n# In the input you will see a teal rectangular object and a yellow rectangular object on a black background.\n# To make the output grid, you should translate the teal object to the right by the width of the yellow object,\n# and change its color to blue. Then, fit the translated teal object to the left edge of the yellow object.\n\ndef main(input_grid):\n    # Step 1: Detect the teal and yellow objects\n    teal_objects = detect_objects(grid=input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=4)\n    yellow_objects = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n    \n    assert len(teal_objects) == 1, \"There should be exactly one teal object\"\n    assert len(yellow_objects) == 1, \"There should be exactly one yellow object\"\n    \n    teal_object = teal_objects[0]\n    yellow_object = yellow_objects[0]\n\n    # Get dimensions of the objects\n    teal_height, teal_width = teal_object.shape\n    yellow_height, yellow_width = yellow_object.shape\n\n    # Step 2: Change teal color to blue\n    teal_object[teal_object != Color.BLACK] = Color.BLUE\n\n    # Step 3: Translate the teal object to the right by the width of the yellow object\n    translated_teal_object = translate(teal_object, x=yellow_width, y=0, background=Color.BLACK)\n\n    # Step 4: Prepare the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 5: Blit the translated teal object onto the output grid\n    blit_object(output_grid, translated_teal_object, background=Color.BLACK)\n\n    # Step 6: Blit the yellow object onto the output grid\n    blit_object(output_grid, yellow_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a blank black grid\n    n = np.random.randint(6, 12)\n    m = np.random.randint(6, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random teal rectangle\n    teal_width, teal_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    teal_sprite = np.full((teal_height, teal_width), Color.TEAL)\n\n    # Place the teal rectangle on the grid\n    x_teal, y_teal = random_free_location_for_sprite(grid, teal_sprite, background=Color.BLACK)\n    blit_sprite(grid, teal_sprite, x_teal, y_teal, background=Color.BLACK)\n\n    # Generate a random yellow rectangle\n    yellow_width, yellow_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    yellow_sprite = np.full((yellow_height, yellow_width), Color.YELLOW)\n\n    # Place the yellow rectangle on the grid, ensuring it does not overlap with teal\n    x_yellow, y_yellow = random_free_location_for_sprite(grid, yellow_sprite, background=Color.BLACK)\n    blit_sprite(grid, yellow_sprite, x_yellow, y_yellow, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/50/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/50/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/50/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/50/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/50/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/50/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/50/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/50/images/train_output_2.png"}]}, "index": 50, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color fill, object expansion\n\n# description:\n# In the input, you will see a grid with a single colored object in the center and a different colored pixel in the top left corner.\n# To make the output, remove the pixel in the top left corner and fill the colored object with the color from that pixel. \n# The filling should expand to fill the entire connected region of the original object.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the pixel in the top left corner\n    color = output_grid[0, 0]\n\n    # Remove the pixel from the top left corner\n    output_grid[0, 0] = Color.BLACK\n\n    # Find the coordinates of the object in the center\n    object_x, object_y = np.where(output_grid != Color.BLACK)\n\n    # Use flood_fill to fill the object with the color from the top left corner\n    for x, y in zip(object_x, object_y):\n        flood_fill(output_grid, x, y, color, connectivity=4)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 7x7 grid with a black background\n    n = m = 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the object, ensuring it\u0027s not black\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Select a color for the corner pixel, ensuring it\u0027s different from the object color\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n    while corner_color == object_color:\n        corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create the object by filling a connected region in the center of the grid\n    center_x, center_y = n // 2, m // 2\n    flood_fill(grid, center_x, center_y, object_color, connectivity=4)\n\n    # Place the corner pixel in the top left corner\n    grid[0, 0] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/51/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/51/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/51/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/51/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/51/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/51/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/51/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/51/images/train_output_2.png"}]}, "index": 51, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, interior detection, color transformation\n\n# description:\n# In the input grid, you will see various colored objects, some of which are \"hollow\" and contain a fully-enclosed region, while others are \"solid\" and do not have a separate middle. \n# To create the output grid, copy the input grid. Then, change the color of all \"hollow\" shapes to be yellow, while keeping the colors of \"solid\" shapes unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid to hold the output\n    output_grid = np.copy(input_grid)\n    \n    # Find all connected objects in the input grid\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=4)\n    \n    # Iterate through detected objects to check if they are hollow\n    for obj in objects:\n        if is_hollow(obj):\n            # Change the color of hollow objects to yellow\n            output_grid[output_grid == obj[0, 0]] = Color.YELLOW\n    \n    return output_grid\n\ndef is_hollow(object):\n    # To check if the object is hollow, we examine its interior\n    interior_mask = object_interior(object)\n    object_mask = object != Color.BLACK\n    # A hollow object will have interior pixels that are not part of the object\n    hollow_mask = interior_mask \u0026 ~object_mask\n    return np.any(hollow_mask)\n\ndef generate_input():\n    n = np.random.randint(10, 28)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Function to create a hollow object\n    def random_hollow_object():\n        width, height = np.random.randint(3, 7), np.random.randint(3, 7)\n        obj = np.full((width, height), Color.BLUE)\n        obj[1:width-1, 1:height-1] = Color.BLACK  # Create a hollow rectangle\n        return obj\n\n    # Function to create a solid object\n    def random_solid_object():\n        width, height = np.random.randint(3, 6), np.random.randint(3, 6)\n        obj = np.full((width, height), Color.BLUE)\n        return obj  # Solid, filled with blue\n\n    # Place at least one hollow and one solid object\n    try:\n        # Add one hollow object\n        hollow_obj = random_hollow_object()\n        x, y = random_free_location_for_sprite(input_grid, hollow_obj, padding=1)\n        blit_sprite(input_grid, hollow_obj, x=x, y=y)\n\n        # Add one solid object\n        solid_obj = random_solid_object()\n        x, y = random_free_location_for_sprite(input_grid, solid_obj, padding=1)\n        blit_sprite(input_grid, solid_obj, x=x, y=y)\n    except ValueError:\n        return generate_input()  # Retry if there\u0027s no free location\n\n    # Continue adding random objects until the grid is somewhat full\n    while True:\n        obj = random_hollow_object() if np.random.rand() \u003c 0.5 else random_solid_object()\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            return input_grid  # Return the current grid when no more can be added", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/52/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/52/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/52/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/52/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/52/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/52/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/52/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/52/images/train_output_2.png"}]}, "index": 52, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, color switch, bounding box detection\n\n# description:\n# In the input you will see a grid with a single yellow object.\n# To make the output, move the object to the bottom right corner of the grid and switch its color from yellow to red.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the yellow object (it\u0027s the only one)\n    # 2. Change its color to red\n    # 3. Translate it to the bottom right corner of the grid\n\n    # Get the single yellow object\n    yellow_objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=Color.BLACK)\n    assert len(yellow_objects) == 1, \"There should be exactly one yellow object\"\n    yellow_object = yellow_objects[0]\n\n    # Make a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change its color to red\n    yellow_object[yellow_object != Color.BLACK] = Color.RED\n\n    # Get the bounding box of the yellow object\n    x, y, width, height = bounding_box(yellow_object)\n\n    # Determine the target position (bottom right corner)\n    target_x = output_grid.shape[0] - height\n    target_y = output_grid.shape[1] - width\n\n    # Translate it to the bottom right corner\n    translated_object = translate(yellow_object, x=target_x - x, y=target_y - y, background=Color.BLACK)\n\n    # Blit the red object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=translated_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    grid_len = np.random.randint(5, 10)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Randomly generate the yellow object and place it on the grid.\n    sprite_width, sprite_height = np.random.randint(1, grid_len), np.random.randint(1, grid_len)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.YELLOW], density=0.5)\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/53/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/53/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/53/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/53/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/53/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/53/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/53/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/53/images/train_output_2.png"}]}, "index": 53, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision detection, pixel movement, alignment\n\n# description:\n# In the input, you will see a grid of colored pixels and several horizontal bars of different colors. \n# The goal is to move each colored pixel vertically towards the nearest bar of the same color until the pixel touches the bar. \n# If a pixel cannot find a matching bar, it should be removed from the output.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # Each object is either a bar or a pixel, all uniform color\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    bars, pixels = [], []\n    for obj in objects:\n        # Identify if the object is a bar or a pixel based on its dimensions\n        w, h = crop(obj).shape\n        if w == 1 or h == 1:  # Horizontal or vertical line\n            bars.append(obj)\n        else:\n            pixels.append(obj)\n\n    # Copy the bars to the output grid\n    for bar in bars:\n        blit_object(output_grid, bar, background=Color.BLACK)\n\n    # Process each pixel to move it towards the matching bar\n    for pixel in pixels:\n        pixel_color = np.unique(pixel)[1]\n        matching_bars = [bar for bar in bars if np.unique(bar)[1] == pixel_color]\n\n        if not matching_bars:\n            # No matching bar, skip this pixel\n            continue\n\n        # Find the closest matching bar and move the pixel towards it\n        closest_bar = matching_bars[0]  # Assume the first bar is closest for simplicity\n        pixel_coords = np.argwhere(pixel != Color.BLACK)[0]  # Get the position of the pixel\n        pixel_x, pixel_y = pixel_coords[0], pixel_coords[1]\n\n        bar_coords = np.argwhere(closest_bar != Color.BLACK)[0]  # Get the position of the bar\n        bar_x, bar_y = bar_coords[0], bar_coords[1]\n\n        # Move the pixel vertically towards the bar\u0027s y-coordinate\n        if pixel_y \u003c bar_y:\n            for y in range(pixel_y, bar_y + 1):\n                output_grid[pixel_x, y] = pixel_color\n        else:\n            for y in range(pixel_y, bar_y - 1, -1):\n                output_grid[pixel_x, y] = pixel_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n\n    # Create the input grid\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a few bars and pixels\n    n_bars = np.random.randint(1, 5)\n    bar_colors = random.sample(Color.NOT_BLACK, n_bars)\n\n    for color in bar_colors:\n        # Create horizontal bars\n        x = np.random.randint(0, n)\n        grid[x, :] = color\n\n        # Sprinkle pixels of the same color\n        n_pixels = np.random.randint(1, 5)\n        for _ in range(n_pixels):\n            px, py = np.random.randint(0, n), np.random.randint(0, m)\n            grid[px, py] = color\n\n    # Add distractor pixels that do not match any bar colors\n    not_a_bar_colors = set(Color.NOT_BLACK) - set(bar_colors)\n    n_distractor_pixels = np.random.randint(1, 5)\n    for _ in range(n_distractor_pixels):\n        px, py = np.random.randint(0, n), np.random.randint(0, m)\n        grid[px, py] = np.random.choice(list(not_a_bar_colors))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/54/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/54/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/54/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/54/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/54/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/54/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/54/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/54/images/train_output_2.png"}]}, "index": 54, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, replication, color matching\n\n# description:\n# In the input, you will see a colored shape surrounded by a black background.\n# To make the output, identify the bounding box of the colored shape and replicate it at different locations in the grid.\n# Each replication should be in a different color from a predetermined color palette.\n\ndef main(input_grid):\n    # Step 1: Identify the bounding box of the colored shape\n    background_color = Color.BLACK\n    x, y, width, height = bounding_box(input_grid, background=background_color)\n\n    # Step 2: Extract the shape from the input grid using the bounding box\n    shape = input_grid[x:x + width, y:y + height]\n\n    # Step 3: Create an output grid filled with the background color\n    output_grid = np.full(input_grid.shape, background_color)\n\n    # Step 4: Replicate the shape at different positions in the output grid\n    # Defining positions for replication\n    replication_positions = [\n        (0, 0),  # Top-left corner\n        (0, input_grid.shape[1] - height),  # Top-right corner\n        (input_grid.shape[0] - width, 0),  # Bottom-left corner\n        (input_grid.shape[0] - width, input_grid.shape[1] - height),  # Bottom-right corner\n        ((input_grid.shape[0] // 2) - (width // 2), (input_grid.shape[1] // 2) - (height // 2))  # Center\n    ]\n    \n    # Step 5: Choose a color palette for replication\n    color_palette = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK]\n    \n    for i, (rep_x, rep_y) in enumerate(replication_positions):\n        # Choose a color from the palette\n        color = color_palette[i % len(color_palette)]\n        # Create a colored version of the extracted shape\n        colored_shape = np.where(shape != background_color, color, background_color)\n        # Place the colored shape into the output grid\n        output_grid[rep_x:rep_x + width, rep_y:rep_y + height] = colored_shape\n    \n    return output_grid\n\ndef generate_input():\n    # Step 1: Create a grid with a black background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Step 2: Define the shape\u0027s size and position\n    shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Step 3: Randomly choose a position for the shape\n    x_start = np.random.randint(1, n - shape_height - 1)\n    y_start = np.random.randint(1, m - shape_width - 1)\n\n    # Step 4: Create the shape inside the grid\n    for i in range(shape_height):\n        for j in range(shape_width):\n            grid[x_start + i, y_start + j] = shape_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/55/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/55/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/55/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/55/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/55/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/55/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/55/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/55/images/train_output_2.png"}]}, "index": 55, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color expansion, pixel patterns\n\n# description:\n# In the input you will see a grid containing a single colored pixel in the center. \n# To make the output, create a larger grid where each colored pixel in the input expands outward in all directions, \n# filling a square area of pixels around it with the same color. \n# Each pixel expands to a 3x3 area in the output.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Create an empty output grid larger than the input grid.\n    # 2. For each colored pixel in the input grid, fill a 3x3 area in the output grid with the same color.\n    \n    input_height, input_width = input_grid.shape\n    output_height = input_height * 3\n    output_width = input_width * 3\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Iterate through each pixel in the input grid\n    for x in range(input_height):\n        for y in range(input_width):\n            color = input_grid[x, y]\n            if color != Color.BLACK:  # Only process colored pixels\n                # Determine the position in the output grid for this pixel\n                output_x = x * 3\n                output_y = y * 3\n                # Fill a 3x3 area in the output grid\n                for dx in range(3):\n                    for dy in range(3):\n                        output_grid[output_x + dx, output_y + dy] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a small grid with a single colored pixel in the center\n    grid_size = np.random.randint(3, 6)  # Random size for the grid (3 to 5)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Place a single colored pixel in the center\n    center_x = grid_size // 2\n    center_y = grid_size // 2\n    grid[center_x, center_y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/56/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/56/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/56/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/56/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/56/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/56/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/56/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/56/images/train_output_2.png"}]}, "index": 56, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# movement tracing, line drawing, pattern detection\n\n# description:\n# In the input, you will see several objects of the same color that are arranged in a rectangular grid. \n# Each object represents a pixel that has moved from a previous position, creating a trail. \n# The goal is to connect the center of each object to its previous position by drawing a line that represents the path it took.\n# Each object will be replaced with a line showing its movement direction. \n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (objects)\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n\n    # Process each object to draw lines representing their movement\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj)\n\n        # Crop the object to extract its position\n        sprite = crop(obj)\n\n        # Assuming the object is a single pixel, find its position:\n        object_x, object_y = object_position(sprite)\n\n        # Define the previous position as the center of the bounding box\n        previous_x = x + w // 2\n        previous_y = y + h // 2\n\n        # Get the color of the object\n        color = object_colors(obj)[0]\n\n        # Draw a line from the object\u0027s previous position to its current position\n        draw_line(output_grid, previous_x, previous_y, color=color, direction=(object_x - previous_x, object_y - previous_y))\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of zeros (black background)\n    n, m = np.random.randint(5, 10, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a color for the objects\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place a few objects in the grid (1-4 objects)\n    num_objects = np.random.randint(1, 5)\n    for _ in range(num_objects):\n        # Create a single-pixel object\n        object_sprite = np.array([[color]])\n\n        # Find a random free location for the object\n        x, y = random_free_location_for_sprite(grid, object_sprite)\n\n        # Place the object in the grid\n        blit_sprite(grid, object_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/57/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/57/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/57/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/57/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/57/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/57/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/57/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/57/images/train_output_2.png"}]}, "index": 57, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotational symmetry, color filling\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels (not black) that is missing parts of its symmetry.\n# To make the output, detect the missing sections of the colored pattern needed to achieve rotational symmetry and fill those sections with a new color (e.g., yellow).\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Use the detect_rotational_symmetry function to find symmetry details\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n\n    # Check all colored pixels (not black)\n    colored_pixels = np.argwhere((input_grid != Color.BLACK) \u0026 (input_grid != Color.BLACK))\n\n    for x, y in colored_pixels:\n        # Apply the symmetry to find the positions that would be filled\n        rotated_x, rotated_y = sym.apply(x, y, iters=1)\n\n        # If the position is black, fill it with yellow\n        if output_grid[rotated_x, rotated_y] == Color.BLACK:\n            output_grid[rotated_x, rotated_y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # make a medium-sized grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # create a base random sprite with rotational symmetry\n    sprite_size = np.random.randint(5, min(n, m) // 2)\n    sprite = random_sprite(sprite_size, sprite_size, symmetry=\u0027radial\u0027, color_palette=[np.random.choice(Color.NOT_BLACK)], density=0.5)\n    \n    # remove a random section to break symmetry\n    quadrant = np.random.choice([\u0027north\u0027, \u0027south\u0027, \u0027east\u0027, \u0027west\u0027])\n    remove_length = np.random.randint(1, sprite_size // 3)\n    \n    if quadrant == \u0027north\u0027:\n        sprite[:remove_length, sprite_size // 2 - 1:sprite_size // 2 + 1] = Color.BLACK\n    elif quadrant == \u0027south\u0027:\n        sprite[sprite_size - remove_length:, sprite_size // 2 - 1:sprite_size // 2 + 1] = Color.BLACK\n    elif quadrant == \u0027east\u0027:\n        sprite[sprite_size // 2 - 1:sprite_size // 2 + 1, sprite_size - remove_length:] = Color.BLACK\n    elif quadrant == \u0027west\u0027:\n        sprite[sprite_size // 2 - 1:sprite_size // 2 + 1, :remove_length] = Color.BLACK\n\n    # Place the sprite into the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/58/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/58/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/58/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/58/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/58/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/58/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/58/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/58/images/train_output_2.png"}]}, "index": 58, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, interior identification, color transformation\n\n# description:\n# The input grid consists of black and blue pixels. The input grid should have regions that are enclosed by blue pixels. \n# To produce the output, find the enclosed regions in the input grid, and color them red. \n# The regions that are adjacent to blue pixels should remain black.\n                \ndef main(input_grid):\n    # Create initial output grid template based on input grid.\n    output_grid = input_grid.copy()\n\n    # Find enclosed regions\n    interior_mask = object_interior(input_grid)\n    boundary_mask = object_boundary(input_grid)\n    inside_but_not_on_edge = interior_mask \u0026 ~boundary_mask\n\n    # Color enclosed regions\n    for x, y in np.argwhere(inside_but_not_on_edge):\n        output_grid[x, y] = Color.RED\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a square grid of arbitrary size with black background, size from 5x5 to 20x20\n    n = random.randint(10, 20)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Generate some random blue sprites as boundaries\n    n_objects = random.randint(1, 3)\n    for _ in range(n_objects):\n        n, m = random.randint(4, 10), random.randint(4, 10)\n        sprite = random_sprite(n, m, color_palette=[Color.BLUE], connectivity=8)\n        interior_mask = object_interior(sprite)\n        boundary_mask = object_boundary(sprite)\n        interior_but_not_edges = interior_mask \u0026 ~boundary_mask\n        sprite[interior_but_not_edges] = Color.BLACK  # Hollow out the interior\n\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n        except:\n            continue\n\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/59/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/59/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/59/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/59/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/59/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/59/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/59/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/59/images/train_output_2.png"}]}, "index": 59, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, object detection, noise removal\n\n# description:\n# In the input, you will see a black grid with several colored objects scattered throughout, and some noise pixels (gray) randomly placed. \n# To create the output, fill the pixels of colored objects that are adjacent to noise pixels with teal, and remove the noise pixels.\n\ndef main(input_grid):\n    # Step 1: Identify all objects and noise pixels\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    noise_pixels = detect_objects(input_grid, colors=[Color.GREY], monochromatic=True, allowed_dimensions=[(1, 1)])\n    \n    # Step 2: Create a mask for the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Step 3: For each noise pixel, find its neighbors and fill adjacent colored pixels with teal\n    for noise_pixel in noise_pixels:\n        noise_mask = noise_pixel != Color.BLACK\n        neighbors_mask = object_neighbors(noise_pixel, background=Color.BLACK, connectivity=4)\n\n        # Identify which objects are adjacent to the noise pixel\n        for obj in objects:\n            object_mask = obj != Color.BLACK\n            \n            # If the noise pixel has at least one neighbor that is part of the object, fill that object with teal\n            if np.any(neighbors_mask \u0026 object_mask):\n                output_grid[object_mask] = Color.TEAL\n\n    # Step 4: Remove noise pixels from the output grid\n    output_grid[output_grid == Color.GREY] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly determine number of colored objects and noise pixels\n    num_objects = np.random.randint(2, 6)\n    num_noise = np.random.randint(5, 15)\n\n    # Add colored objects (not grey)\n    for _ in range(num_objects):\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.GREY])\n        obj_width, obj_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        obj_sprite = np.full((obj_width, obj_height), color)\n        x, y = random_free_location_for_sprite(grid, obj_sprite, background=Color.BLACK)\n        blit_sprite(grid, obj_sprite, x, y, background=Color.BLACK)\n\n    # Add random noise pixels (grey)\n    for _ in range(num_noise):\n        x, y = np.random.randint(n), np.random.randint(m)\n        grid[x, y] = Color.GREY\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/60/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/60/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/60/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/60/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/60/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/60/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/60/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/60/images/train_output_2.png"}]}, "index": 60, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, fitting, bounding box\n\n# description:\n# In the input you will see several colored objects in a grid where some are overlapping.\n# To make the output, extract all objects and fit them together to form a single tightly-packed shape without rotation. \n# Ensure that the final output grid is the smallest bounding box that contains all the objects.\n\ndef main(input_grid):\n    # 1. Extract connected components (objects) from the input grid\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=False)\n    \n    # 2. Create a new output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # 3. Place each object into the output grid\n    for obj in objects:\n        # Get the bounding box of the current object\n        mask = bounding_box_mask(obj, background=Color.BLACK)\n\n        # Determine the position to fit the object into the output grid\n        # Find the top-left corner of the bounding box\n        y_offset, x_offset = np.where(mask)[0][0], np.where(mask)[1][0]\n        \n        # Determine where to place the object in the output grid\n        # Use the bottom-right corner of the last placed object to avoid overlap\n        placement_x = np.max(np.where(output_grid != Color.BLACK)[0]) if np.any(output_grid != Color.BLACK) else 0\n        placement_y = 0\n\n        # Place the object in the output grid\n        blit_sprite(output_grid, crop(obj, background=Color.BLACK), placement_x, placement_y)\n\n    # 4. Crop the output to the smallest bounding box that contains all non-background pixels\n    return crop(output_grid, background=Color.BLACK)\n\ndef generate_input():\n    # Create a random grid with colored objects\n    grid = np.full((20, 20), Color.BLACK)\n    colors = list(Color.NOT_BLACK)\n\n    # Generate a number of random objects and place them in the grid\n    for _ in range(random.randint(5, 10)):\n        # Randomly create a sprite\n        sprite = random_sprite(random.randint(2, 5), random.randint(2, 5), density=0.5, color_palette=colors)\n\n        # Find a random location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If no free location, try again\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/61/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/61/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/61/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/61/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/61/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/61/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/61/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/61/images/train_output_2.png"}]}, "index": 61, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, orbit, transformation\n\n# description:\n# In the input, you will see a pattern with a specific color in the center and a surrounding color pattern.\n# To create the output, you must identify the central color pattern and reflect the surrounding color pattern across the center point.\n# This reflection should be applied in all directions to create a new pattern. \n\ndef main(input_grid):\n    # Identify the center of the grid\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    \n    # Extract the central color (assumed to be a single color)\n    center_color = input_grid[center_x, center_y]\n\n    # Create an output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Get the symmetries of the center color\n    symmetries = [(dx, dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1] if (dx != 0 or dy != 0)]\n\n    # Iterate over the surrounding pixels and apply transformations\n    for x, y in np.ndindex(input_grid.shape):\n        if input_grid[x, y] != center_color:\n            # For each surrounding pixel, get its position in the orbit\n            for dx, dy in symmetries:\n                new_x = center_x + (x - center_x) * dx\n                new_y = center_y + (y - center_y) * dy\n                # Check if the new coordinates are within bounds\n                if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                    output_grid[new_x, new_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a central color pattern and surrounding color patterns\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define a center color\n    center_color = np.random.choice(Color.NOT_BLACK)\n    center_x, center_y = n // 2, m // 2\n\n    # Place the center color\n    grid[center_x, center_y] = center_color\n\n    # Generate surrounding colors\n    surrounding_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Fill a surrounding pattern\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx, dy) != (0, 0):  # Skip the center\n                grid[center_x + dx, center_y + dy] = surrounding_color\n\n    # Randomly rotate the grid to add variety\n    grid = np.rot90(grid, np.random.randint(4))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/62/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/62/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/62/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/62/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/62/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/62/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/62/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/62/images/train_output_2.png"}]}, "index": 62, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotational symmetry, filling missing parts\n\n# description:\n# The input grid consists of colored pixels that form a shape with some parts missing (colored black). \n# Your task is to identify the rotational symmetry of the shape and fill in the missing parts to complete the shape symmetrically.\n\ndef main(input_grid):\n    # Create an output grid based on the input grid\n    output_grid = input_grid.copy()\n\n    # Find the rotational symmetry of the shape\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Find all colored pixels (excluding black)\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # For each colored pixel, calculate its rotated positions and fill in the missing colors\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        \n        # Loop through the 3 additional rotations (90, 180, 270 degrees)\n        for i in range(1, 4):\n            # Calculate rotated coordinates\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n\n            # Fill in the missing pixel if it\u0027s black\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n            else:\n                # Ensure no color conflict occurs\n                assert output_grid[rotated_x, rotated_y] == color, \"The object is not rotationally symmetric\"\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10x10 with a black background\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Generate a colorful sprite with some rotational symmetry\n    sprite = random_sprite(\n        5, 5, density=0.5, symmetry=\"radial\", color_palette=list(Color.NOT_BLACK)\n    )\n\n    # Randomly remove parts of the sprite to create missing sections\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if random.random() \u003c 0.3:  # 30% chance to turn a colored pixel to black\n                sprite[i, j] = Color.BLACK\n\n    # Place the sprite randomly onto the grid, ensuring it doesn\u0027t go out of bounds\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/63/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/63/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/63/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/63/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/63/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/63/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/63/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/63/images/train_output_2.png"}]}, "index": 63, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, boundary coloring\n\n# description:\n# In the input grid, there are enclosed shapes formed by blue pixels surrounded by black pixels. \n# The task is to find these shapes\u0027 boundaries and color them orange in the output grid, while leaving the \n# interior of the shapes unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid to store the output\n    output_grid = input_grid.copy()\n\n    # Detect the boundaries of the shapes\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Color the boundaries orange\n    output_grid[boundary_mask] = Color.ORANGE\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a square grid of arbitrary size with black background, size from 10x10 to 20x20\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a few random blue shapes\n    n_objects = np.random.randint(1, 4)  # Generate 1 to 3 shapes\n    for _ in range(n_objects):\n        # Random size for the shape\n        height = np.random.randint(3, 6)\n        width = np.random.randint(3, 6)\n        \n        # Create a blue sprite\n        sprite = random_sprite(height, width, color_palette=[Color.BLUE], connectivity=8)\n\n        # Make sure the sprite is enclosed by black pixels\n        x, y = np.random.randint(1, n-height-1), np.random.randint(1, n-width-1)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/64/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/64/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/64/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/64/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/64/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/64/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/64/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/64/images/train_output_2.png"}]}, "index": 64, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object extraction\n\n# description:\n# In the input, you will see multiple colored objects on a black background, with some objects being adjacent to each other.\n# Each object has a primary color, and there may be other colored pixels nearby. \n# To create the output, for every primary object, change its color to the color of the closest colored pixel that is not part of it, \n# while retaining its shape and position.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all the connected components (objects) in the input grid.\n    # 2. For each object, find the closest colored pixel that is not part of the object.\n    # 3. Change the object\u0027s color to the closest colored pixel\u0027s color.\n\n    # 1. Find connected components (objects)\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False, background=Color.BLACK)\n    \n    # 2. Prepare the output grid\n    output_grid = np.copy(input_grid)\n    \n    for obj in objects:\n        # Get the primary color of the object\n        primary_color = object_colors(obj, background=Color.BLACK)[0]\n        \n        # Get the positions of the object\n        obj_positions = np.argwhere(obj != Color.BLACK)\n        \n        # Find the closest colored pixel that is NOT part of this object\n        closest_pixel_color = None\n        closest_distance = np.inf\n        \n        for x in range(input_grid.shape[0]):\n            for y in range(input_grid.shape[1]):\n                if input_grid[x, y] != Color.BLACK and (x, y) not in obj_positions:\n                    # Calculate the distance to the object\n                    for obj_x, obj_y in obj_positions:\n                        distance = abs(obj_x - x) + abs(obj_y - y)  # Manhattan distance\n                        if distance \u003c closest_distance:\n                            closest_distance = distance\n                            closest_pixel_color = input_grid[x, y]\n\n        # 3. Change the object\u0027s color to the closest colored pixel\u0027s color\n        if closest_pixel_color is not None:\n            output_grid[obj != Color.BLACK] = closest_pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a canvas with random objects and scattered colored pixels\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    num_objects = np.random.randint(2, 6)\n    for _ in range(num_objects):\n        # Generate a random sprite for the object\n        sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), density=0.5, color_palette=[Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW])\n        \n        # Randomly place the sprite on the canvas\n        x, y = np.random.randint(0, width - sprite.shape[0]), np.random.randint(0, height - sprite.shape[1])\n        blit_sprite(grid, sprite, x, y)\n    \n    # Scatter some colored pixels around the canvas\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[x, y] == Color.BLACK:  # Ensure we place it on a black background\n            grid[x, y] = random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/65/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/65/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/65/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/65/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/65/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/65/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/65/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/65/images/train_output_2.png"}]}, "index": 65, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern restoration, bounding box\n\n# description:\n# In the input you will see a grid divided into 9 squares separated by grey lines. \n# The top-left square contains an original pattern, while the other squares may have portions of that pattern or be empty. \n# To create the output, you need to reconstruct the original pattern in each square based on the top-left square while preserving the gray lines.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Detect the color of the lines\n    for x, row in enumerate(output_grid):\n        if np.unique(row).size == 1:\n            line_color = row[0]\n            break\n\n    # Get all the squares separated by lines in the grid\n    squares = find_connected_components(grid=output_grid, background=line_color, monochromatic=False, connectivity=4)\n\n    # Get all squares\u0027 bounding box and cropped pattern\n    cropped_squares = []\n    for obj in squares:\n        x, y, width, height = bounding_box(grid=obj, background=line_color)\n        square_pattern = crop(grid=obj, background=line_color)\n        cropped_squares.append({\u0027x\u0027: x, \u0027y\u0027: y, \u0027pattern\u0027: square_pattern})\n\n    # Sort the squares by their position\n    cropped_squares = sorted(cropped_squares, key=lambda k: (k[\u0027y\u0027], k[\u0027x\u0027]))\n\n    # The top-left square contains the original pattern\n    template_pattern = cropped_squares[0][\u0027pattern\u0027]\n    other_patterns = cropped_squares[1:]\n\n    # Fill each empty square with the template pattern\n    for square in other_patterns:\n        x, y = square[\u0027x\u0027], square[\u0027y\u0027]\n        square_pattern = square[\u0027pattern\u0027]\n\n        # Restore the pattern based on template\n        for i, j in np.argwhere(template_pattern != Color.BLACK):\n            if square_pattern[i, j] == Color.BLACK:\n                square_pattern[i, j] = template_pattern[i, j]\n\n        # Place the reconstructed pattern on the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=square_pattern, x=x, y=y)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 3x3 grid of squares separated by grey lines\n    square_len = np.random.choice([5, 7, 9])\n    pattern_len = square_len - 2\n    n, m = square_len * 3 + 2, square_len * 3 + 2  # 3 squares and 2 lines on each dimension\n    grid = np.full((n, m), Color.BLACK)\n\n    # Select line color\n    line_color = Color.GRAY\n    for i in range(square_len, n, square_len + 1):\n        draw_line(grid=grid, x=i, y=0, color=line_color, direction=(0, 1))\n        draw_line(grid=grid, x=0, y=i, color=line_color, direction=(1, 0))\n\n    # Create the pattern in the top-left square\n    template_sprite = random_sprite(n=pattern_len, m=pattern_len, connectivity=8, density=0.5)\n\n    # Fill the top-left square with the original pattern\n    blit_sprite(grid, template_sprite, 1, 1)\n\n    # Fill the other squares with either copies of the pattern or corrupted versions\n    for i in range(1, 3):\n        for j in range(1, 3):\n            if (i == 1 and j == 1):\n                continue  # skip the top-left square\n            # Create a corrupted version of the pattern\n            corrupted_sprite = template_sprite.copy()\n            for x, y in np.argwhere(corrupted_sprite != Color.BLACK):\n                if np.random.rand() \u003c 0.5:  # randomly set some pixels to black\n                    corrupted_sprite[x, y] = Color.BLACK\n            blit_sprite(grid, corrupted_sprite, i * (square_len + 1) + 1, j * (square_len + 1) + 1)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/66/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/66/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/66/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/66/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/66/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/66/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/66/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/66/images/train_output_2.png"}]}, "index": 66, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connecting, padding, object detection\n\n# description:\n# In the input, you will see two distinct colored circles on a black background.\n# To create the output, connect the centers of the two circles with a line of a third color (grey).\n# The connection should only occur if there is enough space (defined by a padding) between the objects.\n\ndef main(input_grid):\n    # Copy the input grid as output\n    output_grid = np.copy(input_grid)\n\n    # Detect the objects (circles)\n    circles = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    if len(circles) != 2:\n        raise ValueError(\"The input must contain exactly two objects.\")\n\n    # Get the center positions of the two circles\n    center1 = object_position(circles[0], background=Color.BLACK, anchor=\u0027center\u0027)\n    center2 = object_position(circles[1], background=Color.BLACK, anchor=\u0027center\u0027)\n\n    # Check if there is enough space to connect the centers with padding\n    x_center1, y_center1 = center1\n    x_center2, y_center2 = center2\n\n    # Get the coordinates of the line between the two centers\n    for x in range(min(x_center1, x_center2), max(x_center1, x_center2) + 1):\n        for y in range(min(y_center1, y_center2), max(y_center1, y_center2) + 1):\n            # Check if the current position is between the two circles with a padding\n            if check_between_objects(circles[0], circles[1], x, y, padding=1):\n                output_grid[x, y] = Color.GREY\n    \n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the circles\n    colors = np.random.choice([color for color in Color.NOT_BLACK], 2, replace=False)\n    color1, color2 = colors\n\n    # Generate two circles\n    radius1 = np.random.randint(2, 4)\n    radius2 = np.random.randint(2, 4)\n\n    # Create the first circle\n    circle1 = np.zeros((radius1 * 2 + 1, radius1 * 2 + 1), dtype=int)\n    for x in range(circle1.shape[0]):\n        for y in range(circle1.shape[1]):\n            if (x - radius1) ** 2 + (y - radius1) ** 2 \u003c= radius1 ** 2:\n                circle1[x, y] = color1\n\n    # Create the second circle\n    circle2 = np.zeros((radius2 * 2 + 1, radius2 * 2 + 1), dtype=int)\n    for x in range(circle2.shape[0]):\n        for y in range(circle2.shape[1]):\n            if (x - radius2) ** 2 + (y - radius2) ** 2 \u003c= radius2 ** 2:\n                circle2[x, y] = color2\n\n    # Place the circles on the grid\n    try:\n        x1, y1 = random_free_location_for_sprite(grid=grid, sprite=circle1, background=Color.BLACK, padding=2, padding_connectivity=8)\n        blit_sprite(grid, circle1, x1, y1)\n\n        x2, y2 = random_free_location_for_sprite(grid=grid, sprite=circle2, background=Color.BLACK, padding=2, padding_connectivity=8)\n        blit_sprite(grid, circle2, x2, y2)\n\n    except ValueError:\n        return generate_input()  # If we fail to place circles, regenerate input\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/67/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/67/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/67/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/67/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/67/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/67/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/67/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/67/images/train_output_2.png"}]}, "index": 67, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object translation, pixel patterns\n\n# description:\n# In the input you will see a grid with a square shape made up of colored pixels. \n# The task is to slide this square shape to the right by one pixel, while ensuring that \n# the square shape is still contiguous and does not overlap with the background.\n# If it cannot be slid to the right because of the edge of the grid, the shape remains in its original position.\n\ndef main(input_grid):\n    # Find the connected component (the colored square shape)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    if not objects:\n        return input_grid  # If no object found, return the original input grid\n\n    obj = objects[0]\n\n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(obj)\n\n    # Check if the object can slide right\n    if x + width \u003c input_grid.shape[0]:  # Ensure it stays within bounds\n        # Translate the object to the right by 1 pixel\n        output_grid = translate(obj, 1, 0, background=Color.BLACK)\n    else:\n        output_grid = input_grid.copy()  # If not possible, return original grid\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 5x5 grid with a black background\n    grid = np.full((5, 5), Color.BLACK)\n\n    # Create a random size for the square shape (1 to 3 pixels)\n    square_size = np.random.randint(1, 4)\n\n    # Randomly choose a color for the square\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly determine the top-left corner of the square\n    # Ensure that the square can fit within the grid\n    x = np.random.randint(0, 5 - square_size + 1)\n    y = np.random.randint(0, 5)\n\n    # Fill the square area with the chosen color\n    grid[x:x + square_size, y:y + square_size] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/68/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/68/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/68/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/68/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/68/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/68/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/68/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/68/images/train_output_2.png"}]}, "index": 68, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, filling, color transformation\n\n# description:\n# In the input grid, you will find various shapes made of colored pixels surrounding black pixels (background).\n# The task is to identify the boundaries of each shape and fill the interior of each shape with a new color (blue).\n# The boundary itself should remain unchanged and the outside (background) should still be black.\n\ndef main(input_grid):\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Find the boundaries of the objects in the input grid\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Iterate through the grid to fill in the interiors of the shapes\n    for x, y in np.argwhere(output_grid != Color.BLACK):\n        # Check if this pixel is part of the boundary\n        if boundary_mask[x, y]:\n            continue  # Skip boundary pixels\n        # If not, fill the interior with blue\n        output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a size between 10x10 and 20x20\n    n = random.randint(10, 20)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Generate random colored shapes\n    n_objects = random.randint(2, 5)  # Number of shapes to add\n    colors = random.sample(list(Color.NOT_BLACK), n_objects)\n    \n    for color in colors:\n        # Create a random sprite for the object\n        sprite = random_sprite(random.randint(3, 8), random.randint(3, 8), color_palette=[color])\n        \n        # Try to place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If no space is found, skip this sprite\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/69/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/69/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/69/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/69/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/69/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/69/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/69/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/69/images/train_output_2.png"}]}, "index": 69, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, geometric pattern, filling\n\n# description:\n# In the input you will see a grid with a single colored pixel. \n# To make the output, find the bounding box of the colored pixel and fill it with the same color.\n# Then, draw a diagonal line from the top-left corner of the bounding box to the bottom-right corner.\n\ndef main(input_grid):\n    # Step 1: Find the colored pixel\n    colored_components = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n    assert len(colored_components) == 1, \"There should be exactly one colored pixel.\"\n    \n    colored_pixel = colored_components[0]\n    colored_x, colored_y = object_position(colored_pixel)\n    colored_color = object_colors(colored_pixel)[0]\n\n    # Step 2: Create a mask for the bounding box of the colored pixel\n    bounding_box_mask_result = bounding_box_mask(colored_pixel)\n    min_x, min_y = np.where(bounding_box_mask_result)[0][0], np.where(bounding_box_mask_result)[1][0]\n    max_x, max_y = np.where(bounding_box_mask_result)[0][-1], np.where(bounding_box_mask_result)[1][-1]\n\n    # Step 3: Fill the bounding box with the colored pixel\u0027s color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[min_x:max_x+1, min_y:max_y+1] = colored_color\n\n    # Step 4: Draw a diagonal line from the top-left corner to the bottom-right corner of the bounding box\n    draw_line(output_grid, min_x, min_y, direction=(1, 1), color=colored_color)\n\n    return output_grid\n\ndef generate_input():\n    # Generate an input grid\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose one color for the colored pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the colored pixel within the grid\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/70/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/70/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/70/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/70/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/70/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/70/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/70/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/70/images/train_output_2.png"}]}, "index": 70, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation\n\n# description:\n# In the input, you will see a blue square and a green square on a black background.\n# To make the output, change the blue square to red and the green square to orange, \n# while preserving their positions on the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the blue and green squares in the input grid.\n    # 2. Change the color of the blue square to red.\n    # 3. Change the color of the green square to orange.\n    # 4. Return the modified grid.\n\n    # 1. Detect the objects\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)\n    \n    blue_squares = [obj for obj in objects if Color.BLUE in object_colors(obj)]\n    green_squares = [obj for obj in objects if Color.GREEN in object_colors(obj)]\n    \n    assert len(blue_squares) == 1, \"There should be exactly one blue square\"\n    assert len(green_squares) == 1, \"There should be exactly one green square\"\n    \n    blue_square = blue_squares[0]\n    green_square = green_squares[0]\n    \n    # Create an output grid based on the input grid\n    output_grid = input_grid.copy()\n    \n    # 2. Change the blue square to red\n    blue_x, blue_y = object_position(blue_square)\n    output_grid[blue_x, blue_y] = Color.RED\n    \n    # 3. Change the green square to orange\n    green_x, green_y = object_position(green_square)\n    output_grid[green_x, green_y] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with one blue square and one green square in random positions.\n    width, height = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly place a blue square\n    blue_x, blue_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    grid[blue_x, blue_y] = Color.BLUE\n    \n    # Randomly place a green square, ensuring it doesn\u0027t overlap with the blue square\n    while True:\n        green_x, green_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n        if (green_x, green_y) != (blue_x, blue_y):\n            break\n    grid[green_x, green_y] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/71/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/71/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/71/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/71/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/71/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/71/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/71/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/71/images/train_output_2.png"}]}, "index": 71, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, merging, surrounding\n\n# description:\n# In the input, you will see a blue square and several yellow circles on the grid.\n# To make the output, move the blue square to the center of the region occupied by the yellow circles.\n# Then, surround the blue square with green pixels in a 1-pixel border, and make all other pixels black.\n\ndef main(input_grid):\n    # Step 1: Detect the blue square and yellow circles\n    objects = find_connected_components(input_grid, connectivity=4)\n\n    blue_square = [obj for obj in objects if Color.BLUE in object_colors(obj)][0]\n    yellow_circles = [obj for obj in objects if Color.YELLOW in object_colors(obj)]\n\n    # Step 2: Calculate the center of all yellow circles\n    yellow_positions = np.array([object_position(circle) for circle in yellow_circles])\n    center_x = int(np.mean(yellow_positions[:, 0]))\n    center_y = int(np.mean(yellow_positions[:, 1]))\n\n    # Step 3: Move the blue square to the center of the yellow circles\n    blue_x, blue_y = object_position(blue_square)\n    displacement_x = center_x - blue_x\n    displacement_y = center_y - blue_y\n\n    # Translate blue square to the calculated center\n    translated_blue_square = translate(blue_square, displacement_x, displacement_y)\n\n    # Step 4: Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 5: Surround the translated blue square with green pixels\n    sprite_bbox = bounding_box(translated_blue_square)\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx == 0 and dy == 0) or (sprite_bbox[0] + dx \u003c 0 or sprite_bbox[0] + dx \u003e= output_grid.shape[0] or \n                                          sprite_bbox[1] + dy \u003c 0 or sprite_bbox[1] + dy \u003e= output_grid.shape[1]):\n                continue\n            output_grid[sprite_bbox[0] + dx, sprite_bbox[1] + dy] = Color.GREEN\n\n    # Blit the translated blue square on top of the surrounding green\n    blit_sprite(output_grid, translated_blue_square, x=sprite_bbox[0], y=sprite_bbox[1])\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place a blue square in the grid\n    blue_square = random_sprite(3, 3, color_palette=[Color.BLUE], density=1.0)\n    x, y = random_free_location_for_sprite(grid, blue_square, background=Color.BLACK)\n    blit_sprite(grid, blue_square, x, y)\n\n    # Randomly place several yellow circles on the grid\n    num_circles = np.random.randint(1, 6)\n    yellow_circle = random_sprite(2, 2, color_palette=[Color.YELLOW], density=1.0)\n\n    for _ in range(num_circles):\n        x, y = random_free_location_for_sprite(grid, yellow_circle, background=Color.BLACK)\n        blit_sprite(grid, yellow_circle, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/72/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/72/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/72/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/72/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/72/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/72/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/72/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/72/images/train_output_2.png"}]}, "index": 72, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, translation, color change\n\n# description:\n# In the input, you will see a grid with multiple colored pixels forming a shape.\n# To create the output grid, move the shape upward until it touches the top edge of the grid, while keeping it within the confines of the grid.\n# If any part of the shape exceeds the bounds of the grid, stop moving it. \n# Finally, change the color of the shape to green.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the shape in the input grid.\n    # 2. Calculate the bounding box of the shape to determine its dimensions and position.\n    # 3. Translate the shape upward until it touches the top edge of the grid or exceeds the bounds.\n    # 4. Change the color of the shape to green.\n\n    # 1. Find the connected component, which should be the only shape present\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one shape in the grid\"\n    shape = objects[0]\n\n    # 2. Calculate the bounding box mask of the shape\n    bounding_mask = bounding_box_mask(shape)\n\n    # Get the current position of the shape\n    shape_x, shape_y = object_position(shape, background=Color.BLACK, anchor=\u0027upper left\u0027)\n\n    # 3. Translate the shape upward as far as possible without exceeding the grid bounds\n    height = input_grid.shape[1]\n    new_shape_y = shape_y - (shape_y - 0)  # Move upward until it hits the top\n    if new_shape_y \u003c 0:\n        new_shape_y = 0  # Ensure we do not exceed the top edge\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Blit the translated shape into the output grid\n    shape_translated = translate(shape, x=0, y=new_shape_y - shape_y, background=Color.BLACK)\n    blit_object(output_grid, shape_translated)\n\n    # 4. Change the color of the shape to green\n    output_grid[shape_translated != Color.BLACK] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate an empty grid\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Create a random shape with colors\n    shape_width, shape_height = np.random.randint(1, 4), np.random.randint(1, 4)\n    random_shape = random_sprite(shape_width, shape_height, color_palette=[random.choice(Color.NOT_BLACK)])\n\n    # Choose a random position for the shape, ensuring it fits within the grid\n    x = np.random.randint(0, width - shape_width + 1)\n    y = np.random.randint(0, height - shape_height + 1)\n\n    # Place the shape onto the grid\n    blit_sprite(grid, random_shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/73/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/73/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/73/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/73/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/73/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/73/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/73/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/73/images/train_output_2.png"}]}, "index": 73, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object identification\n\n# description:\n# In the input, you will see a grid of colored pixels with some colored objects scattered on a black background.\n# Each object has a primary color, and there are also some single pixels of a different color attached to them.\n# To make the output grid, change the color of each object to match the color of the attached single pixels (if present).\n# If no attached single pixel exists, the original color of the object should be retained.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all connected components (objects) in the input grid.\n    # 2. For each object, check if there are any attached single pixels.\n    # 3. If an attached pixel exists, change the color of the object to match that pixel\u0027s color.\n    # 4. If no attached pixel exists, retain the original color of the object.\n\n    background_color = Color.BLACK\n    \n    # 1. Find all the connected components (objects) in the input grid\n    objects = find_connected_components(grid=input_grid, connectivity=8, monochromatic=True, background=background_color)\n    \n    # Create an output grid initialized to the background color\n    output_grid = input_grid.copy()\n    \n    # 2. Iterate over each object\n    for obj in objects:\n        # Check if the object has any attached single pixels\n        attached_pixels = []\n        for x, y in np.argwhere(obj != background_color):\n            # Check the 4-connectivity around the pixel\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                neighbor_x, neighbor_y = x + dx, y + dy\n                if 0 \u003c= neighbor_x \u003c input_grid.shape[0] and 0 \u003c= neighbor_y \u003c input_grid.shape[1]:\n                    if input_grid[neighbor_x, neighbor_y] != background_color and input_grid[neighbor_x, neighbor_y] != object_colors(obj, background=background_color)[0]:\n                        attached_pixels.append(input_grid[neighbor_x, neighbor_y])\n        \n        # 3. If attached pixels exist, change the color of the object\n        if attached_pixels:\n            new_color = attached_pixels[0]  # Choose the first attached pixel\u0027s color\n            # Change the color of the object in the output grid\n            output_grid[obj != background_color] = new_color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a medium-sized grid with randomly placed objects and attached pixels\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    num_objects = np.random.randint(3, 8)\n    for _ in range(num_objects):\n        # Randomly create an object\n        object_color = np.random.choice(Color.NOT_BLACK)\n        object_sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.5, symmetry=\"not_symmetric\", color_palette=[object_color])\n        \n        # Place the object on the grid\n        x, y = random_free_location_for_sprite(grid, object_sprite)\n        blit_sprite(grid, object_sprite, x, y)\n\n        # Randomly attach a single pixel of a different color\n        attached_pixel_color = np.random.choice(Color.NOT_BLACK)\n        if attached_pixel_color != object_color:  # Ensure it\u0027s a different color\n            attached_x = np.random.randint(x, x + object_sprite.shape[0])\n            attached_y = np.random.randint(y, y + object_sprite.shape[1])\n            # Ensure the attached pixel does not overlap with the object\n            while grid[attached_x, attached_y] != Color.BLACK:\n                attached_x = np.random.randint(x, x + object_sprite.shape[0])\n                attached_y = np.random.randint(y, y + object_sprite.shape[1])\n            grid[attached_x, attached_y] = attached_pixel_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/74/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/74/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/74/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/74/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/74/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/74/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/74/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/74/images/train_output_2.png"}]}, "index": 74, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color replacement, symmetrical pattern\n\n# description:\n# In the input you will see a grid with a red pixel and a blue pixel.\n# To make the output, swap the colors of the red pixel and the blue pixel, \n# and then form a symmetrical pattern based on their new positions, \n# filling it with yellow pixels.\n\ndef main(input_grid):\n    # 1. Detect the red and blue pixels\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    \n    red_pixels = [obj for obj in objects if Color.RED in object_colors(obj, background=Color.BLACK)]\n    blue_pixels = [obj for obj in objects if Color.BLUE in object_colors(obj, background=Color.BLACK)]\n\n    assert len(red_pixels) == 1, \"There should be exactly one red pixel\"\n    assert len(blue_pixels) == 1, \"There should be exactly one blue pixel\"\n    \n    red_pixel = red_pixels[0]\n    blue_pixel = blue_pixels[0]\n\n    # Get their positions\n    red_x, red_y = object_position(red_pixel, background=Color.BLACK, anchor=\"center\")\n    blue_x, blue_y = object_position(blue_pixel, background=Color.BLACK, anchor=\"center\")\n\n    # 2. Swap the colors of the red pixel and the blue pixel\n    output_grid = input_grid.copy()\n    output_grid[red_x, red_y] = Color.BLUE\n    output_grid[blue_x, blue_y] = Color.RED\n\n    # 3. Create a symmetrical pattern based on the new positions\n    midpoint_x = (red_x + blue_x) // 2\n    midpoint_y = (red_y + blue_y) // 2\n\n    # Fill in the symmetrical pattern with yellow pixels\n    for dx in range(-1, 2):  # -1, 0, 1 for horizontal\n        for dy in range(-1, 2):  # -1, 0, 1 for vertical\n            if (dx != 0 or dy != 0):  # Skip the center point\n                output_grid[midpoint_x + dx, midpoint_y + dy] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a red and a blue pixel in random positions\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place a red pixel at a random position\n    red_x, red_y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[red_x, red_y] = Color.RED\n\n    # Place a blue pixel at a different random position\n    while True:\n        blue_x, blue_y = np.random.randint(0, width), np.random.randint(0, height)\n        if (blue_x, blue_y) != (red_x, red_y):\n            break\n    grid[blue_x, blue_y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/75/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/75/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/75/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/75/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/75/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/75/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/75/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/75/images/train_output_2.png"}]}, "index": 75, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, scaling, pattern arrangement\n\n# description:\n# In the input you will see multiple 2x2 squares of different colors. \n# The task is to scale each square by 3 times and arrange them in the same pattern in the output grid.\n\ndef main(input_grid):\n    # Detect all the 2x2 colored squares in the input grid.\n    squares = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=4, allowed_dimensions=[(2, 2)])\n\n    # Initialize the output grid with a black background.\n    output_grid = np.zeros_like(input_grid)\n\n    # Scale factor for the squares.\n    scale_factor = 3\n\n    # Place each scaled square in the output grid.\n    for square in squares:\n        # Get the position and size of the square\n        x, y = object_position(square, background=Color.BLACK, anchor=\"upper left\")\n        square_sprite = crop(square, background=Color.BLACK)\n\n        # Scale the square by the scale factor\n        scaled_square = scale_sprite(square_sprite, scale_factor)\n\n        # Calculate the new position for the scaled square\n        new_x = x * scale_factor\n        new_y = y * scale_factor\n\n        # Blit the scaled square onto the output grid\n        output_grid = blit_sprite(output_grid, scaled_square, x=new_x, y=new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a size of n x n.\n    grid_size = np.random.randint(6, 10)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly scatter 2x2 colored squares on the grid.\n    colors = Color.NOT_BLACK\n    square_count = np.random.randint(1, 5)  # Randomly decide how many squares to generate\n\n    for _ in range(square_count):\n        square_color = np.random.choice(colors)\n        square = np.full((2, 2), square_color)\n\n        # Try to place the square in a valid location\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=square, background=Color.BLACK, border_size=0, padding=0)\n            grid = blit_sprite(grid, sprite=square, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            # If no space is found, skip placing that square\n            continue\n            \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/76/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/76/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/76/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/76/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/76/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/76/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/76/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/76/images/train_output_2.png"}]}, "index": 76, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, translation, color change\n\n# description:\n# In the input you will see a grid with a blue object surrounded by a yellow background.\n# To create the output, find the blue object, translate it to the bottom right corner of the grid,\n# and change its color to green.\n\ndef main(input_grid):\n    # Step 1: Find the blue object in the grid\n    blue_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n\n    # Assuming there is exactly one blue object\n    assert len(blue_objects) == 1\n    blue_object = blue_objects[0]\n\n    # Step 2: Get the position of the blue object\n    x, y = object_position(blue_object, background=Color.YELLOW, anchor=\"upper left\")\n\n    # Determine the new position for the object (bottom right corner)\n    output_grid = np.full(input_grid.shape, Color.YELLOW)  # Start with a yellow background\n    new_x = output_grid.shape[0] - blue_object.shape[0]\n    new_y = output_grid.shape[1] - blue_object.shape[1]\n\n    # Step 3: Change the color of the blue object to green\n    blue_object[blue_object != Color.YELLOW] = Color.GREEN\n\n    # Step 4: Translate the blue object to the new position and blit it onto the output grid\n    translated_object = translate(blue_object, x=new_x - x, y=new_y - y, background=Color.YELLOW)\n    output_grid = blit_object(output_grid, translated_object, background=Color.YELLOW)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a yellow background and a single blue object\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)  # Random grid size\n    grid = np.full((n, m), Color.YELLOW)  # Start with yellow background\n\n    # Create a blue object of random size\n    object_width, object_height = np.random.randint(1, 4), np.random.randint(1, 4)\n    blue_object = random_sprite(n=object_height, m=object_width, color_palette=[Color.BLUE], density=1.0)\n\n    # Place the blue object at a random location, ensuring it\u0027s within bounds\n    x, y = random_free_location_for_sprite(grid, blue_object, background=Color.YELLOW)\n    grid = blit_sprite(grid, blue_object, x, y, background=Color.YELLOW)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/77/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/77/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/77/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/77/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/77/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/77/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/77/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/77/images/train_output_2.png"}]}, "index": 77, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern rotation, corner markers\n\n# description:\n# In the input you will see a grid with a central square pattern and four differently-colored corner markers.\n# To create the output, rotate the central pattern 90 degrees clockwise and place it in the center of the output grid,\n# while ensuring the corner markers remain in their original positions.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Crop the central pattern out from the input grid\n    central_pattern = crop(grid=input_grid)\n\n    # Step 2: Rotate the central pattern 90 degrees clockwise\n    rotated_pattern = np.rot90(central_pattern, k=-1)\n\n    # Get the shape of the output grid, which should be the same as input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 3: Calculate the position to place the rotated pattern in the center of the output grid\n    pattern_x = (output_grid.shape[0] - rotated_pattern.shape[0]) // 2\n    pattern_y = (output_grid.shape[1] - rotated_pattern.shape[1]) // 2\n\n    # Step 4: Blit the rotated pattern onto the output grid\n    output_grid = blit_sprite(output_grid, rotated_pattern, x=pattern_x, y=pattern_y)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate random central pattern size\n    n, m = np.random.randint(3, 10), np.random.randint(3, 10)\n\n    # Randomly select a color for the central pattern and corner markers\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n    corner_colors = np.random.choice(list(Color.NOT_BLACK), size=4, replace=False)\n\n    # Create the central pattern\n    central_pattern = random_sprite(n, m, color_palette=[pattern_color], density=0.5)\n    \n    # Create an empty grid that will hold the pattern and corner markers\n    enlarged_grid = np.zeros((n + 2, m + 2), dtype=int)\n\n    # Place the corner markers in the corners\n    enlarged_grid[0, 0] = corner_colors[0]  # Top-left\n    enlarged_grid[0, m + 1] = corner_colors[1]  # Top-right\n    enlarged_grid[n + 1, 0] = corner_colors[2]  # Bottom-left\n    enlarged_grid[n + 1, m + 1] = corner_colors[3]  # Bottom-right\n\n    # Place the central pattern in the grid\n    enlarged_grid = blit_sprite(grid=enlarged_grid, sprite=central_pattern, x=1, y=1)\n\n    # Create the final grid and place the enlarged grid randomly\n    grid_width, grid_height = np.random.randint(n + 2, 2 * n + 2), np.random.randint(m + 2, 2 * m + 2)\n    final_grid = np.zeros((grid_width, grid_height), dtype=int)\n\n    # Randomly place the enlarged grid in the final grid\n    pos_x, pos_y = np.random.randint(0, grid_width - (n + 2)), np.random.randint(0, grid_height - (m + 2))\n    final_grid = blit_sprite(grid=final_grid, sprite=enlarged_grid, x=pos_x, y=pos_y)\n\n    return final_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/78/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/78/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/78/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/78/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/78/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/78/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/78/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/78/images/train_output_2.png"}]}, "index": 78, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# enclosed regions, interior detection\n\n# description:\n# In the input grid, you\u0027ll see a random arrangement of colored pixels, with some colors forming enclosed regions surrounded by a different color (e.g., black).\n# To make the output, you need to find these enclosed regions and fill them with a new color (e.g., blue). The output grid should retain the original structure \n# of the input grid but with the interior of the enclosed regions colored in blue.\n\ndef main(input_grid):\n    # Create an output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Detect enclosed regions using the object_interior function\n    interior_mask = object_interior(input_grid, background=Color.BLACK)\n\n    # Fill the enclosed regions with blue color\n    for x, y in np.argwhere(interior_mask):\n        output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of arbitrary size with a black background, size from 10x10 to 20x20\n    n, m = np.random.randint(10, 21, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create random colored pixels to form some enclosed regions (not black)\n    num_colors = np.random.randint(2, 5)\n    colors = random.sample(Color.NOT_BLACK, num_colors)\n\n    # Place colors in a way that can create enclosed regions\n    for color in colors:\n        # Randomly choose a rectangular area to fill with this color\n        x_start, x_end = np.random.randint(1, n-1), np.random.randint(1, n-1)\n        y_start, y_end = np.random.randint(1, m-1), np.random.randint(1, m-1)\n        \n        # Ensure valid indices\n        x_start, x_end = min(x_start, x_end), max(x_start, x_end)\n        y_start, y_end = min(y_start, y_end), max(y_start, y_end)\n\n        # Fill the area with the chosen color\n        grid[x_start:x_end, y_start:y_end] = color\n\n        # Create a boundary around the area using black\n        grid[x_start-1:x_end+1, y_start-1] = Color.BLACK\n        grid[x_start-1:x_end+1, y_end] = Color.BLACK\n        grid[x_start-1, y_start-1:y_end+1] = Color.BLACK\n        grid[x_end, y_start-1:y_end+1] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/79/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/79/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/79/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/79/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/79/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/79/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/79/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/79/images/train_output_2.png"}]}, "index": 79, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape merging, color layering\n\n# description:\n# In the input, you will see several overlapping shapes of different colors on a black background.\n# To create the output, you should merge these shapes into a single shape, \n# preserving the colors from the outermost shape to the innermost shape as layers. \n# The output should be a grid that shows the layers of colors, starting with the outermost color at the top.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all distinct shapes in the input grid.\n    # 2. For each shape, determine its color and crop it to its bounding box.\n    # 3. Sort the shapes based on their area (from largest to smallest).\n    # 4. Create an output grid and fill in the shapes in order of their area.\n\n    # Step 1: Find connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Step 2: Crop each shape and get its color\n    colored_shapes = []\n    for shape in shapes:\n        color = shape[0, 0]  # Assuming the color is uniform within each shape\n        cropped_shape = crop(shape, background=Color.BLACK)\n        colored_shapes.append((cropped_shape, color))\n\n    # Step 3: Sort shapes by area (largest to smallest)\n    colored_shapes.sort(key=lambda item: item[0].size, reverse=True)\n\n    # Step 4: Create output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for cropped_shape, color in colored_shapes:\n        # Get the dimensions of the cropped shape\n        shape_height, shape_width = cropped_shape.shape\n\n        # Calculate the position to place the shape centered in the output grid\n        center_x = (output_grid.shape[0] - shape_height) // 2\n        center_y = (output_grid.shape[1] - shape_width) // 2\n\n        # Blit the cropped shape onto the output grid\n        blit_sprite(output_grid, cropped_shape, x=center_x, y=center_y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with overlapping shapes\n    grid_height = np.random.randint(10, 20)\n    grid_width = np.random.randint(10, 20)\n    grid = np.full((grid_height, grid_width), Color.BLACK)\n\n    # Randomly generate a number of shapes\n    num_shapes = np.random.randint(3, 6)\n\n    for _ in range(num_shapes):\n        # Create a random rectangular shape\n        shape_height = np.random.randint(2, 6)\n        shape_width = np.random.randint(2, 6)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Generate a rectangle of this color\n        shape = np.full((shape_height, shape_width), shape_color)\n\n        # Find a random free location for the shape in the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n\n        # Blit the shape onto the grid\n        blit_sprite(grid, shape, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/80/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/80/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/80/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/80/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/80/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/80/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/80/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/80/images/train_output_2.png"}]}, "index": 80, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, gap filling\n\n# description:\n# In the input you will see two rectangles separated by a gap.\n# To make the output, fill the gap between the two rectangles with a diagonal pattern of colored pixels.\n\ndef main(input_grid):\n    # Copy the input grid as output\n    output_grid = input_grid.copy()\n\n    # Detect the connected components (rectangles)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    if len(objects) != 2:\n        raise ValueError(\"Input grid must contain exactly two colored rectangles.\")\n\n    # Get the bounding boxes of the two objects\n    obj1_bounds = object_position(objects[0])\n    obj2_bounds = object_position(objects[1])\n\n    # Check the bounding box positions\n    x1, y1 = obj1_bounds\n    x2, y2 = obj2_bounds\n\n    # Fill the gap with a diagonal pattern of colored pixels if the objects are separated\n    for x in range(min(x1, x2), max(x1, x2) + 1):\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            # Check if the position is a gap between the two objects\n            if check_between_objects(obj1=objects[0], obj2=objects[1], x=x, y=y, padding=0):\n                # Create a diagonal pattern\n                if (x - min(x1, x2)) % 2 == 0:\n                    output_grid[x, y] = Color.TEAL\n                else:\n                    output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the rectangles\n    colors = np.random.choice([color for color in Color.NOT_BLACK if color != Color.BLACK], 2, replace=False)\n    color1, color2 = colors\n\n    # Generate two rectangles\n    n1, m1 = np.random.randint(3, 7, size=2)\n    n2, m2 = np.random.randint(3, 7, size=2)\n\n    rectangle1 = np.full((n1, m1), color1)\n    rectangle2 = np.full((n2, m2), color2)\n\n    # Place the rectangles on the grid with a gap between them\n    x1, y1 = random_free_location_for_sprite(grid=grid, sprite=rectangle1, background=Color.BLACK, padding=2, padding_connectivity=8)\n    blit_sprite(grid, rectangle1, x1, y1, Color.BLACK)\n\n    # Ensure there is a gap before placing the second rectangle\n    gap_width = np.random.randint(2, 5)\n    x2, y2 = x1 + n1 + gap_width, y1  # Place second rectangle to the right of the first with a gap\n    blit_sprite(grid, rectangle2, x2, y2, Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/81/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/81/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/81/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/81/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/81/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/81/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/81/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/81/images/train_output_2.png"}]}, "index": 81, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cropping, counting, expanding\n\n# description:\n# In the input, you will see a grid with a series of colored circular patterns and a black background.\n# To make the output:\n# 1. Count the number of unique colors in the circular patterns.\n# 2. Crop the grid to include only the circular patterns.\n# 3. Expand the cropped patterns outward in all directions based on the number of unique colors.\n\ndef main(input_grid):\n    # Step 1: Count the number of unique colors\n    unique_colors = set(input_grid.flatten()) - {Color.BLACK}\n    num_colors = len(unique_colors)\n\n    # Step 2: Crop the grid to the smallest bounding box that contains all non-black pixels\n    cropped_grid = crop(input_grid, background=Color.BLACK)\n\n    # Step 3: Create an output grid and place the cropped circular patterns in it\n    cropped_height, cropped_width = cropped_grid.shape\n    output_size = cropped_height + (num_colors - 1) * 2  # Expand outwards\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # Calculate where to place the cropped grid in the output grid\n    start_x = (output_size - cropped_width) // 2\n    start_y = (output_size - cropped_height) // 2\n\n    # Place the cropped grid in the center of the output grid\n    blit_sprite(output_grid, cropped_grid, x=start_x, y=start_y)\n\n    # Expand the cropped patterns outward in all directions based on the number of unique colors\n    for dx in range(-num_colors + 1, num_colors):\n        for dy in range(-num_colors + 1, num_colors):\n            if abs(dx) + abs(dy) \u003c num_colors:\n                blit_sprite(output_grid, cropped_grid, x=start_x + dx, y=start_y + dy)\n\n    return output_grid\n\ndef generate_input():\n    # Make a grid with a black background\n    width, height = np.random.randint(10, 15, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Randomly generate circular patterns\n    num_circles = np.random.randint(1, 5)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_circles, replace=False)\n\n    for color in colors:\n        # Create a circular sprite\n        radius = np.random.randint(1, 3)\n        circle_sprite = np.zeros((radius * 2 + 1, radius * 2 + 1), dtype=int)\n        for x in range(-radius, radius + 1):\n            for y in range(-radius, radius + 1):\n                if x**2 + y**2 \u003c= radius**2:\n                    circle_sprite[x + radius, y + radius] = color\n        \n        # Place the circle in a random location on the grid\n        x, y = random_free_location_for_sprite(input_grid, circle_sprite)\n        blit_sprite(input_grid, circle_sprite, x=x, y=y)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/82/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/82/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/82/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/82/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/82/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/82/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/82/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/82/images/train_output_2.png"}]}, "index": 82, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object duplication, border alignment\n\n# description:\n# In the input you will see a grid with colored objects on a black background.\n# Your task is to duplicate each object and align the copies along the top and left borders of the grid.\n# The duplicated objects should be centered at the top and left edge of the grid respectively.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all the colored objects in the input grid.\n    # 2. For each object, crop the object, scale it, and blit it onto the top and left edges of the grid.\n    \n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Detect all colored objects in the input grid\n    color_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=False, connectivity=8)\n\n    for obj in color_objects:\n        # Crop the object to isolate it\n        cropped_obj = crop(obj, background=Color.BLACK)\n\n        # Get bounding box to find its position\n        x, y, w, h = bounding_box(cropped_obj)\n\n        # Calculate the position for the top edge alignment\n        top_x = (output_grid.shape[1] - w) // 2\n        top_y = 0\n\n        # Calculate the position for the left edge alignment\n        left_x = 0\n        left_y = (output_grid.shape[0] - h) // 2\n\n        # Blit the top aligned sprite\n        output_grid = blit_sprite(output_grid, cropped_obj, top_x, top_y, background=Color.BLACK)\n\n        # Blit the left aligned sprite\n        output_grid = blit_sprite(output_grid, cropped_obj, left_x, left_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid with size of n x m.\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter colored objects on the grid\n    colored_objects_count = np.random.randint(2, 5)\n    for _ in range(colored_objects_count):\n        # Random size for each object (between 1x1 to 3x3)\n        object_size = np.random.randint(1, 4)\n        colored_object = np.full((object_size, object_size), np.random.choice(Color.NOT_BLACK))\n\n        # Find a random free location for the object\n        try:\n            x, y = random_free_location_for_sprite(grid, colored_object, background=Color.BLACK)\n            blit_sprite(grid, colored_object, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no space found, skip adding this object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/83/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/83/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/83/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/83/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/83/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/83/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/83/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/83/images/train_output_2.png"}]}, "index": 83, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, boundary extraction, flood fill\n\n# description:\n# The input grid contains a black background with colored regions (colored pixels) that may be disconnected.\n# To produce the output, you need to find the boundaries of these colored regions and fill the inside of these regions with a new color (e.g., yellow).\n# The regions are defined by the connected components of pixels that are not black. \n\ndef main(input_grid):\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = input_grid.copy()\n    \n    # Find all the connected components (colored regions)\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    \n    # Iterate over each component to find its boundary and fill the interior\n    for component in components:\n        # Get the boundary of the current component\n        boundary = object_boundary(component, background=Color.BLACK)\n        \n        # Create a mask for the interior of this component\n        interior_mask = object_interior(component)\n        \n        # Fill the interior with yellow, but only if it\u0027s not part of the boundary\n        for x, y in np.argwhere(interior_mask \u0026 ~boundary):\n            output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size between 10x10 and 20x20 with a black background\n    width, height = np.random.randint(10, 21, size=2)\n    grid = np.zeros((width, height), dtype=int)\n    \n    # Randomly create colored regions\n    num_regions = np.random.randint(1, 5)\n    for _ in range(num_regions):\n        # Choose a random color (not black)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        \n        # Randomly choose a size for the region\n        region_width = np.random.randint(2, 5)\n        region_height = np.random.randint(2, 5)\n        \n        # Create a sprite of the chosen size and color\n        sprite = np.full((region_width, region_height), color)\n        \n        # Try to place the sprite in a random free location in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            # If no free location is found, we skip to the next region\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/84/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/84/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/84/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/84/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/84/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/84/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/84/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/84/images/train_output_2.png"}]}, "index": 84, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, object detection, color transformation\n\n# description:\n# In the input grid, you will see several colored objects.\n# To create the output, find the largest object in the grid, scale it down by a factor of 2, and change its color to yellow.\n# All other objects should be colored green.\n\ndef main(input_grid):\n    # Create an output grid initialized to the same background color as the input\n    output_grid = np.copy(input_grid)\n    background_color = Color.BLACK\n    \n    # Detect all objects in the grid (non-background pixels)\n    objects = find_connected_components(input_grid, background=background_color, monochromatic=False, connectivity=4)\n    \n    # Find the largest object\n    largest_object = None\n    max_area = 0\n    for obj in objects:\n        area = np.sum(obj != background_color)\n        if area \u003e max_area:\n            max_area = area\n            largest_object = obj\n    \n    if largest_object is not None:\n        # Scale down the largest object\n        scaled_object = scale_sprite(crop(largest_object, background=background_color), factor=2)\n        # Change the color of the scaled object to yellow\n        scaled_object[scaled_object != background_color] = Color.YELLOW\n        \n        # Place the scaled object back into the output grid\n        x, y, _, _ = bounding_box(largest_object, background=background_color)\n        output_grid = blit_object(output_grid, scaled_object, background=background_color)\n\n    # Color all other objects green\n    for obj in objects:\n        if np.sum(obj != background_color) != max_area:  # if not the largest object\n            output_grid[obj != background_color] = Color.GREEN\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random number of colored objects\n    num_objects = np.random.randint(3, 8)\n    colors = np.random.choice(Color.NOT_BLACK, num_objects, replace=False)\n\n    for color in colors:\n        # Create a random sprite for the object\n        sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=[color], background=Color.BLACK)\n        \n        # Place the sprite onto the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            grid = blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If there\u0027s no space, ignore this sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/85/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/85/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/85/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/85/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/85/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/85/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/85/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/85/images/train_output_2.png"}]}, "index": 85, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, pattern detection, connectivity\n\n# description:\n# In the input, you will see a grid containing a series of colored regions, each separated by a black background.\n# To make the output, you need to identify each of these colored regions and color every alternate region blue,\n# while leaving the rest unchanged. For this, you will use the flood fill algorithm to fill in the identified regions.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (regions of colors) in the input grid\n    colored_regions = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Color every alternate region blue\n    for index, region in enumerate(colored_regions):\n        if index % 2 == 0:  # Only color every alternate region\n            # Get the position of a pixel in the region to start the flood fill\n            x, y = np.where(region != Color.BLACK)\n            if len(x) \u003e 0 and len(y) \u003e 0:\n                flood_fill(output_grid, x[0], y[0], Color.BLUE)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    grid_width, grid_height = np.random.randint(8, 15, size=2)\n    grid = np.full((grid_width, grid_height), Color.BLACK)\n\n    # Randomly determine the number of colored regions to create\n    num_regions = np.random.randint(3, 6)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_regions, replace=False)\n\n    # Randomly create colored regions\n    for color in colors:\n        # Random size and position for the region\n        region_width = np.random.randint(2, 5)\n        region_height = np.random.randint(2, 5)\n        start_x = np.random.randint(0, grid_width - region_width)\n        start_y = np.random.randint(0, grid_height - region_height)\n\n        # Fill the region with the chosen color\n        grid[start_x:start_x + region_width, start_y:start_y + region_height] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/86/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/86/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/86/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/86/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/86/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/86/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/86/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/86/images/train_output_2.png"}]}, "index": 86, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern, star shape, collision detection\n\n# description:\n# In the input, you will see a grid with a single colored pixel.\n# To make the output, create a star-shaped pattern from the colored pixel, extending outward in a cross pattern.\n# The star will have arms extending up, down, left, and right. \n# If any of the arms collide with another colored pixel, they should stop growing in that direction.\n\ndef main(input_grid):\n    # Extract the position and color of the single pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # Create the output grid\n    output_grid = input_grid.copy()\n    \n    # Define the directions for the star arms: up, down, left, right\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # (dx, dy)\n\n    # Draw each arm of the star\n    for dx, dy in directions:\n        x, y = pixel_x, pixel_y\n        while True:\n            x += dx\n            y += dy\n            \n            # Check for collision with the background color\n            if not (0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]):\n                break  # Stop if out of bounds\n            \n            if collision(object1=output_grid, object2=np.array([[pixel_color]]), x1=pixel_x, y1=pixel_y, x2=x, y2=y):\n                break  # Stop if colliding with a colored pixel\n            \n            output_grid[x, y] = pixel_color  # Color the current pixel\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    width, height = np.random.randint(5, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose a color for the pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the colored pixel somewhere in the grid\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/87/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/87/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/87/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/87/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/87/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/87/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/87/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/87/images/train_output_2.png"}]}, "index": 87, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, pattern transformation\n\n# description:\n# In the input you will see a single yellow pixel surrounded by a grid of other colors.\n# To make the output grid, you should replace the yellow pixel with a 5x5 pink star pattern centered on that pixel.\n\ndef main(input_grid):\n    # Detect the single yellow pixel in the grid.\n    yellow_pixels = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, allowed_dimensions=[(1, 1)])\n    assert len(yellow_pixels) == 1  # Ensure there is exactly one yellow pixel\n    yellow_pixel = yellow_pixels[0]\n\n    # Find the position of the yellow pixel\n    yellow_x, yellow_y = object_position(yellow_pixel, background=Color.BLACK, anchor=\"upper left\")\n\n    # Construct the 5x5 pink star pattern centered at the yellow pixel\n    star_pattern = np.array([[Color.BLACK, Color.BLACK, Color.PINK, Color.BLACK, Color.BLACK],\n                              [Color.BLACK, Color.PINK, Color.PINK, Color.PINK, Color.BLACK],\n                              [Color.PINK, Color.PINK, Color.PINK, Color.PINK, Color.PINK],\n                              [Color.BLACK, Color.PINK, Color.PINK, Color.PINK, Color.BLACK],\n                              [Color.BLACK, Color.BLACK, Color.PINK, Color.BLACK, Color.BLACK]])\n\n    # Calculate where the upper left corner of the star pattern should be placed\n    pattern_width, pattern_height = star_pattern.shape\n    pattern_x, pattern_y = yellow_x - pattern_width // 2, yellow_y - pattern_height // 2\n\n    # The output grid is the same size as the input grid, start with a blank canvas\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Blit the star pattern onto the output grid\n    output_grid = blit_sprite(grid=output_grid, x=pattern_x, y=pattern_y, sprite=star_pattern, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly set background colors (excluding yellow)\n    available_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.ORANGE, Color.PINK]\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(available_colors)\n\n    # Randomly place one yellow pixel\n    yellow_x, yellow_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[yellow_x, yellow_y] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/88/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/88/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/88/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/88/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/88/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/88/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/88/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/88/images/train_output_2.png"}]}, "index": 88, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layer stacking, color encoding\n\n# description:\n# In the input, you will see a grid with different colored layers that are stacked on top of each other. Each layer can have different shapes and colors, but only the topmost layer is visible. To produce the output, make a new grid where each visible layer is transformed based on its color: \n# - If the layer is red, replace it with yellow.\n# - If the layer is blue, replace it with green.\n# - If the layer is green, replace it with red.\n# The output grid should show only the visible colors from the stacking, maintaining their positions.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all layers in the grid\n    # 2. Replace the visible layers according to the color transformation rules\n    # 3. Create a new output grid that shows only the visible layers after transformation\n\n    # 1. Detect all layers\n    layers = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n\n    # Create an output grid initialized with black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 2. Process each layer, transforming colors and stacking them\n    for layer in layers:\n        # Identify the unique colors in the layer\n        unique_colors = set(layer.flatten())\n        for color in unique_colors:\n            if color == Color.RED:\n                new_color = Color.YELLOW\n            elif color == Color.BLUE:\n                new_color = Color.GREEN\n            elif color == Color.GREEN:\n                new_color = Color.RED\n            else:\n                continue  # Skip colors that do not need transformation\n\n            # Find the positions of the original color and update them in the output grid\n            output_grid[layer == color] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random layers of colors\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly stack layers of colored shapes\n    num_layers = np.random.randint(3, 6)  # Number of layers\n    for _ in range(num_layers):\n        # Generate a random sprite representing a layer\n        layer = random_sprite([2, 3, 4], [2, 3, 4], connectivity=4, color_palette=[Color.RED, Color.BLUE, Color.GREEN], background=Color.BLACK)\n\n        # Randomly place the layer in the grid\n        x, y = random_free_location_for_sprite(grid, layer, background=Color.BLACK)\n        blit_sprite(grid, layer, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/89/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/89/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/89/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/89/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/89/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/89/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/89/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/89/images/train_output_2.png"}]}, "index": 89, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change, connectivity\n\n# description:\n# In the input you will see a grid with several blue objects and a single yellow object.\n# To create the output grid, you should find the yellow object and connect it to the nearest blue object with a green line.\n# If there are no blue objects nearby, the yellow object should be changed to red.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = input_grid.copy()\n    \n    # Detect all blue objects\n    blue_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    \n    # Detect the single yellow object\n    yellow_objects = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n    \n    if len(yellow_objects) == 0:\n        return output_grid # no yellow object found\n    \n    yellow_object = yellow_objects[0]\n    \n    # If no blue objects found, change yellow object to red\n    if len(blue_objects) == 0:\n        yellow_object[yellow_object != Color.BLACK] = Color.RED\n        blit_object(output_grid, yellow_object, background=Color.BLACK)\n        return output_grid\n\n    # Get the position of the yellow object\n    yellow_x, yellow_y, _, _ = bounding_box(yellow_object, background=Color.BLACK)\n\n    # Find the closest blue object\n    closest_blue = None\n    closest_distance = float(\u0027inf\u0027)\n\n    for blue in blue_objects:\n        blue_x, blue_y, _, _ = bounding_box(blue, background=Color.BLACK)\n        distance = np.abs(blue_x - yellow_x) + np.abs(blue_y - yellow_y)\n        \n        if distance \u003c closest_distance:\n            closest_distance = distance\n            closest_blue = blue\n\n    if closest_blue is not None:\n        # Get the bounding box of the closest blue object\n        closest_x, closest_y, _, _ = bounding_box(closest_blue, background=Color.BLACK)\n\n        # Draw a green line connecting the yellow object to the closest blue object\n        for x, y in np.argwhere(output_grid == Color.BLACK):\n            if check_between_objects(yellow_object, closest_blue, x, y, padding=0):\n                output_grid[x, y] = Color.GREEN\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Place the yellow object\n    yellow_sprite = random_sprite(2, 2, color_palette=[Color.YELLOW])\n    y_x, y_y = random_free_location_for_sprite(grid=grid, sprite=yellow_sprite, padding=1)\n    grid = blit_sprite(grid, yellow_sprite, x=y_x, y=y_y, background=Color.BLACK)\n\n    # Place several blue objects around the yellow one\n    num_blue_objects = np.random.randint(1, 6)\n    for _ in range(num_blue_objects):\n        blue_sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[Color.BLUE])\n        while True:\n            try:\n                x, y = random_free_location_for_sprite(grid, blue_sprite, padding=1)\n                grid = blit_sprite(grid, blue_sprite, x=x, y=y, background=Color.BLACK)\n                break\n            except ValueError:\n                continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/90/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/90/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/90/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/90/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/90/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/90/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/90/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/90/images/train_output_2.png"}]}, "index": 90, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color separation, object placement, collision detection\n\n# description:\n# In the input, you will see several colored pixels forming a shape, which is surrounded by a black background.\n# To make the output, you need to place a new shape of a different color, directly below the original shape,\n# ensuring that the new shape does not overlap with the original shape. The new shape should be the same size as the original shape.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the bounding box of the original shape.\n    # 2. Determine the position for the new shape, which will be directly below the original shape.\n    # 3. Create the new shape with a different color.\n    # 4. Check for collision to ensure the new shape can fit without overlapping the original shape.\n    # 5. Place the new shape on the grid if there is no collision.\n\n    # 1. Find the bounding box of the original shape\n    original_shape = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)[0]\n    x, y, width, height = bounding_box(original_shape)\n\n    # 2. Determine the position for the new shape\n    new_shape_x = x\n    new_shape_y = y + height  # Place directly below the original shape\n\n    # 3. Create the new shape with a different color\n    new_shape_color = Color.BLUE  # Example color for the new shape\n    new_shape = np.full((height, width), new_shape_color)\n\n    # 4. Check for collision to ensure the new shape can fit without overlapping the original shape\n    if collision(object1=input_grid, object2=new_shape, x1=new_shape_x, y1=new_shape_y):\n        raise ValueError(\"Collision detected: Cannot place new shape without overlap.\")\n\n    # 5. Place the new shape on the grid\n    output_grid = input_grid.copy()\n    blit_sprite(output_grid, new_shape, x=new_shape_x, y=new_shape_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random shape on a black grid\n    width = np.random.randint(5, 15)\n    height = np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly create a shape with non-black pixels\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_width = np.random.randint(2, 5)\n    shape_height = np.random.randint(2, 5)\n    \n    shape = np.full((shape_height, shape_width), shape_color)\n\n    # Place the shape randomly on the grid\n    x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n    blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/91/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/91/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/91/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/91/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/91/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/91/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/91/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/91/images/train_output_2.png"}]}, "index": 91, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern filling, color identification, connected components\n\n# description:\n# In the input, you will see a 2D grid containing a pattern made up of various colors, including a black background.\n# The top-left corner of the grid contains a unique pattern, and the rest of the grid is filled with different colors.\n# To make the output, identify the unique colors in the input and fill all instances of the identified colors in the grid \n# using the color from the top-left corner of the grid.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = input_grid.copy()\n\n    # Identify colors in the grid excluding the background color (BLACK)\n    unique_colors = object_colors(input_grid, background=Color.BLACK)\n\n    # The pattern color is taken from the top-left corner\n    pattern_color = output_grid[0, 0]\n\n    # Replace all identified unique colors in the output grid with the pattern_color\n    for color in unique_colors:\n        if color != pattern_color:  # Avoid replacing the pattern color itself\n            output_grid[output_grid == color] = pattern_color\n    \n    return output_grid\n\ndef generate_input():\n    # Randomly create a grid size between 10x10 and 20x20\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black background\n\n    # Generate a unique pattern in the top-left corner\n    pattern_height = np.random.randint(2, 5)\n    pattern_width = np.random.randint(2, 5)\n    pattern_color = np.random.choice(Color.NOT_BLACK)\n\n    # Fill the pattern in the top-left corner\n    for i in range(pattern_height):\n        for j in range(pattern_width):\n            grid[i, j] = pattern_color\n\n    # Fill the rest of the grid with random colors\n    colors = list(Color.NOT_BLACK)\n    for i in range(n):\n        for j in range(m):\n            if grid[i, j] == Color.BLACK:  # Only fill black cells\n                grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/92/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/92/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/92/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/92/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/92/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/92/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/92/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/92/images/train_output_2.png"}]}, "index": 92, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, pattern replication, color matching\n\n# description:\n# In the input, you will see a grid with various colored shapes, each shape having a unique indicator color at the top-left corner. \n# Your goal is to replicate a template shape by scaling it to match the size of the shapes in the input, while placing it on top of each shape such that the indicator colors align. \n# The color of the template shape should change to match the color of the shape it is being placed onto.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the template shape and identify its indicator color.\n    # 2. For each shape in the input, rescale the template to the size of the shape using the indicator for alignment.\n    # 3. Change the color of the rescaled template to match the color of the shape it\u0027s being placed over.\n    # 4. Overlay the rescaled template onto the shape in the output grid.\n\n    # 1. Extract the template shape\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    \n    # Identify the template object by finding the object with the most pixels\n    template_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n    template_sprite = crop(template_object, background=Color.BLACK)\n    \n    # Find the indicator color which is in the top-left corner\n    indicator_color = template_sprite[0, 0]\n\n    # 2. Iterate through all objects and rescale the template\n    output_grid = input_grid.copy()\n    for obj in objects:\n        if np.array_equal(obj, template_object):\n            continue  # Skip the template itself\n\n        # Find the new shape\u0027s color and size\n        new_color = [color for color in object_colors(obj, background=Color.BLACK) if color != indicator_color][0]\n        indicator_size = np.sum(obj == indicator_color)\n        \n        # Calculate the scale factor based on the indicator size in the new shape\n        new_scale = np.sum(template_sprite == indicator_color) // indicator_size\n        \n        # Scale the template sprite\n        scaled_template = scale_sprite(template_sprite, new_scale)\n        \n        # Change the color of the scaled template to match the new shape\u0027s color\n        scaled_template[(scaled_template != Color.BLACK) \u0026 (scaled_template != indicator_color)] = new_color\n        \n        # Overlay the scaled template onto the shape\n        x_offset = np.argwhere(obj == indicator_color)[0][0] - np.argwhere(scaled_template == indicator_color)[0][0]\n        y_offset = np.argwhere(obj == indicator_color)[0][1] - np.argwhere(scaled_template == indicator_color)[0][1]\n        blit_sprite(output_grid, scaled_template, x=x_offset, y=y_offset)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random shapes, each having an indicator pixel\n    background = Color.BLACK\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((width, height), background)\n\n    # Randomly select the number of shapes\n    n_shapes = np.random.randint(2, 5)\n    colors = np.random.choice(Color.NOT_BLACK, n_shapes, replace=False)\n\n    for color in colors:\n        # Create a random shape with an indicator pixel\n        shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        shape_sprite = random_sprite(shape_width, shape_height, color_palette=[color], connectivity=4)\n        \n        # Set the top-left corner to be the indicator pixel\n        shape_sprite[0, 0] = Color.RED  # Use red as the indicator color\n\n        # Place the shape on the grid at a random position\n        x, y = random_free_location_for_sprite(grid, shape_sprite, background=background)\n        blit_sprite(grid, shape_sprite, x=x, y=y, background=background)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/93/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/93/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/93/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/93/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/93/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/93/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/93/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/93/images/train_output_2.png"}]}, "index": 93, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# region filling, boundary detection\n\n# description:\n# The input grid consists of colored pixels forming various shapes. The challenge is to identify enclosed regions within those shapes. \n# The output should fill these enclosed regions with a color that matches the color of the boundary pixels. If a boundary pixel is black, the enclosed region should be filled with black.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False)\n\n    for obj in objects:\n        # Get the color of the boundary\n        boundary_mask = object_boundary(obj)\n        boundary_colors = object_colors(obj, background=Color.BLACK)\n        \n        # Determine the fill color for the enclosed region\n        fill_color = Color.BLACK  # Default fill color\n        for color in boundary_colors:\n            if color != Color.BLACK:  # Prefer non-black boundary colors\n                fill_color = color\n                break\n        \n        # Get the interior of the object\n        interior_mask = object_interior(obj, background=Color.BLACK)\n\n        # Fill the output grid using the determined fill color\n        for x, y in np.argwhere(interior_mask):\n            output_grid[x, y] = fill_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a square grid with black background, size from 10x10 to 20x20\n    n = random.randint(10, 20)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Create random colored shapes in the grid\n    num_shapes = random.randint(1, 5)\n    for _ in range(num_shapes):\n        # Generate a random sprite\n        sprite_size = random.randint(3, 8)\n        sprite_color = random.choice(Color.NOT_BLACK)\n        sprite = random_sprite(sprite_size, sprite_size, color_palette=[sprite_color], density=0.5)\n\n        # Find a random location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # Skip if no space is found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/94/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/94/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/94/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/94/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/94/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/94/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/94/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/94/images/train_output_2.png"}]}, "index": 94, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, mirroring, bounding box\n\n# description:\n# In the input you will see a grid with several colored pixels along the left edge.\n# To make the output, you should create a mirror image of these pixels along the right edge of the grid.\n# Each colored pixel should be transformed to the corresponding position on the right side of the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the pixels along the left edge of the grid.\n    # 2. Calculate the width of the input grid to determine the right edge.\n    # 3. Create a mirrored version of the left edge pixels on the right edge.\n\n    # 1. Extract the left edge pixels\n    left_edge_pixels = input_grid[:, 0]\n    \n    # 2. Create output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    width, height = input_grid.shape\n\n    # 3. Mirror the left edge pixels to the right edge\n    for y in range(height):\n        color = left_edge_pixels[y]\n        if color != Color.BLACK:\n            output_grid[y, width - 1] = color\n\n    # Add the original left edge pixels to the output grid for completeness\n    output_grid[:, 0] = left_edge_pixels\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a width of at least 5 and a random height\n    width = np.random.randint(5, 15)\n    height = np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose some colors for the left edge, ensuring that they are not black\n    num_pixels = np.random.randint(1, height + 1)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=False)\n\n    # Place the colors along the left edge of the grid\n    for y in range(num_pixels):\n        grid[0, y] = colors[y]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/95/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/95/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/95/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/95/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/95/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/95/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/95/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/95/images/train_output_2.png"}]}, "index": 95, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, alignment, overlay\n\n# description:\n# In the input you will see a blue object and a yellow arrow indicating a direction.\n# To make the output, rotate the blue object to align it with the arrow, and overlay the rotated blue object on the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the objects; separate the blue object from the yellow arrow\n    # 2. Determine the angle of the arrow\n    # 3. Rotate the blue object to align with the arrow and overlay it on the grid\n\n    # 1. Object detection and setup\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=True)\n\n    blue_objects = [obj for obj in objects if Color.BLUE in object_colors(obj, background=Color.BLACK)]\n    arrow_objects = [obj for obj in objects if Color.YELLOW in object_colors(obj, background=Color.BLACK)]\n\n    assert len(blue_objects) == 1, \"There should be exactly one blue object\"\n    assert len(arrow_objects) == 1, \"There should be exactly one yellow arrow\"\n\n    blue_object = blue_objects[0]\n    arrow_object = arrow_objects[0]\n\n    # Make the output grid: Start with a black background\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. Determine the angle of the arrow\n    arrow_x, arrow_y = object_position(arrow_object, background=Color.BLACK, anchor=\"center\")\n    # Check the direction in which the arrow points\n    arrow_direction = np.array(np.argwhere(arrow_object == Color.YELLOW))\n    if arrow_direction.size == 0:\n        return output_grid  # Return empty if no direction found\n\n    # Calculate the angle based on the arrow\u0027s position\n    # We can use the y-coordinates to determine the vertical position of the arrow\n    if arrow_direction[0][0] \u003c arrow_object.shape[0] / 2:  # Arrow points up\n        angle = 0\n    elif arrow_direction[0][0] \u003e arrow_object.shape[0] / 2:  # Arrow points down\n        angle = 180\n    else:  # Arrow points right\n        angle = 90\n\n    # 3. Rotate the blue object to align with the arrow\n    rotated_blue_object = np.rot90(blue_object, k=angle // 90)\n\n    # Overlay the rotated blue object on the output grid\n    blit_object(output_grid, rotated_blue_object)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a blue shape and a yellow arrow indicating the direction\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a blue object\n    blue_sprite = random_sprite(3, 5, color_palette=[Color.BLUE])\n    x, y = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK)\n    blit_sprite(grid, blue_sprite, x, y, background=Color.BLACK)\n\n    # Create a yellow arrow\n    arrow_sprite = np.zeros((3, 3), dtype=object)\n    arrow_sprite[1, 0] = Color.YELLOW  # Arrow base\n    arrow_sprite[0, 1] = Color.YELLOW  # Arrow point\n    arrow_sprite[1, 1] = Color.YELLOW  # Arrow point\n    arrow_sprite[2, 1] = Color.YELLOW  # Arrow point\n    arrow_sprite[1, 2] = Color.YELLOW  # Arrow point\n\n    # Position the arrow pointing in a random direction\n    arrow_x, arrow_y = random_free_location_for_sprite(grid, arrow_sprite, background=Color.BLACK)\n    blit_sprite(grid, arrow_sprite, arrow_x, arrow_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/96/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/96/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/96/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/96/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/96/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/96/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/96/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/96/images/train_output_2.png"}]}, "index": 96, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# regions, color averaging\n\n# description:\n# In the input, you will see a grid divided into several regions, each made up of connected pixels of the same color.\n# To make the output, replace each region with a single pixel of that color located at the average position of the region\u0027s pixels.\n# The output grid should be the smallest possible size that contains all the new pixels.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all connected components (regions) in the input grid.\n    # 2. For each region, calculate the average position of its pixels.\n    # 3. Create an output grid and place each region\u0027s color at its average position.\n    # 4. Crop the output grid to the smallest bounding box containing all new pixels.\n\n    # 1. Find the connected components in the input grid\n    regions = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Initialize the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 2. For each region, calculate the average position and store the color\n    for region in regions:\n        # Get the color of the region\n        color = object_colors(region, background=Color.BLACK)[0]\n\n        # Get the coordinates of the region\u0027s pixels\n        coordinates = np.argwhere(region != Color.BLACK)\n        if coordinates.size == 0:\n            continue\n        \n        # Calculate the average position\n        avg_x = int(np.mean(coordinates[:, 0]))\n        avg_y = int(np.mean(coordinates[:, 1]))\n\n        # Place the color in the output grid at the average position\n        output_grid[avg_x, avg_y] = color\n\n    # 3. Crop the output grid to the smallest bounding box that contains all non-black pixels\n    output_grid = crop(output_grid, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a random grid with colored regions\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_regions = np.random.randint(5, 10)\n    for _ in range(num_regions):\n        # Choose random color for the region\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Randomly determine the position and size of the region\n        start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n        width, height = np.random.randint(2, 4), np.random.randint(2, 4)\n\n        # Draw the region within the bounds of the grid\n        for x in range(start_x, min(start_x + width, n)):\n            for y in range(start_y, min(start_y + height, m)):\n                grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/97/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/97/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/97/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/97/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/97/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/97/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/97/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/97/images/train_output_2.png"}]}, "index": 97, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, object boundaries, coloring\n\n# description:\n# In the input grid, you will see a background of black pixels, and several enclosed regions formed by green pixels.\n# To produce the output, you need to find the boundaries of these enclosed regions and color them blue. \n# Additionally, any interior pixels (the pixels that are not part of the boundary but are within the enclosed regions) should be colored red.\n\ndef main(input_grid):\n    # Create the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the boundaries of the green regions\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n    \n    # Color the boundaries blue\n    output_grid[boundary_mask] = Color.BLUE\n\n    # Find the interior pixels (not part of the boundary but within the green regions)\n    interior_mask = object_interior(input_grid)\n    inside_but_not_on_edge = interior_mask \u0026 ~boundary_mask\n\n    # Color the interior pixels red\n    output_grid[inside_but_not_on_edge] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Generate a square grid with a black background, size from 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate random green sprites forming enclosed regions\n    n_objects = np.random.randint(2, 5)\n    for _ in range(n_objects):\n        w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n        sprite = random_sprite(w, h, color_palette=[Color.GREEN])\n\n        # Hollow out the interior to create a boundary\n        interior_mask = object_interior(sprite)\n        boundary_mask = object_boundary(sprite)\n        interior_but_not_edges = interior_mask \u0026 ~boundary_mask\n        sprite[interior_but_not_edges] = Color.BLACK  # Make the interior black\n\n        # Try to place the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # Skip if no free location is found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/98/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/98/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/98/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/98/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/98/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/98/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/98/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/98/images/train_output_2.png"}]}, "index": 98, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines, pixel expansion\n\n# description:\n# In the input, you will see a horizontal line of colored pixels on a black background.\n# To make the output, create a square grid and place the input line at the top-left. Each colored pixel shoots a diagonal line outward toward the lower right.\n# The length of the output grid is the product of the number of colored input pixels and the length of the input line.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Determine the size of the output grid based on the input grid dimensions and the number of colored pixels.\n    # 2. Place the input line at the top-left of the output grid.\n    # 3. For each colored pixel, draw diagonal lines extending downward to the right.\n\n    # 1. Count the number of colored pixels in the input grid\n    colored_pixels = np.sum(input_grid != Color.BLACK)\n    input_height, input_width = input_grid.shape\n    output_size = colored_pixels * input_width  # Define output size\n\n    # Create the output grid filled with black color\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # 2. Place the input line at the top-left of the output grid\n    blit_sprite(output_grid, input_grid, x=0, y=0)\n\n    # 3. Draw diagonal lines from each colored pixel in the input line\n    for x in range(input_width):\n        if input_grid[x, 0] != Color.BLACK:  # Only process colored pixels\n            # Start drawing diagonal lines\n            draw_line(output_grid, x, 0, length=None, color=input_grid[x, 0], direction=(1, 1))\n\n    return output_grid\n\ndef generate_input():\n    # Generate a horizontal line of colored pixels\n    width = np.random.randint(3, 8)  # Random width for the line\n    grid = np.full((width, 1), Color.BLACK)  # Start with a black grid\n\n    # Randomly assign colors to the pixels in the line, ensuring at least one color\n    num_colored_pixels = np.random.randint(1, width + 1)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colored_pixels, replace=False)\n    for i in range(num_colored_pixels):\n        grid[np.random.randint(0, width), 0] = colors[i]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/99/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/99/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/99/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/99/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/99/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/99/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/99/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/99/images/train_output_2.png"}]}, "index": 99, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision detection, occlusion, translation\n\n# description:\n# In the input, you will see a colored object (not black) and a rectangular occluder that partially covers it.\n# The output should be the complete object after sliding the occluder away from the object until they just touch.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the occluder and the original object.\n    # 2. Determine the best position to slide the occluder.\n    # 3. Slide the occluder towards the object until they touch without overlapping.\n\n    # Identify the occluder (black rectangle) and the colored object (not black)\n    occluder_mask = (input_grid == Color.BLACK)\n    object_mask = (input_grid != Color.BLACK)\n\n    # Get the shape of the grid\n    height, width = input_grid.shape\n\n    # Initialize output grid with the original object\n    output_grid = np.copy(input_grid)\n\n    # Get coordinates of the object\n    object_coords = np.argwhere(object_mask)\n\n    # Check if the object is present\n    if object_coords.size == 0:\n        return output_grid  # Nothing to process\n\n    # Identify the edges of the occluder\n    occluder_coords = np.argwhere(occluder_mask)\n    occluder_top_left = occluder_coords.min(axis=0)\n    occluder_bottom_right = occluder_coords.max(axis=0)\n\n    # Slide the occluder in four directions\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # Down, Up, Right, Left\n    for dx, dy in directions:\n        # Translate the occluder\n        translated_occluder = translate(input_grid[occluder_top_left[0]:occluder_bottom_right[0]+1, \n                                                   occluder_top_left[1]:occluder_bottom_right[1]+1], \n                                         dx, dy, background=Color.BLACK)\n\n        # Check for collisions with the object\n        if collision(object1=object_mask, object2=translated_occluder, background=Color.BLACK):\n            # If they touch, update the output grid\n            blit_sprite(output_grid, translated_occluder, occluder_top_left[0] + dx, occluder_top_left[1] + dy, \n                        background=Color.BLACK)\n            break\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random grid with a colored object.\n    # 2. Place a rectangular occluder over the object.\n\n    # Create a grid of a random size with a black background\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a colored object\n    object_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.5, color_palette=[object_color])\n\n    # Place the colored object randomly onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Create a rectangular occluder\n    occluder_width, occluder_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    occluder_x, occluder_y = random.randint(0, n-occluder_height), random.randint(0, m-occluder_width)\n    occluder = np.full((occluder_height, occluder_width), Color.BLACK)\n\n    # Blit the occluder on top of the object\n    blit_sprite(grid, occluder, occluder_x, occluder_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/100/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/100/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/100/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/100/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/100/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/100/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/100/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/100/images/train_output_2.png"}]}, "index": 100, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, pattern placement, color identification\n\n# description:\n# In the input you will see a large colored grid with a smaller colored sprite inside a square border of a different color.\n# To make the output, you should scale the sprite to fit exactly within the border square, filling the border completely.\n# The border will be of a specified color (e.g., red), and the smaller sprite will be of another color (e.g., blue).\n# The output should be only the scaled sprite placed inside the border.\n\ndef main(input_grid):\n    # Detect the border square and the small sprite\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=8)\n    \n    # Extract the objects: one will be the border (indicated by a unique color) and the other the sprite\n    for obj in objects:\n        sprite = crop(obj, background=Color.BLACK)\n        if Color.RED in object_colors(sprite, background=Color.BLACK):\n            border_sprite = sprite\n        else:\n            inner_sprite = sprite\n    \n    # Calculate the scaling factor based on the border size.\n    # The border should have a 1-pixel border around it, so we must account for that\n    scale = (len(border_sprite) - 2) // len(inner_sprite)\n\n    # Scale the small sprite to fit the border\n    scaled_inner_sprite = scale_sprite(inner_sprite, factor=scale)\n\n    # Prepare the output grid which will only contain the scaled sprite\n    output_grid = np.full(border_sprite.shape, Color.BLACK)\n    blit_sprite(output_grid, scaled_inner_sprite, x=1, y=1, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the small object size\n    small_object_size = 3\n    scale = np.random.randint(1, 4)  # Scale factor for enlarging the sprite\n    \n    # Create the border square with the specified scale\n    border_size = scale * small_object_size + 2  # accounting for border\n    big_border_square = np.full((border_size, border_size), Color.RED)\n    big_border_square[1:-1, 1:-1] = Color.BLACK  # inner area is black\n\n    # Randomly place the border square in the grid\n    x_border, y_border = random_free_location_for_sprite(grid, big_border_square)\n    grid = blit_sprite(x=x_border, y=y_border, grid=grid, sprite=big_border_square, background=Color.BLACK)\n\n    # Generate the small sprite to fit inside the border\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.RED]\n    random_color = np.random.choice(available_colors)\n\n    # Randomly create the small sprite\n    small_sprite = random_sprite(n=small_object_size, m=small_object_size, color_palette=[random_color], density=0.5)\n\n    # Place the small sprite in the area without the red border\n    x_sprite, y_sprite = random_free_location_for_sprite(grid, small_sprite)\n    grid = blit_sprite(x=x_sprite, y=y_sprite, grid=grid, sprite=small_sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/101/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/101/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/101/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/101/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/101/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/101/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/101/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/101/images/train_output_2.png"}]}, "index": 101, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, bounding box, color transformation\n\n# description:\n# In the input grid, you will see various colored shapes on a black background.\n# To create the output, you should identify the bounding box of each colored shape and change the color of the entire bounding box to a new color.\n# The new color should be determined based on the original color of the shape: \n# - red becomes orange,\n# - blue becomes maroon,\n# - green becomes pink,\n# - yellow becomes maroon.\n# If a shape is black (which should not occur) or has no bounding box, it should be left unchanged.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Find connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False)\n\n    # Process each shape\n    for shape in shapes:\n        # Get the bounding box of the shape\n        x, y, width, height = bounding_box(shape)\n\n        # Determine the color of the shape\n        shape_color = shape[shape != Color.BLACK][0]  # Get color that is not black\n        \n        # Map color to new color\n        if shape_color == Color.RED:\n            new_color = Color.ORANGE\n        elif shape_color == Color.BLUE:\n            new_color = Color.MAROON\n        elif shape_color == Color.GREEN:\n            new_color = Color.PINK\n        elif shape_color == Color.YELLOW:\n            new_color = Color.MAROON\n        else:\n            continue  # If color is not mapped, skip\n\n        # Fill the bounding box with the new color\n        output_grid[x:x + height, y:y + width] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of size n x m\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create a number of colored shapes\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        width, height = np.random.randint(1, 4), np.random.randint(1, 4)\n        color = np.random.choice([Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW])\n        \n        # Create a random sprite\n        sprite = np.full((height, width), color)\n        \n        # Find a random free location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no free location, skip this shape\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/102/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/102/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/102/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/102/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/102/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/102/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/102/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/102/images/train_output_2.png"}]}, "index": 102, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, pixel manipulation\n\n# description:\n# In the input, you will see a central colored pattern surrounded by a border of black pixels. \n# To make the output, you should create layers on top of the original pattern, where each layer is a \n# horizontally mirrored version of the original pattern, displaced by one pixel to the left and right, \n# respectively. The output should consist of three layers: the original pattern, the left mirrored layer, \n# and the right mirrored layer.\n\ndef main(input_grid):\n    # Extract the original pattern\n    original_pattern = input_grid\n\n    # Create mirrored patterns\n    left_mirror = np.fliplr(original_pattern)\n    right_mirror = np.fliplr(original_pattern)\n\n    # Prepare the output grid\n    output_height, output_width = original_pattern.shape\n    output_grid = np.full((output_height, output_width + 4), Color.BLACK)  # +4 for the new layers\n\n    # Place the original pattern in the middle\n    blit_object(output_grid, original_pattern)\n\n    # Place the left mirrored pattern displacing it to the left\n    blit_object(output_grid, left_mirror, background=Color.BLACK)\n    # Shift left mirrored layer one pixel to the left\n    blit_object(output_grid, left_mirror, background=Color.BLACK)\n\n    # Place the right mirrored pattern displacing it to the right\n    blit_object(output_grid, right_mirror, background=Color.BLACK)\n    # Shift right mirrored layer one pixel to the right\n    blit_object(output_grid, right_mirror, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random central pattern\n    size = np.random.randint(3, 6)  # size of the central pattern\n    central_pattern = random_sprite(size, size, density=1.0, color_palette=Color.NOT_BLACK)\n\n    # Create a grid with a black border around the central pattern\n    output_size = size + 4  # 2 pixels padding on each side\n    grid = np.full((output_size, output_size), Color.BLACK)\n    \n    # Place the central pattern in the middle of the grid\n    blit_sprite(grid, central_pattern, 2, 2)  # Center the pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/103/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/103/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/103/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/103/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/103/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/103/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/103/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/103/images/train_output_2.png"}]}, "index": 103, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color expansion, line drawing\n\n# description:\n# In the input, you will see a grid with a central patterned square surrounded by a border of colored pixels. \n# To make the output:\n# 1. Extract the central pattern from the grid, ignoring the border.\n# 2. Enlarge every pixel of the extracted pattern by a factor of 2.\n# 3. From each corner of the enlarged pattern, draw diagonal blue lines extending outward until they hit the edge of the grid.\n\ndef main(input_grid):\n    # Step 1: Extract the central pattern by finding the bounding box\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    \n    # Assuming there\u0027s only one central pattern object\n    central_pattern = objects[0]\n    x, y, w, h = bounding_box(central_pattern)\n\n    # Crop the central pattern from the input grid\n    pattern = crop(input_grid[x:x+w, y:y+h], background=Color.BLACK)\n\n    # Step 2: Enlarge the pattern by a factor of 2\n    enlarged_pattern = np.repeat(np.repeat(pattern, 2, axis=0), 2, axis=1)\n\n    # Create output grid, initializing with black\n    output_grid = np.full((input_grid.shape[0], input_grid.shape[1]), Color.BLACK)\n\n    # Place the enlarged pattern in the output grid\n    output_start_x, output_start_y = (x * 2), (y * 2)\n    blit_sprite(output_grid, enlarged_pattern, output_start_x, output_start_y, background=Color.BLACK)\n\n    # Step 3: Draw diagonal lines from each corner of the enlarged pattern\n    corners = [\n        (output_start_x - 1, output_start_y - 1),  # top-left corner\n        (output_start_x + enlarged_pattern.shape[0], output_start_y - 1),  # top-right corner\n        (output_start_x - 1, output_start_y + enlarged_pattern.shape[1]),  # bottom-left corner\n        (output_start_x + enlarged_pattern.shape[0], output_start_y + enlarged_pattern.shape[1])  # bottom-right corner\n    ]\n    \n    for corner_x, corner_y in corners:\n        # Draw diagonal blue lines outward from each corner\n        draw_line(output_grid, corner_x, corner_y, length=None, color=Color.BLUE, direction=(1, 1))\n        draw_line(output_grid, corner_x, corner_y, length=None, color=Color.BLUE, direction=(-1, -1))\n        draw_line(output_grid, corner_x, corner_y, length=None, color=Color.BLUE, direction=(1, -1))\n        draw_line(output_grid, corner_x, corner_y, length=None, color=Color.BLUE, direction=(-1, 1))\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a central patterned square and a surrounding border\n    n, m = np.random.randint(8, 12), np.random.randint(8, 12)  # Size of the grid\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a pattern color\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a central pattern\n    central_pattern_size = np.random.randint(2, 4)  # Size of the central pattern\n    central_pattern = random_sprite(central_pattern_size, central_pattern_size, density=0.8, color_palette=[pattern_color])\n    \n    # Place the central pattern in the grid, ensuring it doesn\u0027t touch the edges\n    x, y = random_free_location_for_sprite(grid, central_pattern, border_size=1)\n    blit_sprite(grid, central_pattern, x, y)\n\n    # Add a border of colors around the central pattern\n    border_colors = np.random.choice(list(Color.NOT_BLACK), size=4, replace=False)\n    for i in range(n):\n        grid[i, 0] = border_colors[0]  # left border\n        grid[i, -1] = border_colors[1]  # right border\n    for j in range(m):\n        grid[0, j] = border_colors[2]  # top border\n        grid[-1, j] = border_colors[3]  # bottom border\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/104/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/104/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/104/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/104/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/104/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/104/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/104/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/104/images/train_output_2.png"}]}, "index": 104, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color matching, grid manipulation\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels in the center,\n# surrounded by a border of black pixels. The pattern consists of a 3x3 area filled with various colors.\n# To create the output, copy the central pattern and change the color of the pixels to match the color\n# of the top-left pixel of the pattern. The output grid should have an extra border of black pixels around it.\n\ndef main(input_grid):\n    # Step 1: Crop the central 3x3 pattern from the input grid.\n    pattern = input_grid[1:4, 1:4]\n    \n    # Step 2: Determine the color of the top-left pixel of the pattern.\n    color_to_match = pattern[0, 0]\n    \n    # Step 3: Create an output grid with an additional border of black pixels.\n    output_grid = np.full((5, 5), Color.BLACK)\n    \n    # Step 4: Change the color of the pixels in the cropped pattern to match the top-left pixel color.\n    pattern[pattern != Color.BLACK] = color_to_match\n    \n    # Step 5: Blit the modified pattern onto the output grid.\n    blit_sprite(output_grid, pattern, x=1, y=1, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 5x5 grid filled with black pixels\n    input_grid = np.full((5, 5), Color.BLACK)\n    \n    # Generate a random 3x3 pattern with colors\n    pattern_colors = np.random.choice(list(Color.NOT_BLACK), size=(3, 3))\n    \n    # Place the pattern in the center of the input grid\n    input_grid[1:4, 1:4] = pattern_colors\n    \n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/105/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/105/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/105/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/105/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/105/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/105/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/105/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/105/images/train_output_2.png"}]}, "index": 105, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color alignment, object extraction\n\n# description:\n# In the input grid, you will see several colored objects, each containing a distinct color in one of their corners, and a single pixel of another color in the center of the grid.\n# To make the output grid, you should rotate each object until it aligns such that the corner pixel of the object matches the center pixel\u0027s color, then arrange all these objects so that they cluster around the center.\n\ndef main(input_grid):\n    # Detect the colored objects in the grid. Each object has a unique color in one corner.\n    objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n    \n    # Create an output grid that will be modified\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find the center pixel\u0027s color\n    center_color = input_grid[input_grid.shape[0] // 2, input_grid.shape[1] // 2]\n\n    # Process each detected object\n    for obj in objects:\n        # Determine the corner pixel that contains the unique color\n        corner_pixel_pos = np.argwhere(obj != Color.BLACK)[0]\n        corner_color = obj[corner_pixel_pos[0], corner_pixel_pos[1]]\n\n        # Check if the corner color matches the center color\n        if corner_color == center_color:\n            # If colors match, we can place it without rotation\n            x_offset = (output_grid.shape[0] // 2) - corner_pixel_pos[0]\n            y_offset = (output_grid.shape[1] // 2) - corner_pixel_pos[1]\n            blit_sprite(output_grid, obj, x_offset, y_offset, background=Color.BLACK)\n        else:\n            # Rotate the object to find a matching configuration\n            for rotation in range(4):\n                rotated_obj = np.rot90(obj, rotation)\n                new_corner_pos = np.argwhere(rotated_obj != Color.BLACK)[0]\n                new_corner_color = rotated_obj[new_corner_pos[0], new_corner_pos[1]]\n                \n                if new_corner_color == center_color:\n                    # Place the object with the matching corner in the output\n                    x_offset = (output_grid.shape[0] // 2) - new_corner_pos[0]\n                    y_offset = (output_grid.shape[1] // 2) - new_corner_pos[1]\n                    blit_sprite(output_grid, rotated_obj, x_offset, y_offset, background=Color.BLACK)\n                    break\n\n    return output_grid\n\ndef generate_input():\n    # Create a random size grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random center pixel color\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Place the center pixel in the middle of the grid\n    grid[n // 2, m // 2] = center_color\n\n    # Generate random objects with distinct colors in one of their corners\n    num_objects = np.random.randint(3, 7)\n    for _ in range(num_objects):\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n        size = np.random.randint(2, 5)\n        obj = np.full((size, size), Color.BLACK)\n        obj[0, 0] = obj_color  # Set a unique color at one corner of the object\n\n        # Place the object in a random position in the grid, making sure it fits\n        x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK, padding=1)\n        blit_sprite(grid, obj, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/106/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/106/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/106/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/106/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/106/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/106/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/106/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/106/images/train_output_2.png"}]}, "index": 106, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, color change, stacking\n\n# description:\n# In the input, you will see a rectangular grey object at the center of the grid with colored pixels scattered around it.\n# To make the output, each colored pixel should move toward the grey rectangle until it touches, and its color should change to grey. \n# If multiple colored pixels collide, they stack on top of each other.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the grey rectangle.\n    # 2. Move each colored pixel toward the grey rectangle until it touches it.\n    # 3. Change the color of the colored pixels to grey once they touch, and stack them if they collide.\n\n    # Detect all colored objects and the grey object\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)\n    \n    grey_objects = [obj for obj in objects if Color.GREY in object_colors(obj, background=Color.BLACK)]\n    colored_objects = [obj for obj in objects if Color.GREY not in object_colors(obj, background=Color.BLACK)]\n\n    assert len(grey_objects) == 1, \"There should be exactly one grey object\"\n    grey_object = grey_objects[0]\n\n    # Create the output grid starting with the grey object\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    blit_object(output_grid, grey_object)\n\n    # Move the colored objects towards the grey object and change their color\n    for colored_object in colored_objects:\n        # Define possible displacements towards the grey object\n        possible_displacements = [(dx, dy) for dx in range(-1, 2) for dy in range(-1, 2) if (dx != 0 or dy != 0)]\n\n        # Move the colored object towards the grey object\n        for dx, dy in possible_displacements:\n            moved_object = translate(colored_object, dx, dy)\n            if collision(object1=moved_object, object2=grey_object):\n                # Change the color to grey\n                colored_object[colored_object != Color.BLACK] = Color.GREY\n                break\n                \n        # Blit the changed colored object onto the output grid\n        blit_object(output_grid, colored_object)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a grey rectangle at the center and some scattered colored pixels around it\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define the grey rectangle dimensions\n    rectangle_width, rectangle_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    start_x = (width - rectangle_width) // 2\n    start_y = (height - rectangle_height) // 2\n    grid[start_x:start_x + rectangle_width, start_y:start_y + rectangle_height] = Color.GREY\n\n    # Scatter some colored pixels around the grey rectangle\n    for _ in range(np.random.randint(5, 10)):\n        random_color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.GREY])\n        pixel_sprite = np.full((1, 1), random_color)\n        x, y = random_free_location_for_sprite(grid, pixel_sprite, background=Color.BLACK)\n        blit_sprite(grid, pixel_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/107/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/107/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/107/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/107/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/107/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/107/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/107/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/107/images/train_output_2.png"}]}, "index": 107, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color filling\n\n# description:\n# In the input, you will see a grid containing a symmetric pattern of colored pixels that has been partially occluded by a black rectangle.\n# The output should be the missing part of the pattern, which should match the colors of the symmetric pattern.\n\ndef main(input_grid):\n    # Step 1: Identify the occluded area (black rectangle)\n    occlusion_color = Color.BLACK\n    occluded_area = (input_grid == occlusion_color)\n\n    # Step 2: Detect the symmetry of the input grid, excluding the occluded area\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n\n    # Step 3: Fill in the missing part using the symmetry\n    for occluded_x, occluded_y in np.argwhere(occluded_area):\n        # Get the symmetric points\u0027 colors and fill the occluded pixel\n        for symmetric_x, symmetric_y in orbit(input_grid, occluded_x, occluded_y, symmetries):\n            if input_grid[symmetric_x, symmetric_y] != occlusion_color:\n                input_grid[occluded_x, occluded_y] = input_grid[symmetric_x, symmetric_y]\n                break\n\n    # Step 4: Extract the filled region to return as the output sprite\n    filled_in_region = np.full_like(input_grid, occlusion_color)\n    filled_in_region[occluded_area] = input_grid[occluded_area]\n    filled_in_region = crop(filled_in_region, background=occlusion_color)\n\n    return filled_in_region\n\ndef generate_input():\n    # Step 1: Create a random sprite\n    w, h = np.random.randint(3, 6, size=(2))\n    sprite = random_sprite(w, h, color_palette=Color.NOT_BLACK, density=1)\n\n    # Step 2: Create a symmetric pattern by tiling the sprite\n    horizontal_repetitions, vertical_repetitions = np.random.randint(2, 5, size=(2))\n    pattern = np.tile(sprite, (horizontal_repetitions, vertical_repetitions))\n\n    # Step 3: Occlude part of the pattern with a randomly placed black rectangle\n    w_occluder, h_occluder = np.random.randint(2, 5, size=(2))\n    x_occluder = np.random.randint(0, pattern.shape[0] - w_occluder + 1)\n    y_occluder = np.random.randint(0, pattern.shape[1] - h_occluder + 1)\n    black_rectangle_sprite = np.full((w_occluder, h_occluder), Color.BLACK)\n    \n    # Blit the black rectangle onto the pattern to create the occlusion\n    grid_with_occlusion = blit_sprite(pattern, black_rectangle_sprite, x_occluder, y_occluder, background=None)\n\n    return grid_with_occlusion", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/108/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/108/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/108/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/108/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/108/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/108/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/108/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/108/images/train_output_2.png"}]}, "index": 108, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, pattern detection\n\n# description:\n# In the input you will see a grid filled with a pattern of red and green pixels.\n# The task is to find all contiguous regions of red pixels and transform them into purple.\n# The green pixels should remain unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all contiguous components of red pixels using find_connected_components\n    # 2. Transform each found component into purple\n\n    red_color = Color.RED\n    purple_color = Color.PINK  # Assuming purple is represented as pink for this grid\n\n    # Find connected components of red pixels\n    red_components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    output_grid = np.copy(input_grid)\n\n    # Transform each red component into purple\n    for component in red_components:\n        # Get the coordinates of the component and fill them with purple\n        component_coords = np.argwhere(component == red_color)\n        for x, y in component_coords:\n            output_grid[x, y] = purple_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid of size 10x10 to 20x20\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter red and green pixels throughout the grid\n    colors = [Color.RED, Color.GREEN]\n    density = 0.5  # Fill the grid with a density of 50%\n\n    # Fill the grid with random colors\n    for x in range(n):\n        for y in range(m):\n            if np.random.rand() \u003c density:\n                grid[x, y] = np.random.choice(colors)\n            else:\n                grid[x, y] = Color.BLACK  # Fill remaining space with black\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/109/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/109/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/109/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/109/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/109/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/109/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/109/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/109/images/train_output_2.png"}]}, "index": 109, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color guide, filling, objects, extraction\n\n# description:\n# In the input, you will see a colored object in the center and a single pixel in the top right corner of a different color.\n# To make the output, remove the pixel from the top right corner and fill the object in the center \n# with the color from the pixel you removed. The output should be a grid with the object colored \n# in the new color and the pixel removed.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the pixel in the top right corner\n    color = output_grid[0, -1]\n\n    # Remove the pixel from the top right corner\n    output_grid[0, -1] = Color.BLACK\n\n    # Find the coordinates of the central object (assuming it\u0027s the only non-black object)\n    object_coords = np.argwhere(output_grid != Color.BLACK)\n    if object_coords.size == 0:\n        return output_grid  # Return empty grid if no object is found\n\n    # Use the first coordinate found as a starting point for flood_fill\n    start_x, start_y = object_coords[0]\n\n    # Fill the connected area (object) with the new color\n    flood_fill(output_grid, start_x, start_y, color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 7x7 black grid\n    n = m = 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the central object\n    central_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Select a color for the corner pixel\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Ensure that the colors are different\n    while central_color == corner_color:\n        corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random central object (3x3) with the selected color\n    central_object = random_sprite(3, 3, density=0.8, color_palette=[central_color])\n    blit_sprite(grid, central_object, x=2, y=2)\n\n    # Place a single pixel of a different color in the top right corner\n    grid[0, -1] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/110/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/110/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/110/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/110/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/110/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/110/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/110/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/110/images/train_output_2.png"}]}, "index": 110, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, bounding box, color transformation\n\n# description:\n# In the input, you will see a black grid with several isolated colored squares. Each square is surrounded by a blue border. \n# To create the output grid, identify each colored square, find its bounding box, \n# and then replace the blue border with a color gradient that transitions from the color of the square to black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK, dtype=int)\n\n    # Find connected components (colored squares) in the input grid\n    colored_squares = find_connected_components(input_grid, background=Color.BLUE, connectivity=4, monochromatic=False)\n\n    for square in colored_squares:\n        # Get the bounding box of the colored square\n        x, y, width, height = bounding_box(square, background=Color.BLUE)\n\n        # Get the color of the square (assuming it\u0027s monochromatic)\n        square_color = square[np.argwhere(square != Color.BLUE)[0][0], np.argwhere(square != Color.BLUE)[0][1]]\n\n        # Replace the blue border with a gradient\n        for i in range(height):\n            for j in range(width):\n                if square[i, j] == Color.BLUE:\n                    # Calculate the gradient color\n                    gradient_color = Color.BLACK if (i == 0 or j == 0 or i == height - 1 or j == width - 1) else square_color\n                    output_grid[x + i, y + j] = gradient_color\n                else:\n                    output_grid[x + i, y + j] = square[i, j]\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 12-20x12-20\n    n, m = np.random.randint(12, 21), np.random.randint(12, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select a number of colored squares\n    num_squares = np.random.randint(3, 6)\n\n    for _ in range(num_squares):\n        # Create a random size for the square\n        square_size = np.random.randint(2, 5)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Find a random position for the square, ensuring it fits in the grid\n        x = np.random.randint(1, n - square_size - 1)\n        y = np.random.randint(1, m - square_size - 1)\n\n        # Draw the square with a blue border\n        grid[x, y:y + square_size] = color\n        grid[x + square_size - 1, y:y + square_size] = color\n        grid[x:x + square_size, y] = color\n        grid[x:x + square_size, y + square_size - 1] = color\n\n        # Fill the inner square with blue\n        grid[x + 1:x + square_size - 1, y + 1:y + square_size - 1] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/111/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/111/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/111/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/111/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/111/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/111/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/111/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/111/images/train_output_2.png"}]}, "index": 111, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, cropping, pattern matching\n\n# description:\n# In the input, you will see a grid containing various shapes made of colored pixels arranged in a specific pattern.\n# To create the output, you need to find the unique shapes and color them based on their dimensions.\n# For shapes that are 1 pixel tall or wide, color them blue. \n# For shapes that are 2 pixels tall or wide, color them pink. \n# For shapes that are 3 pixels tall or wide, color them red. \n# Any shape larger than that will remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Define the background color\n    background = Color.BLACK\n\n    # Find all connected components (shapes) in the grid\n    shapes = find_connected_components(input_grid, background=background, monochromatic=False)\n\n    for shape in shapes:\n        # Crop the shape to its bounding box\n        cropped_shape = crop(shape, background=background)\n\n        # Get the dimensions of the cropped shape\n        height, width = cropped_shape.shape\n        \n        # Determine the new color based on the dimensions\n        if height \u003c= 1 or width \u003c= 1:\n            new_color = Color.BLUE\n        elif height == 2 or width == 2:\n            new_color = Color.PINK\n        elif height == 3 or width == 3:\n            new_color = Color.RED\n        else:\n            # If the shape is larger than 3 pixels in height or width, keep the original colors\n            continue\n\n        # Apply the new color to the output grid\n        output_grid[shape != background] = new_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size filled with black background\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create shapes of varying sizes and colors\n    for _ in range(np.random.randint(3, 10)):\n        # Randomly select shape dimensions (height and width)\n        height, width = np.random.randint(1, 5), np.random.randint(1, 5)\n        color = random.choice(Color.NOT_BLACK)\n\n        # Create a random sprite for the shape\n        sprite = random_sprite(height, width, color_palette=[color], density=0.8)\n\n        # Place the sprite randomly on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/112/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/112/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/112/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/112/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/112/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/112/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/112/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/112/images/train_output_2.png"}]}, "index": 112, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, object movement, horizontal/vertical line drawing\n\n# description:\n# In the input you will see a grid with a distinctive colored shape. \n# To create the output, you need to move the shape two pixels to the right and one pixel down. \n# After moving, draw a horizontal yellow line from the new position of the shape to the edge of the grid.\n\ndef main(input_grid):\n    # 1. Detect the colored shape in the input grid\n    colored_shapes = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    \n    assert len(colored_shapes) == 1, \"There should be exactly one colored shape\"\n    \n    shape = colored_shapes[0]\n    shape_color = object_colors(shape)[0]\n    \n    # 2. Get the position of the shape\n    shape_x, shape_y = object_position(shape)\n\n    # 3. Move the shape two pixels to the right and one pixel down\n    output_grid = input_grid.copy()\n    \n    # Clear the old position\n    output_grid[shape_x, shape_y] = Color.BLACK\n    \n    # New position\n    new_x = shape_x + 1\n    new_y = shape_y + 2\n    \n    output_grid[new_x, new_y] = shape_color\n    \n    # 4. Draw a horizontal yellow line from the new position to the right edge of the grid\n    for x in range(new_y, output_grid.shape[1]):\n        output_grid[new_x, x] = Color.YELLOW\n        \n    return output_grid\n\ndef generate_input():\n    # Generate a grid with dimensions between 5 and 20\n    width, height = np.random.randint(5, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose a color for the shape, ensuring it\u0027s not black or yellow\n    shape_color = np.random.choice([color for color in Color.NOT_BLACK if color not in [Color.BLACK, Color.YELLOW]])\n\n    # Randomly place a shape (a square) on the grid\n    shape_size = np.random.randint(2, 5)  # Random size between 2 and 4\n    x, y = np.random.randint(0, width - shape_size), np.random.randint(0, height - shape_size)\n    \n    for i in range(shape_size):\n        for j in range(shape_size):\n            grid[x + i, y + j] = shape_color\n            \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/113/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/113/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/113/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/113/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/113/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/113/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/113/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/113/images/train_output_2.png"}]}, "index": 113, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, contact, translation\n\n# description:\n# In the input you will see a blue object and a yellow bar.\n# To make the output, move the blue object to touch the yellow bar. Then rotate the blue object 90 degrees clockwise.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the objects; separate the blue object from the yellow bar\n    # 2. Move the blue object to touch the yellow bar\n    # 3. Rotate the blue object 90 degrees clockwise\n\n    # 1. Object detection and setup\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)\n\n    blue_objects = [obj for obj in objects if Color.BLUE in object_colors(obj, background=Color.BLACK)]\n    yellow_objects = [obj for obj in objects if Color.YELLOW in object_colors(obj, background=Color.BLACK)]\n\n    assert len(blue_objects) == 1, \"There should be exactly one blue object\"\n    assert len(yellow_objects) == 1, \"There should be exactly one yellow bar\"\n    \n    blue_object = blue_objects[0]\n    yellow_object = yellow_objects[0]\n\n    # Make the output grid: Start with the yellow bar\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    blit_object(output_grid, yellow_object)\n\n    # 2. Move the blue object to touch the yellow bar\n    # Consider all displacements, starting with the smallest translations first\n    possible_displacements = [(i*dx, i*dy) for i in range(0, 30) for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]]\n\n    # Only keep the displacements that cause a contact between the blue object and the yellow bar\n    valid_displacements = [displacement for displacement in possible_displacements\n                           if contact(object1=translate(blue_object, *displacement), object2=yellow_object)]\n    \n    assert valid_displacements, \"There should be at least one valid displacement\"\n\n    # Pick the smallest valid displacement\n    displacement = min(valid_displacements, key=lambda displacement: sum(abs(x) for x in displacement))\n\n    # Translate the blue object to the valid location\n    blue_object = translate(blue_object, *displacement)\n    blit_object(output_grid, blue_object)\n\n    # 3. Rotate the blue object 90 degrees clockwise\n    blue_object_rotated = np.rot90(blue_object, k=-1)  # k=-1 for 90 degrees clockwise\n\n    # Blit the rotated blue object onto the output grid\n    blit_object(output_grid, blue_object_rotated)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a blue object and a yellow bar\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create the yellow bar\n    bar_x = np.random.randint(0, width)\n    bar_y = np.random.randint(0, height)\n    grid[bar_x, bar_y:bar_y + np.random.randint(2, 5)] = Color.YELLOW  # Horizontal yellow bar\n\n    # Create a blue object (random shape)\n    blue_sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=[Color.BLUE])\n    x, y = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, blue_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/114/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/114/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/114/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/114/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/114/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/114/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/114/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/114/images/train_output_2.png"}]}, "index": 114, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# occlusion, translational symmetry, color extraction\n\n# description:\n# In the input, you will see a grid with a translationally symmetric pattern that has been partially occluded by black pixels. \n# To create the output, reveal the full pattern by replacing the black pixels with the colors from the symmetric pattern, \n# ensuring that the colors match the original pattern based on its symmetry.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the translational symmetries in the grid.\n    # 2. For each black pixel, use the symmetries to find its corresponding colors in the pattern.\n    # 3. Replace black pixels with the most common color found in their orbit.\n\n    # Find translational symmetries in the input grid, ignoring black pixels\n    translations = detect_translational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=None)\n    assert len(translations) \u003e 0, \"No translational symmetry found\"\n\n    output_grid = np.copy(input_grid)  # Start with a copy of the input grid\n\n    # Iterate through each pixel in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if output_grid[x, y] == Color.BLACK:\n                # Get the orbit of (x, y) under the detected symmetries\n                orbit_pixels = orbit(input_grid, x, y, translations)\n\n                # Collect the colors from the original grid in the orbit\n                orbit_colors = [input_grid[transformed_x, transformed_y] for transformed_x, transformed_y in orbit_pixels]\n                \n                # Filter out black and background colors\n                orbit_colors = [color for color in orbit_colors if color != Color.BLACK]\n\n                if orbit_colors:  # If there are any valid colors found\n                    # Find the most common color in the orbit\n                    most_common_color = max(set(orbit_colors), key=orbit_colors.count)\n                    output_grid[x, y] = most_common_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Create a base sprite that has a symmetric pattern\n    sprite = random_sprite(random.randint(3, 6), random.randint(3, 6), density=1, color_palette=Color.NOT_BLACK)\n    \n    # Blit the sprite onto the grid multiple times to create a pattern\n    for x in range(0, n, sprite.shape[0]):\n        for y in range(0, m, sprite.shape[1]):\n            try:\n                blit_sprite(grid, sprite, x=x, y=y)\n            except ValueError:\n                # If we cannot place the sprite, we simply skip this placement\n                continue\n\n    # Randomly occlude some pixels in the grid\n    num_occluders = np.random.randint(5, 15)  # Random number of occluders\n    for _ in range(num_occluders):\n        occlude_x = np.random.randint(n)\n        occlude_y = np.random.randint(m)\n        grid[occlude_x, occlude_y] = Color.BLACK  # Set the pixel to black\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/115/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/115/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/115/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/115/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/115/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/115/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/115/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/115/images/train_output_2.png"}]}, "index": 115, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry restoration, color filling\n\n# description:\n# In the input you will see a grid with a left-right symmetric monochromatic object that has parts removed.\n# To make the output, identify the mirror symmetry of the object and fill in the missing parts to restore the symmetry.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the left-right symmetry of the object\n    # 2. For each pixel in the input grid that is not black, find its mirror position and copy the color to restore symmetry\n\n    background_color = Color.BLACK\n\n    # Identify the mirror symmetries in the grid, ignoring the background color\n    mirrors = detect_mirror_symmetry(input_grid, ignore_colors=[background_color])\n\n    # Create a copy of the input grid to work on\n    output_grid = input_grid.copy()\n\n    # Fill in the missing parts of the object\n    for x, y in np.argwhere(input_grid != background_color):\n        for mirror in mirrors:\n            # Find the symmetric position\n            symmetric_x, symmetric_y = mirror.apply(x, y)\n            # If the symmetric position is in the grid and is black, fill it with the color from the original position\n            if 0 \u003c= symmetric_x \u003c output_grid.shape[0] and 0 \u003c= symmetric_y \u003c output_grid.shape[1]:\n                output_grid[symmetric_x, symmetric_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a left-right symmetric monochromatic object with parts removed.\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a color for the object\n    object_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a symmetric object by manually defining a left-right symmetric pattern\n    center_row = n // 2\n    for i in range(n):\n        for j in range(m):\n            if j \u003c m // 2:\n                # Create a left-right symmetric shape\n                if np.random.rand() \u003c 0.5:  # Randomly decide to fill or not for left side\n                    grid[i, j] = object_color\n                    grid[i, m - j - 1] = object_color  # Reflect to the right side\n\n    # Remove random parts to create the occluded effect\n    for _ in range(np.random.randint(1, 5)):  # Randomly remove 1 to 5 pixels\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLACK  # Set to background color to simulate removal\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/116/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/116/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/116/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/116/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/116/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/116/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/116/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/116/images/train_output_2.png"}]}, "index": 116, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, horizontal/vertical bars, filtering\n\n# description:\n# In the input, you will see horizontal and vertical bars creating a grid where each colored cell is separated by these bars. \n# The goal is to move each colored cell downwards until it touches the nearest horizontal bar below it. \n# If a colored cell doesn\u0027t have a corresponding bar below, it should be removed from the output.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # Find all connected components in the input\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Separate bars and colored cells\n    horizontal_bars = []\n    colored_cells = []\n    for obj in objects:\n        w, h = crop(obj).shape\n        if w == 1 and h == input_grid.shape[1]:  # Check if horizontal bar\n            horizontal_bars.append(obj)\n        else:  # Otherwise, it is a colored cell\n            colored_cells.append(obj)\n    \n    # Place horizontal bars in the output grid\n    for bar in horizontal_bars:\n        blit_object(output_grid, bar, background=Color.BLACK)\n\n    # Move each colored cell downwards until it touches the nearest horizontal bar\n    for cell in colored_cells:\n        color = np.unique(cell)[1]\n        # Find the nearest horizontal bar below the cell\n        possible_bars = [bar for bar in horizontal_bars if object_position(bar)[0] \u003e object_position(cell)[0]]\n        \n        if not possible_bars:\n            continue  # No bar below, so we skip this cell\n\n        # Get the position of the nearest bar\n        nearest_bar = min(possible_bars, key=lambda bar: object_position(bar)[0])\n        bar_y_position = object_position(nearest_bar)[0]\n\n        # Compute the translation vector\n        current_y_position = object_position(cell)[0]\n        translate_y = bar_y_position - current_y_position - 1  # Move down to just above the bar\n\n        if translate_y \u003e 0:  # Only translate if there\u0027s space\n            translated_cell = translate(cell, 0, translate_y, background=Color.BLACK)\n            blit_object(output_grid, translated_cell, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n\n    # Create a grid for bars and colored cells\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select the number of horizontal bars\n    num_bars = np.random.randint(1, 5)\n    bar_colors = np.random.choice(Color.NOT_BLACK, num_bars, replace=False)\n\n    # Draw horizontal bars\n    for i in range(num_bars):\n        y = np.random.randint(1, n)\n        color = bar_colors[i]\n        grid[y, :] = color  # Fill the entire row with the bar color\n\n    # Randomly place colored cells\n    num_cells = np.random.randint(5, 15)\n    for _ in range(num_cells):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:  # Ensure we place a colored cell on a black background\n            grid[x, y] = np.random.choice(bar_colors)  # Randomly choose a color from the bar colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/117/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/117/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/117/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/117/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/117/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/117/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/117/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/117/images/train_output_2.png"}]}, "index": 117, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# noise reduction, object neighbors, color guide\n\n# description:\n# In the input, you will see a colored shape on a black background, with some noise pixels in the same color scattered around it.\n# To make the output, remove the noise pixels that do not have at least two neighboring pixels of the same color from the shape.\n\ndef main(input_grid):\n    # Create a copy of the input grid to form the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get unique colors in the grid and iterate through them\n    unique_colors = np.unique(input_grid)\n    for color in unique_colors:\n        if color == Color.BLACK:\n            continue  # Skip the background color\n\n        # Find all pixels of the current color\n        color_indices = np.argwhere(input_grid == color)\n\n        for x, y in color_indices:\n            # Create an object from the single pixel and get its neighboring mask\n            obj = np.full(input_grid.shape, Color.BLACK)\n            obj[x, y] = color\n            neighbors_mask = object_neighbors(obj, background=Color.BLACK, connectivity=4)\n\n            # Count how many neighboring pixels are of the same color\n            neighboring_colors = input_grid[neighbors_mask]\n            if np.sum(neighboring_colors == color) \u003c 2:\n                # If less than 2 neighbors are of the same color, it is noise; remove it\n                output_grid[x, y] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid for the background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose a color for the shape\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a random shape (rectangle, triangle, etc.)\n    shape_height = np.random.randint(3, 8)\n    shape_width = np.random.randint(3, 8)\n    shape = random_sprite(shape_height, shape_width, density=0.5, color_palette=[shape_color])\n\n    # Place the shape in the grid at a random location\n    x, y = random_free_location_for_sprite(grid, shape)\n    blit_sprite(grid, shape, x, y)\n\n    # Add noise pixels in the same color scattered randomly\n    n_noise_pixels = np.random.randint(5, 15)\n    for _ in range(n_noise_pixels):\n        noise_x = np.random.randint(n)\n        noise_y = np.random.randint(m)\n        if grid[noise_x, noise_y] == Color.BLACK:  # Ensure noise is placed on a black background\n            grid[noise_x, noise_y] = shape_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/118/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/118/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/118/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/118/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/118/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/118/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/118/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/118/images/train_output_2.png"}]}, "index": 118, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, connected components, color replacement\n\n# description:\n# In the input, you will see a black grid with a series of colored blocks that form a zigzag pattern.\n# To make the output, find the connected components of non-black pixels and color every odd-indexed component blue using flood fill.\n\ndef main(input_grid):\n    # Step 1: Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Step 2: Find all connected components of non-black pixels\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Step 3: Color every odd-indexed component blue using flood fill\n    for i, component in enumerate(components):\n        if i % 2 == 1:  # odd-indexed components\n            # Get a sample point from the component to use for flood fill\n            x, y = np.argwhere(component != Color.BLACK)[0]\n            flood_fill(output_grid, x, y, Color.BLUE)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly create a zigzag pattern using random colors\n    for y in range(height):\n        for x in range(0, width, 2):  # create blocks in a zigzag manner\n            if y % 2 == 0:  # every even row gets colored blocks\n                color = np.random.choice(Color.NOT_BLACK)\n                grid[y, x] = color\n                if x + 1 \u003c width:\n                    grid[y, x + 1] = color  # fill the next cell to form a block\n\n    # Randomly rotate the grid to add variety\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/119/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/119/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/119/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/119/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/119/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/119/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/119/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/119/images/train_output_2.png"}]}, "index": 119, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, drawing lines, color change\n\n# description:\n# In the input you will see a grid with a single colored pixel.\n# To make the output, first move the colored pixel down by two pixels,\n# then draw a blue line from the new pixel location to the bottom of the grid,\n# and finally, change the color of the original pixel location to green.\n\ndef main(input_grid):\n    # Step 1: Extract the single colored pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel, background=Color.BLACK)\n    pixel_color = object_colors(pixel)[0]\n\n    # Step 2: Move the pixel down by two pixels\n    output_grid = np.copy(input_grid)\n    new_pixel_x, new_pixel_y = pixel_x, pixel_y + 2\n    \n    # Ensure the new position is within bounds\n    if new_pixel_y \u003c output_grid.shape[1]:\n        output_grid[new_pixel_x, new_pixel_y] = pixel_color  # Place the pixel in the new position\n\n    # Step 3: Draw a blue line from the new pixel to the bottom of the grid\n    draw_line(output_grid, x=new_pixel_x, y=new_pixel_y, direction=(0, 1), color=Color.BLUE)\n\n    # Step 4: Change the color of the original pixel location to green\n    output_grid[pixel_x, pixel_y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x n\n    grid_size = np.random.randint(5, 15)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly place one colored pixel on the grid\n    color = np.random.choice(Color.NOT_BLACK)\n    x, y = np.random.randint(0, grid_size), np.random.randint(0, grid_size)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/120/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/120/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/120/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/120/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/120/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/120/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/120/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/120/images/train_output_2.png"}]}, "index": 120, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, counting, boundaries\n\n# description:\n# The input consists of a grid with blue and black pixels, where blue pixels represent regions that may enclose areas. \n# To create the output, find the enclosed regions formed by blue pixels and color them with orange if they are surrounded by blue pixels. \n# The black pixels represent the background and should remain unchanged.\n\ndef main(input_grid):\n    # Create initial output grid based on input grid\n    output_grid = np.copy(input_grid)\n\n    # Find the boundary of blue objects\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n    enclosed_regions = np.logical_and(input_grid == Color.BLUE, boundary_mask)\n\n    # Color the enclosed regions orange\n    output_grid[enclosed_regions] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size 10x10 to 15x15\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create blue objects that may enclose areas\n    num_objects = np.random.randint(3, 7)\n    for _ in range(num_objects):\n        # Random dimensions for the sprite\n        obj_height = np.random.randint(2, 5)\n        obj_width = np.random.randint(2, 5)\n        \n        # Create a blue sprite\n        sprite = random_sprite(obj_height, obj_width, color_palette=[Color.BLUE])\n\n        # Randomly place the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/121/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/121/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/121/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/121/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/121/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/121/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/121/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/121/images/train_output_2.png"}]}, "index": 121, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, region filling\n\n# description:\n# In the input grid, there are regions formed by colored pixels, and the rest of the grid is black. \n# The task is to identify the boundaries of these colored regions and fill the interior of these regions with a new color (e.g., blue).\n# The output grid should only show these filled regions, and the rest of the pixels should be black.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the boundaries of the colored regions\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Get the coordinates of the boundary pixels\n    boundary_coords = np.argwhere(boundary_mask)\n\n    # Fill the interior of the regions\n    for x, y in boundary_coords:\n        # Check the surrounding pixels to fill in the interior\n        if input_grid[x, y] != Color.BLACK:\n            # Use a flood fill algorithm to fill the region\n            fill_color = Color.BLUE\n            region_mask = (input_grid == input_grid[x, y])\n            output_grid[region_mask] = fill_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random-sized grid with a black background (between 10x10 and 20x20)\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose the number of regions\n    num_regions = np.random.randint(1, 4)\n\n    for _ in range(num_regions):\n        # Generate a random-sized sprite (region) of colored pixels\n        sprite_height = np.random.randint(3, 6)\n        sprite_width = np.random.randint(3, 6)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        sprite = random_sprite(sprite_height, sprite_width, color_palette=[color], density=0.8)\n\n        # Attempt to place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no space is available, skip placing this sprite\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/122/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/122/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/122/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/122/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/122/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/122/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/122/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/122/images/train_output_2.png"}]}, "index": 122, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, pattern extension, non-black background\n\n# description:\n# In the input you will see a translationally symmetric pattern that does not completely fill the canvas. \n# The background is not black. To make the output, you should extend the symmetric pattern until it covers the entire canvas, \n# but shift everything down by one row.\n\ndef main(input_grid):\n    # Detect the background color which is the most common color around the border of the canvas\n    border_pixels = np.concatenate([input_grid[0, :], input_grid[-1, :], input_grid[:, 0], input_grid[:, -1]])\n    background_color = max(set(border_pixels), key=list(border_pixels).count)\n    \n    # Find the translational symmetry in the grid while ignoring the background color\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[background_color])\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # Create an output grid that is one row taller than the input grid\n    width, height = input_grid.shape\n    output_grid = np.full((width, height + 1), background_color)\n\n    # Copy each pixel from the input grid to the output grid and its symmetric copies\n    for x, y in np.argwhere(input_grid != background_color):\n        # Compute the orbit of this pixel based on the detected symmetries\n        for x2, y2 in orbit(output_grid, x, y, symmetries):\n            output_grid[x2, y2] = input_grid[x, y]\n\n    # Shift everything down by one row, removing the topmost row\n    output_grid = output_grid[:, 1:]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random background grid\n    background_color = random.choice(Color.NOT_BLACK)\n    grid = np.full((np.random.randint(10, 15), np.random.randint(10, 15)), background_color)\n\n    # Create a random sprite (pattern) to be tiled\n    sprite_width, sprite_height = random.randint(2, 4), random.randint(2, 4)\n    sprite = np.random.choice([color for color in Color.ALL_COLORS if color != background_color], (sprite_width, sprite_height))\n\n    # Tile the sprite multiple times, ensuring it doesn\u0027t cover the entire grid\n    for x in range(0, grid.shape[0], sprite_height):\n        for y in range(0, grid.shape[1], sprite_width):\n            if x + sprite_height \u003c= grid.shape[0] and y + sprite_width \u003c= grid.shape[1]:\n                blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/123/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/123/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/123/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/123/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/123/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/123/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/123/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/123/images/train_output_2.png"}]}, "index": 123, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, circular movement, color change\n\n# description:\n# In the input grid, you will see a black background with a single colored pixel in the center and several colored pixels scattered around it.\n# The task is to move each colored pixel towards the center colored pixel in a circular path until they touch the center pixel, then change their color to match it.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the center colored pixel location.\n    # 2. For each colored pixel around it, calculate the direction towards the center pixel.\n    # 3. Move each pixel in a circular path towards the center until they collide with it.\n    # 4. Change their color to match the center pixel\u0027s color.\n\n    # Find the center colored pixel\n    center_pixel_location = np.argwhere(input_grid != Color.BLACK)[0]\n    center_x, center_y = center_pixel_location\n    center_color = input_grid[center_x, center_y]\n\n    # Make the output grid, starting as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Move the colored objects towards the center\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    for pixel in colored_pixels:\n        x, y = pixel\n        if (x, y) == (center_x, center_y):\n            continue  # Skip the center pixel\n\n        # Calculate the direction towards the center pixel\n        direction_x = np.sign(center_x - x)\n        direction_y = np.sign(center_y - y)\n\n        # Move in a circular path towards the center\n        while not collision(object1=output_grid, object2=np.array([[Color.BLACK]]), x1=x, y1=y, x2=center_x, y2=center_y):\n            # Update position in a circular manner\n            if direction_x != 0:\n                x += direction_x\n            if direction_y != 0:\n                y += direction_y\n            \n            # Check if we\u0027re at the center pixel\n            if (x, y) == (center_x, center_y):\n                break\n\n            # Ensure we remain within bounds\n            if not (0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]):\n                break\n\n        # Change the color of the pixel to the center color\n        output_grid[x, y] = center_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a black background and place a colored pixel in the center\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    center_x, center_y = width // 2, height // 2\n    center_color = np.random.choice(Color.NOT_BLACK)\n    grid[center_x, center_y] = center_color\n\n    # Scatter some colored pixels around the center\n    for _ in range(np.random.randint(5, 10)):\n        random_color = np.random.choice([color for color in Color.NOT_BLACK if color != center_color])\n        pixel_sprite = np.full((1, 1), random_color)\n        x, y = random_free_location_for_sprite(grid, pixel_sprite, background=Color.BLACK)\n        blit_sprite(grid, pixel_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/124/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/124/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/124/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/124/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/124/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/124/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/124/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/124/images/train_output_2.png"}]}, "index": 124, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# expansion, boundary detection\n\n# description:\n# In the input, you will see several colored rectangles scattered throughout a grid. Each rectangle has one blue pixel on one of its borders.\n# To produce the output, you need to expand each rectangle outward in the direction of the blue pixel until it hits the border of the grid.\n# Additionally, draw a diagonal orange line from the blue pixel to the edge of the grid in the same direction of expansion.\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n    \n    rectangle_color = Color.GREEN\n    indicator_color = Color.BLUE\n    background = Color.BLACK\n\n    # Get all the connected components (rectangles) in the grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=background)\n    for obj in objects:\n        # Find the blue indicator pixel\n        blue_pixel_coords = np.argwhere(obj == indicator_color)\n        if len(blue_pixel_coords) == 0:\n            continue  # No blue pixel found in this object\n\n        for blue_x, blue_y in blue_pixel_coords:\n            break  # Take the first blue pixel found\n\n        # Get the bounding box of the rectangle\n        x, y, width, height = bounding_box(obj, background=background)  \n\n        # Determine the direction of expansion based on the position of the blue pixel\n        if blue_x == x:  # Blue pixel on the left edge\n            output_grid[x:output_grid.shape[0], y:y + width] = rectangle_color  # Expand downwards\n            draw_line(output_grid, blue_x, blue_y, length=None, color=Color.ORANGE, direction=(1, 1), stop_at_color=[Color.BLACK])\n        elif blue_x == x + height - 1:  # Blue pixel on the right edge\n            output_grid[0:blue_x + 1, y:y + width] = rectangle_color  # Expand upwards\n            draw_line(output_grid, blue_x, blue_y, length=None, color=Color.ORANGE, direction=(-1, -1), stop_at_color=[Color.BLACK])\n        elif blue_y == y:  # Blue pixel on the top edge\n            output_grid[x:x + height, y:output_grid.shape[1]] = rectangle_color  # Expand right\n            draw_line(output_grid, blue_x, blue_y, length=None, color=Color.ORANGE, direction=(1, -1), stop_at_color=[Color.BLACK])\n        elif blue_y == y + width - 1:  # Blue pixel on the bottom edge\n            output_grid[x:x + height, 0:blue_y + 1] = rectangle_color  # Expand left\n            draw_line(output_grid, blue_x, blue_y, length=None, color=Color.ORANGE, direction=(-1, 1), stop_at_color=[Color.BLACK])\n        else:\n            assert False, \"The blue pixel is not on the border of the rectangle\"\n\n    return output_grid\n\ndef generate_input():\n    # Create the background grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    rectangle_num = np.random.randint(2, 5)\n    rectangle_color = Color.GREEN\n    indicator_color = Color.BLUE\n\n    # Draw rectangles on the grid\n    for _ in range(rectangle_num):\n        width = np.random.randint(2, 5)\n        height = np.random.randint(2, 5)\n\n        # Create a rectangle with a blue indicator\n        green_rectangle = np.full((height, width), rectangle_color)\n        blue_x = np.random.choice([0, height - 1])\n        blue_y = np.random.choice(range(width))\n        green_rectangle[blue_x, blue_y] = indicator_color\n\n        # Try to place the rectangle on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=green_rectangle, padding=1)\n        except:\n            return generate_input()\n        \n        blit_sprite(grid, green_rectangle, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/125/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/125/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/125/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/125/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/125/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/125/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/125/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/125/images/train_output_2.png"}]}, "index": 125, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pixel completion\n\n# description:\n# In the input, you will see a grid with a pattern that has rotational symmetry, but some of the pixels are missing (colored black).\n# Your task is to fill in the missing pixels to complete the rotational symmetry of the pattern.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the rotational symmetry in the input grid.\n    # 2. For each colored pixel, rotate it around the center of symmetry and fill in the corresponding missing pixels.\n\n    # Create an output grid initialized to the input grid\n    output_grid = input_grid.copy()\n\n    # Detect the rotational symmetry in the input grid\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Find all colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Loop through each colored pixel and fill in the missing pixels based on symmetry\n    for x, y in colored_pixels:\n        # Get the color of the current pixel\n        color = input_grid[x, y]\n\n        # Fill in the pixels for each of the 4 rotations\n        for i in range(1, 4):\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n\n            # Fill the output grid only if the pixel is currently black (missing)\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n\n    return output_grid\n\n\ndef generate_input():\n    # Initialize a grid of size 10x10\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Create a pattern with rotational symmetry (e.g., a star shape)\n    pattern = np.array([\n        [Color.RED, Color.GREEN, Color.BLUE, Color.GREEN, Color.RED],\n        [Color.GREEN, Color.YELLOW, Color.YELLOW, Color.GREEN, Color.BLACK],\n        [Color.BLUE, Color.YELLOW, Color.BLACK, Color.YELLOW, Color.BLUE],\n        [Color.GREEN, Color.YELLOW, Color.YELLOW, Color.GREEN, Color.BLACK],\n        [Color.RED, Color.GREEN, Color.BLUE, Color.GREEN, Color.RED],\n    ])\n\n    # Randomly place the pattern in the grid\n    x_offset = np.random.randint(0, grid.shape[0] - pattern.shape[0])\n    y_offset = np.random.randint(0, grid.shape[1] - pattern.shape[1])\n    blit_sprite(grid, pattern, x=x_offset, y=y_offset)\n\n    # Randomly remove some pixels to create missing parts\n    for i in range(grid.shape[0]):\n        for j in range(grid.shape[1]):\n            if grid[i, j] != Color.BLACK and np.random.rand() \u003c 0.3:  # 30% chance to remove a pixel\n                grid[i, j] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/126/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/126/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/126/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/126/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/126/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/126/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/126/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/126/images/train_output_2.png"}]}, "index": 126, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, attraction, color change\n\n# description:\n# In the input you will see several colored pixels scattered around a central grey object. \n# To make the output, move each colored pixel toward the grey object until it touches, \n# then change its color to match that of the grey object. If multiple colored pixels collide, they stack.\n\ndef main(input_grid):\n    # Find the grey object and colored pixels\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)\n    \n    grey_objects = [obj for obj in objects if Color.GREY in object_colors(obj, background=Color.BLACK)]\n    colored_objects = [obj for obj in objects if Color.GREY not in object_colors(obj, background=Color.BLACK)]\n\n    assert len(grey_objects) == 1, \"There should be exactly one grey object\"\n    \n    grey_object = grey_objects[0]\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Draw the grey object onto the output grid\n    blit_object(output_grid, grey_object)\n\n    # Move colored objects to touch the grey object\n    for colored_object in colored_objects:\n        # Calculate the center of the grey object\n        grey_x, grey_y, grey_w, grey_h = bounding_box(grey_object, background=Color.BLACK)\n        grey_center_x = grey_x + grey_w // 2\n        grey_center_y = grey_y + grey_h // 2\n\n        # Get the current position of the colored object\n        color_x, color_y = object_position(colored_object)\n\n        # Calculate the translation needed to move towards the grey object\n        translation_x = grey_center_x - color_x\n        translation_y = grey_center_y - color_y\n\n        # Translate the colored object\n        translated_object = translate(colored_object, translation_x, translation_y, background=Color.BLACK)\n\n        # Ensure the colored object touches the grey object\n        while not collision(object1=translated_object, object2=output_grid):\n            translated_object = translate(translated_object, np.sign(translation_x), np.sign(translation_y), background=Color.BLACK)\n\n        # Change its color to grey\n        translated_object[translated_object != Color.BLACK] = Color.GREY\n        blit_object(output_grid, translated_object)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a grey object in the center and scattered colored pixels around it\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a grey square in the middle\n    grey_size = np.random.randint(2, 5)\n    grey_x = width // 2 - grey_size // 2\n    grey_y = height // 2 - grey_size // 2\n    grid[grey_x:grey_x + grey_size, grey_y:grey_y + grey_size] = Color.GREY\n\n    # Scatter some colored pixels around the grey object\n    for _ in range(np.random.randint(5, 10)):\n        random_color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.GREY])\n        pixel_sprite = np.full((1, 1), random_color)\n        x, y = random_free_location_for_sprite(grid, pixel_sprite, background=Color.BLACK)\n        blit_sprite(grid, pixel_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/127/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/127/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/127/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/127/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/127/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/127/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/127/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/127/images/train_output_2.png"}]}, "index": 127, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, object alignment, color swap\n\n# description:\n# In the input, you will see a grid with two objects of different colors aligned horizontally. \n# The output is obtained by shifting the left object to the right until it overlaps with the right object. \n# If the two objects overlap after the translation, change the color of the overlapping pixels to teal.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the two objects in the grid.\n    # 2. Find their bounding boxes and positions.\n    # 3. Shift the left object to the right until it overlaps with the right object.\n    # 4. Change the color of the overlapping pixels to teal.\n\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    \n    assert len(objects) == 2, \"There should be exactly two objects\"\n\n    # Identify the left and right objects based on their bounding boxes\n    left_object = min(objects, key=lambda obj: bounding_box(obj, background)[0])\n    right_object = max(objects, key=lambda obj: bounding_box(obj, background)[0])\n\n    # Get their bounding boxes\n    left_bbox = bounding_box(left_object, background)\n    right_bbox = bounding_box(right_object, background)\n\n    # Calculate the amount to translate\n    translation_amount = right_bbox[0] - (left_bbox[0] + left_bbox[2])\n\n    # Translate the left object\n    translated_left_object = translate(left_object, translation_amount, 0)\n\n    # Create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Overlay the translated left object into the output grid\n    blit_object(output_grid, translated_left_object, background=background)\n\n    # Change the overlapping pixels to teal\n    overlap_mask = (translated_left_object != background) \u0026 (right_object != background)\n    output_grid[overlap_mask] = Color.TEAL\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with two objects of different colors aligned horizontally\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Define colors for the objects\n    left_color = random.choice([color for color in Color.NOT_BLACK if color != Color.RED])\n    right_color = random.choice([color for color in Color.NOT_BLACK if color != left_color])\n\n    # Create two different colored sprites\n    left_sprite = random_sprite(random.randint(2, 4), random.randint(2, 4), color_palette=[left_color])\n    right_sprite = random_sprite(random.randint(2, 4), random.randint(2, 4), color_palette=[right_color])\n\n    # Place the left sprite on the left side of the grid\n    x_left, y_left = random_free_location_for_sprite(grid, left_sprite, border_size=2)\n    blit_sprite(grid, left_sprite, x_left, y_left)\n\n    # Place the right sprite right next to the left sprite\n    x_right, y_right = x_left + left_sprite.shape[1] + np.random.randint(1, 3), y_left\n    blit_sprite(grid, right_sprite, x_right, y_right)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/128/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/128/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/128/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/128/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/128/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/128/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/128/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/128/images/train_output_2.png"}]}, "index": 128, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotational symmetry, occlusion\n\n# description:\n# In the input you will see a partially filled object that is supposed to be rotationally symmetric, but some parts have been covered with black pixels.\n# The output should be what colors need to be added (colored red) to make the object perfectly rotationally symmetric.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Crop the input grid to isolate the object.\n    # 2. Detect the center of rotational symmetry.\n    # 3. Rotate each colored pixel to find and fill in missing sections with red.\n\n    # Step 1: Crop the input grid to isolate the object\n    object_sprite = crop(input_grid)\n\n    # Step 2: Detect the rotational symmetry\n    sym = detect_rotational_symmetry(object_sprite, ignore_colors=[Color.BLACK], background=None)\n\n    output_grid = np.copy(input_grid)\n\n    # Step 3: Rotate each colored pixel and fill in missing pixels with red\n    colored_pixels = np.argwhere(object_sprite != Color.BLACK)\n\n    for x, y in colored_pixels:\n        # Get the color of the pixel\n        color = object_sprite[x, y]\n\n        # Apply the symmetry to each pixel and fill missing sections with red\n        for i in range(1, 4):  # We perform 90-degree rotations (1 to 3)\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n\n            # If the rotated position is black, we fill it with red\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = Color.RED\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a medium-sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a blue sprite that is supposed to be rotationally symmetric\n    sprite_size = np.random.randint(5, min(n, m) - 2)\n    sprite = random_sprite(sprite_size, sprite_size, density=0.5, symmetry=\"radial\", color_palette=[Color.BLUE])\n\n    # Randomly occlude parts of the sprite to break its symmetry\n    num_occlusions = np.random.randint(1, 5)\n    for _ in range(num_occlusions):\n        occlude_x, occlude_y = np.random.randint(0, sprite_size), np.random.randint(0, sprite_size)\n        occlude_w, occlude_h = np.random.randint(1, 3), np.random.randint(1, 3)\n        sprite[occlude_x:occlude_x + occlude_w, occlude_y:occlude_y + occlude_h] = Color.BLACK\n\n    # Place the sprite onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/129/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/129/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/129/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/129/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/129/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/129/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/129/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/129/images/train_output_2.png"}]}, "index": 129, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, symmetry, color mapping\n\n# description:\n# In the input you will see a single colored pixel on a black background.\n# To make the output, scale the colored pixel into a 3x3 sprite, then draw it at the four corners of the grid. \n# Finally, make the entire grid symmetric along both axes, filling in the colors accordingly.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the colored pixel in the input grid.\n    # 2. Scale the colored pixel into a 3x3 sprite.\n    # 3. Draw the sprite in all four corners of the output grid.\n    # 4. Make the output grid symmetric along both axes.\n\n    # 1. Find the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    colored_pixel_location = colored_pixel_locations[0]\n    colored_x, colored_y = colored_pixel_location\n\n    # 2. Create the scaled sprite from the colored pixel\n    sprite = np.full((3, 3), input_grid[colored_x, colored_y])\n    \n    # 3. Create the output grid and place the sprite in each corner\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    output_grid[0:3, 0:3] = sprite  # Top-left\n    output_grid[0:3, -3:] = sprite  # Top-right\n    output_grid[-3:, 0:3] = sprite  # Bottom-left\n    output_grid[-3:, -3:] = sprite  # Bottom-right\n\n    # 4. Create symmetry in the output grid\n    output_grid = np.copy(output_grid[::-1, ::-1])  # Reflect over both axes\n\n    return output_grid\n\ndef generate_input():\n    # Make a black grid for the background\n    width, height = np.random.randint(5, 20, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Place a randomly colored pixel at a random point in the grid\n    color = np.random.choice(Color.NOT_BLACK)\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/130/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/130/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/130/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/130/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/130/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/130/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/130/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/130/images/train_output_2.png"}]}, "index": 130, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, object identification, color change\n\n# description:\n# In the input, you will see a grid containing a variety of shapes in different colors. \n# The goal is to identify shapes that are identical in form but differ in size and color. \n# Scale the smaller object to the size of the larger object, and change its color to green.\n\ndef main(input_grid):\n    # Find the background color (the most common color in the grid)\n    colors = np.unique(input_grid)\n    background = colors[np.argmax([np.sum(input_grid == c) for c in colors])]\n    object_colors = [c for c in colors if c != background]\n\n    # Extract objects by color\n    objects = []\n    for color in object_colors:\n        obj = np.copy(input_grid)\n        obj[input_grid != color] = background\n        objects.append(obj)\n\n    # Define a helper function to determine if two objects are the same shape\n    def same_shape(obj1, obj2):\n        mask1 = crop(obj1, background=background) != background\n        mask2 = crop(obj2, background=background) != background\n        return mask1.shape == mask2.shape and np.array_equal(mask1, mask2)\n\n    output_grid = np.full(input_grid.shape, background)\n\n    # Compare each object against all others to find pairs of same shape but different size\n    for i, obj1 in enumerate(objects):\n        for j, obj2 in enumerate(objects):\n            if i != j and same_shape(obj1, obj2):\n                # Scale the smaller object to the size of the larger one\n                if np.sum(obj1 != background) \u003c np.sum(obj2 != background):\n                    scaled_obj = scale_sprite(crop(obj1, background=background), \n                                               factor=np.ceil(np.sqrt(np.sum(obj2 != background) / np.sum(obj1 != background))).astype(int))\n                    # Change color to green\n                    scaled_obj[scaled_obj != background] = Color.GREEN\n                    # Blit the scaled object back to the output grid\n                    blit_object(output_grid, scaled_obj, background=background)\n                break\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random background color\n    background = np.random.choice(Color.NOT_BLACK)\n\n    # Create a grid of size n x m\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), background)\n\n    # Generate a few objects of various sizes and colors\n    num_objects = np.random.randint(3, 6)\n    object_sizes = [np.random.randint(3, 6) for _ in range(num_objects)]\n    object_colors = np.random.choice(Color.NOT_BLACK, num_objects, replace=False)\n\n    for size, color in zip(object_sizes, object_colors):\n        # Create a random sprite\n        sprite = random_sprite(size, size, color_palette=[color], background=background)\n        # Randomly place the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=background)\n            blit_sprite(grid, sprite, x=x, y=y, background=background)\n        except ValueError:\n            continue # Skip if there is no free space\n\n    # Ensure that there are at least two objects of the same shape but different sizes\n    if len(np.unique(object_sizes)) \u003c num_objects:\n        return generate_input()\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/131/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/131/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/131/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/131/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/131/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/131/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/131/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/131/images/train_output_2.png"}]}, "index": 131, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# noise removal, object detection, border evaluation\n\n# description:\n# In the input, you will see a grid with a black background and several colored objects (rectangles). \n# Some noise pixels (random colored pixels) might be placed close to the objects. \n# To create the output grid, remove the noise pixels that do not touch any colored object significantly (having at least 2 neighbors in common). \n# If a noise pixel is touching an object significantly, change its color to that of the object.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract all connected components (colored objects and noise pixels)\n    # 2. Evaluate the noise pixels and their neighbors to determine if they touch any colored object significantly\n    # 3. Change the color of noise pixels that touch an object significantly, otherwise set them to black\n\n    # Get all objects in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    for obj in objects:\n        # If the object is noise (i.e., small and not black), process it\n        if np.sum(obj != Color.BLACK) == 1:  # Only a single pixel\n            noise_pixel_mask = obj != Color.BLACK\n            noise_neighbors_mask = object_neighbors(obj, background=Color.BLACK)\n\n            # Check neighbors to see if any colored objects are nearby\n            for other_obj in objects:\n                if np.sum(other_obj != Color.BLACK) \u003e 1:  # Only consider larger objects\n                    other_obj_mask = other_obj != Color.BLACK\n                    # Count how many neighbors are part of this larger object\n                    if np.sum(noise_neighbors_mask \u0026 other_obj_mask) \u003e= 2:\n                        # Change the color of this noise pixel to the color of the object\n                        output_grid[noise_pixel_mask] = np.argmax(np.bincount(other_obj[other_obj_mask]))\n                        break\n            else:\n                # If no significant object neighbors found, set it to black\n                output_grid[noise_pixel_mask] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10x10 with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random colored rectangles\n    rectangle_colors = np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(2, 5), replace=False)\n    for color in rectangle_colors:\n        rw, rh = np.random.randint(2, 4), np.random.randint(2, 4)  # Random sizes for rectangles\n        sprite = np.full((rw, rh), color)\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n\n    # Add noise pixels randomly\n    n_noise_pixels = np.random.randint(5, 15)\n    for _ in range(n_noise_pixels):\n        x, y = np.random.randint(n), np.random.randint(m)\n        # Ensure the noise pixels are not placed on existing rectangles\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/132/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/132/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/132/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/132/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/132/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/132/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/132/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/132/images/train_output_2.png"}]}, "index": 132, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, color mapping, scaling\n\n# description:\n# In the input you will see a grid where each cell is a colored region separated by a black background.\n# The goal is to create an output grid where each colored region is represented by a single pixel, \n# and the output grid is a scaled version of the input grid\u0027s layout.\n# In the output, each pixel should represent its corresponding region\u0027s color, \n# and the output grid should be exactly half the width and height of the input grid.\n\ndef main(input_grid):\n    # Step 1: Find the connected components in the input grid\n    regions = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Step 2: Create an output grid that is half the size of the input grid\n    output_width = input_grid.shape[0] // 2\n    output_height = input_grid.shape[1] // 2\n    output_grid = np.full((output_width, output_height), Color.BLACK)\n\n    # Step 3: Map each region to a pixel in the output grid\n    for region in regions:\n        # Get the position of the connected component\n        x, y = object_position(region, background=Color.BLACK)\n\n        # Determine the corresponding pixel position in the output grid\n        output_x = x // 2\n        output_y = y // 2\n\n        # Get the color of the region\n        color = object_colors(region, background=Color.BLACK)[0]\n\n        # Set the corresponding pixel in the output grid to the region\u0027s color\n        output_grid[output_x, output_y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Randomly choose the number of regions\n    w, h = np.random.randint(4, 8), np.random.randint(4, 8)\n    \n    # Create a background grid\n    grid = np.full((w * 2, h * 2), Color.BLACK)  # Scale factor of 2 for the regions\n\n    # Generate unique colors for regions, ensuring no color is black\n    num_regions = np.random.randint(2, 6)\n    colors = np.random.choice(list(Color.NOT_BLACK), num_regions, replace=False)\n\n    # Randomly fill the regions\n    for color in colors:\n        # Randomly choose a position for the region (ensuring it\u0027s in the grid)\n        x_start = np.random.randint(0, w) * 2\n        y_start = np.random.randint(0, h) * 2\n        \n        # Fill a 2x2 block with the color\n        grid[x_start:x_start+2, y_start:y_start+2] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/133/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/133/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/133/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/133/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/133/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/133/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/133/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/133/images/train_output_2.png"}]}, "index": 133, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, filling missing parts\n\n# description:\n# In the input, you will see a translationally symmetric pattern with a missing part (occluded by a black rectangle).\n# Your task is to identify the symmetry of the pattern and fill in the missing part using the detected symmetry.\n\ndef main(input_grid):\n    # Step 1: Identify the occluded area (black rectangle)\n    occlusion_color = Color.BLACK\n    occluded_mask = (input_grid == occlusion_color)\n\n    # Step 2: Detect translational symmetries in the grid, ignoring the occlusion\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n\n    # Step 3: Fill in the missing part of the pattern based on the detected symmetry\n    for occluded_x, occluded_y in np.argwhere(occluded_mask):\n        for symmetric_x, symmetric_y in orbit(input_grid, occluded_x, occluded_y, symmetries):\n            if input_grid[symmetric_x, symmetric_y] != occlusion_color:\n                input_grid[occluded_x, occluded_y] = input_grid[symmetric_x, symmetric_y]\n                break\n\n    # Step 4: Extract the filled-in region to return as output\n    filled_in_region = np.full_like(input_grid, occlusion_color)\n    filled_in_region[occluded_mask] = input_grid[occluded_mask]\n    filled_in_region = crop(filled_in_region, background=occlusion_color)\n\n    return filled_in_region\n\ndef generate_input():\n    # Step 1: Create a random sprite\n    sprite_width, sprite_height = np.random.randint(3, 6, size=2)\n    sprite = random_sprite(sprite_width, sprite_height, color_palette=Color.NOT_BLACK)\n\n    # Step 2: Tile the sprite to create a symmetric pattern\n    horizontal_reps, vertical_reps = np.random.randint(2, 5, size=2)\n    pattern = np.tile(sprite, (horizontal_reps, vertical_reps))\n\n    # Step 3: Randomly occlude part of the pattern with a black rectangle\n    occluder_width, occluder_height = np.random.randint(1, 4, size=2)\n    x_occluder = np.random.randint(0, pattern.shape[0] - occluder_width + 1)\n    y_occluder = np.random.randint(0, pattern.shape[1] - occluder_height + 1)\n\n    # Create the black rectangle and place it in the pattern\n    black_rectangle = np.full((occluder_width, occluder_height), Color.BLACK)\n    blit_sprite(pattern, black_rectangle, x_occluder, y_occluder)\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/134/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/134/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/134/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/134/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/134/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/134/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/134/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/134/images/train_output_2.png"}]}, "index": 134, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, color sorting, pattern transformation\n\n# description:\n# In the input you will see a grid with colored patterns consisting of multiple colored stripes.\n# To create the output grid, you should slide each colored stripe up until it touches the first row of the grid.\n# If a stripe cannot be moved up because of other stripes or the edge of the grid, it should stay in place.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect all colored stripes (connected components) in the grid, ignoring black background\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Process each stripe\n    for obj in objects:\n        # Get the bounding box of the stripe\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        \n        # Determine the original color of the stripe\n        color = np.unique(obj)[1]  # The first unique value is the background (black), so take the second\n        \n        # Calculate the maximum upward translation possible\n        max_translation = x  # Distance to the top of the grid\n        \n        # Translate the stripe upward\n        translated_stripe = translate(obj, x=-max_translation, y=0, background=Color.BLACK)\n        \n        # Blit the translated stripe onto the output grid\n        output_grid = blit_object(output_grid, translated_stripe, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Create a varying number of colored stripes\n    num_stripes = np.random.randint(3, 8)\n    colors_used = set()\n\n    for _ in range(num_stripes):\n        # Randomly choose a color that hasn\u0027t been used yet\n        color = np.random.choice(list(Color.NOT_BLACK), 1)[0]\n        colors_used.add(color)\n\n        # Randomly generate the height and width of the stripe\n        stripe_width = np.random.randint(1, m // 2)\n        stripe_height = np.random.randint(1, n // 3)\n\n        # Randomly choose a position to place the stripe\n        x = np.random.randint(0, n - stripe_height)\n        y = np.random.randint(0, m - stripe_width)\n\n        # Create the stripe\n        for i in range(x, x + stripe_height):\n            for j in range(y, y + stripe_width):\n                grid[i, j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/135/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/135/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/135/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/135/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/135/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/135/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/135/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/135/images/train_output_2.png"}]}, "index": 135, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pixel restoration\n\n# description:\n# In the input you will see an object that has missing parts due to some of its pixels being black (occluded).\n# To make the output, identify the rotational symmetry of the object and restore the missing pixels accordingly, \n# filling them in with the colors of the non-black pixels that correspond to their symmetric positions.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the rotational symmetry of the input grid object\n    # 2. Identify the color of each non-black pixel\n    # 3. Restore the missing pixels based on the detected symmetry\n\n    # Detect rotational symmetry\n    symmetry = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Create an output grid initialized to the input grid\n    output_grid = input_grid.copy()\n\n    # Find all colored pixels in the input grid\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Restore pixels based on symmetry\n    for x, y in colored_pixels:\n        color = input_grid[x, y]  # Get the color of the current pixel\n        \n        # Loop through the 3 additional rotations (90, 180, and 270 degrees)\n        for i in range(1, 4):\n            rotated_x, rotated_y = symmetry.apply(x, y, iters=i)\n            \n            # If the pixel at the rotated position is black, fill it with the original color\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a 10x10 grid\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a random sprite with some color and density\n    sprite = random_sprite(5, 5, density=0.5, color_palette=list(Color.NOT_BLACK))\n\n    # Randomly remove some pixels from the sprite to create occlusions\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.rand() \u003c 0.3:  # 30% chance to occlude a pixel\n                sprite[i, j] = Color.BLACK\n\n    # Place the sprite randomly onto the grid, ensuring it fits\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/136/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/136/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/136/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/136/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/136/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/136/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/136/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/136/images/train_output_2.png"}]}, "index": 136, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# expansion, merging, overlay\n\n# description:\n# In the input, you will see several colored circular objects scattered on a black grid. Each circular object has a single yellow pixel at its center.\n# To make the output, you need to expand each circular object to fill the surrounding area with their color, merging them where they overlap. \n# The final output should contain the merged area of all expanded circular objects.\n\ndef main(input_grid):\n    # 1. Detect and extract the circular objects from the input grid\n    circular_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. For each circular object, expand it and merge into the output grid\n    for circular_obj in circular_objects:\n        # Get the color of the current circular object\n        obj_color = circular_obj[circular_obj != Color.BLACK][0]\n\n        # Calculate expansion area by iterating over the object\u0027s pixels\n        for x in range(circular_obj.shape[0]):\n            for y in range(circular_obj.shape[1]):\n                if circular_obj[x, y] != Color.BLACK:\n                    # Expand to the surrounding area\n                    for dx in range(-1, 2):\n                        for dy in range(-1, 2):\n                            if 0 \u003c= x + dx \u003c output_grid.shape[0] and 0 \u003c= y + dy \u003c output_grid.shape[1]:\n                                # Set the surrounding pixels to the object\u0027s color\n                                output_grid[x + dx, y + dy] = obj_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly select the number of circular objects\n    object_num = np.random.randint(2, 6)\n\n    for _ in range(object_num):\n        # Randomly select a color for the circular object, ensuring it\u0027s not black or yellow\n        obj_color = np.random.choice([c for c in Color.NOT_BLACK if c not in [Color.YELLOW, Color.BLACK]])\n\n        # Create a small circular object with a yellow center\n        radius = np.random.randint(1, 3)\n        center_x = np.random.randint(radius, n - radius)\n        center_y = np.random.randint(radius, m - radius)\n\n        # Draw the circular object\n        for x in range(center_x - radius, center_x + radius + 1):\n            for y in range(center_y - radius, center_y + radius + 1):\n                if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                    grid[x, y] = obj_color  # Fill the circular area\n        grid[center_x, center_y] = Color.YELLOW  # Set the center pixel to yellow\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/137/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/137/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/137/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/137/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/137/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/137/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/137/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/137/images/train_output_2.png"}]}, "index": 137, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object collision, vertical/horizontal alignment, overlapping objects\n\n# description:\n# In the input, you will see colored rectangles and several colored pixels sprinkled on a black background.\n# To make the output grid, each rectangle should be filled with its corresponding color, \n# and each pixel should be moved to the center of the closest rectangle of the same color.\n# If a colored pixel does not match any rectangle, it should be removed.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # Find all the colored rectangles\n    rectangles = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Create a dictionary to hold the color of each rectangle\n    rectangle_colors = {}\n    for rect in rectangles:\n        color = np.unique(rect)[1]\n        bounding_box_coords = bounding_box(rect)\n        rectangle_colors[color] = bounding_box_coords  # Store the bounding box (x, y, width, height)\n        blit_object(output_grid, rect, background=Color.BLACK)  # Draw the rectangle on the output grid\n\n    # Now find all single pixels\n    pixels = detect_objects(input_grid, monochromatic=True, allowed_dimensions=[(1, 1)], background=Color.BLACK)\n\n    for pixel in pixels:\n        pixel_color = np.unique(pixel)[1]\n        if pixel_color in rectangle_colors:\n            # Get the bounding box of the rectangle with the same color\n            x, y, w, h = rectangle_colors[pixel_color]\n            # Calculate the center of the rectangle\n            center_x, center_y = x + w // 2, y + h // 2\n            \n            # Translate the pixel to the center of the corresponding rectangle\n            translated_pixel = translate(pixel, center_x - pixel.shape[0] // 2, center_y - pixel.shape[1] // 2, background=Color.BLACK)\n            blit_object(output_grid, translated_pixel, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black background grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random colored rectangles\n    num_rectangles = np.random.randint(2, 6)  # Generate between 2 to 5 rectangles\n    colors_used = set()\n\n    for _ in range(num_rectangles):\n        color = np.random.choice(list(Color.NOT_BLACK))\n        while color in colors_used:  # Ensure unique colors for rectangles\n            color = np.random.choice(list(Color.NOT_BLACK))\n        colors_used.add(color)\n\n        # Random size for the rectangle\n        rect_height = np.random.randint(1, 5)\n        rect_width = np.random.randint(1, 5)\n\n        # Random position within the grid\n        x = np.random.randint(0, n - rect_height)\n        y = np.random.randint(0, m - rect_width)\n\n        rectangle = np.full((rect_height, rect_width), color)\n        blit_sprite(grid, rectangle, x, y, background=Color.BLACK)\n\n    # Scatter some colored pixels randomly on the grid\n    for _ in range(np.random.randint(5, 15)):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        grid[x, y] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/138/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/138/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/138/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/138/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/138/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/138/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/138/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/138/images/train_output_2.png"}]}, "index": 138, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, contact, color transformation\n\n# description:\n# In the input you will see several orange objects placed in a 10x10 grid, with a single yellow pixel in the grid.\n# To create the output grid, select the orange object that is in contact with the yellow pixel, change its color to orange, and return it as the output.\n\ndef main(input_grid):\n    # Get the color of the objects\n    object_color = Color.ORANGE\n\n    # Detect all the orange objects in the grid\n    orange_objects = detect_objects(grid=input_grid, colors=[object_color], connectivity=8, monochromatic=True)\n\n    # Detect the yellow pixel\n    yellow_pixel = detect_objects(grid=input_grid, colors=[Color.YELLOW], connectivity=8, monochromatic=True)\n\n    if len(yellow_pixel) \u003e 0:\n        yellow_pixel = yellow_pixel[0]  # Take the first yellow pixel\n\n        # Check which orange object is in contact with the yellow pixel\n        for obj in orange_objects:\n            if contact(object1=obj, object2=yellow_pixel, connectivity=4):\n                # Change the color of the detected orange object to orange\n                obj[obj == object_color] = Color.ORANGE\n\n                # Create an output grid and place the modified object back\n                output_grid = np.zeros_like(input_grid)\n                output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n                return output_grid\n\n    # If no object is in contact with the yellow pixel, return an empty grid\n    return np.zeros_like(input_grid)\n\ndef generate_input():\n    # Generate a 10x10 grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the objects and the number of objects.\n    object_color = Color.ORANGE\n\n    # Place a random number of orange objects\n    num_objects = np.random.randint(2, 5)\n\n    for _ in range(num_objects):\n        # Create a random sprite for the orange object\n        sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[object_color])\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n            grid = blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            continue  # Skip if there\u0027s no free location\n\n    # Place a yellow pixel ensuring it contacts one of the orange objects\n    if num_objects \u003e 0:\n        yellow_x, yellow_y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[yellow_x, yellow_y] = Color.YELLOW\n\n        # Ensure yellow pixel is placed adjacent to at least one orange object\n        while True:\n            adjacent_x = yellow_x + np.random.choice([-1, 0, 1])\n            adjacent_y = yellow_y + np.random.choice([-1, 0, 1])\n            if 0 \u003c= adjacent_x \u003c n and 0 \u003c= adjacent_y \u003c m:\n                if grid[adjacent_x, adjacent_y] == Color.BLACK:  # Only place if it\u0027s a free space\n                    grid[adjacent_x, adjacent_y] = object_color\n                    break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/139/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/139/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/139/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/139/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/139/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/139/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/139/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/139/images/train_output_2.png"}]}, "index": 139, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, surrounding, object neighbors\n\n# description:\n# The input consists of a black grid with a single green pixel surrounded by other green pixels. \n# To create the output, fill the entire area that is adjacent to the green pixel (horizontally and vertically) with blue pixels. \n# Ensure that the filling respects the boundaries defined by black pixels (which act as walls).\n\ndef main(input_grid):\n    # Extract the green pixel\n    green_pixel = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)[0]\n    \n    # Create output grid based on the input grid\n    output_grid = input_grid.copy()\n    \n    # Get the position of the green pixel\n    green_x, green_y = object_position(green_pixel)\n\n    # Fill in the neighboring pixels with blue\n    neighbors = object_neighbors(green_pixel, background=Color.BLACK)\n    \n    # Fill the neighborhoods with blue\n    for x, y in np.argwhere(neighbors):\n        output_grid[x, y] = Color.BLUE\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 5x5 and 20x20\n    n = np.random.randint(5, 21)\n    m = np.random.randint(5, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random position for the single green pixel\n    x, y = np.random.randint(1, n-1), np.random.randint(1, m-1)\n    grid[x, y] = Color.GREEN\n\n    # Surround the green pixel with other green pixels\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if (dx != 0 or dy != 0) and 0 \u003c= x + dx \u003c n and 0 \u003c= y + dy \u003c m:\n                grid[x + dx, y + dy] = Color.GREEN\n\n    # Fill the rest of the grid with black\n    grid[grid == 0] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/140/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/140/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/140/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/140/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/140/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/140/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/140/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/140/images/train_output_2.png"}]}, "index": 140, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, topology\n\n# description:\n# The input consists of a grid that contains several colored shapes with potential holes. \n# Each shape is a single color, and it can have a \u0027hole\u0027 (a contiguous black region). \n# The task is to fill these holes with the same color as the shape they belong to if the hole is a perfect square. \n# Otherwise, the holes should remain untouched.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all colored objects in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Process each object found in the grid\n    for obj in objects:\n        # Get the color of the object\n        object_color = np.unique(obj[obj != Color.BLACK])[0]\n\n        # Crop the object to analyze it\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Get the hole mask (the black region)\n        hole_mask = (sprite == Color.BLACK) \u0026 (object_interior(sprite, background=Color.BLACK))\n\n        # Check if the hole is square by comparing dimensions and area\n        def is_square(thing):\n            \"\"\"Check if a cropped area is a square.\"\"\"\n            thing = crop(thing)\n            return np.sum(thing != Color.BLACK) == thing.shape[0] * thing.shape[1] and thing.shape[0] == thing.shape[1]\n\n        # If the hole is a square, fill it with the object\u0027s color\n        if is_square(hole_mask):\n            sprite[hole_mask] = object_color\n\n        # Blit the possibly modified sprite back into the output grid\n        x, y = object_position(obj, background=Color.BLACK)\n        blit_sprite(output_grid, sprite, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 12x12 grid filled with black\n    grid = np.full((12, 12), Color.BLACK)\n\n    # Randomly place a few colored shapes\n    num_shapes = np.random.randint(2, 5)  # Number of shapes to generate\n    colors = np.random.choice(Color.NOT_BLACK, num_shapes, replace=True)  # Random colors for shapes\n\n    for color in colors:\n        # Generate a random rectangular shape\n        height, width = np.random.randint(3, 6), np.random.randint(3, 6)\n        shape = np.full((height, width), color)\n\n        # Randomly place holes in the shape\n        hole_size = np.random.randint(1, min(height, width))  # Size of the hole\n        hole_x, hole_y = np.random.randint(0, height - hole_size + 1), np.random.randint(0, width - hole_size + 1)\n\n        # Fill the defined hole area with black\n        shape[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n        # Try to place the shape on the grid in a free location\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, padding=1)\n            blit_sprite(grid, shape, x, y)\n        except ValueError:\n            # If unable to place, restart the generation\n            return generate_input()\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/141/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/141/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/141/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/141/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/141/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/141/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/141/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/141/images/train_output_2.png"}]}, "index": 141, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filling, object placement, collision detection\n\n# description:\n# In the input, you will see several colored objects scattered on a black grid. Each object has a unique color, but the objects do not overlap. There are also two colored pixels at fixed positions: one at the top left corner and one in the bottom right corner.\n# To make the output grid, you should fill each object with the color of the pixel located at the top left corner, but only if the object is not already that color. If an object matches the color of the pixel at the bottom right corner, it should be removed from the output grid.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the colors from the fixed positions\n    top_left_color = output_grid[0, 0]\n    bottom_right_color = output_grid[-1, -1]\n\n    # Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Iterate through each object and apply the transformations\n    for obj in objects:\n        # Get the color of the current object\n        obj_color = np.unique(obj)[0]\n\n        # Check if the object color matches the color at the bottom right corner\n        if obj_color == bottom_right_color:\n            # Remove the object from the output grid\n            output_grid[output_grid == obj_color] = Color.BLACK\n        else:\n            # Fill the object with the color from the top left corner if it\u0027s not already that color\n            if obj_color != top_left_color:\n                output_grid[output_grid == obj_color] = top_left_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose two distinct colors for the top left and bottom right pixels\n    corner_colors = random.sample(list(Color.NOT_BLACK), 2)\n\n    # Set the colors at the fixed positions\n    grid[0, 0] = corner_colors[0]  # Top left corner\n    grid[-1, -1] = corner_colors[1]  # Bottom right corner\n\n    # Generate random objects of various colors\n    for _ in range(np.random.randint(3, 6)):\n        # Create a random sprite of a single color\n        sprite_color = random.choice([c for c in Color.NOT_BLACK if c not in corner_colors])\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[sprite_color])\n        \n        # Find a free location for the sprite and blit it to the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/142/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/142/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/142/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/142/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/142/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/142/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/142/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/142/images/train_output_2.png"}]}, "index": 142, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color replacement, border manipulation\n\n# description:\n# In the input, you will see a grid containing various colored pixels, including blue and green pixels which are special.\n# To create the output, replace each blue pixel with a yellow pixel and surrounding pixels that are not part of any object with a grey pixel.\n# Additionally, if any green pixel is adjacent to a blue pixel, replace it with an orange pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Find blue pixels and their neighbors\n    blue_pixels = np.argwhere(input_grid == Color.BLUE)\n    green_neighbors = set()\n\n    # Process blue pixels\n    for x, y in blue_pixels:\n        # Replace blue with yellow\n        output_grid[x, y] = Color.YELLOW\n\n        # Check neighbors for green pixels\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 \u003c= nx \u003c input_grid.shape[0] and 0 \u003c= ny \u003c input_grid.shape[1]:\n                if input_grid[nx, ny] == Color.GREEN:\n                    green_neighbors.add((nx, ny))\n\n    # Replace adjacent green pixels with orange\n    for gx, gy in green_neighbors:\n        output_grid[gx, gy] = Color.ORANGE\n\n    # Identify areas that are not part of any object using object_neighbors\n    background = Color.BLACK\n    neighbors_mask = object_neighbors(output_grid, background=background)\n\n    # Replace the non-object border neighbors (that are not blue or green) with grey\n    output_grid[np.logical_and(neighbors_mask, output_grid == background)] = Color.GREY\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_blue = np.random.randint(1, 5)\n    num_green = np.random.randint(1, 5)\n    num_other = np.random.randint(5, 15)\n\n    # Place blue pixels\n    for _ in range(num_blue):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLUE\n\n    # Place green pixels near blue ones to guarantee adjacency\n    for _ in range(num_green):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            # Ensure we place green adjacent to blue\n            dx, dy = np.random.choice([-1, 0, 1]), np.random.choice([-1, 0, 1])\n            adj_x, adj_y = x + dx, y + dy\n            if 0 \u003c= adj_x \u003c n and 0 \u003c= adj_y \u003c m and grid[adj_x, adj_y] == Color.BLUE:\n                grid[x, y] = Color.GREEN\n\n    # Place other colored pixels\n    for _ in range(num_other):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color not in [Color.GREEN, Color.BLUE]])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/143/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/143/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/143/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/143/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/143/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/143/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/143/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/143/images/train_output_2.png"}]}, "index": 143, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, pattern generation\n\n# description:\n# In the input, you will see a grid with a single green pixel at the center. \n# To make the output, fill the grid with green pixels in all four cardinal directions (North, South, East, West) starting from the green pixel at the center until you reach the edge of the grid. Additionally, if there are any pixels touching the filled area, color those pixels yellow.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the grid\n    height, width = input_grid.shape\n    \n    # Find the position of the green pixel\n    green_pixel = np.argwhere(input_grid == Color.GREEN)\n    assert len(green_pixel) == 1, \"There must be exactly one green pixel\"\n    \n    center_x, center_y = green_pixel[0]\n\n    # Create an output grid initialized to the input grid\n    output_grid = np.copy(input_grid)\n\n    # Fill in the four directions from the center pixel\n    for dx in range(-center_x, height - center_x):\n        if dx + center_x \u003e= 0 and dx + center_x \u003c height:\n            output_grid[center_x + dx, center_y] = Color.GREEN  # Fill South and North\n\n    for dy in range(-center_y, width - center_y):\n        if dy + center_y \u003e= 0 and dy + center_y \u003c width:\n            output_grid[center_x, center_y + dy] = Color.GREEN  # Fill East and West\n\n    # Now color touching pixels yellow\n    for x in range(height):\n        for y in range(width):\n            if (output_grid[x, y] == Color.BLACK and \n                (output_grid[max(x-1, 0), y] == Color.GREEN or \n                 output_grid[min(x+1, height-1), y] == Color.GREEN or \n                 output_grid[x, max(y-1, 0)] == Color.GREEN or \n                 output_grid[x, min(y+1, width-1)] == Color.GREEN)):\n                output_grid[x, y] = Color.YELLOW\n                \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with a random size\n    height, width = np.random.randint(5, 20, size=2)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Place a single green pixel at the center\n    center_x, center_y = height // 2, width // 2\n    grid[center_x, center_y] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/144/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/144/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/144/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/144/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/144/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/144/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/144/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/144/images/train_output_2.png"}]}, "index": 144, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, stacking, color transformation\n\n# description:\n# In the input, you will see several blue pixels scattered above a grey baseline. \n# The grey baseline is at the bottom of the grid. \n# To make the output, move each blue pixel downward until it touches the grey baseline. \n# Once they touch, change their color to grey. If multiple blue pixels collide when falling, they will stack on top of each other.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    height, width = output_grid.shape\n\n    # Identify the baseline color (grey)\n    baseline_color = Color.GREY\n\n    # Find the blue pixels and process each one\n    blue_pixels = np.argwhere(output_grid == Color.BLUE)\n\n    for x, y in blue_pixels:\n        # Move the blue pixel downward until it hits the baseline or another blue pixel\n        while y \u003c height - 1:  # until it hits the bottom\n            # Check if the next position is free (not grey or blue)\n            if collision(object1=output_grid, object2=np.array([[Color.BLUE]]), x1=x, y1=y+1, x2=x, y2=y+1):\n                break  # stop if there\u0027s a collision with another blue pixel\n            y += 1  # move down\n\n        # If the pixel has reached the baseline, change its color to grey\n        if y \u003c height - 1 and output_grid[x, y + 1] == baseline_color:\n            output_grid[x, y] = baseline_color  # change to grey\n        else:\n            output_grid[x, y] = Color.GREY  # if it stacked on another blue pixel, it turns grey\n\n    return output_grid\n\ndef generate_input():\n    width, height = 5, 5\n    input_grid = np.zeros((height, width), dtype=int)\n\n    # Create the grey baseline at the bottom\n    input_grid[height-1, :] = Color.GREY\n\n    # Randomly scatter blue pixels above the grey baseline\n    num_blue_pixels = np.random.randint(1, 6)  # between 1 and 5 blue pixels\n    for _ in range(num_blue_pixels):\n        x = np.random.randint(0, width)\n        y = np.random.randint(0, height - 1)  # must be above the grey baseline\n        input_grid[y, x] = Color.BLUE\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/145/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/145/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/145/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/145/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/145/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/145/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/145/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/145/images/train_output_2.png"}]}, "index": 145, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, scaling, mirroring\n\n# description:\n# In the input you will see a grid with various patterns, where each pattern consists of clusters of non-black colors.\n# To make the output, you should first find all connected components (patterns) in the grid,\n# then mirror each pattern vertically, scale it by 2, and place these transformed patterns back into the output grid.\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.full((input_grid.shape[0] * 2, input_grid.shape[1] * 2), Color.BLACK)\n    \n    # Find all connected components (patterns) in the input grid\n    patterns = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n\n    for pattern in patterns:\n        # Get the bounding box of the current pattern\n        x, y, width, height = bounding_box(pattern)\n        \n        # Crop the pattern from the input grid\n        cropped_pattern = crop(pattern, background=Color.BLACK)\n        \n        # Mirror the pattern vertically\n        mirrored_pattern = np.flipud(cropped_pattern)\n\n        # Scale the mirrored pattern by a factor of 2\n        scaled_pattern = scale_sprite(mirrored_pattern, factor=2)\n\n        # Determine the position to place the scaled pattern in the output grid\n        # Place it at the same position as the original pattern\u0027s bounding box in the output grid\n        output_x = x * 2\n        output_y = y * 2\n        \n        # Place the scaled pattern in the output grid\n        blit_sprite(output_grid, scaled_pattern, x=output_x, y=output_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create the background grid\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a number of patterns\n    num_patterns = np.random.randint(1, 5)\n    for _ in range(num_patterns):\n        # Random size for the pattern\n        width, height = np.random.randint(2, 4), np.random.randint(2, 4)\n        \n        # Create a random color for the pattern\n        color = np.random.choice(Color.NOT_BLACK)\n        pattern = np.full((width, height), Color.BLACK)\n\n        # Fill the pattern with the color\n        for i in range(width):\n            for j in range(height):\n                if np.random.rand() \u003c 0.5:  # Randomly decide whether to color the pixel\n                    pattern[i, j] = color\n\n        # Randomly place the pattern on the grid\n        try:\n            x = np.random.randint(0, n - width)\n            y = np.random.randint(0, m - height)\n            blit_sprite(grid, pattern, x=x, y=y)\n        except:\n            return generate_input()\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/146/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/146/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/146/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/146/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/146/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/146/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/146/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/146/images/train_output_2.png"}]}, "index": 146, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, line drawing, pattern filling\n\n# description:\n# In the input, you will see two differently colored patterns (rectangles) separated by a gap filled with black pixels.\n# To make the output, you should connect the two patterns with a vertical red line, ensuring that the line only occupies\n# the black pixels directly between the two patterns, while leaving the patterns intact.\n\ndef main(input_grid):\n    # Copy the input grid as output\n    output_grid = input_grid.copy()\n\n    # Detect the objects (patterns) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Ensure we have exactly two objects\n    if len(objects) != 2:\n        raise ValueError(\"Input grid must contain exactly two patterns.\")\n\n    # Get the bounding boxes of the detected objects\n    box1 = bounding_box(objects[0])\n    box2 = bounding_box(objects[1])\n\n    # Determine the positions of the two patterns\n    x1, y1, _, _ = box1\n    x2, y2, _, _ = box2\n\n    # Ensure x1 \u003c x2 for consistent processing\n    if x1 \u003e x2:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n\n    # Draw a red vertical line in the black space between the two patterns\n    for y in range(min(y1 + 1, y2 - 1), max(y1 + 1, y2 - 1) + 1):\n        for x in range(x1 + 1, x2):\n            if input_grid[y, x] == Color.BLACK:  # Ensure we\u0027re only drawing in black space\n                output_grid[y, x] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the patterns\n    colors = np.random.choice([color for color in Color.NOT_BLACK], 2, replace=False)\n    color1, color2 = colors\n\n    # Generate two rectangles\n    n1, m1 = np.random.randint(3, 10, size=2)\n    n2, m2 = np.random.randint(3, 10, size=2)\n\n    rectangle1 = np.full((n1, m1), color1)\n    rectangle2 = np.full((n2, m2), color2)\n\n    # Place the rectangles on the grid ensuring a gap between them\n    x1, y1 = np.random.randint(0, n - n1), np.random.randint(0, m - m1)\n    blit_sprite(grid, rectangle1, x1, y1, Color.BLACK)\n\n    # Randomly place the second rectangle ensuring a gap\n    x2, y2 = x1 + m1 + np.random.randint(2, 5), y1  # Ensure a gap of at least 2 pixels\n    if x2 + m2 \u003e n:\n        x2 = n - m2 - 1  # Adjust if it exceeds the grid\n\n    blit_sprite(grid, rectangle2, x2, y2, Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/147/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/147/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/147/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/147/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/147/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/147/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/147/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/147/images/train_output_2.png"}]}, "index": 147, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, filling, object placement\n\n# description:\n# In the input you will see a grid containing several colored pixels. Among them, there are red pixels which are special.\n# To create the output, for each red pixel, find the closest black pixel and fill it with yellow. \n# Additionally, draw a yellow border around the red pixel. \n# Any other colored pixels should remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized with the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find the positions of all red pixels\n    red_pixels = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n\n    for red_pixel in red_pixels:\n        # Get the position of the red pixel\n        red_x, red_y = object_position(red_pixel)\n\n        # Draw a yellow border around the red pixel\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if abs(dx) + abs(dy) == 1:  # Only the adjacent pixels (Manhattan distance = 1)\n                    if 0 \u003c= red_x + dx \u003c output_grid.shape[0] and 0 \u003c= red_y + dy \u003c output_grid.shape[1]:\n                        output_grid[red_x + dx, red_y + dy] = Color.YELLOW\n\n        # Find the closest black pixel to fill with yellow\n        min_distance = float(\u0027inf\u0027)\n        closest_black_pixel = None\n\n        # Check the 8 neighboring pixels for the closest black pixel\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if abs(dx) + abs(dy) == 1:  # Only the adjacent pixels\n                    neighbor_x = red_x + dx\n                    neighbor_y = red_y + dy\n                    if 0 \u003c= neighbor_x \u003c output_grid.shape[0] and 0 \u003c= neighbor_y \u003c output_grid.shape[1]:\n                        if output_grid[neighbor_x, neighbor_y] == Color.BLACK:\n                            distance = abs(dx) + abs(dy)\n                            if distance \u003c min_distance:\n                                min_distance = distance\n                                closest_black_pixel = (neighbor_x, neighbor_y)\n\n        # Fill the closest black pixel with yellow if found\n        if closest_black_pixel:\n            output_grid[closest_black_pixel] = Color.YELLOW\n\n    # Blit the modified areas back into the output grid\n    blit_object(output_grid, output_grid)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid of size 10x10 to 20x20\n    width, height = np.random.randint(10, 21, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly place red pixels\n    num_red_pixels = np.random.randint(3, 7)\n    for _ in range(num_red_pixels):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = Color.RED\n\n    # Randomly place other colored pixels (excluding red and black)\n    num_other_pixels = np.random.randint(5, 15)\n    other_colors = [color for color in Color.NOT_BLACK if color != Color.RED]\n    for _ in range(num_other_pixels):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[x, y] == Color.BLACK:  # Ensure we are placing on a black pixel\n            grid[x, y] = np.random.choice(other_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/148/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/148/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/148/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/148/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/148/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/148/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/148/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/148/images/train_output_2.png"}]}, "index": 148, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary, regions, coloring\n\n# description:\n# In the input grid, you will see several shapes of the same color surrounded by a black background. \n# The output should highlight the boundaries of those shapes in a different color. \n# Additionally, if any of the shapes are fully enclosed by the boundary, color their interior in yellow. \n\ndef main(input_grid):\n    # Create an output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find the boundaries of the objects in the grid\n    boundaries = object_boundary(input_grid)\n\n    # Color the boundaries in a distinct color (e.g., Color.BLUE)\n    output_grid[boundaries] = Color.BLUE\n\n    # Find interior of the objects\n    interior_mask = object_interior(input_grid)\n    \n    # Color the interior in yellow\n    for x, y in np.argwhere(interior_mask):\n        if output_grid[x, y] == Color.BLACK:  # Only color if it\u0027s still black\n            output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size between 10x10 and 20x20\n    n = random.randint(10, 20)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Define the color for the shapes\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Generate random shapes with a boundary\n    number_of_shapes = random.randint(2, 5)  # Randomly decide how many shapes to generate\n    for _ in range(number_of_shapes):\n        # Create a random sprite\n        sprite_height = random.randint(3, 6)\n        sprite_width = random.randint(3, 6)\n        sprite = random_sprite(sprite_height, sprite_width, color_palette=[shape_color])\n\n        # Place the sprite in a random free location within the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue  # If no free location is found, skip this shape and try again\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/149/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/149/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/149/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/149/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/149/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/149/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/149/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/149/images/train_output_2.png"}]}, "index": 149, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color rearrangement\n\n# description:\n# In the input you will see a grid with a specific pattern consisting of a 2x2 block of colors.\n# To make the output, identify all the 2x2 blocks in the grid, and rearrange the colors within each block\n# according to the following mapping: \n# - red -\u003e green\n# - green -\u003e blue\n# - blue -\u003e yellow\n# - yellow -\u003e red\n#\n# If a block contains any color not in the specified mapping, it should remain unchanged.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.copy(input_grid)\n\n    # Define the color mapping\n    color_map = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.RED\n    }\n\n    # Scan the grid for 2x2 blocks\n    for x in range(input_grid.shape[0] - 1):\n        for y in range(input_grid.shape[1] - 1):\n            # Check if we have a 2x2 block\n            block_colors = {input_grid[x, y], input_grid[x, y + 1], input_grid[x + 1, y], input_grid[x + 1, y + 1]}\n            # If all colors in the block are in color_map, transform them\n            if block_colors.issubset(color_map.keys()):\n                # Apply the color mapping to the output grid\n                output_grid[x, y] = color_map[input_grid[x, y]]\n                output_grid[x, y + 1] = color_map[input_grid[x, y + 1]]\n                output_grid[x + 1, y] = color_map[input_grid[x + 1, y]]\n                output_grid[x + 1, y + 1] = color_map[input_grid[x + 1, y + 1]]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid of specified size with colors\n    n, m = np.random.randint(6, 12), np.random.randint(6, 12)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly populate the grid with colors that can form 2x2 blocks\n    for x in range(0, n, 2):\n        for y in range(0, m, 2):\n            if x + 1 \u003c n and y + 1 \u003c m:  # Ensure we don\u0027t go out of bounds\n                colors = np.random.choice(list(Color.NOT_BLACK), 4, replace=False)\n                grid[x:x + 2, y:y + 2] = colors.reshape(2, 2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/150/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/150/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/150/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/150/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/150/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/150/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/150/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/150/images/train_output_2.png"}]}, "index": 150, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, symmetry detection, pattern expansion\n\n# description:\n# In the input you will see a pattern of colored pixels that exhibits translational symmetry.\n# The goal is to expand this pattern to fill the entire grid while preserving the symmetry.\n# The output will be a grid that retains the original pattern but extended in all directions based on the detected symmetry.\n\ndef main(input_grid):\n    # Step 1: Find the background color (most common color on the border)\n    pixels_on_border = np.concatenate([input_grid[0, :], input_grid[-1, :], input_grid[:, 0], input_grid[:, -1]])\n    background = max(set(pixels_on_border), key=list(pixels_on_border).count)\n\n    # Step 2: Detect the translational symmetries in the input grid\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[background])\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # Step 3: Create an output grid which is larger than the input grid\n    width, height = input_grid.shape\n    output_grid = np.full((width*2, height*2), background)\n\n    # Step 4: Copy the original pattern and its symmetries to the output grid\n    for x, y in np.argwhere(input_grid != background):\n        # Compute the orbit of each pixel considering the symmetries\n        for x2, y2 in orbit(input_grid, x, y, symmetries):\n            output_grid[x2 + width//2, y2 + height//2] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a background color\n    grid_size = np.random.randint(6, 12)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a colored pattern in the middle of the grid\n    pattern_size = np.random.randint(2, 4)\n    colors = np.random.choice(Color.NOT_BLACK, size=pattern_size, replace=False)\n    \n    # Fill in a pattern that can exhibit symmetry\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            if (i + j) % 2 == 0:  # Create a checkered pattern\n                grid[i + grid_size // 4, j + grid_size // 4] = colors[i % len(colors)]\n    \n    # Randomly rotate the pattern to ensure variability\n    grid = np.rot90(grid, k=np.random.randint(4))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/151/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/151/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/151/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/151/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/151/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/151/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/151/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/151/images/train_output_2.png"}]}, "index": 151, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color merging, masking, conditional transformation\n\n# description:\n# In the input you will see a grid containing colorful objects and a monochromatic object. \n# To make the output, use the monochromatic object as a binary mask and merge the colors of the colorful objects that fall under the mask. \n# The merging operation involves averaging the colors of overlapping colorful objects, while the monochromatic object remains unchanged.\n\ndef main(input_grid):\n    # Step 1: Find connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n\n    # Step 2: Identify the monochromatic mask and colorful objects\n    mask = None\n    colorful_objects = []\n\n    for obj in objects:\n        if len(set(obj.flatten())) == 2 and Color.BLACK in set(obj.flatten()):\n            mask = obj  # This is the monochromatic mask\n        else:\n            colorful_objects.append(obj)  # These are colorful objects\n\n    # Step 3: Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 4: Get the bounding box of the mask and extract it\n    mask_x, mask_y, mask_w, mask_h = bounding_box(mask)\n    mask_region = mask[mask_x:mask_x + mask_w, mask_y:mask_y + mask_h]\n\n    # Step 5: Process each colorful object and merge colors where the mask overlaps\n    for colorful in colorful_objects:\n        # Get the bounding box of the colorful object\n        colorful_x, colorful_y, colorful_w, colorful_h = bounding_box(colorful)\n        colorful_region = colorful[colorful_x:colorful_x + colorful_w, colorful_y:colorful_y + colorful_h]\n\n        # Check for overlap with the mask\n        overlap_x_start = max(mask_x, colorful_x)\n        overlap_y_start = max(mask_y, colorful_y)\n        overlap_x_end = min(mask_x + mask_w, colorful_x + colorful_w)\n        overlap_y_end = min(mask_y + mask_h, colorful_y + colorful_h)\n\n        # If there is an overlap region, merge the colors\n        if overlap_x_start \u003c overlap_x_end and overlap_y_start \u003c overlap_y_end:\n            # Calculate the average color for pixels in the overlap\n            overlap_colors = []\n\n            for x in range(overlap_x_start, overlap_x_end):\n                for y in range(overlap_y_start, overlap_y_end):\n                    if colorful[x, y] != Color.BLACK:  # Only consider non-black pixels\n                        overlap_colors.append(colorful[x, y])\n\n            if overlap_colors:\n                average_color = np.mean(overlap_colors, axis=0).astype(int)\n                # Set the average color in the output grid\n                output_grid[overlap_x_start:overlap_x_end, overlap_y_start:overlap_y_end] = average_color\n\n    # Step 6: Overlay the mask onto the output grid\n    output_grid[np.where(mask != Color.BLACK)] = mask[np.where(mask != Color.BLACK)]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with monochromatic and colorful objects\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a colorful object\n    colorful_sprite = random_sprite(np.random.randint(3, 7), np.random.randint(3, 7), density=0.5)\n    \n    # Randomly place the colorful object in the grid\n    x, y = random_free_location_for_sprite(grid, colorful_sprite)\n    blit_sprite(grid, colorful_sprite, x, y)\n\n    # Create a monochromatic mask\n    mask_color = np.random.choice(Color.NOT_BLACK)\n    mask_sprite = random_sprite(np.random.randint(3, 7), np.random.randint(3, 7), density=1, color_palette=[mask_color])\n    \n    # Randomly place the mask in the grid, ensuring it overlaps the colorful object\n    mask_x, mask_y = random_free_location_for_sprite(grid, mask_sprite, background=Color.BLACK)\n    blit_sprite(grid, mask_sprite, mask_x, mask_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/152/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/152/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/152/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/152/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/152/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/152/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/152/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/152/images/train_output_2.png"}]}, "index": 152, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, shape extension\n\n# description:\n# In the input you will see an incomplete grid that contains a symmetrical pattern. \n# The pattern is missing parts at the edges. To make the output, you should extend \n# the existing pattern symmetrically until it fills the entire grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the symmetry of the existing pattern.\n    # 2. Fill in the missing parts using the detected symmetry.\n    # 3. Return the completed grid.\n\n    # Find the symmetry in the input grid\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=None)\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # Create an output grid with the same shape as the input\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Compute the orbit for each non-background pixel in the input grid and fill in the output grid\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Compute the orbit of the point (x, y)\n        symmetric_points = orbit(output_grid, x, y, symmetries)\n        \n        # Copy the color from the input grid to the output grid based on the orbit\n        for sx, sy in symmetric_points:\n            output_grid[sx, sy] = input_grid[x, y]\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a base sprite with some random color.\n    # 2. Tile the sprite in a way that forms a symmetrical pattern.\n    # 3. Randomly clear some pixels to create an incomplete pattern.\n\n    # Make a random sprite\n    w, h = np.random.randint(2, 5, size=(2))\n    sprite = random_sprite(w, h, color_palette=Color.NOT_BLACK)\n\n    # Tile it to create a symmetrical pattern\n    horizontal_repetitions, vertical_repetitions = np.random.randint(2, 5, size=(2))\n    pattern = np.tile(sprite, (horizontal_repetitions, vertical_repetitions))\n\n    # Randomly clear some pixels to create an incomplete pattern\n    for _ in range(np.random.randint(0, pattern.size // 4)):\n        x, y = np.random.randint(0, pattern.shape[0]), np.random.randint(0, pattern.shape[1])\n        pattern[x, y] = Color.BLACK  # Clear pixel to black (background)\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/153/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/153/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/153/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/153/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/153/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/153/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/153/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/153/images/train_output_2.png"}]}, "index": 153, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bouncing, color transformation\n\n# description:\n# In the input you will see a single green pixel on a black background.\n# To make the output, shoot the green pixel diagonally down and to the left, having it reflect and bounce off the walls until it exits the left side of the grid.\n# Every time the green pixel bounces, place a yellow pixel at the point of contact with the wall.\n# Finally, change all black pixels to maroon.\n\ndef main(input_grid):\n    # Find the location of the green pixel\n    green_pixel_x, green_pixel_y = np.argwhere(input_grid == Color.GREEN)[0]\n    \n    # The direction of the initial shoot is diagonally down and to the left\n    direction = (-1, 1)  # (dx, dy)\n\n    # Loop until the pixel falls out of the canvas\n    while 0 \u003c= green_pixel_x \u003c input_grid.shape[0] and 0 \u003c= green_pixel_y \u003c input_grid.shape[1]:\n        stop_x, stop_y = draw_line(input_grid, green_pixel_x, green_pixel_y, direction=direction, color=Color.GREEN)\n        \n        # Check if we hit a wall and need to bounce\n        if stop_x == green_pixel_x and stop_y == green_pixel_y:\n            break\n        \n        # Update position\n        green_pixel_x, green_pixel_y = stop_x, stop_y\n        \n        # Place a yellow pixel at the point of contact\n        input_grid[stop_x, stop_y] = Color.YELLOW\n        \n        # Change direction upon hitting the wall\n        if stop_x == 0:  # hit left wall\n            direction = (-direction[0], direction[1])  # reflect horizontally\n        elif stop_y == input_grid.shape[1] - 1:  # hit bottom wall\n            direction = (direction[0], -direction[1])  # reflect vertically\n\n    # Change all black pixels to maroon\n    input_grid[input_grid == Color.BLACK] = Color.MAROON\n    \n    return input_grid\n\n\ndef generate_input():\n    width, height = np.random.randint(5, 15), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n    \n    # Place a single green pixel\n    grid[-1, np.random.randint(0, height)] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/154/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/154/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/154/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/154/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/154/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/154/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/154/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/154/images/train_output_2.png"}]}, "index": 154, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel pattern transformation, diagonal expansion, color filling\n\n# description:\n# In the input you will see a grid with several colored pixels arranged in a diagonal line from the top left to the bottom right.\n# To make the output, create a new square grid and for each pixel in the diagonal, fill the square grid in a specific pattern:\n# For each colored pixel, fill a 2x2 square at the position of that pixel in the output, and then extend colors diagonally downward from each pixel.\n\ndef main(input_grid):\n    # Extract the pixels from the input grid\n    pixels = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    \n    # Create the output grid\n    output_size = input_grid.shape[0] * 2  # Output grid will be twice the size of the input grid\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # For each pixel, find its position and fill the output grid\n    for pixel in pixels:\n        pixel_x, pixel_y = object_position(pixel, background=Color.BLACK)\n        pixel_color = object_colors(pixel)[0]\n\n        # Fill a 2x2 square in the output grid\n        x_start = pixel_x * 2\n        y_start = pixel_y * 2\n        output_grid[x_start:x_start + 2, y_start:y_start + 2] = pixel_color\n\n        # Extend colors diagonally downward from each pixel\n        for offset in range(1, output_size):\n            if x_start + offset \u003c output_size and y_start + offset \u003c output_size:\n                output_grid[x_start + offset, y_start + offset] = pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a diagonal line of colored pixels in a grid\n    width, height = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colored pixels\n    num_pixels = np.random.randint(1, min(width, height) + 1)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=False)\n\n    # Place colored pixels diagonally\n    for i in range(num_pixels):\n        if i \u003c width and i \u003c height:\n            grid[i, i] = colors[i]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/155/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/155/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/155/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/155/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/155/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/155/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/155/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/155/images/train_output_2.png"}]}, "index": 155, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, color mapping, size-based transformation\n\n# description:\n# In the input, you will see various colored objects on a black background.\n# The task is to identify the connected components of each colored object and color them based on their size:\n# - If an object has 1 pixel, it should be colored blue.\n# - If an object has 2 pixels, it should be colored green.\n# - If an object has 3 pixels, it should be colored red.\n# - If an object has more than 3 pixels, it should remain its original color.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find connected components in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Color the objects based on their size\n    for obj in objects:\n        num_pixels = np.sum(obj != Color.BLACK)\n        if num_pixels == 1:\n            color = Color.BLUE\n        elif num_pixels == 2:\n            color = Color.GREEN\n        elif num_pixels == 3:\n            color = Color.RED\n        else:\n            color = None  # Keep the original color if more than 3 pixels\n\n        if color is not None:\n            output_grid[obj != Color.BLACK] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size (10x10 to 15x15)\n    n, m = np.random.randint(10, 16), np.random.randint(10, 16)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a number of sprites (objects)\n    num_objects = np.random.randint(3, 8)  # Random number of objects\n    for _ in range(num_objects):\n        # Generate a random sprite\n        sprite = random_sprite(np.random.randint(1, 5), np.random.randint(1, 5), density=1, color_palette=Color.NOT_BLACK)\n        \n        # Randomly place the sprite in the grid\n        x, y = random.randint(0, n - sprite.shape[0]), random.randint(0, m - sprite.shape[1])\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/156/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/156/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/156/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/156/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/156/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/156/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/156/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/156/images/train_output_2.png"}]}, "index": 156, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, pattern connection, rectangular object\n\n# description:\n# In the input grid, you will see a rectangular object of one color surrounded by pixels of another color.\n# The task is to extend the same color pixels from the edges of the rectangle outward to form a rectangular frame of that color.\n# The frame should be one pixel wide and surround the original rectangle.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the rectangular object and its color.\n    # 2. Create a new output grid that is larger than the input grid.\n    # 3. Draw the original rectangle on the output grid.\n    # 4. Extend lines outward from the edges of the rectangle to form a frame.\n    \n    # 1. Find the rectangular object\n    rectangle = max(find_connected_components(input_grid, background=Color.BLACK, monochromatic=True), \n                    key=lambda obj: np.count_nonzero(obj))\n    rectangle_color = object_colors(rectangle)[0]  # Get the color of the rectangle\n\n    # 2. Create a new output grid\n    output_shape = (rectangle.shape[0] + 2, rectangle.shape[1] + 2)  # Add a border\n    output_grid = np.full(output_shape, Color.BLACK)\n\n    # 3. Place the original rectangle in the center of the output grid\n    blit_sprite(output_grid, rectangle, x=1, y=1)\n\n    # 4. Draw the frame by extending the color outward\n    for x in range(rectangle.shape[0]):\n        for y in range(rectangle.shape[1]):\n            if rectangle[x, y] == rectangle_color:\n                # Extend the color outward (up, down, left, right)\n                if x == 0:  # Top edge\n                    output_grid[x, y + 1] = rectangle_color\n                if x == rectangle.shape[0] - 1:  # Bottom edge\n                    output_grid[x + 2, y + 1] = rectangle_color\n                if y == 0:  # Left edge\n                    output_grid[x + 1, y] = rectangle_color\n                if y == rectangle.shape[1] - 1:  # Right edge\n                    output_grid[x + 1, y + 2] = rectangle_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random rectangular object\n    width = np.random.randint(3, 6)  # Random width between 3 and 5\n    height = np.random.randint(3, 6)  # Random height between 3 and 5\n    rect_color = np.random.choice(Color.NOT_BLACK)  # Random color for the rectangle\n    \n    # Create a black grid\n    grid_size = (width + 2, height + 2)  # Add space for border\n    grid = np.full(grid_size, Color.BLACK)\n\n    # Place the rectangular object in the grid\n    for x in range(1, width + 1):\n        for y in range(1, height + 1):\n            grid[x, y] = rect_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/157/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/157/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/157/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/157/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/157/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/157/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/157/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/157/images/train_output_2.png"}]}, "index": 157, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, line drawing, expansion\n\n# description:\n# In the input you will see a grid filled with a random pattern of colored pixels. Each color represents a unique shape. \n# To make the output, you need to find the blue pixels in the grid, and for each blue pixel, draw a yellow line that extends to the edge of the grid in all four cardinal directions (up, down, left, right).\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the coordinates of all blue pixels\n    blue_pixels = np.argwhere(input_grid == Color.BLUE)\n\n    for blue_x, blue_y in blue_pixels:\n        # Draw lines to all four directions from the blue pixel\n        draw_line(output_grid, x=blue_x, y=blue_y, direction=(-1, 0), color=Color.YELLOW)  # Up\n        draw_line(output_grid, x=blue_x, y=blue_y, direction=(1, 0), color=Color.YELLOW)   # Down\n        draw_line(output_grid, x=blue_x, y=blue_y, direction=(0, -1), color=Color.YELLOW)  # Left\n        draw_line(output_grid, x=blue_x, y=blue_y, direction=(0, 1), color=Color.YELLOW)   # Right\n\n    return output_grid\n\ndef generate_input():\n    # Create a background grid and fill it with random colors\n    width, height = np.random.randint(15, 25, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly decide the number of blue pixels\n    num_blue_pixels = np.random.randint(1, 6)\n\n    for _ in range(num_blue_pixels):\n        # Randomly choose a position for the blue pixel\n        x = np.random.randint(0, width)\n        y = np.random.randint(0, height)\n        grid[x, y] = Color.BLUE\n\n        # Optionally fill surrounding pixels with random colors (excluding blue)\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if dx == 0 and dy == 0:  # Skip the center pixel\n                    continue\n                nx, ny = x + dx, y + dy\n                if 0 \u003c= nx \u003c width and 0 \u003c= ny \u003c height and grid[nx, ny] == Color.BLACK:\n                    grid[nx, ny] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/158/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/158/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/158/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/158/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/158/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/158/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/158/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/158/images/train_output_2.png"}]}, "index": 158, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, collision detection\n\n# description:\n# In the input, there are blue and black shapes, with the blue shapes having holes in them. \n# To create the output, fill in the holes with a new color (green) while ensuring the blue shapes remain untouched.\n\ndef main(input_grid):\n    # Create a copy of the input grid to store the output\n    output_grid = np.copy(input_grid)\n\n    # Find the locations of all blue shapes\n    blue_shapes = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    for blue_shape in blue_shapes:\n        # Get the bounding box of the blue shape\n        x, y, width, height = bounding_box(blue_shape, background=Color.BLACK)\n\n        # Check for holes (black pixels) inside the bounding box of the blue shape\n        for i in range(x, x + width):\n            for j in range(y, y + height):\n                if blue_shape[i - x, j - y] == Color.BLACK:\n                    # We need to check if placing green here will not cause collision with blue.\n                    test_shape = np.full_like(blue_shape, Color.BLACK)\n                    test_shape[i - x, j - y] = Color.GREEN\n\n                    # Check for collision with the blue shape\n                    if not collision(object1=blue_shape, object2=test_shape, x1=0, y1=0, x2=i-x, y2=j-y):\n                        # Fill the hole with green\n                        output_grid[i, j] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random number of blue shapes (1-3)\n    num_shapes = np.random.randint(1, 4)\n\n    for _ in range(num_shapes):\n        # Generate a random size for the blue shape\n        shape_height = np.random.randint(3, 6)\n        shape_width = np.random.randint(3, 6)\n\n        # Create the blue shape\n        blue_shape = np.full((shape_height, shape_width), Color.BLUE)\n\n        # Find a free location for the blue shape\n        try:\n            x, y = random_free_location_for_sprite(grid, blue_shape)\n        except ValueError:\n            continue\n\n        # Blit the blue shape onto the grid\n        blit_sprite(grid, blue_shape, x, y)\n\n        # Create holes in the blue shape by randomly changing some pixels to black\n        num_holes = np.random.randint(1, 5)  # Create 1-4 holes\n        for _ in range(num_holes):\n            hole_x = np.random.randint(1, shape_width - 1)\n            hole_y = np.random.randint(1, shape_height - 1)\n            grid[x + hole_y, y + hole_x] = Color.BLACK  # Create a hole\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/159/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/159/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/159/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/159/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/159/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/159/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/159/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/159/images/train_output_2.png"}]}, "index": 159, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color merging, connected components identification\n\n# description:\n# The input consists of a grid with colored pixels forming several shapes. \n# Each shape is either a solid color or made up of a combination of colors. \n# To create the output, identify the connected components and merge the colors \n# of each component into a single color based on the following rules:\n# - If a connected component contains only one color, keep that color.\n# - If a connected component contains multiple colors, merge them into a new color \n#   (e.g., by averaging their RGB values) and fill the component with this new color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find connected components in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Create an output grid initialized to the background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Process each component\n    for component in components:\n        # Extract the colors in the component\n        unique_colors = object_colors(component, background=Color.BLACK)\n\n        if len(unique_colors) == 1:\n            # If there\u0027s only one color, keep it\n            new_color = unique_colors[0]\n        else:\n            # Merge colors by averaging their RGB values\n            # Here, we will assume colors are represented as integers: 0-9\n            new_color = np.mean([int(color) for color in unique_colors]).astype(int)\n            new_color = Color.NOT_BLACK[new_color % len(Color.NOT_BLACK)]  # Ensuring it stays within the defined colors\n\n        # Fill the output grid with the new color for the entire component\n        output_grid[component == Color.BLACK] = new_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter different colors in the grid\n    num_shapes = np.random.randint(5, 15)\n    for _ in range(num_shapes):\n        # Randomly determine the size of the shape\n        shape_height, shape_width = np.random.randint(1, 5), np.random.randint(1, 5)\n        # Choose a random color for the shape\n        shape_color = np.random.choice(Color.NOT_BLACK)\n        # Find a random free location for the shape\n        try:\n            x, y = random_free_location_for_sprite(grid, np.full((shape_height, shape_width), shape_color), padding=1)\n            blit_sprite(grid, np.full((shape_height, shape_width), shape_color), x, y)\n        except ValueError:\n            continue  # If no location is found, skip this shape\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/160/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/160/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/160/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/160/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/160/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/160/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/160/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/160/images/train_output_2.png"}]}, "index": 160, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, connected components, color transformation\n\n# description:\n# In the input, you will see a grid with a colored object (non-black) surrounded by a background color (black).\n# Your task is to identify the colored object and fill its connected area with a new color (yellow).\n# Additionally, if the object has any attached pixels of a different color, fill those with a different color (blue).\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Determine the background color (it will be black)\n    background_color = Color.BLACK\n\n    # Find the connected components (the colored object)\n    objects = find_connected_components(input_grid, connectivity=4, background=background_color, monochromatic=False)\n\n    # Process each object\n    for obj in objects:\n        # Check if the object is not the background\n        if np.any(obj != background_color):\n            # Determine the color of the current object\n            object_color = object_colors(obj, background=background_color)\n\n            # Fill the object area with yellow\n            x, y = np.where(obj != background_color)\n            flood_fill(output_grid, x[0], y[0], Color.YELLOW)\n\n            # Check for any pixels of a different color attached to the object\n            for color in object_color:\n                if color != Color.YELLOW and color != background_color:\n                    # If it\u0027s not the background and not yellow, fill that area with blue\n                    x_att, y_att = np.where(input_grid == color)\n                    for xi, yi in zip(x_att, y_att):\n                        flood_fill(output_grid, xi, yi, Color.BLUE)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size (10 to 20 cells wide and 10 to 20 cells tall)\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a random colored object (not black)\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=[object_color])\n\n    # Place the sprite randomly in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Randomly attach a few pixels of a different color (not black or the object color)\n    num_attached = np.random.randint(1, 4)  # 1 to 3 different colors\n    for _ in range(num_attached):\n        attached_color = np.random.choice(list(Color.NOT_BLACK), replace=False)\n        while attached_color == object_color:\n            attached_color = np.random.choice(list(Color.NOT_BLACK), replace=False)\n\n        # Randomly place the attached color pixel nearby the object\n        attached_x, attached_y = np.random.randint(x, x + sprite.shape[0]), np.random.randint(y, y + sprite.shape[1])\n        if 0 \u003c= attached_x \u003c width and 0 \u003c= attached_y \u003c height:\n            grid[attached_x, attached_y] = attached_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/161/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/161/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/161/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/161/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/161/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/161/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/161/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/161/images/train_output_2.png"}]}, "index": 161, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, gap filling, spatial relationships\n\n# description:\n# In the input, you will see a grid with two distinct colored patterns separated by a gap of black pixels.\n# Your task is to identify the gap between the two patterns and fill it with a specific color (red).\n# If a pixel is not between the two patterns, it should be turned black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid as output\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect the objects (patterns) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    if len(objects) \u003c 2:\n        return output_grid  # If less than two objects, return empty grid\n\n    # Loop through each pixel in the grid\n    for x, y in np.ndindex(input_grid.shape):\n        # Check if the current pixel is between the two detected objects\n        if check_between_objects(obj1=objects[0], obj2=objects[1], x=x, y=y, padding=0):\n            output_grid[x, y] = Color.RED  # Fill the gap with red\n\n    # Return the transformed grid\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a blank grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose two colors for the patterns\n    available_colors = [color for color in Color.NOT_BLACK]\n    color1, color2 = np.random.choice(available_colors, 2, replace=False)\n\n    # Generate two distinct patterns\n    pattern1 = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[color1], density=0.7)\n    pattern2 = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[color2], density=0.7)\n\n    # Place the first pattern in the grid\n    x1, y1 = random_free_location_for_sprite(grid=grid, sprite=pattern1, background=Color.BLACK)\n    grid = blit_sprite(grid=grid, sprite=pattern1, x=x1, y=y1)\n\n    # Place the second pattern in the grid, ensuring there is a gap\n    while True:\n        x2, y2 = random_free_location_for_sprite(grid=grid, sprite=pattern2, background=Color.BLACK)\n        # Check if there\u0027s enough space to ensure a gap\n        if np.all(grid[x2-1:x2+pattern2.shape[0]+1, y2-1:y2+pattern2.shape[1]+1] == Color.BLACK):\n            break\n\n    grid = blit_sprite(grid=grid, sprite=pattern2, x=x2, y=y2)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/162/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/162/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/162/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/162/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/162/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/162/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/162/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/162/images/train_output_2.png"}]}, "index": 162, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, rotation, color change\n\n# description:\n# In the input you will see a grid with a yellow object.\n# To make the output grid, you should rotate the yellow object 90 degrees clockwise and change its color to pink.\n\ndef main(input_grid):\n    # Step 1: Detect the yellow object in the grid.\n    yellow_objects = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n\n    # There should only be one yellow object detected in the grid.\n    assert len(yellow_objects) == 1\n    yellow_object = yellow_objects[0]\n\n    # Step 2: Change the color of the yellow object to pink.\n    yellow_object[yellow_object != Color.BLACK] = Color.PINK\n\n    # Step 3: Rotate the yellow object 90 degrees clockwise.\n    rotated_object = np.rot90(yellow_object, k=-1)\n\n    # Step 4: Create a blank output grid and blit the rotated object onto it.\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    output_grid = blit_object(output_grid, rotated_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_len = np.random.randint(4, 8)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Randomly generate the yellow object and place it on the grid.\n    object_width, object_height = np.random.randint(1, grid_len - 1), np.random.randint(1, grid_len - 1)\n    yellow_sprite = random_sprite(n=object_width, m=object_height, color_palette=[Color.YELLOW], density=0.5)\n    x, y = random_free_location_for_sprite(grid=grid, sprite=yellow_sprite, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=yellow_sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/163/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/163/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/163/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/163/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/163/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/163/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/163/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/163/images/train_output_2.png"}]}, "index": 163, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color patterns, object positioning, falling downward\n\n# description:\n# In the input, you will see a grid with several colored pixels scattered throughout.\n# To make the output, draw a pattern downward from each colored pixel by coloring the pixels directly below it and creating a zigzag effect. \n# The zigzag should alternate direction each time it descends, creating a visually interesting pattern.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the colored pixels in the input grid.\n    # 2. For each colored pixel, create a zigzag pattern downward in the output grid.\n\n    # Find colored pixels (not black)\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Create an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Define the zigzag pattern offsets\n    zigzag_offsets = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Down, Right, Up, Left\n    direction = 0  # Start with the downward direction\n\n    # Iterate through each colored pixel\n    for pixel in colored_pixels:\n        x, y = pixel\n        pixel_color = input_grid[x, y]\n        \n        # Start creating the zigzag pattern from the pixel downwards\n        for step in range(5):  # Create a pattern that falls 5 steps\n            # Calculate the current position\n            current_x = x + step\n            # Alternate direction every two steps\n            current_y = y + (step % 2) * (1 if direction % 2 == 0 else -1)\n            \n            # Check boundaries\n            if 0 \u003c= current_x \u003c output_grid.shape[0] and 0 \u003c= current_y \u003c output_grid.shape[1]:\n                output_grid[current_x, current_y] = pixel_color\n            \n            # Switch direction after two steps\n            if step % 2 == 1:\n                direction += 1\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose the number of colored pixels\n    num_pixels = np.random.randint(5, 10)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=False)\n\n    # Randomly place colored pixels in the grid\n    for color in colors:\n        # Place colored pixels in random positions\n        for _ in range(np.random.randint(1, 5)):  # Each color can appear 1 to 4 times\n            x, y = np.random.randint(0, width), np.random.randint(0, height)\n            grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/164/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/164/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/164/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/164/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/164/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/164/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/164/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/164/images/train_output_2.png"}]}, "index": 164, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, pattern generation\n\n# description:\n# In the input grid, you will see a single green pixel at a random position.\n# To make the output, you need to create a pattern of red pixels by scaling a small red shape around the green pixel.\n# The shape should be a 2x2 red square that is scaled by a factor of 3. The output should have the green pixel at the center of the scaled shape.\n\ndef main(input_grid):\n    # Find the position of the green pixel\n    green_pixel_position = np.argwhere(input_grid == Color.GREEN)[0]\n    green_x, green_y = green_pixel_position\n\n    # Define the small shape (2x2 red square)\n    small_shape = np.full((2, 2), Color.RED, dtype=int)\n\n    # Scale the small shape by a factor of 3\n    scaled_shape = scale_sprite(small_shape, factor=3)\n\n    # Create an output grid with the same size\n    output_grid = np.zeros_like(input_grid)\n\n    # Calculate the starting position for the scaled shape to center it around the green pixel\n    start_x = green_x - scaled_shape.shape[0] // 2\n    start_y = green_y - scaled_shape.shape[1] // 2\n\n    # Place the scaled shape in the output grid\n    for dx in range(scaled_shape.shape[0]):\n        for dy in range(scaled_shape.shape[1]):\n            output_grid[start_x + dx, start_y + dy] = scaled_shape[dx, dy]\n\n    # Ensure that the green pixel remains in the output grid\n    output_grid[green_x, green_y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly place a green pixel in the grid\n    x, y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    grid[x, y] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/165/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/165/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/165/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/165/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/165/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/165/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/165/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/165/images/train_output_2.png"}]}, "index": 165, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filling, boundary detection\n\n# description:\n# The input consists of a grid with a few hollow blue shapes, like circles or ellipses, surrounded by black pixels. \n# To create the output, fill in the hollow blue shapes with orange. The filling should only occur if the \n# blue shape is completely surrounded by black pixels, meaning it has no neighboring blue pixels directly adjacent to it.\n\ndef main(input_grid):\n    # Step 1: Find connected components with blue color\n    blue_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Create an output grid initialized to the input grid\n    output_grid = input_grid.copy()\n\n    # Step 2: Check each blue object\n    for obj in blue_objects:\n        # Check if the object has neighbors that are blue\n        neighbors = object_neighbors(obj, background=Color.BLACK, connectivity=4)\n\n        # If no neighboring blue pixels, fill the object with orange\n        if not np.any(obj[neighbors]):\n            obj[obj == Color.BLUE] = Color.ORANGE  # Fill with orange\n\n        # Blit the potentially modified object back to the output grid\n        blit_sprite(output_grid, obj, x=0, y=0)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of blue shapes (1-3)\n    num_shapes = np.random.randint(1, 4)\n\n    for _ in range(num_shapes):\n        # Random size for the blue shape (3-5 for width and height)\n        shape_width = np.random.randint(3, 6)\n        shape_height = np.random.randint(3, 6)\n\n        # Create a blue shape\n        shape = np.full((shape_width, shape_height), Color.BLUE)\n\n        # Randomly place the shape on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, border_size=1)\n            blit_sprite(grid, shape, x=x, y=y)\n        except ValueError:\n            continue  # If no space is available, skip adding this shape\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/166/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/166/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/166/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/166/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/166/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/166/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/166/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/166/images/train_output_2.png"}]}, "index": 166, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, pattern recognition, placement\n\n# description:\n# In the input, you will see a grid containing a single colored shape. \n# To make the output, scale the shape by a factor of 2, and place it in two distinct locations on the grid: \n# one at the top-left corner and another at the bottom-right corner of the grid, ensuring that both placements do not overlap.\n\ndef main(input_grid):\n    # Step 1: Extract the original shape from the input grid\n    original_shape = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)[0]\n    \n    # Step 2: Scale the shape by a factor of 2\n    scaled_shape = scale_sprite(original_shape, factor=2)\n    \n    # Step 3: Create an output grid of the same size as the input\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # Step 4: Place the scaled shape at the top-left corner\n    blit_sprite(output_grid, sprite=scaled_shape, x=0, y=0, background=Color.BLACK)\n    \n    # Step 5: Place the scaled shape at the bottom-right corner\n    height, width = input_grid.shape\n    blit_sprite(output_grid, sprite=scaled_shape, x=width - scaled_shape.shape[0], y=height - scaled_shape.shape[1], background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly create a shape within the grid\n    shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a sprite\n    sprite = random_sprite(n=shape_width, m=shape_height, density=1.0, color_palette=[shape_color], background=Color.BLACK)\n\n    # Place the sprite in a random location within the grid\n    padding = 1\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=padding, background=Color.BLACK)\n    blit_sprite(grid, sprite=sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/167/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/167/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/167/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/167/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/167/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/167/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/167/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/167/images/train_output_2.png"}]}, "index": 167, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotational symmetry, color filling\n\n# description:\n# In the input, you will see a pattern made of colored pixels that exhibits some rotational symmetry.\n# However, certain parts of the pattern are missing, and are represented as black pixels.\n# The task is to color the missing parts red to complete the pattern, making it fully rotationally symmetric.\n\ndef main(input_grid):\n    # First, we detect the rotational symmetry of the input grid\n    symmetry = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n\n    # Create a copy of the input grid to fill in the missing pixels\n    output_grid = np.copy(input_grid)\n\n    # Iterate through each pixel in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] == Color.BLACK:  # Only consider black pixels\n                # Apply the symmetry transformation in a clockwise direction\n                rotated_x, rotated_y = symmetry.apply(x, y, iters=1)\n\n                # If the rotated position is not black, it means we have a colored pixel that can\n                # be used to infer what the missing pixel should be\n                if input_grid[rotated_x, rotated_y] != Color.BLACK:\n                    output_grid[x, y] = Color.RED  # Color the missing pixel red\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium-sized black grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a base sprite with some color and rotational symmetry\n    sprite_size = np.random.randint(8, min(n, m))\n    sprite = random_sprite(sprite_size, sprite_size, symmetry=\u0027radial\u0027, color_palette=[Color.BLUE], density=0.5)\n    x, y = random_free_location_for_sprite(grid, sprite)\n\n    # Remove a section of the sprite to create missing parts (black pixels)\n    for _ in range(np.random.randint(1, 4)):  # Randomly remove up to 3 sections\n        remove_length = np.random.randint(1, sprite_size // 4)\n        quadrant = np.random.choice([\u0027north\u0027, \u0027south\u0027, \u0027east\u0027, \u0027west\u0027])\n        if quadrant == \u0027north\u0027:\n            sprite[sprite_size // 2 - remove_length:sprite_size // 2, :sprite_size // 2] = Color.BLACK\n        elif quadrant == \u0027south\u0027:\n            sprite[sprite_size // 2:sprite_size // 2 + remove_length, sprite_size // 2:] = Color.BLACK\n        elif quadrant == \u0027east\u0027:\n            sprite[:sprite_size // 2, sprite_size // 2 - remove_length:sprite_size // 2] = Color.BLACK\n        elif quadrant == \u0027west\u0027:\n            sprite[sprite_size // 2:sprite_size // 2 + remove_length, sprite_size // 2 - remove_length:sprite_size // 2] = Color.BLACK\n\n    # Place the modified sprite onto the grid\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/168/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/168/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/168/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/168/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/168/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/168/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/168/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/168/images/train_output_2.png"}]}, "index": 168, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color transformation, shape manipulation\n\n# description:\n# In the input, you will see several colored shapes on a black background.\n# To make the output, extract each shape and perform the following transformations:\n# - If the shape is circular (defined as having a pixel density close to a circular shape), turn it into blue.\n# - If the shape is triangular (defined as having a pixel density close to a triangle), turn it into red.\n# - If the shape is square or rectangular (defined as having a pixel density close to a rectangle), turn it into green.\n# All other shapes should be made transparent (black).\n\ndef main(input_grid):\n    # Initialize the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Extract shapes from the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    for obj in objects:\n        # Crop the object to analyze its shape\n        cropped_object = crop(obj, background=Color.BLACK)\n\n        # Calculate the area and perimeter to determine the shape type\n        area = np.sum(cropped_object != Color.BLACK)\n        perimeter = np.sum(object_interior(cropped_object, background=Color.BLACK))\n\n        # Calculate circularity, triangularity and rectangularity\n        circularity = (4 * np.pi * area) / (perimeter ** 2) if perimeter \u003e 0 else 0\n        triangularity = (area * 2) / (perimeter)  # simplified triangularity calculation\n        rectangularity = (area ** 2) / (perimeter ** 2) if perimeter \u003e 0 else 0\n\n        # Determine shape type and assign color\n        if circularity \u003e 0.7:\n            color = Color.BLUE\n        elif triangularity \u003e 0.5:\n            color = Color.RED\n        elif rectangularity \u003e 0.5:\n            color = Color.GREEN\n        else:\n            continue  # skip if shape does not fit any category\n\n        # Blit the colored shape onto the output grid\n        output_shape = np.full_like(cropped_object, color)\n        blit_object(output_grid, output_shape)\n\n    return output_grid\n\ndef generate_input():\n    grid = np.full((20, 20), Color.BLACK)\n\n    # Generate random shapes\n    num_shapes = np.random.randint(5, 10)\n    for _ in range(num_shapes):\n        shape_type = np.random.choice([\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n        if shape_type == \u0027circle\u0027:\n            shape = random_sprite(n=np.random.randint(4, 7), m=np.random.randint(4, 7), symmetry=\u0027not_symmetric\u0027, color_palette=[Color.GREEN])\n            # Ensuring spherical density\n            for x in range(shape.shape[0]):\n                for y in range(shape.shape[1]):\n                    if (x - shape.shape[0] // 2) ** 2 + (y - shape.shape[1] // 2) ** 2 \u003c= (shape.shape[0] // 2) ** 2:\n                        shape[x, y] = Color.GREEN\n        elif shape_type == \u0027triangle\u0027:\n            shape = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), symmetry=\u0027not_symmetric\u0027, color_palette=[Color.GREEN])\n            shape[shape.shape[0]-1, :] = Color.GREEN  # Base of the triangle\n        elif shape_type == \u0027rectangle\u0027:\n            shape = random_sprite(n=np.random.randint(2, 4), m=np.random.randint(4, 7), symmetry=\u0027not_symmetric\u0027, color_palette=[Color.GREEN])\n\n        # Try to place the shape in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n            blit_sprite(grid, shape, x=x, y=y)\n        except ValueError:\n            continue  # If no space, skip to next shape\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/169/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/169/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/169/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/169/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/169/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/169/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/169/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/169/images/train_output_2.png"}]}, "index": 169, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color transformation, object positioning\n\n# description:\n# In the input, you will see a grid containing a framed rectangle composed of colored pixels.\n# To create the output, you should change the color of the pixels along the perimeter of the rectangle to red,\n# and fill the inner area of the rectangle with blue.\n\ndef main(input_grid):\n    # 1. Detect the rectangle object in the grid\n    objects = find_connected_components(input_grid, monochromatic=False)\n    assert len(objects) == 1, \"exactly one rectangle expected\"\n    rectangle = objects[0]\n\n    # 2. Get the position of the rectangle to determine its boundaries\n    x_start, y_start = object_position(rectangle, background=Color.BLACK, anchor=\"upper left\")\n    x_end, y_end = object_position(rectangle, background=Color.BLACK, anchor=\"lower right\")\n\n    # 3. Create the output grid, initially with the same background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 4. Change the perimeter to red and fill the inner area with blue\n    # Set the perimeter to red\n    output_grid[x_start, y_start:y_end+1] = Color.RED  # Top edge\n    output_grid[x_end, y_start:y_end+1] = Color.RED    # Bottom edge\n    output_grid[x_start:x_end+1, y_start] = Color.RED  # Left edge\n    output_grid[x_start:x_end+1, y_end] = Color.RED    # Right edge\n\n    # Fill the inner area with blue\n    output_grid[x_start+1:x_end, y_start+1:y_end] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(8, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly determine the position and size of the rectangle\n    x_start = np.random.randint(1, width - 2)\n    y_start = np.random.randint(1, height - 2)\n    \n    rect_width = np.random.randint(2, width - x_start)\n    rect_height = np.random.randint(2, height - y_start)\n\n    # Create a rectangle with random colors around the perimeter\n    for x in range(x_start, x_start + rect_width):\n        grid[x, y_start] = np.random.choice(Color.NOT_BLACK)  # Top edge\n        grid[x, y_start + rect_height - 1] = np.random.choice(Color.NOT_BLACK)  # Bottom edge\n\n    for y in range(y_start, y_start + rect_height):\n        grid[x_start, y] = np.random.choice(Color.NOT_BLACK)  # Left edge\n        grid[x_start + rect_width - 1, y] = np.random.choice(Color.NOT_BLACK)  # Right edge\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/170/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/170/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/170/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/170/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/170/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/170/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/170/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/170/images/train_output_2.png"}]}, "index": 170, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, completion\n\n# description:\n# In the input, you will see a pattern of colors that exhibits some rotational symmetry. However, one section of the pattern is missing. \n# Your task is to identify the missing section and fill it in with the correct color to restore full rotational symmetry to the pattern.\n\ndef main(input_grid):\n    # Copy the input grid to start with\n    output_grid = np.copy(input_grid)\n\n    # Use detect_rotational_symmetry to find the center and the symmetry\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n\n    # Iterate through all non-black pixels in the input grid\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Get the rotated positions\n        rotated_x, rotated_y = sym.apply(x, y, iters=1)\n\n        # If the rotated position is black, color it with the color from the original position\n        if output_grid[rotated_x, rotated_y] == Color.BLACK:\n            output_grid[rotated_x, rotated_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a base pattern with some rotational symmetry\n    base_size = np.random.randint(4, 6)\n    base_pattern = random_sprite(base_size, base_size, density=0.5, symmetry=\u0027radial\u0027, color_palette=Color.NOT_BLACK)\n\n    # Randomly remove a section to create the missing symmetry\n    quadrant = np.random.choice([\u0027north\u0027, \u0027south\u0027, \u0027east\u0027, \u0027west\u0027])\n    remove_length = np.random.randint(1, base_size // 2)\n    if quadrant == \u0027north\u0027:\n        base_pattern[:remove_length, base_size//2:] = Color.BLACK\n    elif quadrant == \u0027south\u0027:\n        base_pattern[base_size-remove_length:, base_size//2:] = Color.BLACK\n    elif quadrant == \u0027east\u0027:\n        base_pattern[base_size//2:, base_size-remove_length:] = Color.BLACK\n    elif quadrant == \u0027west\u0027:\n        base_pattern[base_size//2:, :remove_length] = Color.BLACK\n\n    # Place the base pattern in the grid at a random position\n    x, y = random_free_location_for_sprite(grid, base_pattern)\n    grid = blit_sprite(grid, base_pattern, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/171/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/171/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/171/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/171/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/171/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/171/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/171/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/171/images/train_output_2.png"}]}, "index": 171, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, pattern expansion\n\n# description:\n# In the input, you will see a grid of colored pixels that form a pattern.\n# To make the output, you should expand each colored pixel into a small block of pixels,\n# maintaining the original color of the pixel. Each pixel will expand into a 2x2 block of the same color.\n\ndef main(input_grid):\n    # Create the output grid with the same shape but filled with the background color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all connected components (individual colored pixels)\n    components = find_connected_components(input_grid, monochromatic=True)\n\n    # Expand each component into a 2x2 block\n    for component in components:\n        pixel_x, pixel_y = object_position(component, background=Color.BLACK)\n        pixel_color = object_colors(component)[0]  # Get the color of the pixel\n\n        # Place a 2x2 block of the same color in the output grid\n        for dx in range(2):\n            for dy in range(2):\n                new_x = pixel_x * 2 + dx\n                new_y = pixel_y * 2 + dy\n                if new_x \u003c output_grid.shape[0] and new_y \u003c output_grid.shape[1]:\n                    output_grid[new_x, new_y] = pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    width, height = np.random.randint(5, 10, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colored pixels\n    num_pixels = np.random.randint(1, 5)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=False)\n\n    # Randomly place colored pixels in the grid\n    for color in colors:\n        while True:\n            x = np.random.randint(0, width)\n            y = np.random.randint(0, height)\n            if grid[x, y] == Color.BLACK:  # Ensure the spot is free\n                grid[x, y] = color\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/172/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/172/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/172/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/172/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/172/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/172/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/172/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/172/images/train_output_2.png"}]}, "index": 172, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel expansion, boundary detection, color transformation\n\n# description:\n# In the input, you will see a pattern of colored pixels. \n# To make the output grid, expand the colored pixels outward to fill adjacent pixels, \n# making sure that the expansion does not cross any boundaries formed by black pixels. \n# Finally, change the color of the expanded pixels to a new color.\n\ndef main(input_grid):\n    # 1. Find the connected components of colored pixels\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4)\n\n    # Create an output grid initialized to the background color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. For each object, expand it and change its color\n    for obj in objects:\n        # Get the position of the object\n        obj_x, obj_y = object_position(obj, background=Color.BLACK)\n\n        # Get the color of the object\n        original_color = object_colors(obj, background=Color.BLACK)[0]\n\n        # Define the new color for the expansion\n        new_color = Color.GREEN if original_color != Color.GREEN else Color.BLUE\n\n        # 3. Expand the object outward\n        height, width = input_grid.shape\n        for x, y in np.argwhere(obj != Color.BLACK):\n            # Expand to adjacent cells (up, down, left, right)\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 \u003c= nx \u003c height and 0 \u003c= ny \u003c width:\n                    # Only expand if the adjacent pixel is black\n                    if output_grid[nx, ny] == Color.BLACK:\n                        output_grid[nx, ny] = new_color\n\n        # Don\u0027t forget to color the original pixels as well\n        output_grid[obj_x:obj_x + obj.shape[0], obj_y:obj_y + obj.shape[1]] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with some colored pixels\n    height, width = np.random.randint(5, 15, size=2)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly choose a color for the pattern\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly determine the size and position of the pattern\n    pattern_height = np.random.randint(1, 4)\n    pattern_width = np.random.randint(1, 4)\n    \n    # Random position ensuring the pattern fits within the grid\n    start_x = np.random.randint(0, height - pattern_height + 1)\n    start_y = np.random.randint(0, width - pattern_width + 1)\n\n    # Fill the pattern area with the chosen color\n    for x in range(start_x, start_x + pattern_height):\n        for y in range(start_y, start_y + pattern_width):\n            grid[x, y] = pattern_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/173/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/173/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/173/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/173/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/173/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/173/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/173/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/173/images/train_output_2.png"}]}, "index": 173, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, symmetry, color extraction\n\n# description:\n# In the input, you will see a grid with a single colored pixel and a black background. \n# To make the output, mirror the colored pixel across the center of the grid, then change the color of the mirrored pixel to the same color as the original pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the colored pixel\u0027s position and color from the input grid.\n    # 2. Calculate the center of the grid.\n    # 3. Mirror the pixel\u0027s position across the center.\n    # 4. Place the mirrored pixel in the output grid with the same color as the original pixel.\n\n    # 1. Extract the pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # 2. Calculate the center of the grid\n    center_x = input_grid.shape[0] // 2\n    center_y = input_grid.shape[1] // 2\n\n    # 3. Mirror the pixel\u0027s position\n    mirrored_x = center_x - (pixel_x - center_x)\n    mirrored_y = center_y - (pixel_y - center_y)\n\n    # 4. Create the output grid and place the mirrored pixel\n    output_grid = np.zeros_like(input_grid)\n    output_grid[mirrored_x, mirrored_y] = pixel_color\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m with a single colored pixel\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly choose one color\n    color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Randomly place the pixel on the grid\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/174/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/174/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/174/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/174/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/174/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/174/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/174/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/174/images/train_output_2.png"}]}, "index": 174, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color change\n\n# description:\n# In the input, you will see a grid filled with several blue shapes. Some shapes are triangles while others are circles. \n# To create the output, change the color of all triangle shapes to yellow and all circle shapes to red.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Define colors for shapes\n    triangle_color = Color.BLUE\n    circle_color = Color.BLUE\n    new_triangle_color = Color.YELLOW\n    new_circle_color = Color.RED\n    background = Color.BLACK\n\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8, background=background)\n    \n    for obj in objects:\n        # Check if the shape is a triangle or a circle based on its bounding box dimensions\n        x, y, w, h = bounding_box(obj, background=background)\n\n        # Check if the shape is close to an equilateral triangle shape\n        if w == h and np.count_nonzero(obj == triangle_color) \u003e 0:\n            # Change the color of triangle shapes\n            obj[obj == triangle_color] = new_triangle_color\n            blit_object(output_grid, obj, background=background)\n        elif w == h:  # If width and height are equal, it could also be a circle\n            # Change the color of circle shapes\n            obj[obj == circle_color] = new_circle_color\n            blit_object(output_grid, obj, background=background)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of a random size\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly draw triangles and circles in the grid\n    object_color = Color.BLUE\n    \n    for _ in range(np.random.randint(3, 6)):\n        shape_type = np.random.choice([\u0027triangle\u0027, \u0027circle\u0027])\n        \n        # Generate triangle\n        if shape_type == \u0027triangle\u0027:\n            size = np.random.randint(3, 6)\n            triangle = np.full((size, size), object_color)\n            for i in range(size):\n                for j in range(i + 1, size):\n                    triangle[i, j] = Color.BLACK  # Create a right triangle\n            x, y = random_free_location_for_sprite(grid, triangle, background=Color.BLACK)\n            blit_sprite(grid, triangle, x, y)\n\n        # Generate circle\n        elif shape_type == \u0027circle\u0027:\n            size = np.random.randint(3, 6)\n            circle = np.full((size, size), object_color)\n            y, x = np.ogrid[-size//2:size//2, -size//2:size//2]\n            mask = x**2 + y**2 \u003c= (size//2)**2\n            circle[~mask] = Color.BLACK  # Create a circle\n            x, y = random_free_location_for_sprite(grid, circle, background=Color.BLACK)\n            blit_sprite(grid, circle, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/175/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/175/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/175/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/175/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/175/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/175/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/175/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/175/images/train_output_2.png"}]}, "index": 175, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel connection, gap filling\n\n# description:\n# In the input, you will see two distinct shapes (colored pixels) separated by a gap of black pixels.\n# To make the output, connect the two shapes with a yellow line that fills the gap between them.\n# The line should only be drawn in the row or column where the gap exists.\n\ndef main(input_grid):\n    # Copy the input grid as output\n    output_grid = input_grid.copy()\n\n    # Find connected components\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    if len(objects) \u003c 2:\n        return output_grid  # If less than two objects, return the input grid\n\n    # Get the positions of the first and second objects\n    obj1 = objects[0]\n    obj2 = objects[1]\n\n    # Get their positions\n    x1, y1 = object_position(obj1)\n    x2, y2 = object_position(obj2)\n\n    # Attempt to connect the objects by filling the gap\n    gap_found = False\n\n    # Check for a vertical connection possibility\n    if y1 == y2:\n        # Fill the gap vertically\n        for x in range(min(x1, x2) + 1, max(x1, x2)):\n            if output_grid[x, y1] == Color.BLACK:  # Ensure only filling black pixels\n                output_grid[x, y1] = Color.YELLOW\n                gap_found = True\n\n    # If no vertical connection was made, check for horizontal\n    if not gap_found and x1 == x2:\n        # Fill the gap horizontally\n        for y in range(min(y1, y2) + 1, max(y1, y2)):\n            if output_grid[x1, y] == Color.BLACK:  # Ensure only filling black pixels\n                output_grid[x1, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the shapes\n    colors = np.random.choice([color for color in Color.NOT_BLACK], 2, replace=False)\n    color1, color2 = colors\n\n    # Create two small rectangles representing the shapes\n    rectangle1 = np.full((2, 3), color1)\n    rectangle2 = np.full((2, 3), color2)\n\n    # Place the rectangles on the grid with a gap in between\n    x1, y1 = np.random.randint(0, n - 2), np.random.randint(0, m - 4)\n    blit_sprite(grid, rectangle1, x1, y1, Color.BLACK)\n\n    # Ensure there\u0027s a gap and place the second rectangle\n    x2, y2 = x1 + 3, y1  # Place it to the right with a gap\n    while y2 + 3 \u003e= m or np.any(grid[x2:x2 + 2, y1:y1 + 3] != Color.BLACK):\n        x2, y2 = np.random.randint(0, n - 2), np.random.randint(0, m - 4)\n\n    blit_sprite(grid, rectangle2, x2, y2, Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/176/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/176/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/176/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/176/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/176/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/176/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/176/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/176/images/train_output_2.png"}]}, "index": 176, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# expansion, bounding box\n\n# description:\n# In the input, you will see a grid with a single colored pixel surrounded by a black background.\n# To make the output, first, determine the bounding box of the colored pixel, then expand this bounding box by a factor of 2.\n# All pixels within the expanded bounding box should be filled with the same color as the original pixel.\n# Finally, draw a blue border around the expanded area.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find the bounding box of the non-black pixels (the colored pixel)\n    x, y, width, height = bounding_box(input_grid)\n\n    # Expand the bounding box by a factor of 2\n    expanded_x_start = max(0, x - 1)\n    expanded_y_start = max(0, y - 1)\n    expanded_x_end = min(output_grid.shape[0], x + width + 1)\n    expanded_y_end = min(output_grid.shape[1], y + height + 1)\n\n    # Fill the expanded bounding box with the original color\n    original_color = input_grid[x, y]\n    output_grid[expanded_x_start:expanded_x_end, expanded_y_start:expanded_y_end] = original_color\n\n    # Draw a blue border around the expanded area\n    # Top border\n    output_grid[expanded_x_start:expanded_x_end, expanded_y_start] = Color.BLUE\n    # Bottom border\n    output_grid[expanded_x_start:expanded_x_end, expanded_y_end - 1] = Color.BLUE\n    # Left border\n    output_grid[expanded_x_start, expanded_y_start:expanded_y_end] = Color.BLUE\n    # Right border\n    output_grid[expanded_x_end - 1, expanded_y_start:expanded_y_end] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a 5x5 black grid for the background\n    n = m = 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a color for the pixel\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly place the pixel in the grid\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/177/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/177/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/177/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/177/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/177/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/177/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/177/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/177/images/train_output_2.png"}]}, "index": 177, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, object detection, contact detection\n\n# description:\n# In the input you will see a grid with several colored regions and some black pixels scattered around.\n# The regions are filled with various colors, and your task is to replace each colored region with a new color based on the following rules:\n# - If the region touches a black pixel, change the color of that region to yellow.\n# - If the region does not touch any black pixels, change the color of that region to gray.\n# Your output grid should reflect these transformations.\n\ndef main(input_grid):\n    # Get the background color (black)\n    background = Color.BLACK\n    \n    # Find all colored regions in the input grid\n    colored_regions = find_connected_components(grid=input_grid, background=background)\n    \n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, background)\n\n    # Iterate over each colored region to apply the transformation rules\n    for region in colored_regions:\n        # Check if the region touches any black pixels\n        region_x, region_y = object_position(region, background=background, anchor=\"upper left\")\n        \n        # Check surrounding pixels to see if there\u0027s a black pixel in contact\n        touches_black = False\n        for x_offset in [-1, 0, 1]:\n            for y_offset in [-1, 0, 1]:\n                if (x_offset != 0 or y_offset != 0):  # skip the center pixel\n                    if contact(object1=region, object2=np.full((1, 1), background), x1=region_x, y1=region_y, x2=region_x + x_offset, y2=region_y + y_offset):\n                        touches_black = True\n                        break\n            if touches_black:\n                break\n        \n        # Determine the new color based on whether it touches black\n        new_color = Color.YELLOW if touches_black else Color.GRAY\n        \n        # Fill the output grid with the new color for this region\n        output_grid[region != background] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly generate several colored regions\n    num_regions = np.random.randint(3, 6)\n    for _ in range(num_regions):\n        # Create a random sprite with a color\n        color = np.random.choice(Color.NOT_BLACK)\n        sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=[color])\n\n        # Randomly place the sprite into the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n\n    # Add some black pixels scattered around\n    for _ in range(np.random.randint(2, 6)):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = Color.BLACK\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/178/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/178/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/178/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/178/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/178/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/178/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/178/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/178/images/train_output_2.png"}]}, "index": 178, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color blending, merging regions\n\n# description:\n# In the input you will see a grid filled with colored regions. The grid has some larger colored regions and several smaller colored regions scattered throughout.\n# To make the output, you should scale down the larger colored regions by a factor of 2 and blend them with the smaller regions. \n# The output should reflect the colors from both the larger scaled regions and the smaller regions, with the smaller regions being more prominent.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the larger colored regions\n    # 2. Scale these regions down by a factor of 2\n    # 3. Blend the scaled regions with the smaller regions in the input grid\n    # 4. Generate the output grid containing the blended colors\n\n    # Step 1: Detect and find the larger colored regions\n    large_regions = find_connected_components(grid=input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Initialize the output grid with the same shape as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Step 2: Scale down the larger regions\n    for region in large_regions:\n        # Scale the region if it is larger than a certain threshold (e.g., 4 pixels)\n        if np.sum(region != Color.BLACK) \u003e 4:\n            scaled_region = scale_sprite(crop(region, background=Color.BLACK), factor=2)\n\n            # Find a position to place the scaled region (upper left corner)\n            x, y = object_position(region, background=Color.BLACK)\n            output_grid[x // 2: (x // 2) + scaled_region.shape[0], y // 2: (y // 2) + scaled_region.shape[1]] = scaled_region\n    \n    # Step 3: Blend the output grid with the smaller regions\n    small_regions = find_connected_components(grid=input_grid, background=Color.BLACK, monochromatic=False)\n    for small_region in small_regions:\n        # Find the position of the small region\n        x, y = object_position(small_region, background=Color.BLACK)\n        small_region_colors = crop(small_region, background=Color.BLACK)\n\n        # Blend colors into the output grid\n        for i in range(small_region_colors.shape[0]):\n            for j in range(small_region_colors.shape[1]):\n                if small_region_colors[i, j] != Color.BLACK:\n                    output_grid[x + i, y + j] = small_region_colors[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random larger regions and smaller regions\n    grid_size = 20\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n    \n    # Create larger colored regions\n    for _ in range(np.random.randint(2, 5)):\n        color = np.random.choice(Color.NOT_BLACK)\n        x, y = np.random.randint(0, grid_size - 5), np.random.randint(0, grid_size - 5)\n        w, h = np.random.randint(5, 10), np.random.randint(5, 10)\n        grid[x:x + w, y:y + h] = color\n\n    # Create small scattered regions\n    for _ in range(np.random.randint(5, 10)):\n        color = np.random.choice(Color.NOT_BLACK)\n        x, y = np.random.randint(0, grid_size), np.random.randint(0, grid_size)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/179/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/179/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/179/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/179/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/179/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/179/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/179/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/179/images/train_output_2.png"}]}, "index": 179, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alignment, object positioning, color blending\n\n# description:\n# In the input, you will see two colored pixels aligned vertically or horizontally. \n# To create the output, draw a rectangle between the two pixels. \n# The rectangle should be 3 units wide and 5 units tall, with the left half filled with the color of the top or left pixel, and the right half filled with the color of the bottom or right pixel. \n# The rectangle should be centered between the two pixels.\n\ndef main(input_grid):\n    # 1. Find the two colored pixels in the grid.\n    pixels = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # 2. Determine if the pixels are aligned vertically or horizontally.\n    was_originally_horizontal = object_position(pixels[0])[1] == object_position(pixels[1])[1]\n\n    # 3. Sort the pixels to identify which one is \"top\" or \"left\" and which one is \"bottom\" or \"right\".\n    if was_originally_horizontal:\n        top_pixel, bottom_pixel = sorted(pixels, key=lambda x: object_position(x)[0])\n    else:\n        top_pixel, bottom_pixel = sorted(pixels, key=lambda x: object_position(x)[1])\n\n    # 4. Extract colors and positions\n    top_color = object_colors(top_pixel)[0]\n    bottom_color = object_colors(bottom_pixel)[0]\n    top_pos = object_position(top_pixel)\n    bottom_pos = object_position(bottom_pixel)\n\n    # 5. Calculate the position to draw the rectangle\n    rectangle_width, rectangle_height = 3, 5\n    center_x = (top_pos[0] + bottom_pos[0]) // 2\n    center_y = (top_pos[1] + bottom_pos[1]) // 2\n\n    # 6. Create the rectangle sprite\n    rectangle_sprite = np.full((rectangle_height, rectangle_width), Color.BLACK)\n    # Fill left half with top_color and right half with bottom_color\n    for i in range(rectangle_height):\n        for j in range(rectangle_width):\n            if j \u003c rectangle_width // 2:\n                rectangle_sprite[i, j] = top_color\n            else:\n                rectangle_sprite[i, j] = bottom_color\n\n    # 7. Place the rectangle in the grid, centered between the two pixels\n    blit_sprite(input_grid, rectangle_sprite, center_x - rectangle_width // 2, center_y - rectangle_height // 2)\n\n    return input_grid\n\ndef generate_input():\n    # Generate a random background grid\n    width, height = random.randint(10, 15), random.randint(10, 15)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Get the color of two pixels\n    colors = np.random.choice(Color.NOT_BLACK, 2, replace=False)\n    color1, color2 = colors\n\n    # Place the two pixels on the grid\n    x1 = np.random.randint(0, width)\n    y1 = np.random.randint(0, height)\n\n    # Ensure the second pixel is aligned with the first\n    is_vertical = random.choice([True, False])\n    if is_vertical:\n        x2 = x1\n        y2 = np.random.randint(0, height)\n    else:\n        x2 = np.random.randint(0, width)\n        y2 = y1\n\n    grid[x1, y1] = color1\n    grid[x2, y2] = color2\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/180/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/180/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/180/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/180/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/180/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/180/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/180/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/180/images/train_output_2.png"}]}, "index": 180, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, object boundary\n\n# description:\n# In the input grid, there are regions of color that are enclosed by red pixels on a black background. \n# To produce the output, you need to find the boundaries of these red regions, then color the interior regions blue. \n# The boundaries themselves should remain red.\n\ndef main(input_grid):\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = input_grid.copy()\n    \n    # Identify the boundary of the red regions\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Color the interior of the red regions blue\n    # First, find connected components of the red regions\n    red_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True, connectivity=8)\n\n    for red_region in red_objects:\n        # Get the boundary points of the red region\n        red_boundary = object_boundary(red_region, background=Color.BLACK)\n\n        # Fill the interior of the red region with blue\n        for x, y in np.argwhere(red_region != Color.BLACK):\n            if not red_boundary[x, y]:  # Check if it\u0027s not on the boundary\n                output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size between 10x10 to 20x20\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly generate red regions with enclosed interiors\n    n_objects = np.random.randint(1, 4)  # Number of red regions\n    for _ in range(n_objects):\n        # Create a red sprite and ensure it has an enclosed area\n        sprite_width, sprite_height = np.random.randint(3, 8), np.random.randint(3, 8)\n        sprite = np.full((sprite_width, sprite_height), Color.RED)\n\n        # Create a hole in the interior\n        hole_radius = np.random.randint(1, min(sprite_width, sprite_height) // 2)\n        for i in range(1, hole_radius + 1):\n            sprite[i, i] = Color.BLACK\n            sprite[i, sprite_height - i - 1] = Color.BLACK\n            sprite[sprite_width - i - 1, i] = Color.BLACK\n            sprite[sprite_width - i - 1, sprite_height - i - 1] = Color.BLACK\n\n        # Place the red sprite randomly in the grid\n        x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/181/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/181/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/181/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/181/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/181/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/181/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/181/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/181/images/train_output_2.png"}]}, "index": 181, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, occlusion, restoration\n\n# description:\n# In the input, you will see a symmetric monochromatic object partially occluded by a colored rectangle. \n# To make the output, remove the colored rectangle and fill in the missing parts of the object to restore its symmetry.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect and separate the occluding rectangle from the symmetric object\n    # 2. Remove the occluding rectangle from the input grid\n    # 3. Identify the mirror symmetries of the remaining object\n    # 4. Use the detected symmetries to restore the missing parts of the object\n\n    background_color = Color.BLACK\n\n    # Step 1: Extract objects in the grid\n    objects = detect_objects(input_grid, monochromatic=True, connectivity=8, background=background_color)\n    sprites = [crop(obj, background=Color.BLACK) for obj in objects]\n\n    # Step 2: Identify the occluding rectangle and the symmetric object\n    rectangle = None\n    for obj, sprite in zip(objects, sprites):\n        # The occluding rectangle will be a filled shape, so we check its area\n        if sprite.shape[0] * sprite.shape[1] == np.sum(sprite != Color.BLACK):\n            rectangle = obj\n            break\n    \n    # Step 3: Remove the occluding rectangle from the input grid\n    output_grid = input_grid.copy()\n    output_grid[rectangle != Color.BLACK] = Color.BLACK\n\n    # Step 4: Detect mirror symmetries after removing the rectangle\n    mirrors = detect_mirror_symmetry(output_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n\n    # Restore the symmetric object by mirroring\n    for x, y in np.argwhere(output_grid != Color.BLACK):\n        for mirror in mirrors:\n            source_color = output_grid[x, y]\n            destination = mirror.apply(x, y)\n            output_grid[destination] = source_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    object_color, rectangle_color = random.sample(list(Color.NOT_BLACK), 2)\n\n    # Create a random sprite that is symmetric\n    sprite = random_sprite(np.random.randint(5, n-2), np.random.randint(5, m-2), density=0.5, symmetry=\"horizontal\", color_palette=[object_color])\n    \n    # Create a rectangle that will occlude part of the sprite\n    rectangle = np.full((np.random.randint(2, 5), np.random.randint(2, 5)), rectangle_color)\n\n    # Place the sprite in the grid\n    sprite_x, sprite_y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=sprite_x, y=sprite_y)\n\n    # Randomly place the rectangle such that it overlaps with the sprite\n    while True:\n        rectangle_x, rectangle_y = np.random.randint(0, n-rectangle.shape[0]), np.random.randint(0, m-rectangle.shape[1])\n        if collision(object1=grid, object2=rectangle, x2=rectangle_x, y2=rectangle_y, background=Color.BLACK):\n            break\n    blit_sprite(grid, rectangle, x=rectangle_x, y=rectangle_y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/182/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/182/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/182/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/182/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/182/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/182/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/182/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/182/images/train_output_2.png"}]}, "index": 182, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, bounding box, filling, color transformation\n\n# description:\n# In the input, you will see various colored circles (1x1 pixels) scattered throughout the grid.\n# To make the output, for each circle, you will create a square bounding box around it and fill that bounding box with a new color (green).\n# The size of the bounding box will be determined by the distance to the nearest black pixel in all directions (up, down, left, right).\n# If a circle is adjacent to a black pixel, the bounding box will only be 1 pixel wide in that direction.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    # Find all non-background (black) pixels\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Determine the bounding box around each colored pixel\n        bounding_x, bounding_y, bounding_width, bounding_height = bounding_box(input_grid)\n\n        # Fill the bounding box with green\n        output_grid[bounding_x:bounding_x + bounding_width, bounding_y:bounding_y + bounding_height] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place circles (colored pixels) in the grid\n    num_circles = np.random.randint(5, 15)\n    for _ in range(num_circles):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color != Color.BLACK])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/183/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/183/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/183/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/183/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/183/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/183/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/183/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/183/images/train_output_2.png"}]}, "index": 183, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filling, connected components, pixel manipulation\n\n# description:\n# In the input, you will see a grid containing a colored shape in the center and a single pixel in the top left corner.\n# To make the output, remove the pixel from the top left corner and fill the entire shape with the color from that pixel.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the pixel in the top left corner\n    fill_color = output_grid[0, 0]\n\n    # Remove the pixel from the top left corner\n    output_grid[0, 0] = Color.BLACK\n\n    # Find the connected component in the middle and fill it with the new color\n    objects = find_connected_components(output_grid, background=Color.BLACK, connectivity=8)\n    \n    # There should be exactly one object in the middle\n    assert len(objects) == 1, \"Exactly one colored shape expected in the grid.\"\n    \n    # Extract the first object\n    obj = objects[0]\n\n    # Get the position of the object to fill it\n    x, y = object_position(obj)\n    \n    # Use flood_fill to fill the connected component with the fill color\n    flood_fill(output_grid, x, y, fill_color, connectivity=8)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 7x7 black grid as the background\n    n, m = 7, 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the shape in the center\n    shape_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random shape (connected component)\n    shape = np.random.choice([shape_color, Color.BLACK], size=(5, 5), p=[0.6, 0.4])\n    \n    # Ensure the shape has at least one colored pixel\n    while np.all(shape == Color.BLACK):\n        shape = np.random.choice([shape_color, Color.BLACK], size=(5, 5), p=[0.6, 0.4])\n\n    # Place the shape in the center of the grid\n    start_x = (n - shape.shape[0]) // 2\n    start_y = (m - shape.shape[1]) // 2\n    blit_sprite(grid, shape, x=start_x, y=start_y, background=Color.BLACK)\n\n    # Add a single pixel in the top left corner\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n    grid[0, 0] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/184/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/184/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/184/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/184/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/184/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/184/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/184/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/184/images/train_output_2.png"}]}, "index": 184, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color inversion, connected components\n\n# description:\n# In the input, you will see a grid with various colored pixels. \n# To make the output, you should reflect the grid vertically, and then invert the colors:\n# - red -\u003e blue\n# - blue -\u003e red\n# - green -\u003e yellow\n# - yellow -\u003e green\n# - gray -\u003e pink\n# - pink -\u003e gray\n# - orange -\u003e teal\n# - teal -\u003e orange\n# - maroon -\u003e maroon\n# - maroon -\u003e maroon\n# Any black pixels remain unchanged.\n\ndef main(input_grid):\n    # 1. Reflect the grid vertically\n    reflected_grid = np.flip(input_grid, axis=1)\n\n    # 2. Create an output grid and invert the colors\n    output_grid = np.full_like(input_grid, Color.BLACK)  # Start with a black background\n\n    # Define the color mapping for inversion\n    color_mapping = {\n        Color.RED: Color.BLUE,\n        Color.BLUE: Color.RED,\n        Color.GREEN: Color.YELLOW,\n        Color.YELLOW: Color.GREEN,\n        Color.GREY: Color.PINK,\n        Color.PINK: Color.GREY,\n        Color.ORANGE: Color.TEAL,\n        Color.TEAL: Color.ORANGE,\n        Color.MAROON: Color.MAROON,\n        Color.MAROON: Color.MAROON,\n    }\n\n    # Invert colors in the reflected grid\n    for color in Color.ALL_COLORS:\n        if color in color_mapping:\n            output_grid[reflected_grid == color] = color_mapping[color]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid filled with colors except black\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Populate the grid with random colors\n    num_pixels = np.random.randint(20, 50)  # Randomly choose number of colored pixels\n    colors = np.random.choice(Color.NOT_BLACK, num_pixels, replace=True)\n\n    for color in colors:\n        # Randomly place each color in the grid\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/185/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/185/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/185/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/185/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/185/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/185/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/185/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/185/images/train_output_2.png"}]}, "index": 185, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotational symmetry, filling holes\n\n# description:\n# In the input you will see a grid with some colored pixels that form an object with holes.\n# The goal is to detect if the object has rotational symmetry, and if it does, identify the holes that need to be filled.\n# For every hole that can be filled to make the object fully symmetric, color those pixels red.\n\ndef main(input_grid):\n    # Use the function to detect rotational symmetry\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # If symmetry is detected, we will fill in the holes\n    if sym:\n        # Get the dimensions of the grid\n        rows, cols = input_grid.shape\n        \n        # Iterate over the grid to find all black (hole) pixels\n        for x in range(rows):\n            for y in range(cols):\n                if input_grid[x, y] == Color.BLACK:  # This is a hole\n                    # Find the rotated position of this hole\n                    rotated_x, rotated_y = sym.apply(x, y, iters=1)\n\n                    # Check if the rotated position is a colored pixel, if so, we fill the hole\n                    if input_grid[rotated_x, rotated_y] != Color.BLACK:\n                        output_grid[x, y] = Color.RED  # Fill the hole with red\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size n x m filled with black (background color)\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create an object with colored pixels that has rotational symmetry\n    base_sprite_size = np.random.randint(4, 8)\n    sprite = random_sprite(base_sprite_size, base_sprite_size, color_palette=[Color.BLUE], symmetry=\u0027radial\u0027, density=0.5)\n\n    # Randomly remove some pixels to create holes in the object\n    num_holes = np.random.randint(1, 6)\n    for _ in range(num_holes):\n        hole_x = np.random.randint(0, base_sprite_size)\n        hole_y = np.random.randint(0, base_sprite_size)\n        sprite[hole_x, hole_y] = Color.BLACK  # Create a hole\n\n    # Place the sprite randomly on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/186/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/186/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/186/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/186/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/186/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/186/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/186/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/186/images/train_output_2.png"}]}, "index": 186, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape merging, filling\n\n# description:\n# In the input, you will see a grid with various colored shapes (rectangles and circles) made of grey pixels. \n# Each shape has at least one red pixel on its border. To create the output, merge the shapes that are touching (i.e., share at least one pixel) into a single shape \n# and fill the merged shapes with yellow. The red pixels should remain in place as indicators of the original shapes.\n\ndef main(input_grid):\n    # Initialize the output grid with grey as the background\n    output_grid = np.full(input_grid.shape, Color.GREY)\n\n    # Find connected components (shapes) in the input grid\n    objects = find_connected_components(input_grid, background=Color.GREY, connectivity=4, monochromatic=False)\n\n    # Process each shape\n    for obj in objects:\n        # Check if the object contains any red pixels\n        if np.any(obj == Color.RED):\n            # Fill the object with yellow\n            obj[obj != Color.RED] = Color.YELLOW\n            \n            # Blit the filled shape onto the output grid\n            blit_object(output_grid, obj, background=Color.GREY)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size filled with black\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Add a random number of grey shapes (rectangles and circles)\n    num_shapes = np.random.randint(2, 6)\n    for _ in range(num_shapes):\n        shape_type = np.random.choice([\u0027rectangle\u0027, \u0027circle\u0027])\n\n        if shape_type == \u0027rectangle\u0027:\n            width, height = np.random.randint(3, 6), np.random.randint(3, 6)\n            rectangle = np.full((height, width), Color.GREY)\n            # Randomly placing the red pixel on the border\n            red_position = np.random.choice([\u0027top\u0027, \u0027bottom\u0027, \u0027left\u0027, \u0027right\u0027])\n            if red_position == \u0027top\u0027:\n                rectangle[0, np.random.randint(0, width)] = Color.RED\n            elif red_position == \u0027bottom\u0027:\n                rectangle[-1, np.random.randint(0, width)] = Color.RED\n            elif red_position == \u0027left\u0027:\n                rectangle[np.random.randint(0, height), 0] = Color.RED\n            elif red_position == \u0027right\u0027:\n                rectangle[np.random.randint(0, height), -1] = Color.RED\n        \n            try:\n                x, y = random_free_location_for_sprite(grid, rectangle)\n            except ValueError:\n                continue\n            blit_sprite(grid, rectangle, x, y)\n\n        elif shape_type == \u0027circle\u0027:\n            radius = np.random.randint(2, 5)\n            diameter = radius * 2 + 1\n            circle = np.full((diameter, diameter), Color.GREY)\n            y, x = np.ogrid[-radius: radius + 1, -radius: radius + 1]\n            mask = x**2 + y**2 \u003c= radius**2\n            circle[mask] = Color.GREY\n            \n            # Randomly placing the red pixel on the border\n            edge_position = np.random.choice([\u0027top\u0027, \u0027bottom\u0027, \u0027left\u0027, \u0027right\u0027])\n            if edge_position == \u0027top\u0027:\n                circle[0, np.random.randint(0, diameter)] = Color.RED\n            elif edge_position == \u0027bottom\u0027:\n                circle[-1, np.random.randint(0, diameter)] = Color.RED\n            elif edge_position == \u0027left\u0027:\n                circle[np.random.randint(0, diameter), 0] = Color.RED\n            elif edge_position == \u0027right\u0027:\n                circle[np.random.randint(0, diameter), -1] = Color.RED\n            \n            try:\n                x, y = random_free_location_for_sprite(grid, circle)\n            except ValueError:\n                continue\n            blit_sprite(grid, circle, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/187/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/187/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/187/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/187/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/187/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/187/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/187/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/187/images/train_output_2.png"}]}, "index": 187, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, filling, coloring\n\n# description:\n# In the input grid, you will see various blue shapes. Some shapes are \"hollow\" and contain fully-enclosed regions, while others are solid. \n# To create the output grid, copy the input grid, then change the color of all \"hollow\" shapes to yellow, and fill their enclosed regions with red.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = input_grid.copy()\n    \n    # Find all the blue objects in the grid\n    object_color = Color.BLUE\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    \n    for obj in objects:\n        # Check if the object is hollow by using the interior function\n        if is_hollow(obj):\n            # Change the color of the shape to yellow\n            obj[obj != Color.BLACK] = Color.YELLOW\n            \n            # Fill the enclosed region with red\n            interior_mask = object_interior(obj)\n            output_grid[interior_mask] = Color.RED\n        \n        # Copy the modified or unmodified object back to the output grid\n        blit_sprite(output_grid, obj, x=0, y=0)\n    \n    return output_grid\n\ndef is_hollow(object):\n    # Check if the object contains a fully enclosed region\n    interior_mask = object_interior(object)\n    object_mask = object != Color.BLACK\n    hollow_mask = interior_mask \u0026 ~object_mask\n    return np.any(hollow_mask)\n\ndef generate_input():\n    n = np.random.randint(10, 28)\n    input_grid = np.full((n, n), Color.BLACK)\n    \n    # Create random blue shapes, ensuring we have a mix of hollow and solid shapes\n    def random_hollow_object():\n        n, m = np.random.randint(3, 7), np.random.randint(3, 7)\n        obj = np.full((n, m), Color.BLUE)\n        obj[1:n-1, 1:m-1] = Color.BLACK  # Create a hollow object\n        return obj\n\n    def random_solid_object():\n        size = np.random.randint(3, 6)\n        obj = np.full((size, size), Color.BLUE)  # Solid object\n        return obj\n\n    try:\n        # Ensure at least one hollow and one solid object\n        obj = random_hollow_object()\n        x, y = random_free_location_for_sprite(input_grid, obj)\n        blit_sprite(input_grid, obj, x=x, y=y)\n\n        obj = random_solid_object()\n        x, y = random_free_location_for_sprite(input_grid, obj)\n        blit_sprite(input_grid, obj, x=x, y=y)\n    except ValueError:\n        return generate_input()  # Retry if no space is found\n\n    # Fill the grid with random objects until somewhat full\n    while True:\n        obj = random_hollow_object() if np.random.rand() \u003c 0.5 else random_solid_object()\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            return input_grid  # Return filled input grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/188/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/188/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/188/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/188/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/188/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/188/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/188/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/188/images/train_output_2.png"}]}, "index": 188, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, bounding boxes, horizontal patterns\n\n# description:\n# In the input you will see a grid with multiple rows of colored pixels, \n# where each row contains different colored pixels and a black background below. \n# The output will contain the same rows of colors, but each color should be transformed \n# into a new color based on a specific mapping. \n# Additionally, where there are colors in the bounding box of the colored pixels, \n# change those colors according to the mapping. The colors outside of that bounding box remain unchanged.\n\ndef main(input_grid):\n    # Define the color transformation mapping\n    color_mapping = {\n        Color.RED: Color.GREEN,\n        Color.BLUE: Color.YELLOW,\n        Color.GREEN: Color.RED,\n        Color.YELLOW: Color.BLUE,\n        Color.PINK: Color.MAROON,\n        Color.MAROON: Color.PINK,\n        Color.ORANGE: Color.GREY,\n        Color.GREY: Color.ORANGE,\n        Color.TEAL: Color.BLACK,\n        Color.BLACK: Color.TEAL\n    }\n\n    # Create output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Copy the input grid into the output grid\n    output_grid[:] = input_grid\n\n    # Find bounding box of colored pixels\n    mask = bounding_box_mask(input_grid, background=Color.BLACK)\n    bounding_box_coords = np.argwhere(mask)\n\n    if bounding_box_coords.size \u003e 0:\n        # Get the min and max coordinates for the bounding box\n        min_x, min_y = bounding_box_coords.min(axis=0)\n        max_x, max_y = bounding_box_coords.max(axis=0)\n\n        # Iterate through the bounding box area\n        for x in range(min_x, max_x + 1):\n            for y in range(min_y, max_y + 1):\n                # Transform the color based on the mapping\n                original_color = output_grid[x][y]\n                if original_color in color_mapping:\n                    output_grid[x][y] = color_mapping[original_color]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with multiple rows of colors and a black background\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly create a few rows with colors\n    num_rows = np.random.randint(3, 6)\n    \n    for i in range(num_rows):\n        row_color = np.random.choice(list(Color.NOT_BLACK))\n        grid[:, i] = row_color  # Fill entire row with the same color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/189/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/189/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/189/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/189/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/189/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/189/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/189/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/189/images/train_output_2.png"}]}, "index": 189, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision detection, pattern alignment\n\n# description:\n# In the input, you will see a grid containing a blue rectangle surrounded by four yellow circles at each corner.\n# To make the output, move the blue rectangle so that it\u0027s perfectly centered on the nearest yellow circle without overlapping with any other circles.\n\ndef main(input_grid):\n    # Step 1: Detect the objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True)\n    \n    blue_objects = [obj for obj in objects if Color.BLUE in object_colors(obj, background=Color.BLACK)]\n    yellow_objects = [obj for obj in objects if Color.YELLOW in object_colors(obj, background=Color.BLACK)]\n\n    assert len(blue_objects) == 1, \"There should be exactly one blue rectangle\"\n    assert len(yellow_objects) \u003e= 1, \"There should be at least one yellow circle\"\n\n    blue_object = blue_objects[0]\n\n    # Step 2: Find the position of the blue rectangle\n    blue_x, blue_y, blue_width, blue_height = bounding_box(blue_object)\n\n    # Step 3: Determine the position of the nearest yellow circle\n    nearest_yellow_circle = None\n    min_distance = float(\u0027inf\u0027)\n\n    for yellow_object in yellow_objects:\n        yellow_x, yellow_y, yellow_width, yellow_height = bounding_box(yellow_object)\n        \n        # Calculate the center of the yellow circle\n        yellow_center_x = yellow_x + yellow_width // 2\n        yellow_center_y = yellow_y + yellow_height // 2\n        \n        # Calculate the distance from the blue rectangle to the yellow circle center\n        distance = np.sqrt((yellow_center_x - (blue_x + blue_width // 2)) ** 2 + \n                           (yellow_center_y - (blue_y + blue_height // 2)) ** 2)\n        \n        if distance \u003c min_distance:\n            min_distance = distance\n            nearest_yellow_circle = (yellow_center_x, yellow_center_y)\n\n    # Step 4: Move the blue rectangle to the position of the nearest yellow circle\n    new_blue_x, new_blue_y = nearest_yellow_circle[0] - blue_width // 2, nearest_yellow_circle[1] - blue_height // 2\n\n    # Step 5: Check for collisions with other yellow circles before moving\n    for yellow_object in yellow_objects:\n        yellow_x, yellow_y, yellow_width, yellow_height = bounding_box(yellow_object)\n        \n        if yellow_object is not blue_object:  # Skip collision check with itself\n            if collision(object1=blue_object, object2=yellow_object, x1=new_blue_x, y1=new_blue_y, \n                         x2=yellow_x, y2=yellow_y):\n                # If there is a collision, we cannot move there; just return the original grid\n                return input_grid\n\n    # Step 6: Create the output grid and place the blue rectangle at the new position\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    blit_sprite(output_grid, blue_object, new_blue_x, new_blue_y)\n    \n    for yellow_object in yellow_objects:\n        blit_sprite(output_grid, yellow_object, *bounding_box(yellow_object)[:2])\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a blue rectangle and four yellow circles at the corners\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Define the size of the blue rectangle\n    blue_width, blue_height = np.random.randint(2, 4), np.random.randint(2, 4)\n    blue_object = np.full((blue_width, blue_height), Color.BLUE)\n\n    # Randomly place the blue rectangle at least 2 pixels away from edges\n    blue_x = np.random.randint(2, grid_size - blue_width - 2)\n    blue_y = np.random.randint(2, grid_size - blue_height - 2)\n    blit_sprite(grid, blue_object, blue_x, blue_y)\n\n    # Define yellow circle size\n    circle_radius = 1\n    yellow_circle = np.full((2 * circle_radius + 1, 2 * circle_radius + 1), Color.YELLOW)\n    \n    # Place circles at the corners\n    blit_sprite(grid, yellow_circle, 0, 0)\n    blit_sprite(grid, yellow_circle, 0, grid_size - 2 * circle_radius - 1)\n    blit_sprite(grid, yellow_circle, grid_size - 2 * circle_radius - 1, 0)\n    blit_sprite(grid, yellow_circle, grid_size - 2 * circle_radius - 1, grid_size - 2 * circle_radius - 1)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/190/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/190/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/190/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/190/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/190/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/190/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/190/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/190/images/train_output_2.png"}]}, "index": 190, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, filling, color patterns\n\n# description:\n# In the input, you will see a grid with a single colored square in the center. \n# To create the output, first scale this square by a factor of 3. \n# Then, fill the surrounding area with the same color, creating a larger square pattern. \n# The final output grid will be a larger square with the original square\u0027s color.\n\ndef main(input_grid):\n    # 1. Determine the size of the input grid and find the center colored square.\n    center_square = find_connected_components(input_grid, monochromatic=True)[0]\n    center_x, center_y = object_position(center_square)\n    \n    # 2. Scale the square by a factor of 3.\n    scaled_square = scale_sprite(center_square, factor=3)\n    \n    # 3. Create output grid with the same color as the scaled square.\n    output_size = scaled_square.shape[0]\n    output_grid = np.full((output_size, output_size), scaled_square[0, 0])  # Fill with the color of the original square\n\n    # 4. Place the scaled square in the center of the output grid.\n    output_x = (output_size - scaled_square.shape[0]) // 2\n    output_y = (output_size - scaled_square.shape[1]) // 2\n    blit_sprite(output_grid, scaled_square, x=output_x, y=output_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a 5x5 grid with a single colored square in the center.\n    grid_size = 5\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Choose a random color for the center square\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the colored square in the center\n    grid[2, 2] = color\n    grid[2, 3] = color\n    grid[3, 2] = color\n    grid[3, 3] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/191/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/191/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/191/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/191/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/191/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/191/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/191/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/191/images/train_output_2.png"}]}, "index": 191, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color propagation, flood fill\n\n# description:\n# In the input, you will see a grid containing a single colored pixel in the center and a series of colored pixels surrounding it.\n# To produce the output, you should remove the center pixel and then perform a flood fill from the position of the center pixel using the color of the surrounding pixels.\n# The flood fill will propagate outwards, coloring all connected pixels of the same color as the center pixel until it hits the edges of the grid or pixels of different colors.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n    \n    # Get the center pixel\u0027s position and color\n    center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n    center_color = output_grid[center_x, center_y]\n    \n    # Remove the center pixel\n    output_grid[center_x, center_y] = Color.BLACK\n    \n    # Perform a flood fill from the center pixel using the center color\n    flood_fill(output_grid, center_x, center_y, center_color, connectivity=4)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a 7x7 grid with a black background\n    n = m = 7\n    grid = np.full((n, m), Color.BLACK)\n\n    # Select a color for the center pixel and surrounding pixels\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Randomly place the center pixel in the middle of the grid\n    grid[n//2, m//2] = center_color\n\n    # Randomly generate surrounding pixels\n    surrounding_colors = np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(4, 8), replace=False)\n    \n    # Place surrounding pixels in random positions around the center, ensuring they don\u0027t overlap\n    for color in surrounding_colors:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        while (grid[x, y] != Color.BLACK) or (x == n//2 and y == m//2):\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/192/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/192/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/192/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/192/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/192/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/192/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/192/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/192/images/train_output_2.png"}]}, "index": 192, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, symmetry, orbit transformation\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels. \n# To create the output, you will map each color to a new color based on its position. \n# Colors in even rows will be transformed to a different color than those in odd rows.\n# After establishing the new color for each pixel, mirror the entire grid along the vertical axis.\n# Finally, use the `orbit` function to apply symmetry transformations to the new colors based on their positions.\n\ndef main(input_grid):\n    # Step 1: Define color mappings based on even and odd rows\n    color_map_even = {Color.RED: Color.BLUE, Color.GREEN: Color.YELLOW, Color.YELLOW: Color.RED, Color.BLUE: Color.GREEN}\n    color_map_odd = {Color.RED: Color.GREEN, Color.GREEN: Color.BLUE, Color.YELLOW: Color.RED, Color.BLUE: Color.YELLOW}\n    \n    # Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 2: Apply color mappings based on row parity\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            current_color = input_grid[x, y]\n            if x % 2 == 0:  # Even row\n                output_grid[x, y] = color_map_even.get(current_color, current_color)  # Map color if exists\n            else:  # Odd row\n                output_grid[x, y] = color_map_odd.get(current_color, current_color)  # Map color if exists\n\n    # Step 3: Mirror the output grid along the vertical axis\n    output_grid = np.flip(output_grid, axis=1)\n\n    # Step 4: Apply symmetry transformations using orbit\n    for x in range(output_grid.shape[0]):\n        for y in range(output_grid.shape[1]):\n            if output_grid[x, y] != Color.BLACK:  # Only process non-black colors\n                symmetric_points = orbit(output_grid, x, y, symmetries=[MirrorSymmetry(mirror_x=None, mirror_y=None)])\n                for x2, y2 in symmetric_points:\n                    if 0 \u003c= x2 \u003c output_grid.shape[0] and 0 \u003c= y2 \u003c output_grid.shape[1]:\n                        output_grid[x2, y2] = output_grid[x, y]  # Copy the color to the symmetric points\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size and fill it with random colors\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose colors and fill the grid\n    colors = list(Color.NOT_BLACK)\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/193/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/193/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/193/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/193/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/193/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/193/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/193/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/193/images/train_output_2.png"}]}, "index": 193, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, area calculation, color coding\n\n# description:\n# In the input grid, you will find various shapes in different colors. Each shape is made up of colored pixels on a black background. \n# The goal is to identify shapes that have an area of exactly 8 pixels and color them orange, shapes with an area of exactly 12 pixels should be colored blue, \n# and shapes with an area of exactly 16 pixels should be colored grey. All other shapes should remain black.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all the colored objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Iterate through the objects and color them based on their area\n    for obj in objects:\n        area = np.sum(obj != Color.BLACK)  # Calculate the area of the object\n        if area == 8:\n            color = Color.ORANGE\n        elif area == 12:\n            color = Color.BLUE\n        elif area == 16:\n            color = Color.GREY\n        else:\n            continue  # Leave the other shapes in black\n\n        # Color the object in the output grid\n        output_grid[obj != Color.BLACK] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 black grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Define the colors available for the objects\n    object_colors = [Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW]\n    \n    # Place random objects in the grid\n    for _ in range(np.random.randint(3, 6)):  # Create between 3 and 5 objects\n        # Randomly generate a sprite size\n        sprite_size = np.random.choice([8, 12, 16])  # Only allow areas of 8, 12, 16\n        sprite_width = np.random.randint(1, 5)\n        sprite_height = sprite_size // sprite_width\n\n        # Generate a sprite with the chosen size and a random color\n        sprite = random_sprite(sprite_height, sprite_width, color_palette=[np.random.choice(object_colors)])\n\n        try:\n            # Find a random free location for the sprite\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            continue  # If we can\u0027t place the sprite, skip to the next iteration\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/194/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/194/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/194/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/194/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/194/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/194/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/194/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/194/images/train_output_2.png"}]}, "index": 194, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision, translation, packing\n\n# description:\n# In the input, you will see two colored objects placed randomly on a grid. \n# The goal is to fit these two objects together without overlapping and as tightly as possible, \n# translating them if necessary. The output should show the combined object in a rectangular area \n# that minimally contains both objects.\n\ndef main(input_grid):\n    # Step 1: Detect the two colored objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=False)\n    assert len(objects) == 2, \"There should be exactly 2 objects\"\n\n    # Step 2: Crop the objects to their bounding boxes\n    sprites = [crop(obj, background=Color.BLACK) for obj in objects]\n    \n    # Create an output grid that can hold the combined dimensions of both objects\n    combined_width = max(sprite.shape[0] for sprite in sprites)\n    combined_height = sum(sprite.shape[1] for sprite in sprites)\n    \n    output_grid = np.full((combined_width, combined_height), Color.BLACK)\n\n    # Step 3: Attempt to fit the sprites together without overlap\n    for idx, sprite in enumerate(sprites):\n        # Try placing the first object at the start of the output grid\n        y_offset = sum(sprites[i].shape[1] for i in range(idx))  # vertical stacking\n        if not collision(object1=output_grid, object2=sprite, x1=0, y1=y_offset):\n            blit_sprite(output_grid, sprite, x=0, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create two distinct colored objects and place them randomly in a grid\n    grid_width, grid_height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((grid_width, grid_height), Color.BLACK)\n\n    # Create two random sprites\n    sprite1 = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), density=0.8)\n    sprite2 = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), density=0.8)\n\n    # Place the first sprite\n    x1, y1 = random_free_location_for_sprite(grid, sprite1, border_size=1)\n    blit_sprite(grid, sprite1, x=x1, y=y1)\n\n    # Place the second sprite ensuring it does not collide with the first\n    while True:\n        x2, y2 = random_free_location_for_sprite(grid, sprite2, border_size=1)\n        if not collision(object1=grid, object2=sprite2, x2=x2, y2=y2):\n            blit_sprite(grid, sprite2, x=x2, y=y2)\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/195/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/195/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/195/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/195/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/195/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/195/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/195/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/195/images/train_output_2.png"}]}, "index": 195, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contact detection, proximity, object movement\n\n# description:\n# In the input, you will see a grid containing colored objects and colored pixels. Each color represents a different type of object. \n# The output should move each colored pixel to the nearest object of the same color until the pixel touches that object. \n# If a pixel does not have a corresponding object, it should be removed from the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # Find all connected components in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Separate objects from pixels\n    colored_objects = []\n    colored_pixels = []\n    \n    for obj in objects:\n        if np.sum(obj != Color.BLACK) == 1:  # Single pixel is considered a pixel\n            colored_pixels.append(obj)\n        else:\n            colored_objects.append(obj)\n\n    # Copy colored objects to the output grid\n    for obj in colored_objects:\n        x, y, w, h = bounding_box(obj)\n        blit_sprite(output_grid, obj, x=x, y=y)\n\n    # Move each pixel to the nearest object of the same color\n    for pixel in colored_pixels:\n        pixel_color = np.unique(pixel)[1]\n        matching_objects = [obj for obj in colored_objects if np.unique(obj)[1] == pixel_color]\n\n        if not matching_objects:\n            continue  # No matching object, skip this pixel\n        \n        # Find the closest object to the pixel\n        closest_obj = None\n        min_distance = float(\u0027inf\u0027)\n\n        for obj in matching_objects:\n            obj_x, obj_y, obj_w, obj_h = bounding_box(obj)\n            pixel_x, pixel_y, _, _ = bounding_box(pixel)\n\n            # Calculate distance between pixel and object\n            distance = np.linalg.norm(np.array([pixel_x, pixel_y]) - np.array([obj_x, obj_y]))\n\n            if distance \u003c min_distance:\n                min_distance = distance\n                closest_obj = obj\n        \n        # Slide the pixel towards the closest object until it contacts it\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                new_x = pixel_x + dx\n                new_y = pixel_y + dy\n                new_pixel = np.zeros_like(output_grid)\n                blit_sprite(new_pixel, pixel, x=new_x, y=new_y)\n\n                if contact(object1=closest_obj, object2=new_pixel, x1=new_x, y1=new_y):\n                    blit_sprite(output_grid, new_pixel, x=new_x, y=new_y)\n                    break\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate colored objects\n    num_objects = np.random.randint(1, 5)\n    object_colors = np.random.choice(list(Color.NOT_BLACK), num_objects, replace=False)\n\n    for color in object_colors:\n        obj_shape = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[color])\n        try:\n            x, y = random_free_location_for_sprite(grid, obj_shape)\n            blit_sprite(grid, obj_shape, x=x, y=y)\n        except ValueError:\n            continue  # Skip if no free location found\n\n    # Generate colored pixels\n    num_pixels = np.random.randint(5, 15)\n    for _ in range(num_pixels):\n        pixel_color = np.random.choice(object_colors)  # Pixels match existing object colors\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = pixel_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/196/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/196/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/196/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/196/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/196/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/196/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/196/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/196/images/train_output_2.png"}]}, "index": 196, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, shape transformation, blitting\n\n# description:\n# In the input you will see different colored shapes, such as circles, triangles, or squares. \n# Each shape will have a distinct color. To make the output, transform each shape into a triangle, \n# and change its color to a shade darker than the original.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the objects from the grid.\n    # 2. For each object, find its bounding box.\n    # 3. Determine the centroid of the object to position the new triangle.\n    # 4. Create a triangle sprite and change its color to a darker shade.\n    # 5. Blit the new triangle sprite into the output grid.\n\n    # 1. Extract the objects from the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False, connectivity=8)\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. For each object, find its bounding box\n    for obj in objects:\n        if np.count_nonzero(obj) \u003e 0:  # Only consider non-empty objects\n            x, y, width, height = bounding_box(obj)\n            object_center = (x + width // 2, y + height // 2)\n            \n            # 3. Determine the color of the object\n            original_color = obj[obj != Color.BLACK][0]\n            darker_color = get_darker_color(original_color)\n\n            # 4. Create a triangle sprite\n            triangle_sprite = create_triangle_sprite()\n\n            # 5. Blit the new triangle onto the output grid centered at the object\u0027s centroid\n            blit_sprite(output_grid, triangle_sprite, object_center[0] - triangle_sprite.shape[0] // 2, \n                        object_center[1] - triangle_sprite.shape[1] // 2, background=Color.BLACK)\n            output_grid[output_grid == Color.BLACK] = Color.BLACK\n            output_grid[output_grid != Color.BLACK] = darker_color\n\n    return output_grid\n\ndef get_darker_color(color):\n    # Function to determine a darker shade of the given color\n    darker_shades = {\n        Color.RED: Color.MAROON,\n        Color.GREEN: Color.TEAL,\n        Color.BLUE: Color.GREY,\n        Color.YELLOW: Color.ORANGE,\n        Color.PINK: Color.MAROON,\n        Color.GREY: Color.BLACK,\n        Color.ORANGE: Color.RED,\n        Color.TEAL: Color.GREEN,\n        Color.MAROON: Color.BLACK,\n        Color.BLACK: Color.BLACK\n    }\n    return darker_shades.get(color, Color.BLACK)\n\ndef create_triangle_sprite():\n    # Function to create a simple triangle sprite\n    triangle = np.full((5, 5), Color.BLACK)\n    triangle[0, 2] = Color.GREY  # Top point\n    triangle[1, 1:4] = Color.GREY  # Middle part\n    triangle[2, 0:5] = Color.GREY  # Bottom width\n    return triangle\n\ndef generate_input():\n    # Generate a random grid with various colored shapes\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose random colors for shapes\n    colors = random.sample(list(Color.NOT_BLACK), 5)\n\n    # Randomly place shapes in the grid\n    for color in colors:\n        # Create a random shape (circle, square, triangle)\n        shape_type = np.random.choice([\u0027circle\u0027, \u0027square\u0027, \u0027triangle\u0027])\n        if shape_type == \u0027circle\u0027:\n            shape = create_circle_shape(np.random.randint(3, 5), color)\n        elif shape_type == \u0027square\u0027:\n            shape = create_square_shape(np.random.randint(3, 5), color)\n        else:  # triangle\n            shape = create_triangle_shape(color)\n\n        # Place the shape into the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, border_size=1)\n        blit_sprite(grid, shape, x, y)\n\n    return grid\n\ndef create_circle_shape(radius, color):\n    # Create a circular shape represented in a grid\n    diameter = radius * 2\n    circle = np.full((diameter, diameter), Color.BLACK)\n\n    for x in range(diameter):\n        for y in range(diameter):\n            if (x - radius) ** 2 + (y - radius) ** 2 \u003c= radius ** 2:\n                circle[x, y] = color\n                \n    return circle\n\ndef create_square_shape(size, color):\n    # Create a square shape\n    square = np.full((size, size), color)\n    return square\n\ndef create_triangle_shape(color):\n    # Create a triangle shape\n    triangle = np.full((5, 5), Color.BLACK)\n    triangle[0, 2] = color  # Top point\n    triangle[1, 1:4] = color  # Middle part\n    triangle[2, 0:5] = color  # Bottom width\n    return triangle", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/197/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/197/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/197/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/197/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/197/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/197/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/197/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/197/images/train_output_2.png"}]}, "index": 197, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotational symmetry, color filling, grid manipulation\n\n# description:\n# In the input, you will see a colored object that has been partially occluded by black pixels.\n# To make the output, you should restore the object to its original form by filling in the missing parts\n# according to its rotational symmetry. The output should reflect the object as if it were fully present.\n\ndef main(input_grid):\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Detect the rotational symmetry of the input grid\n    symmetry = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Find all colored pixels in the input grid\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Fill in missing pixels based on the symmetry\n    for x, y in colored_pixels:\n        # Get the color of the current pixel\n        color = input_grid[x, y]\n        \n        # Loop through all four rotational positions (0, 90, 180, 270 degrees)\n        for i in range(1, 4):\n            # Calculate the rotated coordinates\n            rotated_x, rotated_y = symmetry.apply(x, y, iters=i)\n\n            # If the rotated position is black, fill it with the current color\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a 10x10 grid\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Create a random sprite that has some rotational symmetry\n    sprite = random_sprite(\n        5, 5, density=0.6, symmetry=\"radial\", color_palette=list(Color.NOT_BLACK)\n    )\n\n    # Randomly occlude some pixels of the sprite with black\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.random() \u003c 0.3:  # 30% chance to occlude\n                sprite[i, j] = Color.BLACK\n\n    # Place the sprite randomly onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/198/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/198/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/198/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/198/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/198/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/198/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/198/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/198/images/train_output_2.png"}]}, "index": 198, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, collision detection\n\n# description:\n# In the input you will see a grid with a single colored object (could be any shape) on a black background.\n# To make the output, you should move this object towards the right until it touches the right edge of the grid or collides with another object (if any). \n# If it collides, the object should stop just before the collision.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the colored object in the grid\n    # 2. Translate the object to the right until it collides or reaches the edge of the grid\n    # 3. Blit the final position of the object onto the output grid\n\n    # 1. Detect the colored object\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    assert len(objects) == 1, \"There should be exactly one colored object\"\n    colored_object = objects[0]\n\n    # Get the position of the colored object\n    x, y = object_position(colored_object, background=Color.BLACK, anchor=\"upper left\")\n    object_width = colored_object.shape[1]\n    object_height = colored_object.shape[0]\n\n    # Create the output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # 2. Translate the object to the right until it collides or reaches the grid edge\n    max_x_translation = output_grid.shape[1] - (x + object_width)\n    for distance in range(1, max_x_translation + 1):\n        if collision(object1=colored_object, object2=output_grid, x1=x, y1=y, x2=x + distance, y2=y):\n            # If collision detected, stop before collision\n            break\n    else:\n        distance = max_x_translation  # No collision, move to the edge\n\n    # Update the position of the object\n    new_x = x + distance\n    \n    # Blit the object onto the output grid at the new position\n    output_grid = blit_sprite(output_grid, sprite=colored_object, x=new_x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    width, height = np.random.randint(10, 20), np.random.randint(5, 10)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Generate a random sprite (object) with non-black colors\n    sprite_height, sprite_width = np.random.randint(2, 5), np.random.randint(2, 5)\n    sprite = random_sprite(sprite_height, sprite_width, density=1.0, color_palette=Color.NOT_BLACK)\n\n    # Place the sprite in a random position that allows it to move\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/199/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/199/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/199/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/199/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/199/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/199/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/199/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/199/images/train_output_2.png"}]}, "index": 199, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, color transformation, grid expansion\n\n# description:\n# In the input you will see a grid with a pattern of colored pixels that are symmetrically repeated in the vertical direction.\n# To make the output, expand the height of the grid to double its original size and change the color of the pattern from its original color to a specified new color.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the translational symmetries in the input grid.\n    # 2. Create an output grid that is double the height of the input grid.\n    # 3. Copy the detected pattern into the new grid, extending it vertically.\n    # 4. Change the color of the pixels in the pattern.\n\n    # Step 1: Detect translational symmetries\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=None)\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # Get the size of the input grid\n    input_height, input_width = input_grid.shape\n    # Step 2: Create an output grid with double the height\n    output_grid = np.full((input_height * 2, input_width), Color.BLACK)\n\n    # Step 3: Copy the detected pattern into the output grid\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Compute the orbit into the output grid\n        for x2, y2 in orbit(output_grid, x, y, symmetries):\n            output_grid[x2, y2] = input_grid[x, y]\n\n    # Step 4: Change the color of the pattern (for example, from Color.RED to Color.GREEN)\n    output_grid[output_grid == Color.RED] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a vertical symmetry pattern\n    height = np.random.randint(3, 7)  # Height of the pattern\n    width = np.random.randint(5, 15)   # Width of the grid\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly color the vertical pattern\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a pattern that repeats vertically\n    for x in range(width):\n        if np.random.rand() \u003c 0.5:  # Randomly decide if a pixel should be colored\n            for y in range(height):\n                grid[y, x] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/200/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/200/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/200/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/200/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/200/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/200/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/200/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/200/images/train_output_2.png"}]}, "index": 200, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, boundary detection, filling\n\n# description:\n# The input grid contains black and green pixels arranged in various patterns. \n# To produce the output grid, you need to identify the green pixels that form the outer boundary of each connected component. \n# Then, fill the interior of those components with a new color (e.g., Color.BLUE). \n# The output grid will maintain the original boundaries but will have the interior filled in.\n\ndef main(input_grid):\n    # Create an output grid initialized to the input grid\n    output_grid = input_grid.copy()\n\n    # Find the boundaries of the green components\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Identify connected components that are not boundaries\n    objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    for obj in objects:\n        # Get the boundary of the current object\n        obj_boundary = object_boundary(obj, background=Color.BLACK)\n\n        # Fill the interior of the object with Color.BLUE\n        for x, y in np.argwhere(obj == Color.GREEN):\n            if not obj_boundary[x, y]:  # Only fill if it\u0027s not on the boundary\n                output_grid[x + obj.min(axis=0)[0], y + obj.min(axis=1)[0]] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a square grid with random green patterns on a black background\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly create connected components of green pixels\n    n_components = np.random.randint(1, 5)\n    for _ in range(n_components):\n        # Random size for the component\n        component_height = np.random.randint(2, 6)\n        component_width = np.random.randint(2, 6)\n        \n        # Create a green component\n        component = np.full((component_height, component_width), Color.GREEN)\n        \n        # Place the component randomly in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, component, background=Color.BLACK, padding=1)\n            blit_sprite(grid, component, x, y, background=Color.BLACK)\n        except:\n            continue  # Ignore if we cannot place the component\n            \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/201/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/201/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/201/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/201/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/201/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/201/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/201/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/201/images/train_output_2.png"}]}, "index": 201, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color transformation, pattern generation\n\n# description:\n# In the input, you will see a grid containing several colored pixels arranged in a pattern.\n# To make the output, you will scale the entire pattern by a factor based on the number of colors in the input.\n# Each pixel in the pattern will change color to a new color determined by the scaling factor; if the scaling factor is even, the new color will be blue, otherwise, it will be red.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the distinct colors in the input grid\n    # 2. Scale the input pattern based on the number of distinct colors\n    # 3. Change the color of the scaled pattern based on the scaling factor\u0027s parity (even/odd)\n\n    # 1. Identify distinct colors in the input grid\n    background = Color.BLACK\n    unique_colors = set(object_colors(input_grid, background=background))\n    unique_colors.discard(Color.BLACK)  # Remove background color\n    num_colors = len(unique_colors)\n\n    # 2. Scale the input pattern based on the number of distinct colors\n    scaling_factor = num_colors\n    scaled_sprite = scale_sprite(input_grid, factor=scaling_factor)\n\n    # 3. Change color based on the scaling factor\u0027s parity\n    new_color = Color.BLUE if scaling_factor % 2 == 0 else Color.RED\n    scaled_sprite[scaled_sprite != background] = new_color\n\n    # Create an output grid to fit the scaled sprite\n    output_grid = np.full_like(scaled_sprite, Color.BLACK)\n\n    # Blit the scaled and recolored sprite onto the output grid\n    x_offset = 0  # Start at the top left corner\n    y_offset = 0\n    blit_sprite(output_grid, scaled_sprite, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colors in the pattern\n    num_colors = np.random.randint(2, 5)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    # Randomly place colored pixels in a pattern\n    for color in colors:\n        # Randomly generate a pattern with a certain density\n        pattern_density = np.random.randint(2, 5)\n        for _ in range(pattern_density):\n            x, y = np.random.randint(0, width), np.random.randint(0, height)\n            grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/202/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/202/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/202/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/202/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/202/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/202/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/202/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/202/images/train_output_2.png"}]}, "index": 202, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, area calculation, transformation\n\n# description:\n# The input consists of a grid with various colored regions. Each region is a connected component of a single color.\n# The goal is to identify the color of the largest region and the color of the smallest region.\n# The output grid should replace the largest region with red and the smallest region with yellow.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # 1. Find all connected components in the grid, treating black as the background\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # 2. Calculate the areas of each component\n    areas = [np.sum(component != Color.BLACK) for component in components]\n\n    # 3. Identify the largest and smallest components by area\n    largest_component = components[np.argmax(areas)]\n    smallest_component = components[np.argmin(areas)]\n\n    # 4. Create an output grid by copying the input grid\n    output_grid = np.copy(input_grid)\n\n    # 5. Replace the colors of the largest and smallest components\n    output_grid[largest_component != Color.BLACK] = Color.RED\n    output_grid[smallest_component != Color.BLACK] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size 10-20x10-20\n    width = np.random.randint(10, 21)\n    height = np.random.randint(10, 21)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly create colored regions\n    num_regions = np.random.randint(3, 7)  # Number of regions\n    colors = [Color.BLUE, Color.GREEN, Color.GREY, Color.ORANGE, Color.TEAL, Color.MAROON]  # Available colors\n\n    for _ in range(num_regions):\n        # Random size for the region (between 2x2 and 5x5)\n        region_width = np.random.randint(2, 6)\n        region_height = np.random.randint(2, 6)\n\n        # Choose a random color for the region\n        color = np.random.choice(colors)\n\n        # Find a random position to place the region\n        try:\n            x, y = random_free_location_for_sprite(grid, np.full((region_width, region_height), color), background=Color.BLACK)\n            blit_sprite(grid, np.full((region_width, region_height), color), x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # Skip if no space available\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/203/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/203/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/203/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/203/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/203/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/203/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/203/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/203/images/train_output_2.png"}]}, "index": 203, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, pixel manipulation, color expansion\n\n# description:\n# In the input, you will see a grid with various colored pixels and at least one special pixel of a specific color (e.g., red).\n# For each special pixel found, you need to:\n# 1. Find the bounding box of the area containing this special pixel.\n# 2. Expand the color of the special pixel to fill the entire bounding box, replacing all pixels of a different color within that box.\n# The output grid should reflect these changes based on the specified transformation.\n\ndef main(input_grid):\n    # Determine the most common color to identify the background\n    background_color = np.bincount(input_grid.flatten()).argmax()\n\n    # Find connected components in the grid to identify distinct sections\n    objects = find_connected_components(input_grid, background=background_color, monochromatic=False)\n\n    # Prepare the output grid, starting as a copy of the input\n    output_grid = input_grid.copy()\n\n    # Iterate over the found objects\n    for obj in objects:\n        # If the object contains the special color (e.g., red), process it\n        if np.any(obj == Color.RED):\n            # Get the bounding box of the object\n            x, y, width, height = bounding_box(obj, background=background_color)\n\n            # Fill the bounding box with the special color (red)\n            output_grid[x:x+width, y:y+height] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid with some colored pixels with a specific number of special pixels\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Random number of special pixels\n    num_special = np.random.randint(1, 5)\n\n    for _ in range(num_special):\n        # Randomly select a position for the special pixel (e.g., red)\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.RED\n\n        # Fill the bounding box around the special pixel with random colors\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if 0 \u003c= x + dx \u003c n and 0 \u003c= y + dy \u003c m and (dx != 0 or dy != 0):\n                    grid[x + dx, y + dy] = np.random.choice([color for color in Color.NOT_BLACK if color != Color.RED])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/204/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/204/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/204/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/204/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/204/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/204/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/204/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/204/images/train_output_2.png"}]}, "index": 204, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, shape matching\n\n# description:\n# In the input, you will see various yellow shapes on a black background. \n# The goal is to detect these shapes and transform their colors based on their dimensions. \n# If a shape is a square, color it red. If it is a rectangle, color it blue. \n# If it is a triangle, color it green. The shapes are defined as follows:\n# - Square: equal width and height\n# - Rectangle: unequal width and height\n# - Triangle: a shape that forms a right triangle.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying it directly\n    output_grid = np.copy(input_grid)\n\n    # Detect all yellow shapes in the input grid\n    yellow_shapes = detect_objects(input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=8)\n\n    for shape in yellow_shapes:\n        # Get bounding box of the shape\n        x, y, w, h = bounding_box(shape, background=Color.BLACK)\n        \n        # Calculate the area of the shape to determine its type\n        area = np.sum(shape != Color.BLACK)\n\n        # Determine if the shape fits certain criteria\n        if w == h:  # It\u0027s a square\n            output_grid[shape != Color.BLACK] = Color.RED\n        elif area == (w * h) and w != h:  # It\u0027s a rectangle\n            output_grid[shape != Color.BLACK] = Color.BLUE\n        elif w == 2 and h == 2:  # It\u0027s a right triangle (2 pixels) for simplicity\n            output_grid[shape != Color.BLACK] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random number of yellow shapes\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        shape_type = np.random.choice([\u0027square\u0027, \u0027rectangle\u0027, \u0027triangle\u0027])\n        \n        if shape_type == \u0027square\u0027:\n            size = np.random.randint(2, 5)\n            shape = np.full((size, size), Color.YELLOW)\n        elif shape_type == \u0027rectangle\u0027:\n            width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n            shape = np.full((height, width), Color.YELLOW)\n        elif shape_type == \u0027triangle\u0027:\n            shape = np.zeros((3, 3), dtype=int)\n            shape[0, 1] = Color.YELLOW\n            shape[1, 0] = Color.YELLOW\n            shape[1, 1] = Color.YELLOW\n            shape[1, 2] = Color.YELLOW\n            shape[2, 1] = Color.YELLOW\n            \n        # Place the shape at a random location\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n            blit_sprite(grid, shape, x=x, y=y)\n        except ValueError:\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/205/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/205/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/205/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/205/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/205/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/205/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/205/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/205/images/train_output_2.png"}]}, "index": 205, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cropping, proximity, color separation\n\n# description:\n# In the input you will see a grid with two clusters of colored pixels and a black background.\n# To make the output, you should find the cluster that is closer to the center of the grid,\n# crop that cluster, and output it. If both clusters are equidistant from the center, crop both \n# and place them side by side in the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the grid\n    height, width = input_grid.shape\n    \n    # Calculate the center of the grid\n    center = (height // 2, width // 2)\n    \n    # Find connected components (clusters) in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Determine the distance of each component\u0027s center from the grid\u0027s center\n    distances = []\n    for component in components:\n        # Find the bounding box of the component to calculate its center\n        x, y, w, h = bounding_box(component)\n        component_center = (x + w // 2, y + h // 2)\n        \n        # Calculate the distance to the center of the grid\n        distance = np.linalg.norm(np.array(component_center) - np.array(center))\n        distances.append((distance, component))\n    \n    # Sort components by distance to center\n    distances.sort(key=lambda x: x[0])\n    \n    # If we have at least two components, check if they are equidistant\n    if len(distances) \u003e= 2 and np.isclose(distances[0][0], distances[1][0]):\n        # Crop both components and place them side by side in the output grid\n        output_height = max(bounding_box(distances[0][1])[2], bounding_box(distances[1][1])[2])\n        output_width = bounding_box(distances[0][1])[3] + bounding_box(distances[1][1])[3]\n        output_grid = np.full((output_height, output_width), Color.BLACK)\n        \n        # Get the cropped components\n        cropped1 = crop(distances[0][1], background=Color.BLACK)\n        cropped2 = crop(distances[1][1], background=Color.BLACK)\n\n        # Place the first component\n        blit_sprite(output_grid, cropped1, x=0, y=0, background=Color.BLACK)\n        # Place the second component to the right of the first\n        blit_sprite(output_grid, cropped2, x=cropped1.shape[0], y=0, background=Color.BLACK)\n        \n    else:\n        # Crop the closest component to the center\n        closest_component = distances[0][1]\n        output_grid = crop(closest_component, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid with two clusters of colored pixels\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select two different colors for the clusters\n    colors = random.sample(list(Color.NOT_BLACK), 2)\n\n    # Randomly create two clusters\n    for color in colors:\n        cluster_size = random.randint(5, 15)  # Size of the cluster\n        for _ in range(cluster_size):\n            x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n            grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/206/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/206/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/206/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/206/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/206/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/206/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/206/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/206/images/train_output_2.png"}]}, "index": 206, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection\n\n# description:\n# In the input you will see a rectangular pattern of random colors except black.\n# To make the output, reflect the pattern horizontally and then vertically, placing the reflected patterns in the output grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Reflect the input grid horizontally to create a mirrored version\n    # 2. Reflect the horizontally mirrored version vertically to create the final output\n\n    # 1. Create the horizontally reflected grid\n    horizontally_reflected = np.fliplr(input_grid)\n\n    # 2. Create the vertically reflected grid\n    vertically_reflected = np.flipud(horizontally_reflected)\n\n    # Stack the original input and the reflected versions into the output grid\n    output_grid = np.vstack((input_grid, horizontally_reflected, vertically_reflected))\n\n    return output_grid\n\ndef generate_input():\n    # Create a random rectangle of colors\n    height = np.random.randint(3, 6)\n    width = np.random.randint(5, 10)\n    \n    # Generate the input grid with random colors\n    grid = random_sprite(height, width, density=1, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/207/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/207/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/207/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/207/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/207/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/207/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/207/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/207/images/train_output_2.png"}]}, "index": 207, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, filling patterns\n\n# description:\n# In the input grid, you will see a pattern that has been partially occluded by black pixels. \n# Your task is to identify the translational symmetries in the pattern and use this information \n# to fill in the occluded areas with the correct colors to restore the original pattern.\n\ndef main(input_grid):\n    # Identify the occlusion color (black)\n    occlusion_color = Color.BLACK\n    \n    # Create a mask for the occluded areas\n    occluded_mask = (input_grid == occlusion_color)\n    \n    # Detect the translational symmetries in the grid\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n    \n    # Fill in the missing parts using the symmetries\n    for occluded_x, occluded_y in np.argwhere(occluded_mask):\n        # Check for symmetric points and fill in the occluded areas\n        for symmetric_x, symmetric_y in orbit(input_grid, occluded_x, occluded_y, symmetries):\n            if input_grid[symmetric_x, symmetric_y] != occlusion_color:\n                input_grid[occluded_x, occluded_y] = input_grid[symmetric_x, symmetric_y]\n                break\n    \n    return input_grid\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random sprite to form the base pattern.\n    # 2. Tile the sprite to create a larger symmetric pattern.\n    # 3. Randomly occlude part of the pattern with black pixels.\n\n    # Step 1: Create a random sprite\n    sprite_width, sprite_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    sprite = random_sprite(sprite_width, sprite_height, color_palette=Color.NOT_BLACK, density=1)\n\n    # Step 2: Tile the sprite to create a symmetric pattern\n    horizontal_repetitions, vertical_repetitions = np.random.randint(2, 5, size=(2))\n    pattern = np.tile(sprite, (horizontal_repetitions, vertical_repetitions))\n\n    # Step 3: Occlude a random portion of the pattern with black pixels\n    occlude_width, occlude_height = np.random.randint(2, 5, size=(2))\n    x_occlude = np.random.randint(0, pattern.shape[0] - occlude_width + 1)\n    y_occlude = np.random.randint(0, pattern.shape[1] - occlude_height + 1)\n    \n    # Create a black rectangle for occlusion\n    black_rectangle = np.full((occlude_width, occlude_height), Color.BLACK)\n    blit_sprite(pattern, black_rectangle, x_occlude, y_occlude, background=None)\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/208/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/208/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/208/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/208/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/208/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/208/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/208/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/208/images/train_output_2.png"}]}, "index": 208, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, color regions, connectivity\n\n# description:\n# In the input, you will see a grid containing multiple colored regions. Each region is formed by pixels of a single color, \n# surrounded by a background color (black). The task is to find all the colored regions and color every alternate \n# region with a new color (yellow) using the flood fill technique.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Find all the connected components (regions) in the input grid\n    regions = find_connected_components(output_grid, background=Color.BLACK)\n\n    # Iterate through the regions and color every alternate one yellow\n    for index, region in enumerate(regions):\n        if index % 2 == 0:  # Change color for every second region\n            # Get the starting point of the region to perform flood fill\n            x, y = np.where(region == region[0, 0])  # Get the coordinates of the region\n            flood_fill(output_grid, x[0], y[0], Color.YELLOW)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Set the size of the grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)  # Initialize the grid with the background color (black)\n\n    # Randomly generate a number of colored regions\n    num_regions = np.random.randint(3, 6)\n    colors = random.sample(Color.NOT_BLACK, k=num_regions)  # Select unique colors for the regions\n\n    for color in colors:\n        # Randomly select a starting point for the region\n        start_x, start_y = np.random.randint(1, n-1), np.random.randint(1, m-1)\n        \n        # Randomly determine the size and shape of the region\n        region_height = np.random.randint(2, 5)\n        region_width = np.random.randint(2, 5)\n\n        # Ensure that we do not exceed grid bounds\n        for i in range(region_height):\n            for j in range(region_width):\n                if 0 \u003c= start_x + i \u003c n and 0 \u003c= start_y + j \u003c m:\n                    grid[start_x + i, start_y + j] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/209/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/209/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/209/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/209/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/209/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/209/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/209/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/209/images/train_output_2.png"}]}, "index": 209, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color transformation, resizing\n\n# description:\n# In the input, you will see various colored shapes made up of 1x1 pixels, including 2x2 yellow squares and 1x4 green rectangles.\n# To make the output:\n# 1. Detect all 2x2 yellow squares and color them blue.\n# 2. Detect all 1x4 green rectangles and color them orange.\n# 3. Enlarge the output grid size to accommodate the number of detected shapes, with each shape expanded to 3x3 for squares and 1x6 for rectangles.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.full((input_grid.shape[0] * 3, input_grid.shape[1] * 3), Color.BLACK)\n\n    # Detect 2x2 yellow squares\n    yellow_squares = detect_objects(input_grid, background=Color.BLACK, colors=[Color.YELLOW], allowed_dimensions=[(2, 2)])\n\n    for square in yellow_squares:\n        # Color the square blue\n        square[square == Color.YELLOW] = Color.BLUE\n        \n        # Blit the enlarged square into the output grid\n        x, y, w, h = bounding_box(square)\n        blit_sprite(output_grid, np.repeat(np.repeat(square, 3, axis=0), 3, axis=1), x * 3, y * 3, background=Color.BLACK)\n\n    # Detect 1x4 green rectangles\n    green_rectangles = detect_objects(input_grid, background=Color.BLACK, colors=[Color.GREEN], allowed_dimensions=[(1, 4), (4, 1)])\n\n    for rect in green_rectangles:\n        # Color the rectangle orange\n        rect[rect == Color.GREEN] = Color.ORANGE\n        \n        # Blit the enlarged rectangle into the output grid\n        x, y, w, h = bounding_box(rect)\n        # Expand the rectangle to 1x6 if it\u0027s horizontal, otherwise to 6x1 if it\u0027s vertical\n        if w == 4 and h == 1:\n            blit_sprite(output_grid, np.repeat(rect, 1, axis=0), x * 3, y * 3, background=Color.BLACK)\n        else:\n            blit_sprite(output_grid, np.repeat(np.repeat(rect, 1, axis=0), 6, axis=1), x * 3, y * 3, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    n_shapes = np.random.randint(4, 10)\n\n    for _ in range(n_shapes):\n        # Randomly choose between creating a yellow square or a green rectangle\n        if np.random.rand() \u003c 0.5:  # Create a yellow square\n            sprite = np.full((2, 2), Color.YELLOW)\n        else:  # Create a green rectangle\n            sprite = np.full((1, 4), Color.GREEN)\n        \n        # Place the shape randomly on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no free location is available, skip this shape creation\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/210/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/210/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/210/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/210/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/210/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/210/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/210/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/210/images/train_output_2.png"}]}, "index": 210, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, replication, color transformation\n\n# description:\n# In the input, you will see a grid consisting of a colorful sprite that is repeated horizontally, forming a pattern.\n# The sprite has been partially occluded by a black rectangle. \n# To create the output, find the symmetry in the input grid, replicate the missing part of the sprite to fill in the black rectangle,\n# and then change the color of the completed sprite from its original color to a new color.\n\ndef main(input_grid):\n    # Color to replace the original sprite color\n    new_color = Color.RED\n\n    # Find the region of the black rectangle (the occlusion)\n    occlusion_color = Color.BLACK\n    black_rectangle_mask = (input_grid == occlusion_color)\n\n    # Find the symmetry in the grid, ignoring the occlusion\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n\n    # Fill in the missing part of the sprite using symmetry\n    for occluded_x, occluded_y in np.argwhere(black_rectangle_mask):\n        for symmetric_x, symmetric_y in orbit(input_grid, occluded_x, occluded_y, symmetries):\n            if input_grid[symmetric_x, symmetric_y] != occlusion_color:\n                input_grid[occluded_x, occluded_y] = input_grid[symmetric_x, symmetric_y]\n                break\n\n    # Change the color of the completed sprite from its original color to new_color\n    output_grid = input_grid.copy()\n    original_colors = np.unique(input_grid[~black_rectangle_mask])\n    for color in original_colors:\n        if color != new_color and color != occlusion_color:\n            output_grid[output_grid == color] = new_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random sprite\n    # 2. Tile it horizontally to create a symmetric pattern\n    # 3. Occlude part of it with a black rectangle\n\n    # Create a random sprite\n    w, h = np.random.randint(2, 5, size=(2))\n    sprite = random_sprite(w, h, color_palette=Color.NOT_BLACK, density=1)\n\n    # Tile it horizontally to create a symmetric pattern\n    horizontal_repetitions = np.random.randint(3, 6)\n    pattern = np.tile(sprite, (1, horizontal_repetitions))\n\n    # Occlude a part of the pattern with a black rectangle\n    w_occluder, h_occluder = np.random.randint(1, 3, size=(2))\n    x_occluder = np.random.randint(0, pattern.shape[0] - w_occluder + 1)\n    y_occluder = np.random.randint(0, pattern.shape[1] - h_occluder + 1)\n    black_rectangle_sprite = np.full((w_occluder, h_occluder), Color.BLACK)\n    blit_sprite(pattern, black_rectangle_sprite, x_occluder, y_occluder, background=None)\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/211/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/211/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/211/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/211/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/211/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/211/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/211/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/211/images/train_output_2.png"}]}, "index": 211, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, radial symmetry\n\n# description:\n# In the input, you will see a grid containing a single green pixel. \n# To make the output, draw radial lines from the green pixel to each edge of the grid. \n# The lines should continue until they hit the edge, creating a star-like pattern.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the position of the green pixel\n    green_pixel = np.where(input_grid == Color.GREEN)\n    green_x, green_y = green_pixel[0][0], green_pixel[1][0]\n\n    # Draw lines in all four cardinal directions (up, down, left, right)\n    # Upward line\n    draw_line(output_grid, green_x, green_y, direction=(0, -1), color=Color.YELLOW)\n\n    # Downward line\n    draw_line(output_grid, green_x, green_y, direction=(0, 1), color=Color.YELLOW)\n\n    # Leftward line\n    draw_line(output_grid, green_x, green_y, direction=(-1, 0), color=Color.YELLOW)\n\n    # Rightward line\n    draw_line(output_grid, green_x, green_y, direction=(1, 0), color=Color.YELLOW)\n\n    # Additionally, draw diagonal lines for more radial symmetry\n    # Up-Left\n    draw_line(output_grid, green_x, green_y, direction=(-1, -1), color=Color.YELLOW)\n\n    # Up-Right\n    draw_line(output_grid, green_x, green_y, direction=(1, -1), color=Color.YELLOW)\n\n    # Down-Left\n    draw_line(output_grid, green_x, green_y, direction=(-1, 1), color=Color.YELLOW)\n\n    # Down-Right\n    draw_line(output_grid, green_x, green_y, direction=(1, 1), color=Color.YELLOW)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random size for the grid\n    n = np.random.randint(6, 15)\n    m = np.random.randint(6, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a single green pixel at a random position\n    green_x = np.random.randint(0, n)\n    green_y = np.random.randint(0, m)\n    grid[green_x, green_y] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/212/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/212/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/212/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/212/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/212/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/212/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/212/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/212/images/train_output_2.png"}]}, "index": 212, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, pattern duplication\n\n# description:\n# In the input you will see a pattern of colored pixels surrounded by black pixels.\n# To make the output, duplicate the pattern within its bounding box and place it to the right of the original pattern.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the bounding box of the original pattern.\n    # 2. Create a new grid that will hold the duplicated pattern.\n    # 3. Duplicate the original pattern and place it next to the original.\n\n    # 1. Find the bounding box of non-background pixels\n    mask = bounding_box_mask(input_grid, background=Color.BLACK)\n    bounding_box = np.argwhere(mask)\n\n    # Extract the coordinates for the bounding box\n    min_x, min_y = bounding_box.min(axis=0)\n    max_x, max_y = bounding_box.max(axis=0)\n\n    # Crop the original pattern based on the bounding box\n    original_pattern = input_grid[min_x:max_x + 1, min_y:max_y + 1]\n\n    # 2. Create output grid\n    output_height = original_pattern.shape[0]\n    output_width = original_pattern.shape[1] * 2  # double the width to accommodate the duplicate\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # 3. Place the original pattern and the duplicated pattern\n    output_grid[:, :output_width // 2] = original_pattern\n    output_grid[:, output_width // 2:] = original_pattern\n\n    return output_grid\n\ndef generate_input():\n    # Create a random pattern of colors inside a bounding box\n    width, height = np.random.randint(5, 15, size=2)\n    pattern = random_sprite(width, height, density=1, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n\n    # Create a larger grid to place the pattern\n    grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly place the pattern in the grid, ensuring there\u0027s space around it\n    x, y = random_free_location_for_sprite(grid, pattern, background=Color.BLACK, border_size=1)\n    blit_sprite(grid, pattern, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/213/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/213/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/213/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/213/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/213/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/213/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/213/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/213/images/train_output_2.png"}]}, "index": 213, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision detection, object alignment\n\n# description:\n# In the input, you will see a blue irregular shape and a green rectangle.\n# Move the blue object in any of the four cardinal directions until it just touches the green rectangle\n# Return the resulting grid with both objects aligned.\n\ndef main(input_grid):\n    # Extract the blue and green objects from the input grid\n    blue_object = np.zeros_like(input_grid)\n    blue_object[input_grid == Color.BLUE] = Color.BLUE\n\n    green_object = np.zeros_like(input_grid)\n    green_object[input_grid == Color.GREEN] = Color.GREEN\n\n    # Initialize the output grid with the blue object\n    output_grid = np.copy(blue_object)\n\n    # Consider possible sliding directions\n    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n        for slide_distance in range(max(input_grid.shape)):\n            # Translate the blue object\n            translated_blue_object = translate(blue_object, dx * slide_distance, dy * slide_distance, background=Color.BLACK)\n            # Check if the translated blue object is touching the green object\n            if contact(object1=translated_blue_object, object2=green_object):\n                # If they are touching, blit the translated blue object onto the output grid\n                blit_sprite(output_grid, translated_blue_object, x=0, y=0, background=Color.BLACK)\n                return output_grid\n\n    assert False, \"No valid slide found\"\n\ndef generate_input():\n    # Create a black grid as background\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a blue irregular sprite\n    blue_sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), color_palette=[Color.BLUE], background=Color.BLACK)\n    x1, y1 = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK)\n    blit_sprite(grid, blue_sprite, x1, y1, background=Color.BLACK)\n\n    # Create a green rectangle sprite\n    green_sprite = np.full((3, 5), Color.GREEN)  # Fixed rectangle size\n    x2, y2 = random_free_location_for_sprite(grid, green_sprite, background=Color.BLACK)\n    blit_sprite(grid, green_sprite, x2, y2, background=Color.BLACK)\n\n    # Check if the blue object can slide to touch the green rectangle\n    for x in range(n):\n        if Color.BLUE in grid[x, :] and Color.GREEN in grid[x, :]:\n            return grid\n    for y in range(m):\n        if Color.BLUE in grid[:, y] and Color.GREEN in grid[:, y]:\n            return grid\n\n    # If not, try again\n    return generate_input()", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/214/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/214/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/214/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/214/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/214/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/214/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/214/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/214/images/train_output_2.png"}]}, "index": 214, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotational symmetry, symmetry detection, color filling\n\n# description:\n# In the input, you will see a grid containing a colorful sprite that is partially rotationally symmetric. \n# The sprite has some missing sections, and the task is to fill in the missing sections with the corresponding colors to make it fully rotationally symmetric.\n# The output should be the modified grid with the filled colors.\n\ndef main(input_grid):\n    # Detect the rotational symmetry of the sprite\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n    \n    # Prepare the output grid, which starts as a copy of the input\n    output_grid = np.copy(input_grid)\n    \n    # Iterate through all the colored pixels in the input grid\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n    \n    for x, y in colored_pixels:\n        # Get the rotated positions for the current pixel\n        rotated_x, rotated_y = sym.apply(x, y, iters=1)\n        \n        # If the rotated position is black (missing), fill it with the color of the original pixel\n        if output_grid[rotated_x, rotated_y] == Color.BLACK:\n            output_grid[rotated_x, rotated_y] = input_grid[x, y]\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid of random dimensions\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random sprite with some rotational symmetry\n    sprite_size = np.random.randint(5, min(n, m))\n    colors = random.sample(list(Color.NOT_BLACK), 3)  # Select a few colors\n    sprite = random_sprite(sprite_size, sprite_size, color_palette=colors, density=0.5)\n    \n    # Introduce missing sections by randomly removing some parts of the sprite\n    for _ in range(np.random.randint(1, 5)):  # Create 1 to 4 missing sections\n        x_start = np.random.randint(0, sprite_size)\n        y_start = np.random.randint(0, sprite_size)\n        x_end = min(sprite_size, x_start + np.random.randint(1, 3))\n        y_end = min(sprite_size, y_start + np.random.randint(1, 3))\n        sprite[x_start:x_end, y_start:y_end] = Color.BLACK\n    \n    # Place the sprite in the grid at a random location\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/215/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/215/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/215/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/215/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/215/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/215/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/215/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/215/images/train_output_2.png"}]}, "index": 215, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, filling, color matching\n\n# description:\n# In the input, you will see a central colored star shape surrounded by black pixels. \n# To create the output, fill the star shape with a pattern where each arm of the star is filled with a color from the edges of the star. \n# The outer area of the star should be filled with the color of the center of the star.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid with the same dimensions as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find connected components to identify the star shape\n    background_color = Color.BLACK\n    star_shapes = find_connected_components(input_grid, background=background_color, connectivity=4, monochromatic=False)\n\n    # Process each detected star shape\n    for star in star_shapes:\n        # Get the bounding box of the star\n        x, y, w, h = bounding_box(star, background=background_color)\n        star_shape = crop(star, background=background_color)\n\n        # Identify the central color (the color of the \u0027center\u0027 of the star)\n        center_color = object_colors(star_shape, background=background_color)[0]\n        \n        # Fill the star shape with the center color first\n        output_grid[star != background_color] = center_color\n\n        # Now, fill in the arms of the star with the colors from the edges\n        edge_colors = []\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if abs(dx) + abs(dy) == 1:  # Check only direct neighbors\n                    edge_pixel = (x + dx, y + dy)\n                    if 0 \u003c= edge_pixel[0] \u003c output_grid.shape[0] and 0 \u003c= edge_pixel[1] \u003c output_grid.shape[1]:\n                        edge_color = output_grid[edge_pixel]\n                        if edge_color not in edge_colors and edge_color != background_color:\n                            edge_colors.append(edge_color)\n\n        # Fill each arm of the star with the corresponding edge color\n        if edge_colors:\n            for edge_color in edge_colors:\n                # Draw a line of the edge color from the center of the star outwards\n                draw_line(output_grid, x + w // 2, y + h // 2, color=edge_color, direction=(1, 0))\n                draw_line(output_grid, x + w // 2, y + h // 2, color=edge_color, direction=(-1, 0))\n                draw_line(output_grid, x + w // 2, y + h // 2, color=edge_color, direction=(0, 1))\n                draw_line(output_grid, x + w // 2, y + h // 2, color=edge_color, direction=(0, -1))\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid filled with black pixels\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Define the star shape\n    star_shape = np.full((5, 5), Color.BLACK)\n    star_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a simple star shape pattern\n    star_shape[1:4, 1] = star_color  # Vertical part\n    star_shape[2, 0] = star_color  # Left arm\n    star_shape[2, 4] = star_color  # Right arm\n    star_shape[0, 2] = star_color  # Top arm\n    star_shape[4, 2] = star_color  # Bottom arm\n\n    # Randomly place the star in the grid\n    x, y = random_free_location_for_sprite(grid, star_shape, background=Color.BLACK)\n    blit_sprite(grid, star_shape, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/216/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/216/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/216/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/216/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/216/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/216/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/216/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/216/images/train_output_2.png"}]}, "index": 216, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, object alignment, shifting\n\n# description:\n# In the input, you will see a grid containing several colored rectangles. Each rectangle is made up of connected non-black pixels.\n# To make the output, shift each rectangle to the right by one pixel, and fill the leftmost column of the output grid with black pixels.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all the connected components (rectangles) in the grid.\n    # 2. Create an output grid that is the same size as the input grid.\n    # 3. For each rectangle, shift it one pixel to the right in the output grid.\n    # 4. Fill the leftmost column with black pixels.\n\n    # 1. Extract the rectangles\n    rectangles = find_connected_components(input_grid, monochromatic=False)\n\n    # 2. Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 3. Shift each rectangle to the right\n    for rectangle in rectangles:\n        # Get the bounding box of the rectangle\n        x, y, width, height = bounding_box(rectangle)\n\n        # Shift the rectangle one pixel to the right\n        for i in range(width):\n            for j in range(height):\n                if rectangle[x + i, y + j] != Color.BLACK:\n                    output_grid[x + i, y + j] = rectangle[x + i, y + j]\n\n        # Ensure that the rectangle is shifted one pixel to the right\n        for i in range(width):\n            if y + i + 1 \u003c output_grid.shape[1]:  # check bounds\n                output_grid[x + i, y + j + 1] = rectangle[x + i, y + j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random rectangles\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly create 2 to 4 rectangles\n    n_rectangles = np.random.randint(2, 5)\n    for _ in range(n_rectangles):\n        # Create a random rectangle size\n        rect_width, rect_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        rectangle = np.full((rect_width, rect_height), Color.BLACK)\n\n        # Randomly color the rectangle\n        color = np.random.choice(Color.NOT_BLACK)\n        rectangle[:, :] = color\n\n        # Randomly place the rectangle in the grid\n        x, y = random_free_location_for_sprite(grid, rectangle)\n        blit_sprite(grid, rectangle, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/217/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/217/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/217/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/217/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/217/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/217/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/217/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/217/images/train_output_2.png"}]}, "index": 217, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change, noise removal\n\n# description:\n# In the input you will see a grid with several larger blue rectangles and random noise pixels (single blue or green pixels).\n# To make the output, if a noise pixel is adjacent to a blue rectangle, change its color to match that rectangle.\n# If a noise pixel is not adjacent to any rectangle, change its color to black (delete it).\n\ndef main(input_grid):\n    # Step 1: Find all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=Color.BLACK)\n    \n    # Step 2: Separate the rectangles from noise pixels\n    noise_pixels = [obj for obj in objects if np.sum(obj != Color.BLACK) == 1] # isolated pixels\n    rectangles = [obj for obj in objects if np.sum(obj != Color.BLACK) \u003e 1] # larger objects\n    \n    # Step 3: Create an output grid that starts as a copy of the input grid\n    output_grid = np.copy(input_grid)\n    \n    # Step 4: Process noise pixels\n    for noise in noise_pixels:\n        noise_mask = noise != Color.BLACK\n        noise_neighbors = object_neighbors(noise, background=Color.BLACK, connectivity=4)\n        \n        # Step 5: Check if this noise pixel is adjacent to any rectangle\n        for rect in rectangles:\n            rect_mask = rect != Color.BLACK\n            if np.sum(noise_neighbors \u0026 rect_mask) \u003e 0:\n                # If adjacent to a rectangle, change noise pixel color to that rectangle\u0027s color\n                rectangle_color = np.argmax(np.bincount(rect[rect_mask])) # finding the color of the rectangle\n                output_grid[noise_mask] = rectangle_color\n                break\n        else:\n            # If no rectangle was found adjacent, change the noise pixel to black\n            output_grid[noise_mask] = Color.BLACK\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a black background\n    w, h = np.random.randint(10, 20, size=2)\n    grid = np.full((w, h), Color.BLACK)\n\n    # Randomly create blue rectangles\n    rectangle_color = Color.BLUE\n    n_rectangles = np.random.randint(2, 5)  # Random number of rectangles\n\n    for _ in range(n_rectangles):\n        rw, rh = np.random.randint(3, 6), np.random.randint(3, 6)  # Random size for rectangles\n        sprite = np.full((rw, rh), rectangle_color)\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    # Randomly add noise pixels (single pixels)\n    n_noise_pixels = np.random.randint(5, 15)\n    for _ in range(n_noise_pixels):\n        x, y = np.random.randint(w), np.random.randint(h)\n        grid[x, y] = np.random.choice([Color.BLUE, Color.GREEN])  # Noise can be blue or green\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/218/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/218/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/218/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/218/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/218/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/218/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/218/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/218/images/train_output_2.png"}]}, "index": 218, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, color change, collision detection\n\n# description:\n# In the input you will see a grid with a blue object. \n# The goal is to translate the object up by 2 pixels and change its color to green.\n# However, if there is another colored object (not blue) directly above the blue object, \n# the blue object should not be moved, and its color should change to yellow instead.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the blue object\n    # 2. Check for collision with any object directly above the blue object\n    # 3. If there is a collision, change the color to yellow; otherwise, move it up and change the color to green\n\n    # 1. Get the single blue object\n    blue_objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    assert len(blue_objects) == 1\n    blue_object = blue_objects[0]\n\n    # Find the position of the blue object\n    blue_x, blue_y = object_position(blue_object)\n\n    # 2. Check for collision above\n    # Create a single pixel object to check for collisions\n    above_x, above_y = blue_x, blue_y - 1\n    above_pixel = np.array([[input_grid[above_x, above_y]]]) if above_x \u003e= 0 else np.full((1, 1), Color.BLACK)\n\n    # Check for collision with the above pixel\n    if collision(object1=blue_object, object2=above_pixel, x2=0, y2=-1, background=Color.BLACK):\n        # Change color to yellow since there is a collision\n        output_grid = np.full(input_grid.shape, Color.BLACK)\n        blit_object(output_grid, blue_object, background=Color.BLACK)\n        blue_object[blue_object != Color.BLACK] = Color.YELLOW\n        blit_object(output_grid, blue_object, background=Color.BLACK)\n    else:\n        # Move the blue object up by 2 pixels and change its color to green\n        output_grid = np.full(input_grid.shape, Color.BLACK)\n        blue_object[blue_object != Color.BLACK] = Color.GREEN\n        blue_object = translate(blue_object, x=0, y=-2, background=Color.BLACK)\n        blit_object(output_grid, blue_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a non-uniform distribution of colors and a single blue object.\n    width, height = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a blue object of random size\n    object_width, object_height = np.random.randint(1, 4), np.random.randint(1, 4)\n    blue_sprite = np.full((object_width, object_height), Color.BLUE)\n\n    # Find a location for the blue sprite\n    x, y = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK)\n    blit_sprite(grid, blue_sprite, x, y, background=Color.BLACK)\n\n    # Randomly place some other colored objects around the blue sprite\n    for _ in range(np.random.randint(0, 5)):\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.BLUE])\n        obj_width, obj_height = np.random.randint(1, 3), np.random.randint(1, 3)\n        other_sprite = np.full((obj_width, obj_height), color)\n        x, y = random_free_location_for_sprite(grid, other_sprite, background=Color.BLACK)\n        blit_sprite(grid, other_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/219/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/219/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/219/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/219/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/219/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/219/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/219/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/219/images/train_output_2.png"}]}, "index": 219, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid filling, bounding box, color extraction\n\n# description:\n# In the input, you will see a grid containing several colored shapes, each shape being a connected component. \n# The goal is to find the shape with the largest bounding box area and fill the entire grid with that shape\u0027s color. \n# If multiple shapes have the same maximum bounding box area, choose the first one you encounter.\n\ndef main(input_grid):\n    # 1. Find connected components in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    \n    # 2. Initialize variables to track the largest bounding box and its color\n    max_area = 0\n    max_color = Color.BLACK\n\n    # 3. Iterate through each component, calculate its bounding box, and determine its area\n    for component in components:\n        color = np.unique(component[component != Color.BLACK])\n        if len(color) == 1:  # Ensuring the component is monochromatic (only one color)\n            x1, y1, width, height = bounding_box(component, background=Color.BLACK)\n            area = width * height\n            \n            # 4. Update the maximum area and corresponding color if necessary\n            if area \u003e max_area:\n                max_area = area\n                max_color = color[0]\n\n    # 5. Create output grid filled with the color of the shape with the largest bounding box\n    output_grid = np.full(input_grid.shape, max_color, dtype=int)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random colors and shapes\n    height, width = np.random.randint(10, 20), np.random.randint(10, 20)\n    input_grid = np.full((height, width), Color.BLACK)\n    \n    num_shapes = np.random.randint(5, 10)\n    for _ in range(num_shapes):\n        # Randomly decide the shape\u0027s color\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Randomly generate the position and size of the shape\n        shape_height, shape_width = np.random.randint(2, 5), np.random.randint(2, 5)\n        x = np.random.randint(0, height - shape_height)\n        y = np.random.randint(0, width - shape_width)\n\n        # Place the shape in the grid\n        input_grid[x:x + shape_height, y:y + shape_width] = shape_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/220/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/220/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/220/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/220/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/220/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/220/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/220/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/220/images/train_output_2.png"}]}, "index": 220, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, enclosed regions, boundary detection\n\n# description:\n# The input grid consists of black and blue pixels. The blue pixels form boundaries that enclose certain areas of black pixels. \n# To create the output, identify the enclosed black regions surrounded by blue boundaries and color those regions orange.\n\ndef main(input_grid):\n    # Start with a copy of the input grid for the output\n    output_grid = input_grid.copy()\n\n    # Calculate the interior and boundary masks\n    interior_mask = object_interior(input_grid)\n    boundary_mask = object_boundary(input_grid)\n\n    # Identify the black pixels that are inside but not on the boundary\n    inside_but_not_on_edge = interior_mask \u0026 ~boundary_mask\n\n    # Color the enclosed regions orange\n    for x, y in np.argwhere(inside_but_not_on_edge):\n        if output_grid[x, y] == Color.BLACK:\n            output_grid[x, y] = Color.ORANGE\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a square grid with a black background, size from 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Randomly generate blue boundaries with some enclosed areas\n    n_objects = np.random.randint(1, 4)\n    for _ in range(n_objects):\n        # Create a random boundary sprite\n        width, height = np.random.randint(3, 6), np.random.randint(3, 6)\n        sprite = random_sprite(width, height, color_palette=[Color.BLUE], connectivity=8)\n\n        # Ensure the sprite forms a solid boundary\n        boundary_mask = object_boundary(sprite)\n        sprite[boundary_mask] = Color.BLUE\n\n        # Try to place the sprite randomly in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no free location is found, skip to the next sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/221/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/221/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/221/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/221/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/221/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/221/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/221/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/221/images/train_output_2.png"}]}, "index": 221, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, object placement, grid manipulation\n\n# description:\n# In the input, you will see a grid containing a few yellow objects on a black background, and a cluster of colored pixels located at random positions. \n# To create the output grid:\n# 1. Detect the yellow objects and calculate their centroid.\n# 2. Move the colored pixels towards the centroid of the yellow objects, filling any gaps with the background color.\n# 3. The output grid should include the translated colored pixels overlapping with the yellow objects.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Detect yellow objects in the input grid\n    yellow_objects = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n    \n    # Calculate the centroid of the yellow objects by averaging their positions\n    centroids = []\n    for obj in yellow_objects:\n        x, y, w, h = bounding_box(obj)\n        centroid_x = x + w // 2\n        centroid_y = y + h // 2\n        centroids.append((centroid_x, centroid_y))\n\n    # Average centroid position\n    if centroids:\n        avg_centroid_x = int(np.mean([c[0] for c in centroids]))\n        avg_centroid_y = int(np.mean([c[1] for c in centroids]))\n    else:\n        avg_centroid_x, avg_centroid_y = 0, 0\n\n    # Detect colored pixels on the grid excluding yellow and black\n    colored_pixels = detect_objects(grid=input_grid, colors=[c for c in Color.NOT_BLACK if c != Color.YELLOW], monochromatic=True, allowed_dimensions=[(1, 1)])\n\n    # Translate each colored pixel towards the centroid of the yellow objects\n    for pixel in colored_pixels:\n        pixel_x, pixel_y = np.where(pixel != Color.BLACK)\n        pixel_position = (pixel_x[0], pixel_y[0])  # Get the position of the pixel\n\n        # Calculate translation vector towards the centroid\n        translate_x = avg_centroid_x - pixel_position[0]\n        translate_y = avg_centroid_y - pixel_position[1]\n        \n        # Translate the pixel and blit it to the output grid\n        translated_pixel = translate(pixel, translate_x, translate_y, background=Color.BLACK)\n        blit_sprite(output_grid, translated_pixel, x=pixel_position[0] + translate_x, y=pixel_position[1] + translate_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a black background of size 10x10\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate yellow objects\n    for _ in range(np.random.randint(1, 4)):\n        yellow_sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[Color.YELLOW])\n        try:\n            x, y = random_free_location_for_sprite(grid, yellow_sprite, padding=1)\n            blit_sprite(grid, yellow_sprite, x=x, y=y)\n        except:\n            pass\n\n    # Randomly place colored pixels (not yellow or black) in the grid\n    num_colored_pixels = np.random.randint(5, 15)\n    for _ in range(num_colored_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:  # Ensure the position is not already colored\n            grid[x, y] = np.random.choice([c for c in Color.NOT_BLACK if c != Color.YELLOW])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/222/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/222/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/222/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/222/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/222/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/222/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/222/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/222/images/train_output_2.png"}]}, "index": 222, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape replication, rotation\n\n# description:\n# In the input, you will see a small object of a single color. \n# To make the output, replicate the object four times, rotating each replication 90 degrees counter-clockwise from the previous one, \n# and arrange them to form a new larger object.\n\ndef main(input_grid):\n    # 1. Find the single colored object\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=True, background=background)\n    \n    assert len(objects) == 1, \"There should be exactly one single-colored object\"\n    \n    small_object = objects[0]\n    \n    # 2. Crop the small object to its bounding box\n    cropped_object = crop(small_object, background=background)\n    \n    # Create an output grid large enough to accommodate the four rotations of the small object\n    output_size = (cropped_object.shape[0] * 2, cropped_object.shape[1] * 2)\n    output_grid = np.full(output_size, Color.BLACK)\n\n    # 3. Place the original and its rotations in the output grid\n    placements = [\n        (0, 0),                          # original\n        (0, cropped_object.shape[1]),   # 90 degrees\n        (cropped_object.shape[0], 0),    # 270 degrees\n        (cropped_object.shape[0], cropped_object.shape[1])  # 180 degrees\n    ]\n\n    for (dx, dy) in placements:\n        blit_sprite(output_grid, cropped_object, x=dx, y=dy, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a single-colored object randomly placed in the grid\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n    \n    # Create a single-colored sprite\n    color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(n=3, m=3, density=1, color_palette=[color], symmetry=\"not_symmetric\")\n    \n    # Randomly place the sprite on the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/223/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/223/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/223/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/223/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/223/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/223/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/223/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/223/images/train_output_2.png"}]}, "index": 223, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundaries, color transformation, bounding boxes\n\n# description:\n# In the input, you will see a grid with colored objects on a black background. Some objects may touch the edges of the grid. \n# The goal is to create an output grid where each object is transformed into a new color that is based on its position relative to the bounding box of the entire grid.\n# If the object is fully inside the bounding box (not touching any edge), change its color to BLUE. \n# If the object touches the top or bottom edge, change its color to GREEN. \n# If it touches the left or right edge, change its color to YELLOW. \n# If it touches multiple edges, change its color to ORANGE.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components (colored objects) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Determine the colors based on the edge conditions\n    for obj in objects:\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n        \n        touches_top = (x == 0)\n        touches_bottom = (x + height == input_grid.shape[0])\n        touches_left = (y == 0)\n        touches_right = (y + width == input_grid.shape[1])\n        \n        # Determine the new color based on edge touches\n        if touches_top or touches_bottom:\n            if touches_left or touches_right:\n                new_color = Color.ORANGE\n            else:\n                new_color = Color.GREEN\n        elif touches_left or touches_right:\n            new_color = Color.YELLOW\n        else:\n            new_color = Color.BLUE\n        \n        # Change the color of the object in the output grid\n        output_grid[obj == obj[0, 0]] = new_color  # Color the entire object\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid of random size between 8 and 12 for both dimensions\n    n = np.random.randint(8, 13)\n    m = np.random.randint(8, 13)\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Generate a random number of objects\n    num_objects = np.random.randint(2, 6)\n\n    for _ in range(num_objects):\n        # Create a random width and height for the object\n        width = np.random.randint(1, 4)\n        height = np.random.randint(1, 4)\n        \n        # Create an object with a random color from those available\n        color = np.random.choice([Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.PINK, Color.ORANGE, Color.TEAL, Color.MAROON])\n        object_sprite = np.full((width, height), color)\n\n        # Find a random location to place the object, ensuring it fits within the grid\n        x = np.random.randint(0, n - height + 1)\n        y = np.random.randint(0, m - width + 1)\n\n        # Blit the object onto the grid\n        blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/224/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/224/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/224/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/224/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/224/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/224/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/224/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/224/images/train_output_2.png"}]}, "index": 224, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, boundary detection, color filling\n\n# description:\n# In the input, you will see a grid with a colored shape that is touching one of the edges of the grid. \n# To create the output, translate the shape inward by one pixel, and fill the area it vacated with black pixels. \n# If the shape is already one pixel in from the nearest edge, it should remain unchanged.\n\ndef main(input_grid):\n    # Identify the background color\n    background = Color.BLACK\n\n    # Find the connected component of the main object\n    objects = find_connected_components(input_grid, background=background, connectivity=8, monochromatic=True)\n    assert len(objects) == 1, \"There should be exactly one object\"\n\n    main_object = objects[0]\n\n    # Detect the position of the main object\n    x1, y1 = object_position(main_object, anchor=\"upper left\")\n    x2, y2 = object_position(main_object, anchor=\"lower right\")\n\n    # Check if the object is touching any of the edges\n    touching_left = x1 == 0\n    touching_right = x2 == input_grid.shape[1] - 1\n    touching_top = y1 == 0\n    touching_bottom = y2 == input_grid.shape[0] - 1\n\n    # If the object is not touching any edge, return it unchanged\n    if not (touching_left or touching_right or touching_top or touching_bottom):\n        return input_grid\n\n    # Translate the object inward by one pixel\n    translated_object = translate(main_object, x=1 if not touching_left else 0, y=1 if not touching_top else 0)\n    translated_object = translate(translated_object, x=-1 if not touching_right else 0, y=-1 if not touching_bottom else 0)\n\n    # Create the output grid initialized to the background color\n    output_grid = np.full_like(input_grid, background)\n\n    # Blit the translated object into the output grid\n    blit_object(output_grid, translated_object)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size filled with a black background\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random color for the object\n    object_color = random.choice(Color.NOT_BLACK)\n\n    # Create a random shape and place it near the edge of the grid\n    shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    sprite = random_sprite(shape_width, shape_height, color_palette=[object_color])\n\n    # Randomly place the sprite at an edge\n    edge = np.random.choice([\u0027top\u0027, \u0027bottom\u0027, \u0027left\u0027, \u0027right\u0027])\n    if edge == \u0027top\u0027:\n        blit_sprite(grid, sprite, x=random.randint(0, m - shape_width), y=0)\n    elif edge == \u0027bottom\u0027:\n        blit_sprite(grid, sprite, x=random.randint(0, m - shape_width), y=n - shape_height)\n    elif edge == \u0027left\u0027:\n        blit_sprite(grid, sprite, x=0, y=random.randint(0, n - shape_height))\n    elif edge == \u0027right\u0027:\n        blit_sprite(grid, sprite, x=m - shape_width, y=random.randint(0, n - shape_height))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/225/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/225/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/225/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/225/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/225/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/225/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/225/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/225/images/train_output_2.png"}]}, "index": 225, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, filling gaps\n\n# description:\n# In the input you will see a 2D grid with a central object that has holes (colored pixels missing) and is surrounded by a symmetrical border.\n# To make the output, you should identify the symmetry of the border, then fill in the holes of the central object such that it becomes symmetrical with respect to the detected border.\n\ndef main(input_grid):\n    # Define background color\n    background_color = Color.BLACK\n\n    # Step 1: Identify the outer symmetrical border\n    border_symmetries = detect_mirror_symmetry(input_grid, ignore_colors=[background_color], background=background_color)\n\n    # Step 2: Extract the central object (non-border area)\n    output_grid = input_grid.copy()\n    for x, y in np.argwhere(input_grid != background_color):\n        # Step 3: Fill the holes in the central object using the detected symmetries\n        for symmetry in border_symmetries:\n            # Get the mirror position for the current pixel\n            mirror_x, mirror_y = symmetry.apply(x, y)\n            # If the mirror position is within bounds and not background, fill it\n            if (0 \u003c= mirror_x \u003c output_grid.shape[0]) and (0 \u003c= mirror_y \u003c output_grid.shape[1]):\n                output_grid[mirror_x, mirror_y] = output_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a central symmetric object\n    object_color = np.random.choice(Color.NOT_BLACK)\n    object_sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), \n                                   color_palette=[object_color], symmetry=\u0027mirror\u0027)\n\n    # Create a border around the central object\n    border_color = np.random.choice(Color.NOT_BLACK)\n    border_length = max(object_sprite.shape) + 4  # Make room for a border\n    border_sprite = random_sprite(n=border_length, m=border_length, \n                                   color_palette=[border_color], symmetry=\u0027mirror\u0027)\n\n    # Place the border in the center of the grid\n    border_x = (n - border_length) // 2\n    border_y = (m - border_length) // 2\n    blit_sprite(grid, border_sprite, x=border_x, y=border_y)\n\n    # Place the central object in the center\n    object_x = border_x + 2  # Offset for central alignment\n    object_y = border_y + 2\n    blit_sprite(grid, object_sprite, x=object_x, y=object_y)\n\n    # Introduce holes into the central object\n    for _ in range(np.random.randint(1, 6)):  # Randomly create between 1 to 5 holes\n        hole_x = np.random.randint(object_x, object_x + object_sprite.shape[0])\n        hole_y = np.random.randint(object_y, object_y + object_sprite.shape[1])\n        grid[hole_x, hole_y] = Color.BLACK  # Make it a hole\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/226/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/226/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/226/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/226/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/226/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/226/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/226/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/226/images/train_output_2.png"}]}, "index": 226, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape counting, color transformation, bounding box\n\n# description:\n# In the input, you will see several shapes of different colors on a black background. \n# Each shape is uniquely colored. The output grid should change the color of the shape with the least pixels to green, \n# and the shape with the most pixels to green.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all the shapes (connected components) in the grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=background)\n    \n    # Calculate the area of each shape and store them with their colors\n    areas = {}\n    for obj in objects:\n        color = obj[0, 0]  # the color of the shape\n        area = np.sum(obj != background)\n        areas[color] = area\n    \n    # Determine the colors of the smallest and largest shapes\n    smallest_color = min(areas, key=areas.get)\n    largest_color = max(areas, key=areas.get)\n\n    # Change the colors in the output grid\n    output_grid[input_grid == smallest_color] = Color.GREEN\n    output_grid[input_grid == largest_color] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of a random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # We\u0027ll create a random number of shapes\n    num_shapes = np.random.randint(3, 7)\n    colors_used = set()\n    \n    for _ in range(num_shapes):\n        # Generate a random sprite for the shape\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n        sprite = random_sprite(w, h, color_palette=list(Color.NOT_BLACK), density=0.5)\n        \n        # Make sure the color of the shape is unique\n        while True:\n            shape_color = np.random.choice(list(Color.NOT_BLACK))\n            if shape_color not in colors_used:\n                colors_used.add(shape_color)\n                break\n\n        # Place the shape on the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        sprite[sprite != Color.BLACK] = shape_color\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/227/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/227/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/227/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/227/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/227/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/227/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/227/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/227/images/train_output_2.png"}]}, "index": 227, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, topology, color transformation\n\n# description:\n# In the input grid, you will see various colored objects. Some of these objects are \"hollow\" (they have a fully-enclosed interior), while others are solid (filled). \n# To create the output grid, copy the input grid. Change the color of all hollow objects to green, while leaving solid objects unchanged.\n\ndef main(input_grid):\n    # Extract the connected components (objects) from the input grid\n    objects = find_connected_components(input_grid, connectivity=4)\n    \n    # Create a copy of the input grid for output\n    output_grid = input_grid.copy()\n    \n    # Process each object to determine if it is hollow\n    for obj in objects:\n        # Check if the object is hollow\n        if is_hollow(obj):\n            # Change the color of the hollow object to green\n            output_grid[obj != Color.BLACK] = Color.GREEN\n            \n    return output_grid\n\ndef is_hollow(object):\n    # Use the object_interior function to find the interior of the object\n    interior_mask = object_interior(object)\n    object_mask = object != Color.BLACK\n    \n    # A hollow object will have some interior area that is not part of the object\n    hollow_mask = interior_mask \u0026 ~object_mask\n    return np.any(hollow_mask)\n\ndef generate_input():\n    # Create a grid of random size\n    n = np.random.randint(10, 28)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Randomly create a number of objects, some of which will be hollow and some solid\n    def random_hollow_object():\n        n, m = np.random.randint(3, 7), np.random.randint(3, 7)\n        obj = np.full((n, m), Color.BLUE)\n        obj[1:n-1, 1:m-1] = Color.BLACK  # Create a hollow square\n        return obj\n\n    def random_filled_object():\n        n, m = np.random.randint(3, 7), np.random.randint(3, 7)\n        obj = np.full((n, m), Color.BLUE)\n        return obj  # Fully filled object\n\n    # Ensure at least one hollow and one filled object\n    try:\n        obj = random_hollow_object()\n        x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n        blit_sprite(input_grid, obj, x=x, y=y)\n\n        obj = random_filled_object()\n        x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n        blit_sprite(input_grid, obj, x=x, y=y)\n    except ValueError:\n        return generate_input()\n\n    # Fill the grid with random objects\n    for _ in range(np.random.randint(3, 10)):\n        obj = random_hollow_object() if np.random.rand() \u003c 0.5 else random_filled_object()\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            continue  # Skip if no valid position found\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/228/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/228/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/228/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/228/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/228/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/228/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/228/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/228/images/train_output_2.png"}]}, "index": 228, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cropping, framing, coloring\n\n# description:\n# In the input, you will see a grid with various colored circles of different sizes.\n# To create the output grid, you need to:\n# 1. Crop each circle to its smallest bounding box.\n# 2. Draw a square frame around each cropped circle, using the color GREEN.\n# 3. The frame should be twice the size of the cropped circle.\n# 4. Fill the area inside the frame with the color YELLOW.\n\ndef main(input_grid):\n    # 1. Find all circle objects\n    circle_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # The output grid is initialized with the background color\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for circle in circle_objects:\n        # 2. Crop the circle to its smallest bounding box\n        cropped_circle = crop(circle, background=Color.BLACK)\n        circle_height, circle_width = cropped_circle.shape\n\n        # 3. Determine the coordinates for the frame\n        x, y, _, _ = bounding_box(cropped_circle, background=Color.BLACK)\n        \n        # Calculate frame dimensions\n        frame_size = max(circle_height, circle_width) * 2\n        frame_x = x - (frame_size - circle_width) // 2\n        frame_y = y - (frame_size - circle_height) // 2\n\n        # 4. Draw the GREEN frame around the cropped circle\n        green_frame = np.full((frame_size, frame_size), Color.GREEN)\n        blit_sprite(output_grid, green_frame, frame_x, frame_y, background=Color.BLACK)\n\n        # 5. Fill the area inside the frame with YELLOW\n        output_grid[frame_y:frame_y + frame_size, frame_x:frame_x + frame_size] = Color.YELLOW\n        # Place the cropped circle back in the center of the frame\n        blit_sprite(output_grid, cropped_circle, frame_x + (frame_size - circle_width) // 2, frame_y + (frame_size - circle_height) // 2, background=Color.YELLOW)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a black grid of random size\n    width = np.random.randint(10, 20)\n    height = np.random.randint(10, 20)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly generate circles on the grid\n    num_circles = np.random.randint(1, 5)  # Number of circles\n    for _ in range(num_circles):\n        radius = np.random.randint(1, 4)  # Random radius\n        circle_sprite = np.zeros((radius * 2, radius * 2), dtype=int)\n        \n        # Create a filled circle\n        for x in range(circle_sprite.shape[0]):\n            for y in range(circle_sprite.shape[1]):\n                if (x - radius) ** 2 + (y - radius) ** 2 \u003c= radius ** 2:\n                    circle_sprite[x, y] = Color.RED  # Color of the circle\n        \n        # Find a random location to place the circle\n        try:\n            x, y = random_free_location_for_sprite(grid, circle_sprite, background=Color.BLACK, padding=1)\n            blit_sprite(grid, circle_sprite, x, y, background=Color.BLACK)\n        except:\n            continue  # Skip if there\u0027s no space\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/229/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/229/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/229/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/229/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/229/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/229/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/229/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/229/images/train_output_2.png"}]}, "index": 229, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, color transformation, positioning\n\n# description:\n# In the input you will see a grid with several colored objects on a black background.\n# Each object is surrounded by black pixels, and the goal is to transform the grid by \n# creating a new grid that retains the original object colors, but places them \n# in the top-left corner of the grid, one after another, preserving their bounding boxes.\n# The output should be arranged in a manner such that no two objects overlap.\n\ndef main(input_grid):\n    # Step 1: Detect all the objects in the grid\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=4)\n    output_grid = np.full(input_grid.shape, Color.BLACK)  # Start with a black grid\n\n    # Step 2: Calculate the positions for each object in the output grid\n    current_y = 0  # The current position in the output grid for the next object\n    for obj in objects:\n        bounding_box = bounding_box_mask(obj)  # Get the bounding box for the current object\n\n        # Calculate the position to place the object in the output grid\n        height, width = bounding_box.shape\n        if current_y + height \u003e output_grid.shape[0]:  # If we run out of vertical space, stop\n            break\n        \n        # Place the object in the output grid at the current position\n        x_offset, y_offset = object_position(obj, background=Color.BLACK)\n        blit_sprite(output_grid, obj, x=0, y=current_y)\n        \n        # Move the current_y down by the height of the bounding box for the next object\n        current_y += height\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 20x20 with random objects\n    grid_size = 20\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly generate a few objects to place in the grid\n    num_objects = np.random.randint(3, 6)  # Between 3 and 5 objects\n    for _ in range(num_objects):\n        obj = random_sprite(n=np.random.randint(2, 5), m=np.random.randint(2, 5), density=0.5, connectivity=4)\n        x, y = random_free_location_for_sprite(grid, sprite=obj, background=Color.BLACK)\n        blit_sprite(grid, sprite=obj, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/230/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/230/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/230/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/230/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/230/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/230/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/230/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/230/images/train_output_2.png"}]}, "index": 230, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, translation, color matching\n\n# description:\n# In the input, you will see a small red square on a black background and several larger scattered blue pixels.\n# To make the output, isolate the small red square and then scale it up by a factor of 3. \n# Match the colors of the scaled square with the blue pixels, placing the scaled square over the blue pixels wherever they overlap.\n\ndef main(input_grid):\n    # 1. Detect the small red square\n    red_square_coords = np.argwhere(input_grid == Color.RED)\n    assert len(red_square_coords) == 1, \"There should be exactly one red square\"\n    \n    red_x, red_y = red_square_coords[0]\n    \n    # 2. Crop the red square to create the sprite\n    red_sprite = np.array([[Color.RED]])\n    \n    # 3. Scale the sprite by a factor of 3\n    scaled_sprite = scale_sprite(red_sprite, factor=3)\n\n    # 4. Create the output grid and fill it with the original input grid\n    output_grid = np.copy(input_grid)\n\n    # 5. Try to place the scaled sprite over the blue pixels\n    for dx in range(output_grid.shape[0] - scaled_sprite.shape[0] + 1):\n        for dy in range(output_grid.shape[1] - scaled_sprite.shape[1] + 1):\n            # Check if the placement overlaps with blue pixels\n            placement_area = output_grid[dx:dx + scaled_sprite.shape[0], dy:dy + scaled_sprite.shape[1]]\n            if np.any((placement_area == Color.BLUE) \u0026 (scaled_sprite == Color.RED)):\n                # Place the scaled sprite\n                output_grid[dx:dx + scaled_sprite.shape[0], dy:dy + scaled_sprite.shape[1]] = scaled_sprite\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid as the background\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place a small red square in the grid\n    red_x = np.random.randint(0, width)\n    red_y = np.random.randint(0, height)\n    grid[red_x, red_y] = Color.RED\n\n    # Scatter some blue pixels randomly in the grid\n    n_blue_pixels = np.random.randint(5, 15)\n    for _ in range(n_blue_pixels):\n        blue_x, blue_y = np.random.randint(0, width), np.random.randint(0, height)\n        # Ensure we don\u0027t place over the red square\n        while grid[blue_x, blue_y] != Color.BLACK:\n            blue_x, blue_y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[blue_x, blue_y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/231/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/231/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/231/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/231/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/231/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/231/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/231/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/231/images/train_output_2.png"}]}, "index": 231, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, color filling, pattern creation\n\n# description:\n# In the input, you will see a colored object (not black) surrounded by a black background.\n# To make the output, find the bounding box of the colored object and fill that area with green.\n# If the bounding box is larger than a specific size, change the color of the pixels inside the box to pink instead.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find connected components to extract the colored object\n    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n    \n    # There should be at least one colored object\n    assert len(objects) \u003e 0, \"No colored object found in the input.\"\n\n    # Get the first colored object\n    colored_object = objects[0]\n    \n    # Find the bounding box of the colored object\n    x, y, width, height = bounding_box(colored_object)\n\n    # Create output grid\n    output_grid = np.copy(input_grid)\n\n    # Determine fill color based on the size of the bounding box\n    fill_color = Color.GREEN\n    if width * height \u003e 20:  # Arbitrary threshold for larger boxes\n        fill_color = Color.PINK\n\n    # Fill the bounding box area with the selected color\n    output_grid[x:x + width, y:y + height] = fill_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random size with a colored object in it\n    width, height = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a random colored object\n    object_width, object_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    x_start, y_start = np.random.randint(0, width - object_width), np.random.randint(0, height - object_height)\n\n    # Choose a color for the object (not black)\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Draw the colored object in the grid\n    draw_line(grid, x=x_start, y=y_start, length=object_height, direction=(1, 0), color=color)\n    draw_line(grid, x=x_start, y=y_start + object_height - 1, length=object_width, direction=(0, 1), color=color)\n    draw_line(grid, x=x_start + object_width - 1, y=y_start, length=object_height, direction=(1, 0), color=color)\n    draw_line(grid, x=x_start, y=y_start, end_x=x_start + object_width - 1, end_y=y_start + object_height - 1, color=color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/232/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/232/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/232/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/232/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/232/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/232/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/232/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/232/images/train_output_2.png"}]}, "index": 232, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color, pattern creation, centered object\n\n# description:\n# In the input, you will see a single blue pixel. \n# To create the output grid, you should:\n# 1. Draw a pattern of four different colors centered at the blue pixel\u0027s location:\n#    orange in the upper left, yellow in the upper right, blue in the lower left, and grey in the lower right.\n# 2. Remove the blue pixel (equivalently start with a blank canvas and draw the pattern at the blue pixel\u2019s location).\n\ndef main(input_grid):\n    # Find the blue single pixel object\n    blue_pixel_objects = find_connected_components(grid=input_grid, background=Color.BLACK, monochromatic=True)\n    assert len(blue_pixel_objects) == 1\n    blue_pixel_object = blue_pixel_objects[0]\n\n    # Find out the position of the blue pixel\n    blue_x, blue_y = object_position(blue_pixel_object, background=Color.BLACK, anchor=\"upper left\")\n\n    # Construct the specific pattern that is going to be drawn where the blue pixel was\n    pattern = np.array([[Color.ORANGE, Color.YELLOW],\n                        [Color.BLUE, Color.GREY]])\n\n    # The output grid is the same size of input grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Calculate the position where the pattern\u0027s upper left corner should be\n    pattern_x = blue_x\n    pattern_y = blue_y\n\n    # Blit the pattern onto the output grid\n    blit_sprite(output_grid, pattern, x=pattern_x, y=pattern_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = 5, 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select the position of the blue pixel and draw it.\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = Color.BLUE\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/233/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/233/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/233/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/233/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/233/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/233/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/233/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/233/images/train_output_2.png"}]}, "index": 233, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, shape matching, object extraction\n\n# description:\n# In the input, there are two identical shapes of different sizes and colors. The smaller shape is in the center of the grid, while the larger shape is around it.\n# The task is to return the smaller shape, but scaled up to the same size as the larger shape. The output should preserve the color of the smaller shape.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the background color\n    # 2. Extract objects by color\n    # 3. Identify the smaller and larger objects\n    # 4. Scale the smaller object to the size of the larger object\n    # 5. Place the scaled object in the output grid\n\n    # 1. Determine the background color, which is the most common color in the grid\n    colors = np.unique(input_grid)\n    background = colors[np.argmax([np.sum(input_grid == c) for c in colors])]\n    object_colors = [c for c in colors if c != background]\n\n    # 2. Extract the objects by their colors\n    objects = []\n    for color in object_colors:\n        obj = np.copy(input_grid)\n        obj[input_grid != color] = background\n        objects.append((color, obj))\n\n    # 3. Identify the smaller and larger objects\n    smaller_object = None\n    larger_object = None\n\n    for color, obj in objects:\n        if not smaller_object or np.sum(obj != background) \u003c np.sum(smaller_object[1] != background):\n            larger_object = smaller_object\n            smaller_object = (color, obj)\n        elif not larger_object or np.sum(obj != background) \u003e np.sum(larger_object[1] != background):\n            larger_object = (color, obj)\n\n    # Ensure we found two objects\n    assert smaller_object is not None and larger_object is not None, \"Should find both a smaller and a larger object\"\n\n    # 4. Scale the smaller object to match the size of the larger object\n    scaled_smaller_object = scale_sprite(smaller_object[1], factor=int(np.sqrt(np.sum(larger_object[1] != background) / np.sum(smaller_object[1] != background))))\n\n    # 5. Prepare the output grid\n    output_grid = np.full_like(input_grid, background)\n\n    # Place the scaled smaller object in the output grid centered over the original position\n    center_x, center_y = object_position(smaller_object[1], background=background, anchor=\"center\")\n    scaled_width, scaled_height = scaled_smaller_object.shape\n    x_offset = center_x - scaled_width // 2\n    y_offset = center_y - scaled_height // 2\n\n    blit_sprite(output_grid, scaled_smaller_object, x=x_offset, y=y_offset, background=background)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random background color and place two shapes of the same form but different sizes and colors.\n    background = Color.BLACK\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), background)\n\n    # Create a smaller object\n    small_color = random.choice(Color.NOT_BLACK)\n    small_shape = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=[small_color], background=background)\n    \n    # Place the small shape in the grid\n    x, y = random_free_location_for_sprite(grid, small_shape, background=background)\n    blit_sprite(grid, small_shape, x=x, y=y, background=background)\n\n    # Create a larger object by scaling the smaller one\n    scale_factor = np.random.randint(2, 4)  # Scale the small object by a factor of 2 to 3\n    large_shape = scale_sprite(small_shape, scale_factor)\n    large_color = random.choice([c for c in Color.NOT_BLACK if c != small_color])\n    large_shape[large_shape != background] = large_color\n\n    # Place the large shape in the grid, allowing partial overlap\n    x_offset = np.random.randint(-5, 5)\n    y_offset = np.random.randint(-5, 5)\n    blit_sprite(grid, large_shape, x=x + x_offset, y=y + y_offset, background=background)\n\n    # Return the generated grid\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/234/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/234/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/234/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/234/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/234/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/234/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/234/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/234/images/train_output_2.png"}]}, "index": 234, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, object interior, color transformation\n\n# description:\n# In the input, you will see several colored objects, and one object is surrounded by a grey border. \n# To create the output, you should change the color of the enclosed object to the color of the grey border,\n# but only if the color of the border matches the color of the pixels on the interior of the enclosed object.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all objects in the grid\n    # 2. Identify the grey bordered object and its interior\n    # 3. Check if the interior of the grey bordered object matches the color of the grey border\n    # 4. Change the color of the enclosed object to the color of the grey border\n\n    # 1. Detect all objects in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    grey_borders = []\n    for obj in objects:\n        if Color.GREY in object_colors(obj, background=Color.BLACK):\n            grey_borders.append(obj)\n\n    # There should only be one grey bordered object\n    assert len(grey_borders) \u003c= 1\n    if len(grey_borders) == 0:\n        return input_grid  # No grey border found, return the original grid\n\n    grey_object = grey_borders[0]\n    \n    # 2. Compute the interior of the grey bordered object\n    interior_mask = object_interior(grey_object, background=Color.BLACK)\n    \n    # 3. Check the color of the grey border\n    border_color = Color.GREY  # The border color itself\n    interior_colors = np.unique(input_grid[interior_mask])\n    interior_colors = interior_colors[interior_colors != Color.BLACK]  # Exclude black\n\n    if border_color in interior_colors:\n        new_color = border_color\n    else:\n        return input_grid  # No color change if the interior doesn\u0027t match the grey color\n\n    # 4. Change the color of the enclosed object to the color of the grey border\n    output_grid = np.copy(input_grid)\n    output_grid[interior_mask] = new_color  # Fill the interior with the new color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random dimensions.\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random colored object to be enclosed.\n    enclosed_color = np.random.choice(Color.NOT_BLACK)\n    enclosed_object = random_sprite(3, 3, color_palette=[enclosed_color])\n\n    # Place the enclosed object at a random position in the grid.\n    x, y = random_free_location_for_sprite(grid, enclosed_object, background=Color.BLACK)\n    blit_sprite(grid, enclosed_object, x, y)\n\n    # Create a grey border around the enclosed object.\n    grey_border = np.full((5, 5), Color.GREY)\n    grey_border[1:-1, 1:-1] = Color.BLACK  # Make the interior black\n    blit_sprite(grid, grey_border, x - 1, y - 1)\n\n    # Add some additional random colored objects around the grid.\n    for _ in range(np.random.randint(1, 5)):\n        random_color = np.random.choice(Color.NOT_BLACK)\n        random_object = random_sprite(2, 2, color_palette=[random_color])\n        rand_x, rand_y = random_free_location_for_sprite(grid, random_object, background=Color.BLACK)\n        blit_sprite(grid, random_object, rand_x, rand_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/235/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/235/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/235/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/235/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/235/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/235/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/235/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/235/images/train_output_2.png"}]}, "index": 235, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color replacement, blitting, grid manipulation\n\n# description:\n# In the input you will see a grid with a single colored pixel in one of the corners and a set of colored pixels scattered throughout the grid.\n# All pixels that match the color of the corner pixel should be replaced with a gray pixel, and the rest should remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Get the color of the corner pixel\n    corner_color = output_grid[0, 0]\n    \n    # Replace all pixels matching the corner color with gray\n    output_grid[output_grid == corner_color] = Color.GRAY\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a corner color from the available colors\n    corner_color = random.choice(Color.NOT_BLACK)\n    grid[0, 0] = corner_color  # Set the corner pixel\n\n    # Fill the rest of the grid with random colors, including the corner color\n    for i in range(n):\n        for j in range(m):\n            if (i, j) != (0, 0):  # Skip the corner pixel\n                grid[i, j] = random.choice(Color.ALL_COLORS)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/236/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/236/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/236/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/236/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/236/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/236/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/236/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/236/images/train_output_2.png"}]}, "index": 236, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color blending, spatial transformation\n\n# description:\n# In the input, you will see a grid with a central pattern composed of several colored pixels. \n# The grid also has a colored border surrounding the central pattern. \n# To make the output, you should extract the central pattern, blend its colors with the border color, \n# and then place the blended pattern back into the middle of a new grid that is larger than the original.\n\ndef main(input_grid):\n    # 1. Crop the central pattern from the input\n    central_pattern = crop(input_grid, background=Color.BLACK)\n\n    # 2. Identify the border color by examining the pixels surrounding the central pattern\n    top_border_color = input_grid[0, :].max()\n    bottom_border_color = input_grid[-1, :].max()\n    left_border_color = input_grid[:, 0].max()\n    right_border_color = input_grid[:, -1].max()\n\n    # Assuming a uniform border color\n    border_color = Color.BLACK\n    if top_border_color != Color.BLACK:\n        border_color = top_border_color\n    elif bottom_border_color != Color.BLACK:\n        border_color = bottom_border_color\n    elif left_border_color != Color.BLACK:\n        border_color = left_border_color\n    elif right_border_color != Color.BLACK:\n        border_color = right_border_color\n\n    # 3. Blend the central pattern colors with the border color\n    blended_pattern = np.where(central_pattern != Color.BLACK, central_pattern, border_color)\n\n    # 4. Create a new grid larger than the central pattern to place the blended pattern in the center\n    new_height = blended_pattern.shape[0] + 2\n    new_width = blended_pattern.shape[1] + 2\n    output_grid = np.full((new_height, new_width), Color.BLACK)\n\n    # 5. Place the blended pattern in the center of the new grid\n    output_grid[1:-1, 1:-1] = blended_pattern\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random-sized grid with a border around a central pattern\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    \n    # Create a grid and fill it with black\n    grid = np.full((n + 2, m + 2), Color.BLACK)\n\n    # Randomly choose a color for the border\n    border_color = np.random.choice(Color.NOT_BLACK)\n    grid[0, :] = border_color\n    grid[-1, :] = border_color\n    grid[:, 0] = border_color\n    grid[:, -1] = border_color\n\n    # Generate a random central pattern\n    central_pattern = random_sprite(n, m, density=0.4, color_palette=list(Color.NOT_BLACK))\n\n    # Place the central pattern in the middle of the border grid\n    grid[1:-1, 1:-1] = central_pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/237/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/237/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/237/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/237/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/237/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/237/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/237/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/237/images/train_output_2.png"}]}, "index": 237, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, color filling, grid transformation\n\n# description:\n# In the input, you will see a black grid containing a series of colored lines (horizontal or vertical) and a gray square\n# To create the output grid, fill the gray square with the colors of the lines in the order they appear from top to bottom or left to right.\n\ndef main(input_grid):\n    # Step 1: Detect the gray square in the input grid\n    gray_squares = detect_objects(grid=input_grid, colors=[Color.GRAY], monochromatic=True, connectivity=4)\n    assert len(gray_squares) == 1, \"There should be exactly one gray square in the input grid\"\n    gray_square = gray_squares[0]\n\n    # Step 2: Crop the gray square to determine its size\n    output_grid = crop(gray_square)\n\n    # Step 3: Detect the color lines in the input grid\n    color_lines = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n    colors_in_order = []\n    \n    for line in color_lines:\n        # Get the position and size of the color line\n        x_pos, y_pos, x_len, y_len = bounding_box(grid=line)\n        color = line[x_pos, y_pos]\n        \n        if color != Color.GRAY:\n            # Store the color in the order they appear\n            colors_in_order.append(color)\n    \n    # Step 4: Fill the gray square with the colors of the lines in the order they appear\n    num_colors = output_grid.shape[0]  # Assuming the gray square is square-shaped\n\n    for i in range(num_colors):\n        if i \u003c len(colors_in_order):\n            draw_line(grid=output_grid, x=0, y=i, direction=(1, 0), color=colors_in_order[i])\n        else:\n            break  # No more colors to fill\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid, ensuring it\u0027s large enough for the gray square\n    n, m = np.random.randint(9, 15), np.random.randint(9, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Randomly determine the size of the gray square\n    square_size = np.random.randint(2, 6)\n    \n    # Draw the gray square in the grid\n    square_x, square_y = np.random.randint(0, n - square_size), np.random.randint(0, m - square_size)\n    gray_square = np.full((square_size, square_size), Color.GRAY)\n    grid = blit_sprite(grid, gray_square, square_x, square_y)\n\n    # Randomly generate colored lines around the gray square\n    num_lines = np.random.randint(3, 6)\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.GRAY]\n    \n    # Generate random horizontal or vertical lines\n    for _ in range(num_lines):\n        color = np.random.choice(available_colors)\n        is_horizontal = np.random.choice([True, False])\n        \n        if is_horizontal:\n            y_pos = np.random.randint(0, n)\n            draw_line(grid=grid, x=0, y=y_pos, direction=(1, 0), color=color)\n        else:\n            x_pos = np.random.randint(0, m)\n            draw_line(grid=grid, x=x_pos, y=0, direction=(0, 1), color=color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/238/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/238/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/238/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/238/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/238/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/238/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/238/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/238/images/train_output_2.png"}]}, "index": 238, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, pattern placement\n\n# description:\n# The input consists of a grid with several red objects of varying sizes.\n# The goal is to detect these red objects and replace them with a yellow square of the same size, placing it in the center of the detected red object.\n\ndef main(input_grid):\n    # Detect all red objects in the grid\n    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n\n    # Create an output grid initialized with the input grid\n    output_grid = input_grid.copy()\n\n    for obj in red_objects:\n        # Get the bounding box to find the center of the red object\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        \n        # Calculate the center position\n        center_x = x + w // 2\n        center_y = y + h // 2\n        \n        # Create a yellow square of the same size as the red object\n        yellow_square = np.full(obj.shape, Color.YELLOW)\n        \n        # Place the yellow square centered on the red object\u0027s position\n        blit_sprite(output_grid, yellow_square, x=center_x - w // 2, y=center_y - h // 2, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size (10x10 to 20x20)\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate red objects\n    for _ in range(np.random.randint(3, 10)):\n        # Random size and position for the red object\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n        obj = random_sprite(w, h, color_palette=[Color.RED])\n        \n        # Find a free location to place the red object\n        x, y = random_free_location_for_sprite(grid, obj)\n        blit_sprite(grid, obj, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/239/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/239/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/239/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/239/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/239/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/239/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/239/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/239/images/train_output_2.png"}]}, "index": 239, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color matching, object fitting, interior detection\n\n# description:\n# In the input you will see several colored rectangular objects on a black background, each with a black hollow square hole inside. \n# The holes are perfect squares and there are additional solid squares of various colors. \n# To make the output, check if each colored square perfectly fits inside the black hole of any rectangular object. \n# If it fits, place the colored square inside the hole. If it doesn\u0027t fit, leave it as is.\n\ndef main(input_grid):\n    # Step 1: Identify the grey rectangular objects and the holes inside them.\n    grey_input = input_grid.copy()\n    grey_input[input_grid != Color.GREY] = Color.BLACK\n    grey_objects = find_connected_components(grey_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Step 2: Extract the interiors of the holes (which are black).\n    hole_interiors = [object_interior(obj, background=Color.BLACK) \u0026 (obj == Color.BLACK) for obj in grey_objects]\n\n    # Step 3: Identify all the colored squares that are not part of the grey objects.\n    non_grey_input = input_grid.copy()\n    non_grey_input[input_grid == Color.GREY] = Color.BLACK\n    colored_squares = find_connected_components(non_grey_input, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Step 4: Prepare the output grid (start with a copy of the input).\n    output_grid = np.copy(input_grid)\n\n    # Step 5: Check each colored square to see if it fits into any of the holes.\n    for square in colored_squares:\n        square_mask = crop(square, background=Color.BLACK) != Color.BLACK  # Create a mask of the current square.\n        square_shape = square_mask.shape\n\n        for interior in hole_interiors:\n            # Check if this hole\u0027s interior can accommodate the square.\n            interior_mask = crop(interior, background=Color.BLACK) != Color.BLACK  # Mask for the hole\u0027s interior.\n            if interior_mask.shape == square_shape and np.array_equal(interior_mask, square_mask):\n                # If it fits, place it in the hole\u0027s position.\n                hole_x, hole_y, _, _ = bounding_box(interior)\n                blit_sprite(output_grid, square, hole_x, hole_y, background=Color.BLACK)\n                # Clear the original location of the square.\n                output_grid[square != Color.BLACK] = Color.BLACK\n                break  # Move to the next square after placing it.\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 25, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    n_grey_objects = np.random.randint(1, 4)\n    for _ in range(n_grey_objects):\n        grey_width, grey_height = np.random.randint(5, 8, size=2)\n        grey_sprite = np.full((grey_width, grey_height), Color.GREY)\n\n        # Create a black hole in the grey object.\n        hole_size = np.random.randint(2, min(grey_width, grey_height) - 1)  # Ensure the hole is smaller than the grey object.\n        hole_sprite = np.full((hole_size, hole_size), Color.BLACK)\n        hole_x, hole_y = random_free_location_for_sprite(grey_sprite, hole_sprite, border_size=1, background=Color.GREY)\n        blit_sprite(grey_sprite, hole_sprite, hole_x, hole_y, background=Color.GREY)\n\n        # Place the grey object in the input grid.\n        x, y = random_free_location_for_sprite(input_grid, grey_sprite, padding=1)\n        blit_sprite(input_grid, grey_sprite, x, y, background=Color.BLACK)\n\n        # Add a solid colored square that fits into the hole.\n        color = np.random.choice(Color.NOT_BLACK)\n        colored_square = np.full((hole_size, hole_size), color)\n        blit_sprite(input_grid, colored_square, x + hole_x, y + hole_y, background=Color.BLACK)\n\n    # Optionally add additional distractor colored squares.\n    n_distracter_objects = np.random.randint(5, 10)\n    for _ in range(n_distracter_objects):\n        distractor_size = np.random.randint(1, 3)\n        distractor_color = np.random.choice(Color.NOT_BLACK)\n        distractor_sprite = np.full((distractor_size, distractor_size), distractor_color)\n        x, y = random_free_location_for_sprite(input_grid, distractor_sprite, padding=1)\n        blit_sprite(input_grid, distractor_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/240/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/240/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/240/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/240/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/240/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/240/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/240/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/240/images/train_output_2.png"}]}, "index": 240, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, color transformation, grid manipulation\n\n# description:\n# In the input grid, you will see several colored pixels forming a pattern.\n# To create the output grid, find the bounding box of the non-black pixels and fill this box with the color of the top-left pixel found within the bounding box.\n# The rest of the pixels outside the bounding box should be set to black.\n\ndef main(input_grid):\n    # 1. Find the bounding box of the colored pixels in the input grid\n    bounding_box_mask_result = bounding_box_mask(input_grid, background=Color.BLACK)\n    \n    # 2. Get the coordinates of the bounding box\n    bounding_box_indices = np.argwhere(bounding_box_mask_result)\n    \n    if bounding_box_indices.size == 0:\n        # If there are no colored pixels, return an all-black grid of the same shape\n        return np.zeros_like(input_grid)\n\n    # Find the top-left and bottom-right corners of the bounding box\n    top_left = bounding_box_indices.min(axis=0)\n    bottom_right = bounding_box_indices.max(axis=0)\n\n    # 3. Extract the color of the top-left pixel in the bounding box\n    top_left_color = input_grid[top_left[0], top_left[1]]\n\n    # 4. Create the output grid and fill the bounding box with the top-left color\n    output_grid = np.zeros_like(input_grid)\n    output_grid[top_left[0]:bottom_right[0]+1, top_left[1]:bottom_right[1]+1] = top_left_color\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose the number of colored pixels to place\n    num_colored_pixels = np.random.randint(1, 20)\n    \n    # Place colored pixels randomly on the grid\n    for _ in range(num_colored_pixels):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/241/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/241/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/241/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/241/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/241/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/241/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/241/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/241/images/train_output_2.png"}]}, "index": 241, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, topology\n\n# description:\n# In the input grid, you will see colored shapes outlined by black pixels. \n# To produce the output grid, find the interior of these shapes and fill them with a new color (let\u0027s say blue). \n# The black pixels outline the shapes, while the non-black pixels represent the shapes themselves.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color (black)\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find the interior of the objects in the input grid\n    interior_mask = object_interior(input_grid, background=Color.BLACK)\n\n    # Fill the interior regions with blue\n    for x, y in np.argwhere(interior_mask):\n        output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a square grid of arbitrary size with a black background, size from 5x5 to 20x20\n    n = random.randint(5, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate some random colored shapes outlined by black pixels\n    n_shapes = random.randint(1, 4)\n    for _ in range(n_shapes):\n        shape_height = random.randint(3, 6)\n        shape_width = random.randint(3, 6)\n        shape_sprite = random_sprite(shape_height, shape_width, density=0.5, background=Color.BLACK)\n\n        # Make a boundary of black pixels around the shape\n        boundary_sprite = np.pad(shape_sprite, pad_width=1, mode=\u0027constant\u0027, constant_values=Color.BLACK)\n\n        # Find a random free location to place the shape with its boundary\n        try:\n            x, y = random_free_location_for_sprite(grid, boundary_sprite, background=Color.BLACK, padding=1)\n        except ValueError:\n            continue\n        \n        blit_sprite(grid, boundary_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/242/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/242/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/242/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/242/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/242/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/242/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/242/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/242/images/train_output_2.png"}]}, "index": 242, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid masking, color replacement, bounding box detection\n\n# description:\n# In the input you will see a grid with a random pattern of non-black colors. \n# To make the output, detect the bounding box of the non-black pixels \n# and replace that area with a solid orange color.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = input_grid.copy()\n\n    # Get the bounding box mask of the non-black pixels\n    mask = bounding_box_mask(input_grid, background=Color.BLACK)\n\n    # Get the coordinates of the bounding box corners\n    rows, cols = np.where(mask)\n    top_left_x, top_left_y = np.min(rows), np.min(cols)\n    bottom_right_x, bottom_right_y = np.max(rows), np.max(cols)\n\n    # Fill the bounding box area with orange color\n    output_grid[top_left_x:bottom_right_x + 1, top_left_y:bottom_right_y + 1] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size (between 5x5 and 20x20)\n    length = np.random.randint(5, 20)\n    grid = np.full((length, length), Color.BLACK)\n\n    # Randomly scatter non-black colors onto the grid\n    available_colors = [c for c in Color.NOT_BLACK]\n    density = 0.3  # density of non-black pixels\n\n    randomly_scatter_points(grid, color=np.random.choice(available_colors), density=density, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/243/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/243/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/243/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/243/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/243/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/243/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/243/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/243/images/train_output_2.png"}]}, "index": 243, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, color change, contact detection\n\n# description:\n# In the input you will see a grid containing two distinct groups of colored pixels: red and blue. \n# To make the output, move each red pixel towards the nearest blue pixel until they touch, \n# at which point the red pixel will change its color to blue. If multiple red pixels touch the same blue pixel, they will stack.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the locations of red and blue pixels.\n    # 2. For each red pixel, find the nearest blue pixel and move towards it until contact is made.\n    # 3. Change the color of the red pixel to blue once it touches the blue pixel.\n\n    # Find all red and blue pixel locations\n    red_pixels = np.argwhere(input_grid == Color.RED)\n    blue_pixels = np.argwhere(input_grid == Color.BLUE)\n\n    # Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Blit the blue pixels onto the output grid first\n    for bx, by in blue_pixels:\n        output_grid[bx, by] = Color.BLUE\n\n    # Move red pixels towards the nearest blue pixel\n    for rx, ry in red_pixels:\n        # Determine the closest blue pixel to the red pixel\n        closest_blue = None\n        min_distance = float(\u0027inf\u0027)\n        \n        for bx, by in blue_pixels:\n            distance = np.abs(rx - bx) + np.abs(ry - by)  # Manhattan distance\n            if distance \u003c min_distance:\n                min_distance = distance\n                closest_blue = (bx, by)\n\n        # Now move the red pixel towards the closest blue pixel\n        while not contact(object1=np.full((1, 1), Color.RED), object2=np.full((1, 1), Color.BLUE), x1=rx, y1=ry, x2=closest_blue[0], y2=closest_blue[1]):\n            # Move the red pixel one step closer to the blue pixel\n            if rx \u003c closest_blue[0]:\n                rx += 1\n            elif rx \u003e closest_blue[0]:\n                rx -= 1\n            \n            if ry \u003c closest_blue[1]:\n                ry += 1\n            elif ry \u003e closest_blue[1]:\n                ry -= 1\n            \n        # Change its color to blue and blit it onto the output grid\n        output_grid[rx, ry] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random distribution of red and blue pixels\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly place some blue pixels\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = Color.BLUE\n\n    # Randomly place some red pixels, ensuring they don\u0027t overlap with blue pixels\n    for _ in range(np.random.randint(5, 15)):\n        while True:\n            x, y = np.random.randint(0, width), np.random.randint(0, height)\n            if grid[x, y] == Color.BLACK:  # Only place red if the spot is empty\n                grid[x, y] = Color.RED\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/244/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/244/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/244/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/244/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/244/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/244/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/244/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/244/images/train_output_2.png"}]}, "index": 244, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, boundary detection, color filling\n\n# description:\n# The input grid contains colored regions enclosed by a boundary of black pixels. \n# Your task is to fill the enclosed regions with a specific color (yellow), while keeping the boundary intact.\n# The output grid should preserve the original boundaries but fill the interior enclosed regions with yellow pixels.\n\ndef main(input_grid):\n    # Create an output grid initialized to the input grid\n    output_grid = input_grid.copy()\n\n    # Find the boundary of the regions\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Fill enclosed regions with yellow\n    for x, y in np.argwhere(~boundary_mask):\n        if output_grid[x, y] == Color.BLACK:  # Only fill non-boundary pixels\n            output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a square grid of arbitrary size with black background, size from 5x5 to 20x20\n    n = np.random.randint(5, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate some random colored regions which are enclosed by black boundaries\n    num_regions = np.random.randint(1, 4)\n    for _ in range(num_regions):\n        # Random dimensions for the rectangular region\n        height = np.random.randint(3, 6)\n        width = np.random.randint(3, 6)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a sprite with the specified color\n        sprite = np.full((height, width), color)\n\n        # Create a boundary of black pixels around the sprite\n        boundary_height = height + 2\n        boundary_width = width + 2\n        boundary_sprite = np.full((boundary_height, boundary_width), Color.BLACK)\n        boundary_sprite[1:1+height, 1:1+width] = sprite\n\n        # Find a random position to place the boundary sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, boundary_sprite, padding=0, border_size=1)\n        except ValueError:\n            continue  # If no free space is found, skip to the next region\n\n        blit_sprite(grid, boundary_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/245/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/245/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/245/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/245/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/245/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/245/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/245/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/245/images/train_output_2.png"}]}, "index": 245, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color blending, object detection\n\n# description:\n# In the input, you will see several colored objects, each marked with a unique pixel at the center. To create the output grid:\n# 1. For each object, determine its center pixel (the unique pixel).\n# 2. Scale the object based on the distance of its center pixel to its outermost colored pixels.\n# 3. Blend the scaled object back into the grid at the position of the center pixel, replacing the original object.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all connected components (objects) in the input grid.\n    # 2. For each object, identify the unique center pixel and calculate the scaling factor based on the object\u2019s dimensions.\n    # 3. Scale the object and place it back, blending it with the grid.\n\n    # 1. Find all objects in the input grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, background=background, connectivity=4, monochromatic=False)\n\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n\n    for obj in objects:\n        # 2. Identify the center pixel (unique pixel) and calculate the scaling factor\n        center_pixel = np.argwhere(obj != background)\n        if center_pixel.size == 0:\n            continue  # Skip if no center pixel found\n\n        # Assume the center pixel is the unique colored pixel, which is the only non-background pixel\n        center_x, center_y = center_pixel[0]\n        unique_color = obj[center_x, center_y]\n\n        # Calculate the scaling factor based on the distance of the center pixel to the outer edges of the object\n        min_x = np.min(center_pixel[:, 0])\n        max_x = np.max(center_pixel[:, 0])\n        min_y = np.min(center_pixel[:, 1])\n        max_y = np.max(center_pixel[:, 1])\n\n        # The scaling factor is determined by the max dimension of the object\n        width = max_x - min_x + 1\n        height = max_y - min_y + 1\n        scaling_factor = max(width, height)\n\n        # Crop the object to create a sprite\n        sprite = crop(obj, background=Color.BLACK)\n\n        # 3. Scale the object and blend it back into the grid\n        scaled_sprite = scale_sprite(sprite, scaling_factor)\n\n        # Calculate the new position to place the scaled sprite, centering it over the original center pixel\n        new_x = center_x - (scaled_sprite.shape[0] // 2)\n        new_y = center_y - (scaled_sprite.shape[1] // 2)\n\n        # Blit the scaled sprite back into the output grid at the new position\n        blit_sprite(output_grid, scaled_sprite, x=new_x, y=new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid containing several objects with unique center pixels\n    background = Color.BLACK\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), background)\n\n    num_objects = np.random.randint(3, 6)  # Number of objects to place\n    for _ in range(num_objects):\n        # Create a random object\n        sprite_width, sprite_height = np.random.randint(3, 6), np.random.randint(3, 6)\n        sprite = random_sprite(sprite_width, sprite_height, density=0.5, color_palette=Color.NOT_BLACK)\n        \n        # Randomly pick a unique center pixel\n        center_x, center_y = np.random.randint(0, sprite.shape[0]), np.random.randint(0, sprite.shape[1])\n        sprite[center_x, center_y] = np.random.choice(Color.NOT_BLACK)  # Make the center pixel unique\n        \n        # Place sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/246/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/246/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/246/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/246/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/246/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/246/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/246/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/246/images/train_output_2.png"}]}, "index": 246, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, pixel manipulation, color filling\n\n# description:\n# In the input, you will see a grid with a single colored shape (not black) located somewhere in the grid. The rest of the grid is black.\n# To make the output:\n# 1. Find the bounding box of the colored shape.\n# 2. Fill the bounding box area with a new color (e.g., green).\n# 3. Draw a border of red pixels around the bounding box of the shape.\n\ndef main(input_grid):\n    # 1. Find the connected components in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False)\n    \n    # There should be exactly one colored shape\n    assert len(objects) == 1, \"There should be exactly one non-black object\"\n    shape = objects[0]\n\n    # 2. Find the bounding box of the shape\n    x, y, w, h = bounding_box(shape)\n\n    # Create the output grid - start with a black grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 3. Fill the bounding box area with green\n    output_grid[x:x+w, y:y+h] = Color.GREEN\n\n    # 4. Draw a red border around the bounding box\n    for dx in range(w):\n        output_grid[x + dx, y] = Color.RED  # top border\n        output_grid[x + dx, y + h - 1] = Color.RED  # bottom border\n\n    for dy in range(h):\n        output_grid[x, y + dy] = Color.RED  # left border\n        output_grid[x + w - 1, y + dy] = Color.RED  # right border\n\n    # Overlay the original shape on top of the output grid\n    blit_sprite(output_grid, shape, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random dimensions\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random color for the shape that is not black\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a random shape (connected component)\n    shape_width, shape_height = np.random.randint(2, 6), np.random.randint(2, 6)\n    shape_sprite = random_sprite(shape_width, shape_height, density=1, color_palette=[shape_color])\n\n    # Place the shape in the grid at a random location\n    x, y = random_free_location_for_sprite(grid, shape_sprite, padding=1)\n    blit_sprite(grid, shape_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/247/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/247/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/247/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/247/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/247/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/247/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/247/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/247/images/train_output_2.png"}]}, "index": 247, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shrinking, color change, bounding box masking\n\n# description:\n# In the input, you will see a grid containing a single green object.\n# To create the output grid, you should shrink the object to half its original size (rounded down) \n# and change its color to red, while also ensuring that the object remains centered in the new grid.\n\ndef main(input_grid):\n    # Step 1: Find the green object in the grid\n    green_objects = detect_objects(grid=input_grid, colors=[Color.GREEN], monochromatic=True, connectivity=4)\n    assert len(green_objects) == 1, \"There should be exactly one green object\"\n    green_object = green_objects[0]\n\n    # Step 2: Calculate the bounding box of the green object\n    x, y, width, height = bounding_box(green_object, background=Color.BLACK)\n    \n    # Step 3: Calculate new dimensions (shrinking)\n    new_width = width // 2\n    new_height = height // 2\n\n    # Step 4: Create a new output grid, initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 5: Create a new object by cropping the bounding box of the green object\n    cropped_object = green_object[x:x + height, y:y + width]\n\n    # Step 6: Downscale the object\n    if new_width \u003e 0 and new_height \u003e 0:\n        # Shrink the object using slicing to get the new object\n        shrunk_object = cropped_object[::2, ::2]  # Downscale by taking every second pixel\n        shrunk_object[shrunk_object != Color.BLACK] = Color.RED  # Change color to red\n\n        # Step 7: Center the shrunk object in the output grid\n        center_x = (output_grid.shape[0] - new_height) // 2\n        center_y = (output_grid.shape[1] - new_width) // 2\n        output_grid[center_x:center_x + new_height, center_y:center_y + new_width] = shrunk_object\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    grid_len = np.random.randint(6, 10)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Create a random green object\n    sprite_width, sprite_height = np.random.randint(1, grid_len), np.random.randint(1, grid_len)\n    green_object = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.GREEN], density=0.5)\n\n    # Place the green object randomly in the grid\n    x, y = random_free_location_for_sprite(grid=grid, sprite=green_object, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=green_object, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/248/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/248/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/248/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/248/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/248/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/248/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/248/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/248/images/train_output_2.png"}]}, "index": 248, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object fitting, holes, interior detection\n\n# description:\n# In the input, you will see multiple colored objects, each containing a black hole inside of it. \n# The goal is to find all the objects that perfectly fit into their corresponding black holes. \n# If an object fits, it should be placed inside the black hole; otherwise, it remains in its original position. \n# The output grid should reflect this transformation.\n\ndef main(input_grid):\n    # Step 1: Identify all grey objects with black holes inside\n    grey_input = input_grid.copy()\n    grey_input[input_grid != Color.GREY] = Color.BLACK\n    grey_objects = find_connected_components(grey_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Step 2: Extract the black hole areas from the grey objects\n    interior_black_holes = [object_interior(obj, background=Color.BLACK) \u0026 (obj == Color.BLACK) for obj in grey_objects]\n\n    # Step 3: Identify colored objects that may fit into these black holes\n    non_grey_input = input_grid.copy()\n    non_grey_input[input_grid == Color.GREY] = Color.BLACK\n    colored_objects = find_connected_components(non_grey_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    output_grid = np.copy(input_grid)\n\n    # Step 4: Check if each colored object fits into any black hole\n    for obj in colored_objects:\n        # Create a mask for the colored object\n        object_mask = obj != Color.BLACK\n        object_shape = obj.shape\n        \n        # Check if the current object can fit into any of the black holes\n        for hole in interior_black_holes:\n            hole_shape = hole.shape\n            if object_shape == hole_shape:  # Check if shapes match\n                # If it fits, remove it from its original location and place it inside the hole\n                output_grid[object_mask] = Color.BLACK  # Clear the original position\n                \n                # Place the object inside the hole\n                hole_x, hole_y, _, _ = bounding_box(hole)\n                blit_sprite(output_grid, obj, hole_x, hole_y, background=Color.BLACK)\n                break  # Break since it can only fit into one hole\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 25, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create grey objects with black holes\n    n_grey_objects = np.random.randint(1, 4)  # Number of grey objects can vary\n    for _ in range(n_grey_objects):\n        grey_width, grey_height = np.random.randint(5, 8, size=2)\n        grey_sprite = np.full((grey_width, grey_height), Color.GREY)\n\n        # Create a black hole in the grey object\n        hole_width, hole_height = np.random.randint(1, grey_width - 2), np.random.randint(1, grey_height - 2)\n        hole_sprite = random_sprite(hole_width, hole_height, color_palette=[Color.BLACK], background=Color.GREY, symmetry=\"not_symmetric\")\n        \n        # Place hole inside grey sprite\n        hole_x, hole_y = random_free_location_for_sprite(grey_sprite, hole_sprite, border_size=1, background=Color.GREY)\n        blit_sprite(grey_sprite, hole_sprite, hole_x, hole_y, background=Color.GREY)\n\n        # Place the grey object in the input grid\n        x, y = random_free_location_for_sprite(input_grid, grey_sprite, padding=1, border_size=1)\n        blit_sprite(input_grid, grey_sprite, x, y, background=Color.BLACK)\n\n        # Create corresponding objects that fit into the black hole\n        object_sprite = np.full((hole_width, hole_height), Color.BLACK)\n        object_sprite[hole_sprite == Color.BLACK] = np.random.choice([c for c in Color.NOT_BLACK if c != Color.GREY])\n\n        # Place the fitting object in the input grid\n        x, y = random_free_location_for_sprite(input_grid, object_sprite, padding=1, border_size=1)\n        blit_sprite(input_grid, object_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/249/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/249/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/249/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/249/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/249/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/249/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/249/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/249/images/train_output_2.png"}]}, "index": 249, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color merging, interior filling, contact detection\n\n# description:\n# In the input, you will see a grid with a colored object that has multiple holes and is surrounded by a border of another color.\n# To make the output, fill each hole in the object with the color of the surrounding border.\n# If the hole is in contact with the border, it should be filled; otherwise, leave it as is.\n\ndef main(input_grid):\n    # Identify the border color (the most prevalent color on the border)\n    border_color = max(Color.ALL_COLORS, key=lambda color: np.sum(input_grid[0] == color) + np.sum(input_grid[-1] == color) +\n                                                np.sum(input_grid[:, 0] == color) + np.sum(input_grid[:, -1] == color))\n\n    # Find the object (the main colored shape) in the grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n    \n    # Create an output grid initialized to the original input\n    output_grid = np.copy(input_grid)\n\n    # Process each object found (assuming there\u0027s only one relevant object)\n    for obj in objects:\n        # Get the interior mask of the object\n        interior_mask = object_interior(obj, background=Color.BLACK)\n\n        # Get the positions of the holes (black pixels) within the object\n        holes = np.argwhere(obj == Color.BLACK)\n\n        for hole in holes:\n            hole_x, hole_y = hole\n\n            # Check if this hole is in contact with the border color\n            if contact(object1=obj, object2=np.full((1, 1), border_color), x1=hole_x, y1=hole_y, x2=hole_x, y2=hole_y):\n                # Fill the hole with the border color in the output grid\n                output_grid[hole_x, hole_y] = border_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10 with a colored object and holes\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Choose a color for the main object (not black)\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a colored object with holes\n    object_shape = random_sprite(6, 6, density=0.5, color_palette=[object_color], background=Color.BLACK)\n\n    # Randomly position the object in the grid\n    x, y = random_free_location_for_sprite(grid, object_shape, background=Color.BLACK)\n    blit_sprite(grid, object_shape, x, y)\n\n    # Add holes in the object\n    for _ in range(3):  # Create 3 holes\n        hole_position = (np.random.randint(1, 5), np.random.randint(1, 5))  # Ensure holes are within bounds\n        grid[x + hole_position[0], y + hole_position[1]] = Color.BLACK  # Create a hole by setting to black\n\n    # Add a border around the object\n    border_color = np.random.choice(list(Color.NOT_BLACK))\n    for i in range(grid_size):\n        grid[i, 0] = border_color\n        grid[i, grid_size - 1] = border_color\n        grid[0, i] = border_color\n        grid[grid_size - 1, i] = border_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/250/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/250/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/250/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/250/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/250/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/250/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/250/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/250/images/train_output_2.png"}]}, "index": 250, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, line drawing, gap filling\n\n# description:\n# In the input you will see two large colored shapes separated by a gap of black pixels.\n# To make the output, you need to fill this gap with a zigzag line of a third color (e.g., PINK).\n# The line should connect the edges of the two shapes and should not overlap with any of the shapes.\n\ndef main(input_grid):\n    # Copy the input grid to output\n    output_grid = input_grid.copy()\n\n    # Detect the objects in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Ensure there are exactly two objects\n    assert len(objects) == 2, \"There should be exactly two objects\"\n\n    # Get positions of the two objects\n    obj1_positions = np.argwhere(objects[0] != Color.BLACK)\n    obj2_positions = np.argwhere(objects[1] != Color.BLACK)\n\n    # Identify the edges of the objects\n    obj1_edges = np.unique(obj1_positions[:, 0]), np.unique(obj1_positions[:, 1])\n    obj2_edges = np.unique(obj2_positions[:, 0]), np.unique(obj2_positions[:, 1])\n\n    # Determine the range of x and y coordinates that need to be filled\n    min_x = min(obj1_edges[0].min(), obj2_edges[0].min())\n    max_x = max(obj1_edges[0].max(), obj2_edges[0].max())\n    min_y = min(obj1_edges[1].min(), obj2_edges[1].min())\n    max_y = max(obj1_edges[1].max(), obj2_edges[1].max())\n\n    # Fill the gap with a zigzag line of Color.PINK\n    for x in range(min_x, max_x + 1):\n        for y in range(min_y, max_y + 1):\n            if check_between_objects(obj1=objects[0], obj2=objects[1], x=x, y=y, padding=1):\n                # Create a zigzag pattern by alternating rows\n                if (x % 2) == 0:\n                    output_grid[x, y] = Color.PINK\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a gap between two large shapes\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two different colors for the shapes\n    colors = np.random.choice([color for color in Color.NOT_BLACK], 2, replace=False)\n    color1, color2 = colors\n\n    # Generate two large rectangles\n    rect_height1, rect_width1 = np.random.randint(4, 10, size=2)\n    rect_height2, rect_width2 = np.random.randint(4, 10, size=2)\n\n    # Create the rectangles\n    rectangle1 = np.full((rect_height1, rect_width1), color1)\n    rectangle2 = np.full((rect_height2, rect_width2), color2)\n\n    # Place the rectangles on the grid with some padding to ensure a gap\n    x1, y1 = random_free_location_for_sprite(grid=grid, sprite=rectangle1, background=Color.BLACK, padding=2, border_size=2)\n    blit_sprite(grid, rectangle1, x1, y1)\n\n    # Attempt to place the second rectangle, ensuring that it is not too close to the first\n    try:\n        x2, y2 = random_free_location_for_sprite(grid=grid, sprite=rectangle2, background=Color.BLACK, padding=2, border_size=2)\n        blit_sprite(grid, rectangle2, x2, y2)\n    except ValueError:\n        return generate_input()  # Regenerate if placement fails\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/251/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/251/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/251/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/251/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/251/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/251/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/251/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/251/images/train_output_2.png"}]}, "index": 251, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change, contact\n\n# description:\n# In the input you will see a grid with scattered blue and orange objects.\n# To create the output grid, move each blue object towards the nearest orange object until they touch, then change the blue object\u0027s color to green.\n\ndef main(input_grid):\n    # Step 1: Find all blue and orange objects in the grid\n    blue_objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    orange_objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n\n    # Make a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    for blue_object in blue_objects:\n        # Step 2: For each blue object, find the nearest orange object\n        nearest_orange = None\n        min_distance = float(\u0027inf\u0027)\n\n        for orange_object in orange_objects:\n            # Calculate the distance from the blue object to the orange object\n            bbox_blue = bounding_box(blue_object, background=Color.BLACK)\n            bbox_orange = bounding_box(orange_object, background=Color.BLACK)\n\n            # Calculate the center points of both objects\n            center_blue = (bbox_blue[0] + bbox_blue[2] // 2, bbox_blue[1] + bbox_blue[3] // 2)\n            center_orange = (bbox_orange[0] + bbox_orange[2] // 2, bbox_orange[1] + bbox_orange[3] // 2)\n\n            # Calculate the Euclidean distance\n            distance = np.sqrt((center_blue[0] - center_orange[0]) ** 2 + (center_blue[1] - center_orange[1]) ** 2)\n\n            # Update nearest orange object if this one is closer\n            if distance \u003c min_distance:\n                min_distance = distance\n                nearest_orange = orange_object\n\n        # Step 3: Move the blue object towards the nearest orange object until they touch\n        if nearest_orange is not None:\n            # Try moving towards the nearest orange object by 1 pixel increments\n            while not contact(object1=blue_object, object2=nearest_orange):\n                blue_object = translate(blue_object, x=1 if center_blue[0] \u003c center_orange[0] else -1,\n                                               y=1 if center_blue[1] \u003c center_orange[1] else -1,\n                                               background=Color.BLACK)\n\n            # Step 4: Change the color of the blue object to green upon contact\n            blue_object[blue_object != Color.BLACK] = Color.GREEN\n            \n            # Blit the updated blue object onto the output grid\n            output_grid = blit_object(output_grid, blue_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate blue and orange objects\n    for color in [Color.BLUE, Color.ORANGE]:\n        for _ in range(np.random.randint(1, 4)):\n            w, h = np.random.randint(1, 3), np.random.randint(1, 3)  # Small objects\n            sprite = random_sprite(n=w, m=h, color_palette=[color], density=1.0)\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n            grid = blit_sprite(grid=grid, sprite=sprite, x=x, y=y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/252/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/252/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/252/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/252/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/252/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/252/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/252/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/252/images/train_output_2.png"}]}, "index": 252, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, color matching, object placement\n\n# description:\n# In the input you will see a small irregularly shaped object. The output should be a larger version of this object, scaled up and placed in a specified rectangular area of the grid. The output should match the color of the original object and be centered in the specified area.\n\ndef main(input_grid):\n    # Step 1: Detect the small object in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n    small_object = [obj for obj in objects if np.count_nonzero(obj) \u003e 0][0]  # Assuming there\u0027s only one small object\n    \n    # Step 2: Crop the small object\n    small_sprite = crop(small_object, background=Color.BLACK)\n    \n    # Step 3: Scale the small sprite by a factor of 3\n    scaled_sprite = scale_sprite(small_sprite, factor=3)\n\n    # Step 4: Define the area where the scaled sprite should be placed\n    output_grid = np.full(input_grid.shape, Color.BLACK)  # Start with a black grid\n\n    # Center the scaled sprite in the middle of the output grid\n    center_x = (output_grid.shape[0] - scaled_sprite.shape[0]) // 2\n    center_y = (output_grid.shape[1] - scaled_sprite.shape[1]) // 2\n\n    # Step 5: Place the scaled sprite into the output grid\n    blit_sprite(output_grid, scaled_sprite, x=center_x, y=center_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a small irregular object to begin with\n    small_sprite = random_sprite([2, 3], [2, 3], connectivity=4, color_palette=[color for color in Color.NOT_BLACK if color != Color.BLACK], background=Color.BLACK)\n    \n    # Create a grid large enough to place the scaled object\n    grid_width, grid_height = 15, 15\n    grid = np.full((grid_width, grid_height), Color.BLACK)\n\n    # Randomly place the small sprite in the grid\n    x, y = random_free_location_for_sprite(grid, small_sprite, background=Color.BLACK)\n    blit_sprite(grid, small_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/253/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/253/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/253/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/253/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/253/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/253/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/253/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/253/images/train_output_2.png"}]}, "index": 253, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, pattern extraction, scaling\n\n# description:\n# In the input, you will see multiple colored 2x2 patterns scattered across the grid.\n# To make the output grid, you should first extract each 2x2 pattern and scale each by a factor of 3,\n# then arrange them in the order they appeared in the input from left to right, filling in the output grid.\n\ndef main(input_grid):\n    # Step 1: Detect all 2x2 colored patterns in the input grid\n    patterns = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, \n                              monochromatic=False, allowed_dimensions=[(2, 2)], \n                              connectivity=4)\n\n    # Create an output grid scaled to accommodate the new patterns\n    output_grid = np.zeros((input_grid.shape[0] * 3, input_grid.shape[1] * 3), dtype=int)\n\n    # Step 2: Scale each detected pattern and blit onto the output grid\n    for obj in patterns:\n        # Get the position of each colored pattern\n        x, y = object_position(obj, background=Color.BLACK, anchor=\"upper left\")\n        \n        # Crop the 2x2 pattern to produce the sprite\n        sprite = crop(obj, background=Color.BLACK)\n        \n        # Scale the sprite by a factor of 3\n        scaled_sprite = scale_sprite(sprite, factor=3)\n        \n        # Calculate the position to blit the scaled pattern onto the output grid\n        new_x, new_y = x * 3, y * 3\n        \n        # Place the scaled sprite on the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=scaled_sprite, x=new_x, y=new_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a background grid with size of n x n.\n    grid_size = np.random.randint(5, 10)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Define the colors available for the patterns\n    colors = Color.NOT_BLACK\n\n    # Generate a random number of 2x2 patterns\n    num_patterns = np.random.randint(1, 6)\n\n    for _ in range(num_patterns):\n        # Generate a random 2x2 colored pattern\n        pattern = random_sprite(2, 2, density=1, color_palette=colors)\n\n        # Find a random free location for the pattern in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, pattern, background=Color.BLACK)\n            grid = blit_sprite(grid, pattern, x, y)\n        except ValueError:\n            # If no free location is found, we can skip this pattern\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/254/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/254/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/254/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/254/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/254/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/254/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/254/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/254/images/train_output_2.png"}]}, "index": 254, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, object detection, color transformation\n\n# description:\n# In the input, you will see a grid with multiple objects made of different colors on a black background. Each object has a unique color but is surrounded by black pixels. \n# The goal is to fill each object with a new color (for example, green) while preserving their unique shapes. The filled color should only replace the original colors, \n# and black pixels should remain unchanged.\n\ndef main(input_grid):\n    # copy the input grid to output grid\n    output_grid = np.copy(input_grid)\n\n    # Find all unique colored objects except for black\n    unique_colors = set(output_grid.flatten()) - {Color.BLACK}\n    \n    # Fill each unique colored object with a new color, e.g., green\n    for color in unique_colors:\n        # Find the first pixel of this color\n        x, y = np.argwhere(output_grid == color)[0]\n        # Use flood fill to fill the entire connected component with green\n        flood_fill(output_grid, x, y, Color.GREEN, connectivity=4)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of random size\n    n, m = np.random.randint(6, 12), np.random.randint(6, 12)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a set of colored objects\n    num_objects = np.random.randint(1, 5)  # Create between 1 and 4 objects\n    for _ in range(num_objects):\n        color = np.random.choice(list(Color.NOT_BLACK))\n        width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n        sprite = random_sprite(n=width, m=height, color_palette=[color], density=0.7)\n        \n        # Place the sprite randomly on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/255/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/255/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/255/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/255/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/255/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/255/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/255/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/255/images/train_output_2.png"}]}, "index": 255, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, topology, border detection\n\n# description:\n# The input consists of a black grid containing several grey circles. Each circle is hollow (i.e., contains a black region inside).\n# To create the output, fill in the hollow circles with blue if they are completely surrounded by black pixels. \n# If a circle has any neighboring grey pixels, leave it unchanged.\n\ndef main(input_grid):\n    # Extract the grey circles from the input grid\n    circles = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Create an output grid to store the result\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # For each grey circle, check its neighbors and fill it if necessary\n    for circle in circles:\n        # Crop to get the sprite of the circle\n        sprite = crop(circle, background=Color.BLACK)\n\n        # Check if it has any neighboring grey pixels\n        neighbors = object_neighbors(circle, background=Color.BLACK, connectivity=4)\n\n        # If there are no neighbors that are grey, fill it with blue\n        if not np.any(circle[neighbors]):  # If no grey neighbors\n            sprite[sprite == Color.BLACK] = Color.BLUE  # Fill the inner part with blue\n\n        # Get the position of the circle to draw it back in the output grid\n        x, y = object_position(circle, background=Color.BLACK)\n        blit_sprite(output_grid, sprite, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 15x15 black grid\n    grid_size = 15\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly choose the number of grey circles\n    num_circles = np.random.randint(2, 6)\n\n    for _ in range(num_circles):\n        # Randomly choose the size of the circle\n        radius = np.random.randint(2, 5)  # Radius of the circle\n        circle_diameter = radius * 2 + 1\n        circle_sprite = np.full((circle_diameter, circle_diameter), Color.GREY)\n\n        # Create a hollow circle by setting the inner part to black\n        for i in range(circle_diameter):\n            for j in range(circle_diameter):\n                if (i - radius) ** 2 + (j - radius) ** 2 \u003c radius ** 2:\n                    circle_sprite[i, j] = Color.BLACK  # Set inner part to black\n\n        # Find a random location to place the circle\n        try:\n            x, y = random_free_location_for_sprite(grid, circle_sprite, padding=1)\n        except ValueError:\n            continue  # If no location found, skip to the next circle\n\n        # Blit the circle onto the grid\n        blit_sprite(grid, circle_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/256/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/256/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/256/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/256/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/256/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/256/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/256/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/256/images/train_output_2.png"}]}, "index": 256, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation, pixel manipulation\n\n# description:\n# In the input, you will see a grid with several colored objects. Each object has a distinct color, except one color that appears in multiple connected components.\n# To make the output grid, you should detect the connected components of the grid, identify the unique color that appears in multiple components,\n# and transform all pixels of that color into a new designated color while preserving the other colors.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create an output grid initialized to be the same as input\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components in the grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Dictionary to count occurrences of each color\n    color_count = {}\n\n    # Count colors in connected components\n    for component in components:\n        colors_in_component = object_colors(component, background=Color.BLACK)\n        for color in colors_in_component:\n            if color in color_count:\n                color_count[color] += 1\n            else:\n                color_count[color] = 1\n\n    # Identify the color that appears in multiple components\n    target_color = None\n    for color, count in color_count.items():\n        if count \u003e 1:  # More than one component\n            target_color = color\n            break\n\n    # If we found a target color, change all its occurrences in the output grid to a new color\n    if target_color is not None:\n        new_color = Color.RED  # Define the new color\n        output_grid[output_grid == target_color] = new_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize a 10x10 grid representing a black background.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Set colors for the objects to be created\n    available_colors = [c for c in Color.NOT_BLACK]\n\n    # Create a number of connected components\n    for _ in range(np.random.randint(2, 6)):  # Random number of objects\n        color = np.random.choice(available_colors)\n        width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n        object_sprite = np.full((width, height), color)\n\n        # Find a free location for the object\n        x, y = random_free_location_for_sprite(grid, object_sprite, background=Color.BLACK)\n        blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n\n        # Randomly decide if we should add another component of the same color\n        if np.random.rand() \u003e 0.5:  # 50% chance to create a second connected component of the same color\n            second_sprite = np.full((width, height), color)\n            offset_x = np.random.randint(1, 3) * (1 if np.random.rand() \u003e 0.5 else -1)\n            offset_y = np.random.randint(1, 3) * (1 if np.random.rand() \u003e 0.5 else -1)\n            x2, y2 = x + offset_x, y + offset_y\n            \n            # Check if the new position is within bounds\n            if 0 \u003c= x2 \u003c n - width and 0 \u003c= y2 \u003c m - height:\n                blit_sprite(grid, second_sprite, x2, y2, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/257/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/257/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/257/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/257/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/257/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/257/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/257/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/257/images/train_output_2.png"}]}, "index": 257, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern filling, boundary detection\n\n# description:\n# The input consists of a black grid containing a few hollow rectangles made of grey pixels. \n# Each rectangle has a grey border and is surrounded by black. \n# To create the output, fill in the hollow grey rectangles with blue, but only if they are completely surrounded by black pixels, \n# meaning that the grey pixels do not touch any other grey pixels outside the rectangle.\n\ndef main(input_grid):\n    # Step 1: Find the connected grey components (hollow rectangles)\n    grey_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Step 2: Create an output grid initialized to black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 3: For each grey object, check if it is completely surrounded by black pixels\n    for obj in grey_objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj, background=Color.BLACK)\n\n        # Step 4: Check if the object is surrounded by black pixels\n        neighbors = object_neighbors(obj, background=Color.BLACK)\n\n        # If there are no neighboring grey pixels, fill the object with blue\n        if not np.any(neighbors):\n            # Fill the object with blue\n            obj[obj == Color.GREY] = Color.BLUE\n        \n        # Blit the object onto the output grid\n        blit_sprite(output_grid, obj, x, y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid with random dimensions\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create 2-4 grey rectangles\n    num_rectangles = np.random.randint(2, 5)\n    rectangles = []\n\n    for _ in range(num_rectangles):\n        # Random size for the rectangle\n        r_n = np.random.randint(2, 5)\n        r_m = np.random.randint(2, 5)\n        rectangle = np.full((r_n, r_m), Color.GREY)\n\n        try:\n            # Find a random free location for the rectangle\n            x, y = random_free_location_for_sprite(grid, rectangle, padding=1)\n        except ValueError:\n            continue  # If no space, skip to the next rectangle\n\n        # Blit the rectangle onto the grid\n        blit_sprite(grid, rectangle, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/258/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/258/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/258/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/258/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/258/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/258/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/258/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/258/images/train_output_2.png"}]}, "index": 258, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, color transformation\n\n# description:\n# In the input you will see a grid consisting of a horizontal striped pattern of red pixels. \n# To make the output, detect the translational symmetry of the stripes and extend the pattern vertically, \n# changing the color of the stripes to yellow.\n\ndef main(input_grid):\n    # Detect translational symmetries in the input grid\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n    \n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n    \n    # Determine the height of the original pattern\n    height = input_grid.shape[0]\n    \n    # Create an output grid with the same width but extend the height to accommodate more stripes\n    output_grid = np.full((height * 3, input_grid.shape[1]), Color.BLACK)  # Tripling the height for the output\n    \n    # Copy the original pattern into the output grid and its symmetric copies\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Compute the orbit into the output grid\n        for x2, y2 in orbit(output_grid, x, y, symmetries):\n            output_grid[x2, y2] = input_grid[x, y]\n    \n    # Change the color of the stripes from red to yellow\n    output_grid[output_grid == Color.RED] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of a fixed height with horizontal stripes of red pixels\n    width = np.random.randint(5, 15)\n    height = np.random.randint(2, 5)\n    grid = np.zeros((height, width), dtype=int)\n\n    # Fill the grid with red stripes\n    for row in range(height):\n        if row % 2 == 0:  # Create stripes every other row\n            grid[row] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/259/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/259/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/259/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/259/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/259/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/259/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/259/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/259/images/train_output_2.png"}]}, "index": 259, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation, border drawing\n\n# description:\n# In the input you will see a grid with two colored pixels located at the top left corner and the bottom right corner.\n# To make the output, you should draw a rectangle connecting these two pixels and create a border around the rectangle where the top edge is colored to match the top pixel and the bottom edge matches the bottom pixel.\n\ndef main(input_grid):\n    # 1. Find the colored pixels\n    pixels = find_connected_components(input_grid, monochromatic=True)\n    \n    # Extract the top left and bottom right pixels\n    top_left = pixels[0]\n    bottom_right = pixels[1]\n\n    # Get positions and colors\n    top_left_x, top_left_y = object_position(top_left)\n    bottom_right_x, bottom_right_y = object_position(bottom_right)\n    top_color = object_colors(top_left)[0]\n    bottom_color = object_colors(bottom_right)[0]\n\n    # 2. Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Draw rectangle between the two pixels\n    draw_line(output_grid, x=top_left_x, y=top_left_y, end_x=bottom_right_x, end_y=top_left_y, color=top_color) # Top edge\n    draw_line(output_grid, x=top_left_x, y=bottom_right_y, end_x=bottom_right_x, end_y=bottom_right_y, color=bottom_color) # Bottom edge\n    draw_line(output_grid, x=top_left_x, y=top_left_y, end_x=top_left_x, end_y=bottom_right_y, color=top_color) # Left edge\n    draw_line(output_grid, x=bottom_right_x, y=top_left_y, end_x=bottom_right_x, end_y=bottom_right_y, color=bottom_color) # Right edge\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate the grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose two colors for the two pixels\n    colors = np.random.choice(Color.NOT_BLACK, size=2, replace=False)\n\n    # Place top-left pixel\n    grid[0, 0] = colors[0]  # Top-left corner\n\n    # Place bottom-right pixel ensuring it is not in the same row/column as the top-left pixel\n    grid[width - 1, height - 1] = colors[1]  # Bottom-right corner\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/260/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/260/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/260/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/260/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/260/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/260/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/260/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/260/images/train_output_2.png"}]}, "index": 260, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, color separation, connectivity\n\n# description:\n# In the input, you will see a grid containing different colored shapes separated by black regions.\n# To make the output, find all the connected components of non-black pixels, and fill every second shape with blue using the flood fill algorithm.\n\ndef main(input_grid):\n    # Create a copy of the input grid to hold the output\n    output_grid = np.copy(input_grid)\n\n    # Find all connected components that are not black\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Fill every second shape with blue\n    for i, shape in enumerate(shapes):\n        if i % 2 == 1:  # Fill every second shape (1st, 3rd, 5th, ...)\n            # Get the position of a pixel within the shape to use as the starting point for flood fill\n            x, y = object_position(shape, background=Color.BLACK)\n            # Use flood fill to color the shape blue\n            flood_fill(output_grid, x, y, Color.BLUE)\n\n    return output_grid\n\ndef generate_input():\n    # Set the dimensions of the grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly generate shapes in the grid\n    num_shapes = np.random.randint(3, 6)  # Number of shapes\n    for _ in range(num_shapes):\n        # Random size for the shape\n        shape_width = np.random.randint(2, 5)\n        shape_height = np.random.randint(2, 5)\n\n        # Random color for the shape (not black)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Random position for the shape, ensuring it fits in the grid\n        x = np.random.randint(0, width - shape_width)\n        y = np.random.randint(0, height - shape_height)\n\n        # Draw the shape in the grid\n        for dx in range(shape_width):\n            for dy in range(shape_height):\n                grid[x + dx, y + dy] = shape_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/261/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/261/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/261/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/261/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/261/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/261/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/261/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/261/images/train_output_2.png"}]}, "index": 261, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, positioning, grid manipulation\n\n# description:\n# In the input, you will see a grid containing a pattern of colored pixels and a single colored square (not black).\n# The task is to translate the single colored square to the nearest edge of the grid without overlapping any colored pixels from the pattern.\n# The output grid should show the translated square in its new position.\n\ndef main(input_grid):\n    # Identify the colored square\n    colored_square = np.zeros_like(input_grid)\n    colored_square[input_grid != Color.BLACK] = input_grid[input_grid != Color.BLACK]\n    \n    # Get the coordinates of the colored square\n    square_coords = np.argwhere(colored_square != Color.BLACK)\n    \n    if square_coords.size == 0:\n        return input_grid  # No colored square found\n    \n    # Find the center of the colored square\n    min_x, min_y = square_coords.min(axis=0)\n    max_x, max_y = square_coords.max(axis=0)\n    \n    square_width = max_x - min_x + 1\n    square_height = max_y - min_y + 1\n    \n    # Define the output grid\n    output_grid = np.copy(input_grid)\n\n    # Attempt to translate the square to each edge of the grid\n    n, m = output_grid.shape\n    \n    # Possible directions to translate: up, down, left, right\n    translations = [\n        (-min_x, 0),  # Move up to the top\n        (n - (max_x + 1), 0),  # Move down to the bottom\n        (0, -min_y),  # Move left to the left edge\n        (0, m - (max_y + 1))  # Move right to the right edge\n    ]\n    \n    # Try each translation\n    for dx, dy in translations:\n        translated_square = translate(colored_square, dx, dy, background=Color.BLACK)\n        \n        # Check if the translated square overlaps with any colored pixels in the original grid\n        if np.any((translated_square != Color.BLACK) \u0026 (output_grid != Color.BLACK)):\n            continue\n        \n        # Place the translated square into the output grid\n        blit_sprite(output_grid, translated_square, x=0, y=0, background=Color.BLACK)\n        return output_grid\n    \n    return output_grid  # If no translation is possible, return the original grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Create a random pattern of colors\n    pattern_size = np.random.randint(2, min(n, m) // 2)\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Fill the grid with a pattern of the selected color\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[i, j] = pattern_color\n    \n    # Place the colored square in a random position within the grid\n    square_size = 2\n    square_color = np.random.choice(list(Color.NOT_BLACK))\n    square_x = np.random.randint(0, n - square_size)\n    square_y = np.random.randint(0, m - square_size)\n    \n    for i in range(square_size):\n        for j in range(square_size):\n            grid[square_x + i, square_y + j] = square_color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/262/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/262/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/262/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/262/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/262/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/262/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/262/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/262/images/train_output_2.png"}]}, "index": 262, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotational symmetry, color filling, pixel manipulation\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels that is almost rotationally symmetric, \n# but some parts are missing (covered in black pixels). \n# To make the output, you should fill in the missing parts to make the pattern rotationally symmetric \n# around its center.\n\ndef main(input_grid):\n    # Find the rotational symmetry of the grid\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Create an output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # Get all the colored pixels (excluding black)\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Fill in the missing pixels to create rotational symmetry\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        \n        # Loop through the 4 rotations (0\u00b0, 90\u00b0, 180\u00b0, 270\u00b0)\n        for i in range(1, 4):\n            # Calculate rotated coordinates\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n\n            # If the rotated position is black, fill it with the color\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n            else:\n                # If there\u0027s a color clash, enforce the symmetry\n                assert output_grid[rotated_x, rotated_y] == color, \"The object is not rotationally symmetric\"\n\n    return output_grid\n\n\ndef generate_input():\n    # Initialize a grid of size 10x10\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Create a sprite with a random density of colors\n    sprite = random_sprite(\n        5, 5, density=0.4, symmetry=\"radial\", color_palette=list(Color.NOT_BLACK)\n    )\n\n    # Randomly remove some pixels from the sprite to create missing sections\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.random() \u003c 0.3:  # 30% chance to remove a pixel\n                sprite[i, j] = Color.BLACK\n\n    # Place the sprite onto the grid at a random location\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/263/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/263/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/263/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/263/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/263/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/263/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/263/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/263/images/train_output_2.png"}]}, "index": 263, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, spatial relationships\n\n# description:\n# In the input you will see two colored rectangles on a black background. \n# To make the output, you will need to connect the two rectangles with a pink line, \n# and color the area between them a light gray if it is empty.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = input_grid.copy()\n\n    # Find the connected components (the two rectangles)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    if len(objects) \u003c 2:\n        return output_grid  # If we don\u0027t have two objects, return the original grid.\n\n    # Get the coordinates of the two rectangles\n    rect1 = objects[0]\n    rect2 = objects[1]\n\n    # Get the bounding boxes\n    x1, y1, w1, h1 = bounding_box(rect1, background=Color.BLACK)\n    x2, y2, w2, h2 = bounding_box(rect2, background=Color.BLACK)\n\n    # Draw a pink line between the two rectangles\n    for x in range(min(x1 + w1, x2 + w2), max(x1, x2)):\n        for y in range(min(y1 + h1, y2 + h2), max(y1, y2)):\n            if check_between_objects(obj1=rect1, obj2=rect2, x=x, y=y, padding=1, background=Color.BLACK):\n                output_grid[x, y] = Color.PINK\n\n    # Color the area between rectangles as light gray\n    for x in range(min(x1 + w1, x2 + w2), max(x1, x2)):\n        for y in range(min(y1 + h1, y2 + h2), max(y1, y2)):\n            if output_grid[x, y] == Color.BLACK:\n                output_grid[x, y] = Color.MAROON\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a black background\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate two rectangles with distinct colors\n    colors = np.random.choice([color for color in Color.NOT_BLACK], 2, replace=False)\n    color1, color2 = colors\n\n    # Randomly create two rectangles\n    rect1_width, rect1_height = np.random.randint(2, 6), np.random.randint(2, 6)\n    rect2_width, rect2_height = np.random.randint(2, 6), np.random.randint(2, 6)\n\n    rectangle1 = np.full((rect1_height, rect1_width), color1)\n    rectangle2 = np.full((rect2_height, rect2_width), color2)\n\n    # Place the first rectangle on the grid\n    x1, y1 = random_free_location_for_sprite(grid=grid, sprite=rectangle1, background=Color.BLACK, padding=1)\n    blit_sprite(grid, rectangle1, x1, y1)\n\n    # Place the second rectangle on the grid\n    x2, y2 = random_free_location_for_sprite(grid=grid, sprite=rectangle2, background=Color.BLACK, padding=1)\n    blit_sprite(grid, rectangle2, x2, y2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/264/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/264/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/264/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/264/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/264/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/264/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/264/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/264/images/train_output_2.png"}]}, "index": 264, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, morphing, rotation\n\n# description:\n# In the input, you will see a colored rectangular object and a larger rectangular border of a different color.\n# To make the output, morph the colored rectangular object into a circular shape while preserving its color, then rotate it 90 degrees clockwise and place it inside the larger border.\n\ndef main(input_grid):\n    # Detect the colored rectangular object and the larger border\n    objects = detect_objects(input_grid, monochromatic=True, connectivity=8)\n\n    # Initialize variables for the inner object and the outer border\n    inner_sprite = None\n    outer_sprite = None\n\n    for obj in objects:\n        sprite = crop(obj, background=Color.BLACK)\n        if sprite.shape[0] \u003e 3 and sprite.shape[1] \u003e 3:  # Assuming larger dimensions indicate the border\n            outer_sprite = sprite\n        else:\n            inner_sprite = sprite\n\n    # Morph the inner sprite into a circular shape\n    inner_shape = np.zeros((outer_sprite.shape[0]-2, outer_sprite.shape[1]-2), dtype=int)\n    center_x, center_y = inner_shape.shape[0] // 2, inner_shape.shape[1] // 2\n    radius = min(center_x, center_y) - 1\n    for x in range(inner_shape.shape[0]):\n        for y in range(inner_shape.shape[1]):\n            if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                inner_shape[x, y] = inner_sprite[1, 1]  # Keep the color of the inner sprite\n\n    # Rotate the circular shape 90 degrees clockwise\n    rotated_inner_shape = np.rot90(inner_shape, -1)\n\n    # Prepare the output grid\n    output_grid = np.full(outer_sprite.shape, Color.BLACK)\n    blit_sprite(output_grid, outer_sprite, x=0, y=0)\n    blit_sprite(output_grid, rotated_inner_shape, x=1, y=1)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create the outer rectangular border\n    border_color = Color.RED\n    border_size = np.random.randint(5, 10)\n    border = np.full((border_size, border_size), border_color)\n    border[1:-1, 1:-1] = Color.BLACK  # Hollow center\n    \n    # Randomly place the border in the grid\n    x_border, y_border = random_free_location_for_sprite(grid, border)\n    blit_sprite(grid, border, x=x_border, y=y_border)\n\n    # Create the inner colored rectangle\n    inner_color = np.random.choice(list(Color.NOT_BLACK))\n    inner_sprite = random_sprite(3, 5, color_palette=[inner_color], density=1.0)  # Rectangular sprite\n    x_inner, y_inner = random_free_location_for_sprite(grid, inner_sprite)\n    blit_sprite(grid, inner_sprite, x=x_inner, y=y_inner)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/265/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/265/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/265/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/265/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/265/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/265/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/265/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/265/images/train_output_2.png"}]}, "index": 265, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, bounding box\n\n# description:\n# In the input, you will see a grid with a single colored shape.\n# To make the output, mirror the shape vertically along the vertical centerline of the bounding box.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the object in the input grid\n    # 2. Find the bounding box of the object\n    # 3. Create a mirrored version of the object along the vertical axis of its bounding box\n    # 4. Blit the mirrored shape onto the output grid\n\n    # 1. Detect the object\n    objects = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one object\"\n    obj = objects[0]\n\n    # 2. Find the bounding box of the object\n    x, y, width, height = bounding_box(obj)\n\n    # 3. Create a mirrored version of the object\n    mirrored_sprite = np.zeros_like(obj)\n    for dx in range(width):\n        for dy in range(height):\n            if obj[x + dx, y + dy] != Color.BLACK:\n                mirrored_sprite[x + dx, y + (2 * y + width - 1 - (y + dy))] = obj[x + dx, y + dy]\n\n    # 4. Prepare the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Blit the mirrored shape onto the output grid\n    output_grid = blit_sprite(output_grid, mirrored_sprite, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_size = np.random.randint(10, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a random sprite (the shape)\n    sprite_width, sprite_height = np.random.randint(2, 7), np.random.randint(2, 7)\n    sprite_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[sprite_color], density=0.5)\n\n    # Blit the sprite onto a random location on the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n    grid = blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/266/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/266/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/266/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/266/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/266/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/266/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/266/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/266/images/train_output_2.png"}]}, "index": 266, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, topology, object detection\n\n# description:\n# The input is a black grid that contains several grey circular objects, each with a hole in the center.\n# To produce the output grid, fill in the hole of each grey object with red if the hole is circular. \n# If the hole is not circular, leave the hole as it is.\n\ndef main(input_grid):\n    # Step 1: Find all grey circular objects\n    grey_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # Step 2: Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 3: For each grey object, check for circular holes and fill them\n    for obj in grey_objects:\n        # Get the interior of the object to find the hole\n        hole_mask = (obj == Color.BLACK) \u0026 object_interior(obj, background=Color.BLACK)\n\n        # Check if the hole is circular\n        if is_circular_hole(hole_mask):\n            # Fill the hole with red\n            obj[hole_mask] = Color.RED\n\n        # Blit the possibly modified grey object back to the output grid\n        x, y = object_position(obj, background=Color.BLACK)\n        blit_sprite(output_grid, obj, x, y)\n\n    return output_grid\n\ndef is_circular_hole(hole_mask):\n    # To check if the hole is circular, we can analyze its bounding box\n    # Calculate the area of the hole\n    area = np.sum(hole_mask)\n    \n    # Get the bounding box dimensions\n    y_coords, x_coords = np.argwhere(hole_mask).T\n    height = np.max(y_coords) - np.min(y_coords) + 1\n    width = np.max(x_coords) - np.min(x_coords) + 1\n\n    # Check if the area is close to a circle\u0027s area (\u03c0 * r^2) given the bounding box dimensions\n    # An approximate circular shape would have height and width close to each other\n    circularity = height / width if width != 0 else 0\n    \n    return area \u003e 0 and 0.8 \u003c circularity \u003c 1.2\n\ndef generate_input():\n    # Create a 12x12 black grid\n    grid = np.full((12, 12), Color.BLACK)\n\n    # Add 2-4 grey circular objects, each with a hole\n    num_grey_circles = np.random.randint(2, 5)\n\n    for _ in range(num_grey_circles):\n        # Generate a grey circle with a hole in the middle\n        radius = np.random.randint(2, 5)\n        circle_shape = create_circular_shape(radius)\n        \n        # Find a random position to place the circle on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, circle_shape, border_size=1)\n        except ValueError:\n            # If no space can be found, retry\n            return generate_input()\n\n        # Randomly create a hole in the circle\n        hole_size = np.random.randint(1, radius)\n        hole_x, hole_y = np.random.randint(1, circle_shape.shape[0] - hole_size), np.random.randint(1, circle_shape.shape[1] - hole_size)\n        circle_shape[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n\n        # Blit the circle shape to the grid\n        grid = blit_sprite(grid, circle_shape, x, y, background=Color.BLACK)\n\n    return grid\n\ndef create_circular_shape(radius):\n    # Create a circular shape represented in a grid\n    size = radius * 2 + 1\n    circle = np.full((size, size), Color.GREY)\n    for x in range(size):\n        for y in range(size):\n            if (x - radius) ** 2 + (y - radius) ** 2 \u003e radius ** 2:\n                circle[x, y] = Color.BLACK  # Outside the circle\n    return circle", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/267/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/267/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/267/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/267/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/267/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/267/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/267/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/267/images/train_output_2.png"}]}, "index": 267, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color merging, filling, connectivity\n\n# description:\n# In the input, you will see a grid with a colored object in the center surrounded by a black background. \n# There will also be a single pixel of a different color located randomly on the grid. \n# To make the output, remove the pixel from its original position and fill the entire area of the object in the center with the color of the removed pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find the color of the single pixel\n    pixel_color_x, pixel_color_y = np.where(output_grid != Color.BLACK)\n    \n    # Store the color of the pixel (there should be only one)\n    pixel_color = output_grid[pixel_color_x[0], pixel_color_y[0]]\n\n    # Remove the pixel from its position\n    output_grid[pixel_color_x[0], pixel_color_y[0]] = Color.BLACK\n\n    # Find the central object (the non-black area)\n    object_x, object_y = np.where(output_grid != Color.BLACK)\n    \n    # Fill the connected area of the object with the pixel color\n    flood_fill(output_grid, object_x[0], object_y[0], pixel_color, connectivity=4)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 7x7 black grid\n    n = m = 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the sprite\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random sprite and place it in the center of the grid\n    sprite = random_sprite(n-2, m-2, density=0.7, color_palette=[sprite_color])\n    blit_sprite(grid, sprite, x=1, y=1)\n\n    # Place a single pixel in a random position in the grid, making sure it\u0027s not in the sprite area\n    while True:\n        corner_x, corner_y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[corner_x, corner_y] == Color.BLACK:\n            grid[corner_x, corner_y] = np.random.choice(list(Color.NOT_BLACK))\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/268/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/268/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/268/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/268/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/268/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/268/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/268/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/268/images/train_output_2.png"}]}, "index": 268, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, connectivity, regions\n\n# description:\n# In the input, you will see a grid that contains several colored regions (non-black), separated by black regions.\n# To create the output, identify the connected regions of colors and color every second region with a new color (e.g., yellow).\n# Use flood fill to achieve this transformation.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected color regions in the input grid, ignoring black\n    color_regions = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Color every second connected region with yellow using flood fill\n    for i, region in enumerate(color_regions):\n        if i % 2 == 0:  # Color every second region\n            x, y = np.argwhere(region != Color.BLACK)[0]  # Get a point in the region\n            flood_fill(output_grid, x, y, Color.YELLOW)  # Fill the region with yellow\n\n    return output_grid\n\ndef generate_input():\n    # Define the grid size\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of color regions\n    num_regions = np.random.randint(3, 6)\n\n    for _ in range(num_regions):\n        # Randomly choose the size of the region\n        region_width, region_height = np.random.randint(2, 5, size=2)\n        \n        # Create a random color for the region (not black)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Find a random free location for the region\n        try:\n            x, y = random_free_location_for_sprite(grid, np.full((region_width, region_height), color), padding=1, padding_connectivity=4)\n            # Draw the region on the grid\n            for i in range(region_width):\n                for j in range(region_height):\n                    grid[x + i, y + j] = color\n        except ValueError:\n            continue  # If no space is found, skip and try to create another region\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/269/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/269/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/269/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/269/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/269/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/269/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/269/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/269/images/train_output_2.png"}]}, "index": 269, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, occlusion, position\n\n# description:\n# In the input, you will see a grid where a colorful object is partially occluded by a black rectangle. \n# To make the output, you need to reposition the visible parts of the object to create a complete symmetrical image \n# about the center of the grid, filling in the occluded parts with the appropriate colors.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the occluded rectangle and remove it from the grid.\n    # 2. Find the center of the grid.\n    # 3. For each visible colored pixel, calculate its mirrored position about the center.\n    # 4. Fill in the missing pixels with the colors from the original object.\n\n    # Step 1: Detect the colored object\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n    if len(colored_pixels) == 0:\n        return input_grid  # No colored pixels to process\n\n    # Step 2: Find the center of the grid\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n\n    # Step 3: Create output grid and fill in the mirrored positions\n    output_grid = np.copy(input_grid)\n\n    for x, y in colored_pixels:\n        # Calculate mirrored position about the center\n        mirrored_x = 2 * center_x - x\n        mirrored_y = 2 * center_y - y\n        \n        # Check if the mirrored position is within bounds\n        if (0 \u003c= mirrored_x \u003c input_grid.shape[0]) and (0 \u003c= mirrored_y \u003c input_grid.shape[1]):\n            # Fill in the color from the original position if the output grid is black\n            if output_grid[mirrored_x, mirrored_y] == Color.BLACK:\n                output_grid[mirrored_x, mirrored_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a colorful sprite and place it randomly on the grid\n    sprite_size = np.random.randint(5, min(n, m) // 2)\n    sprite = random_sprite(sprite_size, sprite_size, color_palette=Color.NOT_BLACK, density=0.5)\n\n    # Place the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=x, y=y)\n\n    # Create a random occluder (black rectangle) that overlaps the sprite\n    occluder_width, occluder_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    occluder_x = np.random.randint(0, n - occluder_height)\n    occluder_y = np.random.randint(0, m - occluder_width)\n    \n    # Make sure the occluder overlaps the sprite\n    for i in range(occluder_x, occluder_x + occluder_height):\n        for j in range(occluder_y, occluder_y + occluder_width):\n            if grid[i, j] != Color.BLACK:  # Only occlude if there\u0027s something to occlude\n                grid[i, j] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/270/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/270/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/270/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/270/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/270/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/270/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/270/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/270/images/train_output_2.png"}]}, "index": 270, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, bounding box, filling, expansion\n\n# description:\n# In the input, you will see a grid with a shape made up of colored pixels.\n# To make the output grid, you should first find the bounding box of the shape,\n# then fill the shape with a new color, and finally expand the filled shape outward by a given distance \n# in all four directions (up, down, left, right).\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the bounding box of the shape\n    # 2. Fill the shape inside the bounding box with a new color\n    # 3. Expand the filled shape outward by a certain distance\n\n    # 1. Find the bounding box of the shape\n    objects = find_connected_components(input_grid, monochromatic=False)\n    assert len(objects) == 1, \"There should be exactly one shape\"\n    shape = objects[0]\n    shape_color = object_colors(shape)[0]\n    \n    # Get bounding box\n    x, y, width, height = bounding_box(shape)\n\n    # 2. Fill the shape with a new color (let\u0027s say Color.GREEN)\n    output_grid = np.copy(input_grid)\n    output_grid[shape == shape_color] = Color.GREEN\n\n    # 3. Expand the filled shape outward by a distance of 1\n    for dx in range(-1, 2):  # -1, 0, 1\n        for dy in range(-1, 2):  # -1, 0, 1\n            if abs(dx) + abs(dy) == 1:  # Only expand one pixel outward\n                for x_offset in range(width):\n                    for y_offset in range(height):\n                        if output_grid[x + x_offset, y + y_offset] == Color.GREEN:\n                            output_grid[x + x_offset + dx, y + y_offset + dy] = Color.GREEN\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random size\n    width = np.random.randint(8, 20)\n    height = np.random.randint(8, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a random shape (a filled rectangle)\n    rect_width = np.random.randint(3, 6)\n    rect_height = np.random.randint(3, 6)\n    top_left_x = np.random.randint(0, width - rect_width)\n    top_left_y = np.random.randint(0, height - rect_height)\n\n    # Fill the rectangle with a random color\n    color = np.random.choice(Color.NOT_BLACK)\n    for x in range(rect_width):\n        for y in range(rect_height):\n            grid[top_left_x + x, top_left_y + y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/271/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/271/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/271/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/271/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/271/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/271/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/271/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/271/images/train_output_2.png"}]}, "index": 271, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, translation, color filling\n\n# description:\n# In the input you will see a yellow 3x3 square and several blue pixels scattered around it.\n# To make the output grid, slide the yellow square in any of the four cardinal directions until it just touches the nearest blue pixel.\n# The area covered by the yellow square should then be filled with red.\n\ndef main(input_grid):\n    # Extract the yellow square object\n    yellow_square = np.zeros_like(input_grid)\n    yellow_square[input_grid == Color.YELLOW] = Color.YELLOW\n\n    # Find the position of the yellow square\n    yellow_x, yellow_y = np.argwhere(yellow_square == Color.YELLOW)[0]  # Get the position of the first yellow pixel\n    square_size = 3  # Since it\u0027s a 3x3 square\n\n    # The output grid starts as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Directions for sliding: right, left, down, up\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    # The maximum distance to slide in any direction\n    max_distance = max(input_grid.shape)\n\n    # Slide the yellow square in each direction until it touches a blue pixel\n    for dx, dy in directions:\n        for distance in range(1, max_distance):\n            # Translate the yellow square\n            translated_square = translate(yellow_square, dx * distance, dy * distance, background=Color.BLACK)\n            if contact(object1=translated_square, object2=input_grid):\n                # Check if there is contact with blue pixels\n                if np.any(translated_square[input_grid == Color.BLUE]):\n                    # Fill the area of the yellow square in the output grid with red\n                    output_grid[yellow_x:yellow_x + square_size, yellow_y:yellow_y + square_size] = Color.RED\n                    return output_grid\n\n    return output_grid  # Return unmodified output grid if no blue pixels are touched\n\ndef generate_input():\n    # Create a black grid of size n x m\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Place a yellow 3x3 square somewhere in the grid\n    yellow_square = np.full((3, 3), Color.YELLOW)\n    x, y = random_free_location_for_sprite(grid, yellow_square, padding=1)\n    blit_sprite(grid, yellow_square, x, y)\n\n    # Place several blue pixels around the yellow square\n    number_of_blue_pixels = np.random.randint(5, 15)\n    for _ in range(number_of_blue_pixels):\n        blue_pixel = random_sprite(1, 1, density=1, color_palette=[Color.BLUE])\n        try:\n            x, y = random_free_location_for_sprite(grid, blue_pixel, padding=1)\n            blit_sprite(grid, blue_pixel, x, y)\n        except:\n            continue  # Skip if no space is available for the blue pixel\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/272/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/272/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/272/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/272/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/272/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/272/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/272/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/272/images/train_output_2.png"}]}, "index": 272, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# direction, line drawing, object detection\n\n# description:\n# In the input, you will see several vertical or horizontal lines of the same color and a single pixel of a different color. \n# The goal is to detect the lines, determine their direction, and draw a new line of the color of the single pixel that extends from the center of the detected lines in both directions.\n\ndef main(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Detect the lines present in the grid\n    lines = detect_objects(input_grid, colors=list(Color.NOT_BLACK), monochromatic=True, connectivity=8)\n\n    # For each detected line, determine its center and direction\n    for line in lines:\n        # Find the bounding box of the detected line\n        x, y, width, height = bounding_box(line)\n\n        # Determine the color of the line\n        line_color = np.unique(line[line != Color.BLACK])[0]\n\n        # Calculate the center of the line\n        center_x = x + width // 2\n        center_y = y + height // 2\n\n        # Detect the direction of the line\n        if width \u003e height:  # Horizontal line\n            direction = (1, 0)  # Direction to the right\n        else:  # Vertical line\n            direction = (0, 1)  # Direction downwards\n\n        # Find the single pixel of a different color (the color to use for the new line)\n        single_pixel_color = np.unique(input_grid[input_grid != Color.BLACK])\n        single_pixel_color = single_pixel_color[single_pixel_color != line_color][0]  # Exclude the line color\n\n        # Draw a new line of the color of the single pixel from the center of the line in both directions\n        draw_line(output_grid, center_x, center_y, length=None, color=single_pixel_color, direction=direction)\n        draw_line(output_grid, center_x, center_y, length=None, color=single_pixel_color, direction=(-direction[0], -direction[1]))\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly decide the color of the lines\n    line_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create vertical or horizontal lines\n    for _ in range(random.randint(1, 3)):\n        if random.choice([True, False]):  # Vertical line\n            col = random.randint(0, m - 1)\n            start_row = random.randint(0, n - 3)\n            grid[start_row:start_row + random.randint(2, 4), col] = line_color\n        else:  # Horizontal line\n            row = random.randint(0, n - 1)\n            start_col = random.randint(0, m - 3)\n            grid[row, start_col:start_col + random.randint(2, 4)] = line_color\n\n    # Place a single pixel of a different color\n    single_pixel_color = np.random.choice(Color.NOT_BLACK)\n    while single_pixel_color == line_color:\n        single_pixel_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Randomly place the single pixel in the grid\n    x, y = random_free_location_for_sprite(grid, np.array([[single_pixel_color]]), background=Color.BLACK)\n    grid[x, y] = single_pixel_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/273/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/273/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/273/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/273/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/273/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/273/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/273/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/273/images/train_output_2.png"}]}, "index": 273, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, pattern extension, non-black background\n\n# description:\n# In the input, you will see a translationally symmetric pattern in a grid with a non-black background.\n# To make the output, continue the symmetric pattern until it covers the entire canvas, shifting everything down by one pixel.\n\ndef main(input_grid):\n    # Step 1: Detect the background color\n    pixels_on_border = np.concatenate([input_grid[0, :], input_grid[-1, :], input_grid[:, 0], input_grid[:, -1]])\n    background = max(set(pixels_on_border), key=list(pixels_on_border).count)\n\n    # Step 2: Find the translational symmetries in the input grid\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[], background=background)\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # Step 3: Prepare an output grid with the same width but one more row to accommodate the downward shift\n    width, height = input_grid.shape\n    output_grid = np.full((width + 1, height), background)  # Initialize with the background color\n\n    # Step 4: Copy all of the input pixels to the output, while computing their orbits\n    for x, y in np.argwhere(input_grid != background):\n        # Compute the orbit into the output grid\n        for x2, y2 in orbit(output_grid, x, y, symmetries):\n            output_grid[x2, y2] = input_grid[x, y]\n\n    # Step 5: Shift everything down by one pixel\n    output_grid = output_grid[:-1, :]  # Remove the last row to achieve the downward shift\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Choose a random background color that is not black\n    background_color = random.choice(Color.NOT_BLACK)\n\n    # Step 2: Create a random canvas\n    grid = np.full((np.random.randint(15, 30), np.random.randint(15, 30)), background_color)\n\n    # Step 3: Make a basic sprite with a random size\n    w, h = random.randint(2, 4), random.randint(2, 4)\n    sprite = np.random.choice([color for color in Color.ALL_COLORS if color != background_color], (w, h))\n\n    # Step 4: Tile the sprite multiple times on the grid\n    max_x = random.randint(w + 1, grid.shape[0])\n    max_y = random.randint(h + 1, grid.shape[1])\n    for x in range(0, max_x, w):\n        for y in range(0, max_y, h):\n            blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/274/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/274/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/274/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/274/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/274/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/274/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/274/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/274/images/train_output_2.png"}]}, "index": 274, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, transformation, output generation\n\n# description:\n# In the input you will see a grid with several colored pixels, some of which are purple (Color.PINK).\n# To make the output grid, create a new grid where each purple pixel is replaced with a green pixel.\n# Additionally, for each purple pixel, create a blue pixel in the immediate vertical neighbors (up and down) unless the neighbor is already occupied by another color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.PINK:\n                # Replace purple pixel with a green pixel\n                output_grid[x][y] = Color.GREEN\n                \n                # Add blue pixels in the immediate vertical neighbors\n                if x \u003e 0:  # Check above\n                    if output_grid[x - 1][y] == Color.BLACK:\n                        output_grid[x - 1][y] = Color.BLUE\n                if x \u003c input_grid.shape[0] - 1:  # Check below\n                    if output_grid[x + 1][y] == Color.BLACK:\n                        output_grid[x + 1][y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly place some pink pixels in the grid\n    num_pink = np.random.randint(1, 10)  # Number of pink pixels to introduce\n    for _ in range(num_pink):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.PINK\n\n    # Scatter some other random colors in the grid\n    num_other_colors = np.random.randint(5, 20)\n    for _ in range(num_other_colors):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:  # Only place if the spot is empty\n            grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color != Color.PINK])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/275/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/275/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/275/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/275/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/275/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/275/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/275/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/275/images/train_output_2.png"}]}, "index": 275, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, connection, line drawing\n\n# description:\n# In the input you will see two colored pixels located in different parts of the grid.\n# To make the output, connect the two colored pixels with a blue line, but only if the line does not intersect with any other colored pixels.\n# If the line would intersect any other pixels, change the connecting line to a dashed blue line, which consists of alternating blue and black pixels.\n\ndef main(input_grid):\n    # Make a copy of the input grid for the output\n    output_grid = input_grid.copy()\n\n    # Find the two colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    if len(colored_pixels) != 2:\n        raise ValueError(\"Input grid must contain exactly two colored pixels.\")\n\n    pixel1, pixel2 = colored_pixels[0], colored_pixels[1]\n    x1, y1 = pixel1\n    x2, y2 = pixel2\n\n    # Check if there are any pixels between the two colored pixels\n    for x in range(min(x1, x2), max(x1, x2) + 1):\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            if (x, y) != (x1, y1) and (x, y) != (x2, y2) and input_grid[x, y] != Color.BLACK:\n                # If there is an intersection, draw a dashed line\n                for i in range(0, abs(x2 - x1) + 1):\n                    if (x1 \u003c x2 and x1 + i \u003c= x2) or (x1 \u003e x2 and x2 + i \u003c= x1):\n                        # Alternate between blue and black\n                        color = Color.BLUE if i % 2 == 0 else Color.BLACK\n                        output_grid[x1 + i * np.sign(x2 - x1), y1 + i * np.sign(y2 - y1)] = color\n                return output_grid\n\n    # If there are no intersections, draw a solid blue line\n    draw_line(output_grid, x1, y1, end_x=x2, end_y=y2, color=Color.BLUE)\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(5, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose two colors for the colored pixels\n    colors = np.random.choice(Color.NOT_BLACK, size=2, replace=False)\n\n    # Randomly place the two colored pixels on the grid\n    for color in colors:\n        while True:\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            if grid[x, y] == Color.BLACK:  # Ensure the pixel is placed on a black background\n                grid[x, y] = color\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/276/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/276/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/276/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/276/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/276/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/276/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/276/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/276/images/train_output_2.png"}]}, "index": 276, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# interiors, object fitting, color patterns, transformations\n\n# description:\n# In the input, you will see multiple colored rectangles with a black hole in the center of each. \n# Each rectangle will have a corresponding shape that matches the hole\u0027s dimensions but is a different color. \n# The task is to fit each matching shape into its respective black hole, replacing the hole with the colored shape. \n# If a shape does not match a hole, leave it in its original position.\n\ndef main(input_grid):\n    # Parse the input into grey rectangles with holes and colored shapes\n    grey_input = input_grid.copy()\n    grey_input[input_grid != Color.GREY] = Color.BLACK\n    grey_objects = find_connected_components(grey_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Extracting black hole regions\n    black_holes = [object_interior(obj, background=Color.BLACK) \u0026 (obj == Color.BLACK) for obj in grey_objects]\n\n    # Non-grey objects that could potentially fit into the holes\n    non_grey_input = input_grid.copy()\n    non_grey_input[input_grid == Color.GREY] = Color.BLACK\n    colored_shapes = find_connected_components(non_grey_input, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Prepare the output grid\n    output_grid = np.copy(input_grid)\n\n    # Check if each colored shape can fit into a black hole\n    for colored_shape in colored_shapes:\n        shape_mask = crop(colored_shape, background=Color.BLACK)\n        shape_height, shape_width = shape_mask.shape\n        \n        # Get the color of the shape\n        shape_color = object_colors(colored_shape, background=Color.BLACK)[0]\n\n        for hole in black_holes:\n            # Crop the black hole\u0027s interior\n            hole_mask = crop(hole, background=Color.BLACK)\n            hole_height, hole_width = hole_mask.shape\n            \n            # Check if the shape can fit into the hole\n            if shape_height == hole_height and shape_width == hole_width:\n                # Remove the black hole from the output grid\n                output_grid[hole != Color.BLACK] = Color.BLACK\n                # Place the colored shape into the hole\n                hole_x, hole_y, _, _ = bounding_box(hole)\n                blit_sprite(output_grid, shape_mask, hole_x, hole_y, background=Color.BLACK)\n                break\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 20, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    n_grey_objects = np.random.randint(1, 4)\n    for _ in range(n_grey_objects):\n        grey_width, grey_height = np.random.randint(4, 7, size=2)\n        grey_sprite = np.full((grey_width, grey_height), Color.GREY)\n\n        # Create a black hole in the grey object\n        hole_width, hole_height = np.random.randint(1, grey_width-1), np.random.randint(1, grey_height-1)\n        hole_sprite = np.full((hole_width, hole_height), Color.BLACK)\n        hole_x, hole_y = np.random.randint(0, grey_width - hole_width), np.random.randint(0, grey_height - hole_height)\n        blit_sprite(grey_sprite, hole_sprite, hole_x, hole_y, background=Color.GREY)\n\n        # Place the grey object in the input grid\n        x, y = random_free_location_for_sprite(input_grid, grey_sprite)\n        blit_sprite(input_grid, grey_sprite, x, y, background=Color.BLACK)\n\n        # Create a matching shape for the hole\n        shape_sprite = np.full((hole_width, hole_height), np.random.choice(Color.NOT_BLACK))\n        # Place the shape in the input grid\n        x_shape, y_shape = random_free_location_for_sprite(input_grid, shape_sprite)\n        blit_sprite(input_grid, shape_sprite, x_shape, y_shape, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/277/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/277/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/277/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/277/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/277/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/277/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/277/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/277/images/train_output_2.png"}]}, "index": 277, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, scaling, filling\n\n# description:\n# In the input you will see a grid containing a central pattern surrounded by black pixels. \n# The task is to extract this central pattern, scale it up by a specified factor, \n# and then fill the entire grid with this scaled pattern, such that it covers the grid completely.\n\ndef main(input_grid):\n    # Step 1: Detect the central pattern by finding the connected component that is not black\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1, \"Exactly one central pattern expected\"\n    central_pattern = crop(objects[0], background=Color.BLACK)\n\n    # Step 2: Define a scaling factor\n    scaling_factor = 3  # This can be changed for different inputs\n\n    # Step 3: Scale the central pattern\n    scaled_pattern = scale_sprite(central_pattern, factor=scaling_factor)\n\n    # Step 4: Prepare the output grid\n    output_width = scaled_pattern.shape[0]\n    output_height = scaled_pattern.shape[1]\n    output_grid = np.full((output_width, output_height), Color.BLACK)\n\n    # Step 5: Fill the output grid with the scaled pattern\n    for x in range(0, output_grid.shape[0], scaled_pattern.shape[0]):\n        for y in range(0, output_grid.shape[1], scaled_pattern.shape[1]):\n            blit_sprite(output_grid, scaled_pattern, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random input grid with a central pattern\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a central pattern\n    pattern_size = np.random.randint(2, min(n, m) // 2)\n    center_x, center_y = n // 2, m // 2\n    pattern = random_sprite(n=pattern_size, m=pattern_size, density=0.5, color_palette=Color.NOT_BLACK)\n\n    # Place the pattern in the center of the grid\n    blit_sprite(grid, pattern, x=center_x - pattern_size // 2, y=center_y - pattern_size // 2, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/278/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/278/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/278/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/278/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/278/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/278/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/278/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/278/images/train_output_2.png"}]}, "index": 278, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, boundary detection\n\n# description:\n# The input grid consists of a black background with several green objects. \n# Some of these green objects may have holes, creating enclosed regions. \n# To produce the output grid, color the boundaries of all enclosed regions with blue, \n# while leaving the rest of the grid unchanged.\n\ndef main(input_grid):\n    # Create an output grid based on the input grid\n    output_grid = input_grid.copy()\n\n    # Find all green objects in the grid\n    green_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # For each green object, find its boundary\n    for obj in green_objects:\n        boundary_mask = object_boundary(obj, background=Color.BLACK)\n\n        # Color the boundary with blue\n        output_grid[boundary_mask] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate a square grid of size 10 to 20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a random number of green objects\n    num_objects = np.random.randint(2, 6)\n\n    for _ in range(num_objects):\n        # Create a random sprite of green pixels\n        w, h = np.random.randint(3, 8), np.random.randint(3, 8)\n        sprite = random_sprite(w, h, color_palette=[Color.GREEN], density=0.5, connectivity=8)\n\n        # Randomly place the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue\n\n        # Create holes in the sprite to form enclosed regions\n        num_holes = np.random.randint(0, 3)  # Up to 2 holes\n        for _ in range(num_holes):\n            hole_width, hole_height = np.random.randint(1, 3), np.random.randint(1, 3)\n            hole_sprite = random_sprite(hole_width, hole_height, color_palette=[Color.BLACK], density=1.0)\n            hole_x, hole_y = np.random.randint(x + 1, x + w - hole_width - 1), np.random.randint(y + 1, y + h - hole_height - 1)\n            blit_sprite(grid, hole_sprite, hole_x, hole_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/279/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/279/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/279/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/279/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/279/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/279/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/279/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/279/images/train_output_2.png"}]}, "index": 279, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reconstruction, cropping\n\n# description:\n# In the input, you will see a 5x5 grid containing a colored pattern in the center, surrounded by a black background.\n# To create the output, crop the pattern and replicate it to fill the entire grid, leaving a border of black pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)  \n\n    # Crop the central pattern from the input grid\n    pattern = crop(input_grid, background=Color.BLACK)\n\n    # Get the shape of the cropped pattern\n    pattern_height, pattern_width = pattern.shape\n\n    # Fill the output grid with the cropped pattern\n    for i in range(0, output_grid.shape[0], pattern_height):\n        for j in range(0, output_grid.shape[1], pattern_width):\n            # Avoid writing outside the bounds of the grid\n            if i + pattern_height \u003c= output_grid.shape[0] and j + pattern_width \u003c= output_grid.shape[1]:\n                output_grid[i:i + pattern_height, j:j + pattern_width] = pattern\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size 11x11 with a black background\n    grid_size = 11\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Define the size and position of the central pattern\n    pattern_size = 5\n    start_x = (grid_size - pattern_size) // 2\n    start_y = (grid_size - pattern_size) // 2\n\n    # Create a random pattern in the center\n    pattern_color = random.choice(Color.NOT_BLACK)\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            if np.random.rand() \u003e 0.5:  # Randomly fill some pixels\n                grid[start_x + i, start_y + j] = pattern_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/280/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/280/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/280/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/280/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/280/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/280/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/280/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/280/images/train_output_2.png"}]}, "index": 280, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color extraction, object transformation\n\n# description:\n# In the input you will see a grid containing a repeated pattern of colors arranged in a specific manner,\n# with a special blue square located in the center of the grid. \n# To create the output, you should extract the pattern surrounding the blue square,\n# and change all colors within the pattern to match the color of the blue square.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Detect the blue square in the input grid\n    blue_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    \n    if not blue_objects:\n        return input_grid  # If no blue square, return the input grid unchanged\n\n    # Assume only one blue square is present\n    blue_square = blue_objects[0]\n    blue_color = blue_square[0, 0]  # Get the color of the blue square\n\n    # Crop the grid around the blue square\n    output_grid = input_grid.copy()\n    x, y, _, _ = bounding_box(blue_square)\n\n    # Define the pattern area around the blue square (1 pixel border)\n    pattern_area = output_grid[max(0, x-1):min(output_grid.shape[0], x + blue_square.shape[0] + 1),\n                                max(0, y-1):min(output_grid.shape[1], y + blue_square.shape[1] + 1)]\n\n    # Change all colors in the pattern area to the color of the blue square\n    output_grid[max(0, x-1):min(output_grid.shape[0], x + blue_square.shape[0] + 1),\n                max(0, y-1):min(output_grid.shape[1], y + blue_square.shape[1] + 1)] = blue_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize the grid with a random size\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a repeating color pattern\n    colors = random.sample(Color.NOT_BLACK, k=3)  # Choose three different colors\n    pattern = np.array([[colors[0], colors[1]], [colors[1], colors[2]]])  # A simple 2x2 pattern\n\n    # Fill the grid with the pattern\n    for i in range(0, n, 2):\n        for j in range(0, m, 2):\n            if i \u003c n and j \u003c m:\n                grid[i:i+2, j:j+2] = pattern\n\n    # Place a blue square in the center of the grid\n    center_x, center_y = n // 2, m // 2\n    grid[center_x, center_y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/281/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/281/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/281/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/281/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/281/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/281/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/281/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/281/images/train_output_2.png"}]}, "index": 281, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color extraction, object manipulation, shapes\n\n# description:\n# In the input, you will see a grid containing a single circular object in various colors. The background is black.\n# To make the output grid, draw concentric circles around the original circle, using colors that alternate between those found in the original circle.\n# The radius of the new circles will increase by 1 unit for each additional circle drawn.\n\ndef main(input_grid):\n    # 1. Find the circular object\n    background = Color.BLACK\n    circular_objects = find_connected_components(input_grid, connectivity=8, monochromatic=False, background=background)\n    \n    assert len(circular_objects) == 1, \"There should be exactly one circular object in the grid.\"\n    circular_object = circular_objects[0]\n\n    # 2. Extract the colors from the circular object\n    colors_in_circle = object_colors(circular_object, background=background)\n    if len(colors_in_circle) == 0:\n        return input_grid  # No colors, return original grid\n\n    # 3. Determine the center of the circular object\n    center_x, center_y = np.argwhere(circular_object != background)[0]\n\n    # 4. Prepare to draw concentric circles\n    output_grid = input_grid.copy()\n    max_radius = 3  # You can choose how many circles to draw\n    for radius in range(1, max_radius + 1):\n        color_to_use = colors_in_circle[(radius - 1) % len(colors_in_circle)]\n        # Draw the circle with the current radius\n        draw_circle(output_grid, center_x, center_y, radius, color=color_to_use)\n\n    return output_grid\n\ndef draw_circle(grid, center_x, center_y, radius, color):\n    # Draw a circle of a given radius centered at (center_x, center_y)\n    for x in range(-radius, radius + 1):\n        for y in range(-radius, radius + 1):\n            if x**2 + y**2 \u003c= radius**2:  # Check if the point is within the circle\n                if 0 \u003c= center_x + x \u003c grid.shape[0] and 0 \u003c= center_y + y \u003c grid.shape[1]:  # Check bounds\n                    grid[center_x + x, center_y + y] = color\n\ndef generate_input():\n    # Generate a grid with a single circular object\n    grid_size = np.random.randint(10, 20)\n    grid = np.full((grid_size, grid_size), Color.BLACK)  # Start with a black grid\n\n    # Randomly choose a color for the circular object\n    circular_color = random.choice(Color.NOT_BLACK)\n    \n    # Randomly choose a center and radius for the circle\n    center_x = np.random.randint(1, grid_size - 1)\n    center_y = np.random.randint(1, grid_size - 1)\n    radius = np.random.randint(2, 5)\n\n    # Draw the circular object\n    for x in range(-radius, radius + 1):\n        for y in range(-radius, radius + 1):\n            if x**2 + y**2 \u003c= radius**2:  # Check if the point is within the circle\n                if 0 \u003c= center_x + x \u003c grid.shape[0] and 0 \u003c= center_y + y \u003c grid.shape[1]:  # Check bounds\n                    grid[center_x + x, center_y + y] = circular_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/282/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/282/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/282/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/282/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/282/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/282/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/282/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/282/images/train_output_2.png"}]}, "index": 282, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, object positioning, color manipulation\n\n# description:\n# In the input, you will see a grid with a variety of colored objects placed on a black background. \n# Exactly one of the colored objects is surrounded by a ring of black pixels, making it appear as a \u0027target\u0027.\n# To create the output, move the colored object at the center of the target to the position of the top-left corner of the grid, \n# and fill its original position with black pixels. The remaining colored objects should remain unchanged.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the colored objects and locate the target object (the one surrounded by black pixels).\n    # 2. Determine the position of the target object.\n    # 3. Move the target object to the top-left corner of the grid while filling its original position with black pixels.\n\n    # Step 1: Detect all colored objects\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False, background=Color.BLACK)\n\n    # Find the target object that is surrounded by black pixels\n    target_object = None\n    for obj in objects:\n        # Check if the object is surrounded by black pixels\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj)\n        # Check the pixels surrounding the bounding box\n        if (input_grid[x-1:x+width+1, y-1:y+height+1] == Color.BLACK).all():\n            target_object = obj\n            break\n\n    assert target_object is not None, \"No target object found.\"\n\n    # Step 2: Determine the position of the target object\n    target_x, target_y = object_position(target_object, background=Color.BLACK)\n\n    # Prepare the output grid\n    output_grid = input_grid.copy()\n\n    # Step 3: Move the target object to the top-left corner\n    # Fill the original position with black pixels\n    original_x, original_y, _, _ = bounding_box(target_object)\n    output_grid[original_x:original_x + target_object.shape[0], original_y:original_y + target_object.shape[1]] = Color.BLACK\n\n    # Blit the target object to the top-left corner\n    blit_object(output_grid, target_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a black background.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a set of random colored objects\n    colors = np.random.choice(Color.NOT_BLACK, size=5, replace=False)\n\n    # Randomly place these colored objects in the grid\n    for color in colors:\n        # Create a random shape for the object\n        width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n        colored_sprite = np.full((width, height), color)\n\n        # Find a free location for this sprite and blit it to the grid\n        x, y = random_free_location_for_sprite(grid, colored_sprite, background=Color.BLACK)\n        blit_sprite(grid, colored_sprite, x, y, background=Color.BLACK)\n\n        # Randomly decide if this colored object should be the target surrounded by black pixels\n        if np.random.rand() \u003c 0.5:\n            # Surround the object with black pixels\n            for i in range(-1, width + 1):\n                for j in range(-1, height + 1):\n                    if 0 \u003c= x + i \u003c n and 0 \u003c= y + j \u003c m:\n                        grid[x + i, y + j] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/283/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/283/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/283/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/283/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/283/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/283/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/283/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/283/images/train_output_2.png"}]}, "index": 283, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flood fill, revealing patterns, noise detection\n\n# description:\n# In the input you will see a grid containing several colored circles (filled 3x3 squares)\n# on a black background, along with random noise pixels scattered throughout the grid. \n# To generate the output, you should remove the noise pixels that are not adjacent to any circle.\n# If a noise pixel is adjacent to a circle, reveal the color of that circle in the output grid.\n\ndef main(input_grid):\n    # Find all the colored circles (representing filled 3x3 squares)\n    colored_objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    \n    # Create an output grid, initially a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Detect noise pixels (pixels not part of any colored circle)\n    noise_pixels = input_grid == Color.BLACK\n    \n    for circle in colored_objects:\n        circle_mask = circle != Color.BLACK  # Mask for colored pixels\n        neighbors_mask = object_neighbors(circle, background=Color.BLACK, connectivity=4)  # Get neighboring pixels\n\n        # For each pixel in the noise area, if it is a neighbor of a circle\n        for x in range(input_grid.shape[0]):\n            for y in range(input_grid.shape[1]):\n                if noise_pixels[x, y] and neighbors_mask[x, y]:\n                    # If it is a neighbor, set the output grid pixel to the color of the circle\n                    output_grid[x, y] = np.argmax(np.bincount(circle[circle_mask].flatten()))\n    \n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color for the circles\n    circle_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly choose the number of circles\n    num_circles = np.random.randint(3, 6)\n\n    for _ in range(num_circles):\n        # Create a filled circle (3x3 square)\n        circle = np.full((3, 3), circle_color)\n        x, y = random_free_location_for_sprite(grid, circle, border_size=1, padding=1)\n        grid = blit_sprite(grid, circle, x, y)\n\n    # Add noise pixels randomly across the grid\n    num_noise_pixels = np.random.randint(10, 30)\n    for _ in range(num_noise_pixels):\n        x, y = np.random.randint(n), np.random.randint(m)\n        grid[x, y] = Color.BLACK  # Add noise\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/284/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/284/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/284/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/284/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/284/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/284/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/284/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/284/images/train_output_2.png"}]}, "index": 284, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color connection, component extraction, background filling\n\n# description:\n# In the input, you will see a grid filled with colored pixels and black background.\n# To make the output grid, find connected components of each color (excluding the black background) and fill the background with the color of the largest connected component.\n# If there are multiple largest components of the same size, choose the first one encountered.\n\ndef main(input_grid):\n    # Find connected components, ignoring the black background\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    # Determine the largest component\n    largest_component = max(components, key=lambda comp: np.sum(comp != Color.BLACK))\n\n    # Get the color of the largest component\n    largest_color = largest_component[0, 0]\n\n    # Create output grid filled with the largest color\n    output_grid = np.full(input_grid.shape, largest_color)\n\n    # Blit the largest connected component back onto the output grid\n    blit_object(output_grid, largest_component, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly populate the grid with colored pixels\n    num_colors = np.random.randint(3, 10)\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    # Randomly fill in pixels\n    for color in colors:\n        num_pixels = np.random.randint(5, 15)\n        for _ in range(num_pixels):\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/285/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/285/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/285/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/285/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/285/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/285/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/285/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/285/images/train_output_2.png"}]}, "index": 285, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# center detection, color propagation, bounding box\n\n# description:\n# In the input, you will see a grid with various colored squares. \n# To create the output, you need to find the color of the square closest to the center of the grid \n# and change the color of all other squares to match its color. \n# The output grid should retain the original size of the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Determine the center of the grid\n    center_x = input_grid.shape[0] // 2\n    center_y = input_grid.shape[1] // 2\n\n    # Step 2: Find the square closest to the center\n    min_distance = float(\u0027inf\u0027)\n    closest_color = None\n\n    # Step 3: Iterate through the grid to find the closest square color\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # Check if the current cell is not black (background)\n            if input_grid[x, y] != Color.BLACK:\n                # Calculate the distance from the center\n                distance = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)\n                if distance \u003c min_distance:\n                    min_distance = distance\n                    closest_color = input_grid[x, y]\n\n    # Step 4: Create the output grid and fill it with the closest color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[input_grid != Color.BLACK] = closest_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid of random colors with some background\n    grid_size = 20\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly scatter colored squares in the grid\n    num_squares = np.random.randint(5, 15)\n    for _ in range(num_squares):\n        square_size = np.random.randint(2, 5)\n        color = np.random.choice([c for c in Color.NOT_BLACK])  # Exclude black color\n\n        # Find a random location for the square\n        try:\n            x, y = random_free_location_for_sprite(grid, np.full((square_size, square_size), color), background=Color.BLACK)\n            blit_sprite(grid, np.full((square_size, square_size), color), x, y)\n        except:\n            continue  # If no free location, skip this square\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/286/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/286/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/286/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/286/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/286/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/286/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/286/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/286/images/train_output_2.png"}]}, "index": 286, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, shape detection\n\n# description:\n# In the input you will see a grid with a pattern of teal shapes. \n# To create the output grid, identify the largest teal shape and move it up by 2 pixels. \n# If it moves out of bounds, replace it with black.\n\ndef main(input_grid):\n    # Step 1: Detect connected components (teal shapes)\n    teal_shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Step 2: Find the largest teal shape by area\n    largest_shape = max(teal_shapes, key=lambda shape: np.sum(shape == Color.TEAL))\n\n    # Step 3: Translate the largest shape up by 2 pixels\n    translated_shape = translate(largest_shape, x=0, y=-2, background=Color.BLACK)\n\n    # Step 4: Create an output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Step 5: Blit the translated shape onto the output grid\n    output_grid = blit_object(output_grid, translated_shape, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter teal shapes within the grid\n    num_shapes = np.random.randint(1, 6)\n    for _ in range(num_shapes):\n        shape_width = np.random.randint(2, 5)\n        shape_height = np.random.randint(2, 5)\n        shape = np.full((shape_height, shape_width), Color.TEAL)\n\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n            blit_sprite(grid, shape, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no free location can be found, skip this shape\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/287/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/287/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/287/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/287/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/287/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/287/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/287/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/287/images/train_output_2.png"}]}, "index": 287, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color transformation, bounding box analysis\n\n# description:\n# In the input, you will see a grid with several colored shapes (green, yellow, and blue)\n# To create the output, change all blue shapes to yellow, yellow shapes to green, and green shapes to blue.\n# The transformation should only apply to shapes, ignoring the black background.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all colored objects in the grid\n    colors_to_transform = {\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.GREEN,\n        Color.GREEN: Color.BLUE\n    }\n    \n    # Detect objects for each color\n    for original_color, new_color in colors_to_transform.items():\n        objects = detect_objects(grid=input_grid, colors=[original_color], monochromatic=True, connectivity=4)\n        for obj in objects:\n            # Get the bounding box mask of the object\n            bbox_mask = bounding_box_mask(obj, background=Color.BLACK)\n            # Change the color of the object within the bounding box\n            output_grid[bbox_mask] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # List of colors to use for shapes\n    shape_colors = [Color.GREEN, Color.YELLOW, Color.BLUE]\n\n    # Randomly generate shapes and place them in the grid\n    for _ in range(np.random.randint(3, 6)):  # Create between 3 to 5 shapes\n        shape_color = np.random.choice(shape_colors)\n        shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=0.5)\n\n        # Find a free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, padding=1)\n            grid = blit_sprite(grid, shape, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no free location can be found, skip this shape\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/288/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/288/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/288/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/288/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/288/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/288/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/288/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/288/images/train_output_2.png"}]}, "index": 288, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object completion, topology\n\n# description:\n# In the input you will see a black background with several incomplete teal shapes (like triangles or L-shapes).\n# To make the output, complete the shapes with red color, ensuring that the completed shape remains connected.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = input_grid.copy()\n\n    # Find all teal objects in the grid\n    object_color = Color.TEAL\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj, background=background)\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Create a mask for the current object\n        mask = sprite != background\n        \n        # Identify the neighbors of the current object\n        neighbors_mask = object_neighbors(sprite, background=Color.BLACK, connectivity=4)\n        \n        # Fill the gaps in the object using the red color\n        # We only fill if there are neighboring pixels that are part of the object\n        if np.any(neighbors_mask):\n            # Fill the black pixels within the bounding box that are not part of the object\n            for i in range(sprite.shape[0]):\n                for j in range(sprite.shape[1]):\n                    if sprite[i, j] == Color.BLACK and neighbors_mask[i, j]:\n                        sprite[i, j] = Color.RED\n        \n            # Place the modified sprite back onto the output grid\n            output_grid[x:x + w, y:y + h] = np.where(sprite == Color.RED, Color.RED, output_grid[x:x + w, y:y + h])\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # The color for the incomplete shapes\n    object_color = Color.TEAL\n\n    # Create a number of incomplete shapes\n    for _ in range(np.random.randint(3, 6)):\n        # Randomly generate a shape with some parts missing\n        w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n        shape_sprite = random_sprite(n=w, m=h, density=0.5, color_palette=[object_color], connectivity=8)\n\n        # Randomly choose a position to draw the shape\n        x, y = random_free_location_for_sprite(grid=grid, sprite=shape_sprite, border_size=1)\n        grid = blit_sprite(grid=grid, sprite=shape_sprite, x=x, y=y)\n\n    # Randomly scatter some pixels that are black to create holes in the teal objects\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(n), np.random.randint(m)\n        grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/289/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/289/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/289/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/289/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/289/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/289/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/289/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/289/images/train_output_2.png"}]}, "index": 289, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, blitting objects, grid manipulation\n\n# description:\n# In the input, you will see a colored object in the center of a black grid, surrounded by a black border.\n# To make the output, fill the outer border with a specified color (Color.BLUE) and the inner object with another color (Color.GREEN).\n# The inner object should be preserved in its original shape.\n\ndef main(input_grid):\n    # Create an output grid filled with the border color\n    output_grid = np.full(input_grid.shape, Color.BLUE)\n\n    # Find the connected component that represents the inner object\n    inner_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Blit each inner object onto the output grid with the specified inner color\n    for obj in inner_objects:\n        obj[obj != Color.BLACK] = Color.GREEN  # Change the color of the inner object to green\n        blit_object(output_grid, obj, background=Color.BLUE)  # Use blit_object to place it correctly over the blue border\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Draw a colored object in the center of the grid\n    object_color = np.random.choice(Color.NOT_BLACK)\n    object_shape = np.random.randint(2, 6)  # Random size for the object\n\n    # Fill in the center with the object color\n    for i in range(n // 2 - object_shape // 2, n // 2 + object_shape // 2 + 1):\n        for j in range(m // 2 - object_shape // 2, m // 2 + object_shape // 2 + 1):\n            grid[i, j] = object_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/290/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/290/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/290/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/290/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/290/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/290/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/290/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/290/images/train_output_2.png"}]}, "index": 290, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object movement, collision detection\n\n# description:\n# In the input, you will see a blue object and a yellow object on a black grid.\n# To create the output, move the blue object towards the yellow object until they collide.\n# If they collide, the blue object should be removed from the grid, and the yellow object should change its color to red.\n\ndef main(input_grid):\n    # 1. Detect the blue and yellow objects\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=False)\n\n    blue_objects = [obj for obj in objects if Color.BLUE in object_colors(obj, background=Color.BLACK)]\n    yellow_objects = [obj for obj in objects if Color.YELLOW in object_colors(obj, background=Color.BLACK)]\n\n    assert len(blue_objects) == 1, \"There should be exactly one blue object\"\n    assert len(yellow_objects) == 1, \"There should be exactly one yellow object\"\n\n    blue_object = blue_objects[0]\n    yellow_object = yellow_objects[0]\n\n    # 2. Make the output grid and copy the input\n    output_grid = input_grid.copy()\n\n    # 3. Move the blue object towards the yellow object\n    # Find the positions of the blue and yellow objects\n    blue_x, blue_y = object_position(blue_object)\n    yellow_x, yellow_y = object_position(yellow_object)\n\n    # Calculate the direction to move the blue object towards the yellow object\n    dx = np.sign(yellow_x - blue_x)\n    dy = np.sign(yellow_y - blue_y)\n\n    # Move the blue object step by step until it collides with the yellow object\n    while not collision(object1=blue_object, object2=yellow_object, x1=blue_x, y1=blue_y, x2=yellow_x, y2=yellow_y):\n        blue_x += dx\n        blue_y += dy\n\n        # Update the position of the blue object in the output grid\n        output_grid[blue_x, blue_y] = Color.BLUE\n\n        # Clear the previous position of the blue object\n        if (blue_x - dx \u003e= 0 and blue_y - dy \u003e= 0):\n            output_grid[blue_x - dx, blue_y - dy] = Color.BLACK\n\n    # 4. Upon collision, remove the blue object and change the yellow object\u0027s color to red\n    output_grid[blue_x, blue_y] = Color.BLACK  # Remove the blue object\n    yellow_x, yellow_y = object_position(yellow_object)\n    output_grid[yellow_x, yellow_y] = Color.RED  # Change the yellow object to red\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a blue object and a yellow object on it\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create blue object\n    blue_sprite = random_sprite(3, 3, color_palette=[Color.BLUE])\n    x_blue, y_blue = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK)\n    blit_sprite(grid, blue_sprite, x_blue, y_blue, background=Color.BLACK)\n\n    # Create yellow object\n    yellow_sprite = random_sprite(3, 3, color_palette=[Color.YELLOW])\n    x_yellow, y_yellow = random_free_location_for_sprite(grid, yellow_sprite, background=Color.BLACK)\n    blit_sprite(grid, yellow_sprite, x_yellow, y_yellow, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/291/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/291/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/291/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/291/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/291/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/291/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/291/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/291/images/train_output_2.png"}]}, "index": 291, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, color replacement, object detection\n\n# description:\n# In the input, you will see a green object in the center and some yellow pixels scattered around in a bounding box shape.\n# To make the output, change the color of the central green object to match the average color of the yellow pixels inside the bounding box.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the green object and the yellow pixels.\n    # 2. Calculate the bounding box of the yellow pixels.\n    # 3. Compute the average color of the yellow pixels within that bounding box.\n    # 4. Change the color of the green object to this average color.\n\n    # 1. Input parsing\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=True, background=background)\n\n    # Identify the green object and yellow pixels\n    green_object = next(obj for obj in objects if Color.GREEN in object_colors(obj, background=background))\n    yellow_pixels = [obj for obj in objects if Color.YELLOW in object_colors(obj, background=background)]\n\n    # Ensure there is at least one yellow pixel\n    assert yellow_pixels, \"There should be at least one yellow pixel\"\n\n    # 2. Calculate the bounding box of the yellow pixels\n    yellow_bounding_box = np.zeros(input_grid.shape, dtype=bool)\n    for yellow in yellow_pixels:\n        bounding_box = bounding_box_mask(yellow, background=background)\n        yellow_bounding_box = np.logical_or(yellow_bounding_box, bounding_box)\n\n    # 3. Compute the average color of the yellow pixels within the bounding box\n    yellow_area = input_grid[yellow_bounding_box]\n    average_color = np.mean(yellow_area[yellow_area != Color.BLACK])\n\n    # 4. Change the color of the green object to the average color\n    output_grid = input_grid.copy()\n    output_grid[green_object != background] = average_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a green object in the center and some yellow pixels around it\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Create a green object (sprite)\n    green_object = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=[Color.GREEN])\n    x, y = random_free_location_for_sprite(grid, green_object, padding=1)\n    blit_sprite(grid, green_object, x, y)\n\n    # Randomly place yellow pixels around the green object within a bounding box shape\n    for _ in range(np.random.randint(5, 15)):\n        px, py = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[px, py] == Color.BLACK:  # Ensure we only place on empty spots\n            grid[px, py] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/292/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/292/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/292/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/292/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/292/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/292/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/292/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/292/images/train_output_2.png"}]}, "index": 292, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# borders, filling, color transformation\n\n# description:\n# In the input you will see an object comprising of red pixels on a black background. \n# To make the output, you should fill the area surrounding the object with yellow pixels, \n# creating a border of yellow pixels around the red object.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Detect the red object\n    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n    \n    # There should only be one red object in the grid\n    assert len(red_objects) == 1\n    red_object = red_objects[0]\n\n    # Get the coordinates of the red object\n    red_indices = np.argwhere(red_object == Color.RED)\n\n    # Find the bounding box of the red object\n    min_x, min_y = red_indices.min(axis=0)\n    max_x, max_y = red_indices.max(axis=0)\n\n    # Draw the yellow border around the red object\n    for x in range(min_x - 1, max_x + 2):\n        draw_line(output_grid, x, min_y - 1, color=Color.YELLOW, direction=(0, 1))  # Top border\n        draw_line(output_grid, x, max_y + 1, color=Color.YELLOW, direction=(0, 1))  # Bottom border\n        \n    for y in range(min_y - 1, max_y + 2):\n        draw_line(output_grid, min_x - 1, y, color=Color.YELLOW, direction=(1, 0))  # Left border\n        draw_line(output_grid, max_x + 1, y, color=Color.YELLOW, direction=(1, 0))  # Right border\n\n    return output_grid\n\n\ndef generate_input():\n    # Make a rectangular black grid\n    n = np.random.randint(5, 15)\n    m = np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the width and height of the red object\n    width, height = np.random.randint(2, 5), np.random.randint(2, 5)\n    red_object = np.full((width, height), Color.RED)\n\n    # Find a random free location for this red object\n    x, y = random_free_location_for_sprite(grid, red_object, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, red_object, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/293/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/293/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/293/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/293/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/293/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/293/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/293/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/293/images/train_output_2.png"}]}, "index": 293, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape filling, object interior, color replacement\n\n# description:\n# In the input you will see an object with a defined shape in one color (not black) and a black interior.\n# The goal is to fill the entire interior of the object with a new color, while keeping the outline intact.\n\ndef main(input_grid):\n    # Identify the shape in the input grid\n    shape_color = np.unique(input_grid[input_grid != Color.BLACK])[0]  # Get the color of the outline\n    assert shape_color != Color.BLACK, \"The shape should not be black.\"\n\n    # Find the interior of the shape\n    shape_interior = object_interior(input_grid, background=Color.BLACK)\n\n    # Create an output grid to modify\n    output_grid = input_grid.copy()\n\n    # Fill the interior with a new color (for example, Color.GREEN)\n    fill_color = Color.GREEN\n    output_grid[shape_interior] = fill_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random background color (not black)\n    background_color = np.random.choice(Color.NOT_BLACK)\n    width, height = np.random.randint(5, 20, size=2)\n    input_grid = np.full((width, height), background_color)\n\n    # Create a shape (non-black color) with a black interior\n    shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    shape_sprite = random_sprite(shape_width, shape_height, density=0.5, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n\n    # Place the shape in the grid\n    x, y = np.random.randint(0, width - shape_width), np.random.randint(0, height - shape_height)\n    blit_sprite(input_grid, shape_sprite, x, y, background=background_color)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/294/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/294/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/294/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/294/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/294/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/294/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/294/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/294/images/train_output_2.png"}]}, "index": 294, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern connection, object detection, line drawing\n\n# description:\n# In the input you will see two colorful patterns separated by a horizontal gap of black pixels.\n# To make the output, you need to connect the two patterns by drawing a vertical line of a specified color.\n# The line should be drawn only in the gap between the two patterns, leaving a padding around the patterns.\n\ndef main(input_grid):\n    # Copy the input grid as output\n    output_grid = input_grid.copy()\n    \n    # Detect the objects (colorful patterns)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Ensure there are exactly two objects to connect\n    if len(objects) != 2:\n        raise ValueError(\"There should be exactly two colorful patterns in the input grid.\")\n    \n    # Get the bounding boxes of the two colorful patterns\n    (x1, y1, w1, h1) = bounding_box(objects[0])\n    (x2, y2, w2, h2) = bounding_box(objects[1])\n    \n    # Find the gap between the two patterns\n    gap_x = x1 + w1 + 1  # The position right after the first pattern\n    gap_y_min = max(y1, y2)  # The maximum y position of both patterns\n    gap_y_max = min(y1 + h1, y2 + h2)  # The minimum y position of the bottom edge of both patterns\n    \n    # Draw the vertical line in the gap if there\u0027s space\n    if gap_y_min \u003c gap_y_max:\n        for y in range(gap_y_min, gap_y_max):\n            output_grid[y, gap_x] = Color.TEAL  # Draw the connecting line\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with black background\n    n, m = np.random.randint(10, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the patterns\n    color1 = np.random.choice(Color.NOT_BLACK)\n    color2 = np.random.choice([color for color in Color.NOT_BLACK if color != color1])\n    \n    # Generate two rectangles for the colorful patterns\n    w1, h1 = np.random.randint(3, 6), np.random.randint(3, 6)\n    w2, h2 = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    rectangle1 = np.full((h1, w1), color1)\n    rectangle2 = np.full((h2, w2), color2)\n\n    # Place the first rectangle on the grid\n    x1, y1 = np.random.randint(0, n - h1), np.random.randint(0, m - w1 - 1)\n    blit_sprite(grid, rectangle1, x=x1, y=y1)\n\n    # Place the second rectangle below with a gap\n    x2, y2 = x1 + h1 + np.random.randint(1, 3), np.random.randint(0, m - w2 - 1)\n    blit_sprite(grid, rectangle2, x=x2, y=y2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/295/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/295/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/295/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/295/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/295/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/295/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/295/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/295/images/train_output_2.png"}]}, "index": 295, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color replacement, grid transformation\n\n# description:\n# In the input you will see a grid containing multiple 3x3 red squares scattered across a black background, with a yellow border around the grid.\n# The goal is to transform the grid by detecting the red squares and replacing their color with green, while keeping the yellow border intact.\n\ndef main(input_grid):\n    # Initialize the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Detect red squares (3x3) in the grid\n    red_squares = detect_objects(grid=input_grid, \n                                  colors=[Color.RED], \n                                  allowed_dimensions=[(3, 3)], \n                                  monochromatic=True, \n                                  background=Color.BLACK, \n                                  connectivity=4)\n\n    # Replace the color of each detected red square with green in the output grid\n    for red_square in red_squares:\n        x, y = object_position(red_square, background=Color.BLACK)\n        output_grid[x:x+3, y:y+3] = Color.GREEN\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 black grid with a yellow border\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Set the yellow border\n    grid[0, :] = Color.YELLOW\n    grid[:, 0] = Color.YELLOW\n    grid[n-1, :] = Color.YELLOW\n    grid[:, m-1] = Color.YELLOW\n    \n    # Randomly generate red 3x3 squares and place them in the grid\n    for _ in range(np.random.randint(2, 5)):\n        red_square = np.full((3, 3), Color.RED)\n\n        # Find a random free location for the red square avoiding the yellow border\n        x, y = random_free_location_for_sprite(grid, red_square, background=Color.BLACK, border_size=1)\n        blit_sprite(grid, red_square, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/296/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/296/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/296/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/296/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/296/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/296/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/296/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/296/images/train_output_2.png"}]}, "index": 296, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alignment, lines, boundaries\n\n# description:\n# In the input, you will see a blue object on a black background, and several colored pixels on the left and right edges of the grid.\n# To make the output, draw a vertical yellow line from the blue object to the top of the grid, \n# and then draw horizontal lines from the top of the vertical line to each colored pixel on both edges, stopping at the edges of the grid.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Detect the blue object\n    blue_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    assert len(blue_objects) == 1\n    blue_object = blue_objects[0]\n\n    # Get the position of the blue object\n    blue_x, blue_y = object_position(blue_object)\n\n    # Draw a vertical yellow line from the blue object to the top of the grid\n    draw_line(output_grid, blue_x, blue_y, length=blue_y, color=Color.YELLOW, direction=(0, -1))\n\n    # Now find the colored pixels on the left and right edges\n    left_edge_pixels = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=4)\n    right_edge_pixels = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=4)\n\n    # For left edge\n    for pixel in left_edge_pixels:\n        pos_x, pos_y = object_position(pixel)\n        if pos_x == 0:  # Only consider pixels on the left edge\n            draw_line(output_grid, 0, 0, end_x=0, end_y=blue_y, color=Color.YELLOW)\n\n    # For right edge\n    for pixel in right_edge_pixels:\n        pos_x, pos_y = object_position(pixel)\n        if pos_x == output_grid.shape[0] - 1:  # Only consider pixels on the right edge\n            draw_line(output_grid, output_grid.shape[0] - 1, 0, end_x=output_grid.shape[0] - 1, end_y=blue_y, color=Color.YELLOW)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a black background.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the width and height of the BLUE rectangle between 2 and 5.\n    width, height = np.random.randint(2, 6), np.random.randint(2, 6)\n    blue_sprite = np.full((width, height), Color.BLUE)\n\n    # Find a free location for this sprite and blit it to the grid\n    x, y = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, blue_sprite, x, y, background=Color.BLACK)\n\n    # Put a random number of colored pixels on the left and right edges of the canvas\n    for _ in range(np.random.randint(3, 6)):\n        # Left edge\n        y_pos = np.random.randint(0, n)\n        grid[y_pos, 0] = np.random.choice([Color.RED, Color.GREEN, Color.YELLOW, Color.PINK])\n\n        # Right edge\n        y_pos = np.random.randint(0, n)\n        grid[y_pos, m-1] = np.random.choice([Color.RED, Color.GREEN, Color.YELLOW, Color.PINK])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/297/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/297/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/297/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/297/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/297/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/297/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/297/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/297/images/train_output_2.png"}]}, "index": 297, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# circular pattern generation, color transformation\n\n# description:\n# In the input, you will see multiple colored pixels forming a pattern in the center of the grid.\n# To make the output, take each colored pixel from the input and draw a circular pattern centered around that pixel with a radius equal to the distance of the farthest colored pixel from the center of the grid.\n\ndef main(input_grid):\n    # Find the center of the grid\n    center_x = input_grid.shape[0] // 2\n    center_y = input_grid.shape[1] // 2\n\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Get all unique colors in the input grid, excluding black\n    unique_colors = np.unique(input_grid)\n    unique_colors = unique_colors[unique_colors != Color.BLACK]\n\n    # Find the maximum distance to determine the radius for circles\n    max_distance = 0\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] in unique_colors:\n                distance = np.sqrt((x - center_x) ** 2 + (y - center_y) ** 2)\n                max_distance = max(max_distance, distance)\n\n    # Draw circles for each colored pixel in the input grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] in unique_colors:\n                color = input_grid[x, y]\n                # Draw a circle around the pixel\n                for angle in np.linspace(0, 2 * np.pi, num=36):  # 36 points for the circle\n                    circle_x = int(center_x + max_distance * np.cos(angle))\n                    circle_y = int(center_y + max_distance * np.sin(angle))\n                    if 0 \u003c= circle_x \u003c output_grid.shape[0] and 0 \u003c= circle_y \u003c output_grid.shape[1]:\n                        output_grid[circle_x, circle_y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly scatter colored pixels in the center of the grid\n    num_pixels = np.random.randint(1, 6)  # Random number of colored pixels\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=False)\n\n    for color in colors:\n        # Randomly choose a position around the center to place the pixel\n        x = np.random.randint(width)\n        y = np.random.randint(height)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/298/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/298/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/298/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/298/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/298/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/298/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/298/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/298/images/train_output_2.png"}]}, "index": 298, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# merging shapes, color blending, connected components\n\n# description:\n# In the input, you will see two or more colored shapes on a black background. \n# To make the output, merge all connected components of the same color into larger shapes, filling the grid with these colors. \n# Each shape should grow to fill the entire area of its respective color, while maintaining the original color.\n\ndef main(input_grid):\n    # Get connected components of the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # For each connected component, fill the output grid with the component\u0027s color\n    for component in objects:\n        # Get the color of the component\n        color = component[component != Color.BLACK][0]\n        \n        # Find the bounding box of the component\n        min_x, max_x = np.min(np.where(component)[0]), np.max(np.where(component)[0])\n        min_y, max_y = np.min(np.where(component)[1]), np.max(np.where(component)[1])\n        \n        # Fill the output grid with this color in the bounding box area\n        output_grid[min_x:max_x + 1, min_y:max_y + 1] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Number of shapes to generate\n    num_shapes = np.random.randint(2, 5)\n\n    for _ in range(num_shapes):\n        # Randomly choose a color for the shape\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Randomly determine size of each shape\n        width = np.random.randint(1, 6)\n        height = np.random.randint(1, 6)\n\n        # Randomly place the shape in the grid, ensuring it stays within bounds\n        x = np.random.randint(0, input_grid.shape[0] - width + 1)\n        y = np.random.randint(0, input_grid.shape[1] - height + 1)\n\n        # Create the shape by filling in the rectangle\n        input_grid[x:x + width, y:y + height] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/299/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/299/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/299/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/299/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/299/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/299/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/299/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/299/images/train_output_2.png"}]}, "index": 299, "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 300}];
        const sourceInfo = {
            barc_gpt4_desc: {
                name: 'GPT-4',
                description: 'Data generated by GPT4-generated descriptions and GPT4o-mini-generated codes, with 100 seeds from the training dataset.'
            },
            barc_gpt4o_mini_desc: {
                name: 'GPT4o-mini',
                description: 'Data generated by GPT4o-mini generated descriptions and GPT4o-mini generated codes, with 100 seeds from the training dataset.'
            },
            barc_heavy: {
                name: 'Heavy Model',
                description: 'Data generated by GPT4o-generated descriptions and GPT4o-mini-generated codes, with 160 seeds from the training dataset.'
            },
            barc_heavy_suggest: {
                name: 'Heavy Model with Suggestions',
                description: 'Data generated by GPT4o generated descriptions and GPT4o-mini with suggestion functions generated codes, with 160 seeds from the training dataset.'
            }
        };

        let state = {
            currentSource: 'barc_gpt4_desc',
            page: 0,
            loading: false,
            itemsPerPage: 12,
            shuffled: false,
            shuffledExamples: [],
            originalExamples: [], 
            shuffleCount: 0
        };

        // UI Components
        const ui = {
            grid: document.getElementById('examplesGrid'),
            loading: document.getElementById('loadingIndicator'),
            sourceSelect: document.getElementById('sourceSelector'),
            totalCount: document.getElementById('totalCount'),
            currentSource: document.getElementById('currentSource'),
            description: document.getElementById('descriptionText'),
            shuffleButton: document.getElementById('shuffleButton'),
            resetButton: document.getElementById('resetButton')
        };

        // Helper Functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            // Double shuffle for better randomization
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function getFilteredExamples() {
            const filtered = examples.filter(ex => ex.source === state.currentSource);
            if (state.shuffled) {
                return state.shuffledExamples;
            }
            return filtered;
        }

        function handleShuffle() {
            state.shuffled = true;
            state.page = 0;
            state.shuffleCount++;
            ui.grid.innerHTML = '';
            
            if (state.shuffleCount === 1) {
                const filtered = examples.filter(ex => ex.source === state.currentSource);
                state.originalExamples = [...filtered];
            }
            
            state.shuffledExamples = shuffleArray(
                state.shuffleCount === 1 ? state.originalExamples : state.shuffledExamples
            );
            
            // Show reset button (both desktop and mobile)
            ui.resetButton.classList.remove('hidden');
            document.getElementById('mobileResetButton')?.classList.remove('hidden');
            
            // Add spin animation
            [ui.shuffleButton, document.getElementById('mobileShuffleButton')].forEach(button => {
                if (button) {
                    const icon = button.querySelector('i');
                    icon.classList.add('spin-animation');
                    setTimeout(() => icon.classList.remove('spin-animation'), 1000);
                }
            });
            
            loadMoreExamples();
        }

        function handleReset() {
            state.shuffled = false;
            state.page = 0;
            state.shuffleCount = 0;
            state.shuffledExamples = [];
            ui.grid.innerHTML = '';
            
            // Hide reset button (both desktop and mobile)
            ui.resetButton.classList.add('hidden');
            document.getElementById('mobileResetButton')?.classList.add('hidden');
            
            // Add spin animation
            [ui.resetButton, document.getElementById('mobileResetButton')].forEach(button => {
                if (button) {
                    const icon = button.querySelector('i');
                    icon.classList.add('spin-animation');
                    setTimeout(() => icon.classList.remove('spin-animation'), 1000);
                }
            });
            
            loadMoreExamples();
        }

        function updateSourceInfo() {
            const filtered = getFilteredExamples();
            const info = sourceInfo[state.currentSource];
            
            ui.totalCount.textContent = filtered.length;
            ui.currentSource.textContent = info.name;
            ui.description.textContent = info.description;
        }

        function showToast(message, isError = false) {
            const toast = document.createElement('div');
            toast.className = 'copy-toast';
            toast.textContent = message;
            if (isError) {
                toast.style.background = 'rgba(239, 68, 68, 0.9)';
            }
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 1500);
        }

        function copyToClipboard(text, button) {
            // Check if we can use the modern clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showCopySuccess(button);
                    })
                    .catch(() => {
                        fallbackCopyToClipboard(text, button);
                    });
            } else {
                fallbackCopyToClipboard(text, button);
            }
        }

        function fallbackCopyToClipboard(text, button) {
            // Create temporary textarea
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            
            try {
                textArea.select();
                document.execCommand('copy');
                showCopySuccess(button);
            } catch (err) {
                showToast('Failed to copy', true);
            } finally {
                textArea.remove();
            }
        }

        function showCopySuccess(button) {
            showToast('Copied to clipboard');
            button.classList.add('copied');
            const icon = button.querySelector('i');
            icon.classList.remove('fa-copy');
            icon.classList.add('fa-check');
            
            setTimeout(() => {
                button.classList.remove('copied');
                icon.classList.remove('fa-check');
                icon.classList.add('fa-copy');
            }, 1500);
        }

        function createExampleCard(example) {
            const codeHtml = example.code ? example.code.replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';
            const rawCode = example.code ? example.code.replace(/`/g, '\\`').replace(/\${/g, '\\${') : '';
            
            return `
                <div class="card-container" id="card-${example.index}">
                    <div class="card-flipper">
                        <div class="card-front">
                            <div class="example-card">
                                <div class="card-header">
                                    <span class="text-lg font-medium text-slate-400">
                                        Example ${example.index + 1}
                                    </span>
                                    <button class="button-base" onclick="toggleCode(${example.index})">
                                        <i class="fas fa-code"></i>
                                        <span>View Code</span>
                                    </button>
                                </div>
                                
                                <div class="image-grid">
                                    ${example.images.train.map((train, i) => `
                                        <div class="image-container">
                                            <div class="image-pair">
                                                <div class="image-wrapper">
                                                    <img data-src="${train.input}" 
                                                        alt="Train Input ${i+1}" 
                                                        class="w-full rounded-lg">
                                                    <p class="image-caption">Train Input ${i+1}</p>
                                                </div>
                                                <div class="image-wrapper">
                                                    <img data-src="${train.output}" 
                                                        alt="Train Output ${i+1}" 
                                                        class="w-full rounded-lg">
                                                    <p class="image-caption">Train Output ${i+1}</p>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                    
                                    <div class="image-container">
                                        <div class="image-pair">
                                            <div class="image-wrapper">
                                                <img data-src="${example.images.test.input}" 
                                                    alt="Test Input"
                                                    class="w-full rounded-lg">
                                                <p class="image-caption">Test Input</p>
                                            </div>
                                            <div class="image-wrapper">
                                                <img data-src="${example.images.test.output}" 
                                                    alt="Test Output"
                                                    class="w-full rounded-lg">
                                                <p class="image-caption">Test Output</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-back">
                            <div class="card-header">
                                <!-- Change the onclick to use a data attribute instead -->
                                <button class="button-base copy-button" data-code="${rawCode}">
                                    <i class="fas fa-copy"></i>
                                    <span>Copy</span>
                                </button>
                                <button class="button-base" onclick="toggleCode(${example.index})">
                                    <i class="fas fa-image"></i>
                                    <span>View Example</span>
                                </button>
                            </div>
                            <div class="code-content">
                                <pre><code class="language-python">${codeHtml}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function initializeCopyButtons() {
            // Remove any existing listeners first
            document.querySelectorAll('.copy-button').forEach(button => {
                button.removeEventListener('click', handleCopyClick);
            });
            
            // Add fresh listeners
            document.querySelectorAll('.copy-button').forEach(button => {
                button.addEventListener('click', handleCopyClick);
            });
        }

        function handleCopyClick(event) {
            const button = event.currentTarget;
            const code = button.getAttribute('data-code');
            if (code) {
                copyToClipboard(code, button);
            }
        }

        function toggleCode(index) {
            const cardContainer = document.querySelector(`#card-${index}`);
            if (!cardContainer) return;
            
            const flipper = cardContainer.querySelector('.card-flipper');
            if (flipper) {
                flipper.classList.toggle('flipped');
            }
        }

        // Data Loading
        async function loadMoreExamples() {
            if (state.loading) return;
            
            state.loading = true;
            ui.loading.classList.remove('hidden');
            
            try {
                const filtered = getFilteredExamples();
                const start = state.page * state.itemsPerPage;
                const end = start + state.itemsPerPage;
                const pageExamples = filtered.slice(start, end);
                
                if (pageExamples.length > 0) {
                    const fragment = document.createDocumentFragment();
                    pageExamples.forEach(example => {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = createExampleCard(example);
                        fragment.appendChild(tempDiv.firstElementChild);
                    });
                    ui.grid.appendChild(fragment);
                    state.page++;
                    
                    // Initialize copy buttons after adding new content
                    initializeCopyButtons();
                    
                    // Initialize lazy loading for new images
                    requestAnimationFrame(() => {
                        lazyLoadImages();
                    });
                }
            } catch (error) {
                console.error('Error loading examples:', error);
            } finally {
                state.loading = false;
                ui.loading.classList.add('hidden');
            }
        }

        const debouncedResize = debounce(() => {
            initializeCopyButtons();
        }, 250);

        window.addEventListener('resize', debouncedResize);

        // Event Handlers
        function handleSourceChange(event) {
            state.currentSource = event.target.value;
            state.page = 0;
            state.shuffled = false;
            state.shuffleCount = 0;
            state.shuffledExamples = [];
            ui.grid.innerHTML = '';
            
            // Sync both selectors
            document.getElementById('sourceSelector').value = event.target.value;
            document.getElementById('mobileSourceSelector').value = event.target.value;
            
            // Reset UI
            ui.shuffleButton.classList.remove('shuffle-active');
            ui.resetButton.classList.add('hidden');
            
            updateSourceInfo();
            loadMoreExamples();
        }

        function handleScroll() {            
            const threshold = 1000;
            const bottomDistance = document.documentElement.scrollHeight - (window.scrollY + window.innerHeight);
            
            if (bottomDistance < threshold) {
                loadMoreExamples();
            }
            
            // Trigger lazy loading check on scroll
            lazyLoadImages();
        }

        // Initialize
        function initializeViewport() {
            const viewportStyle = document.createElement('meta');
            viewportStyle.name = 'viewport';
            viewportStyle.content = 'width=device-width, initial-scale=1.0';
            document.head.appendChild(viewportStyle);
        }

        function initializeIntersectionObserver() {
            const options = {
                root: null,
                rootMargin: '100px',
                threshold: 0.1
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, options);

            document.querySelectorAll('.example-card').forEach(card => {
                observer.observe(card);
            });
        }

        function initializePage() {
            // Set up scrollbar
            const scrollbar = document.querySelector('.custom-scrollbar');
            const thumb = document.querySelector('.scrollbar-thumb');
            const track = document.querySelector('.scrollbar-track');
            let isDragging = false;
            let startY;
            let scrollStartY;

            function updateThumbSize() {
                const viewportHeight = window.innerHeight;
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const scrollbarHeight = track.offsetHeight;
                
                // Calculate thumb height based on viewport/document ratio
                const thumbHeight = Math.max(
                    (viewportHeight / documentHeight) * scrollbarHeight,
                    40 // Minimum thumb height
                );
                
                thumb.style.height = `${thumbHeight}px`;
            }

            function flipCard(index) {
                const cardContainer = document.getElementById(`card-${index}`);
                const flipper = cardContainer.querySelector('.card-flipper');
                flipper.classList.toggle('flipped');
            }

            // Handle clicking outside the card
            document.addEventListener('click', function(event) {
                const cardContainers = document.querySelectorAll('.card-container');
                cardContainers.forEach(container => {
                    const flipper = container.querySelector('.card-flipper');
                    const isFlipped = flipper.classList.contains('flipped');
                    
                    if (isFlipped && !container.contains(event.target)) {
                        flipper.classList.remove('flipped');
                    }
                });
            });

            // Stop propagation on card clicks to prevent the outside click handler from firing
            document.querySelectorAll('.card-container').forEach(container => {
                container.addEventListener('click', function(event) {
                    event.stopPropagation();
                });
            });

            function updateThumbPosition() {
                if (isDragging) return;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const scrollbarHeight = track.offsetHeight;
                const maxScroll = documentHeight - viewportHeight;
                const scrolled = window.scrollY;
                
                if (maxScroll <= 0) {
                    thumb.style.display = 'none';
                    return;
                }
                
                thumb.style.display = 'block';
                const scrollRatio = scrolled / maxScroll;
                const thumbTravel = scrollbarHeight - thumb.offsetHeight;
                const thumbPosition = thumbTravel * scrollRatio;
                
                thumb.style.transform = `translateY(${thumbPosition}px)`;
            }

            // Handle thumb drag
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                thumb.classList.add('dragging');
                startY = e.clientY - thumb.getBoundingClientRect().top;
                scrollStartY = window.scrollY;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const trackRect = track.getBoundingClientRect();
                const y = e.clientY - trackRect.top - startY;
                const scrollbarHeight = track.offsetHeight;
                const thumbHeight = thumb.offsetHeight;
                const maxY = scrollbarHeight - thumbHeight;
                
                const boundedY = Math.max(0, Math.min(y, maxY));
                const scrollRatio = boundedY / maxY;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const maxScroll = documentHeight - viewportHeight;
                
                window.scrollTo(0, maxScroll * scrollRatio);
                thumb.style.transform = `translateY(${boundedY}px)`;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                thumb.classList.remove('dragging');
            });

            // Track click to jump to position
            track.addEventListener('click', (e) => {
                if (e.target === thumb) return;
                
                const trackRect = track.getBoundingClientRect();
                const clickY = e.clientY - trackRect.top;
                const scrollbarHeight = track.offsetHeight;
                const thumbHeight = thumb.offsetHeight;
                const maxY = scrollbarHeight - thumbHeight;
                
                const boundedY = Math.max(0, Math.min(clickY - thumbHeight / 2, maxY));
                const scrollRatio = boundedY / maxY;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const maxScroll = documentHeight - viewportHeight;
                
                window.scrollTo({
                    top: maxScroll * scrollRatio,
                    behavior: 'smooth'
                });
            });

            // Update on scroll
            window.addEventListener('scroll', updateThumbPosition, { passive: true });

            // Update on resize
            window.addEventListener('resize', () => {
                updateThumbSize();
                updateThumbPosition();
            });

            // Set up intersection observer
            initializeIntersectionObserver();

            // Set up initial state and UI
            updateSourceInfo();
            loadMoreExamples();

            // Add event listeners
            window.addEventListener('scroll', handleScroll, { passive: true });
            ui.sourceSelect.addEventListener('change', handleSourceChange);
            ui.shuffleButton.addEventListener('click', handleShuffle);
            ui.resetButton.addEventListener('click', handleReset);

            // Initialize scrollbar
            updateThumbSize();
            updateThumbPosition();

            // Add keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === 's' && !e.ctrlKey && !e.metaKey) {
                    handleShuffle();
                } else if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
                    if (!state.shuffled) return;
                    handleReset();
                }
                switch(e.key) {
                    case 'ArrowLeft':
                        const prevOption = ui.sourceSelect.selectedIndex - 1;
                        if (prevOption >= 0) {
                            ui.sourceSelect.selectedIndex = prevOption;
                            handleSourceChange({ target: ui.sourceSelect });
                        }
                        break;
                    case 'ArrowRight':
                        const nextOption = ui.sourceSelect.selectedIndex + 1;
                        if (nextOption < ui.sourceSelect.options.length) {
                            ui.sourceSelect.selectedIndex = nextOption;
                            handleSourceChange({ target: ui.sourceSelect });
                        }
                        break;
                }
            });

            if (window.matchMedia('(max-width: 768px)').matches) {
                const mobileSourceSelector = document.getElementById('mobileSourceSelector');
                if (mobileSourceSelector) {
                    mobileSourceSelector.value = state.currentSource;
                }
            }

            document.querySelectorAll('pre code').forEach((block) => {
                Prism.highlightElement(block);
            });
        }

        // Add performance optimizations
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Optimize scroll handler
        const debouncedScroll = debounce(handleScroll, 16);
        window.addEventListener('scroll', debouncedScroll, { passive: true });
        let globalImageObserver;

        // Image loading optimization
        function lazyLoadImages() {
            // Create observer if it doesn't exist
            if (!globalImageObserver) {
                globalImageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            if (img.dataset.src) {
                                img.src = img.dataset.src;
                                img.removeAttribute('data-src');
                                observer.unobserve(img);
                            }
                        }
                    });
                }, {
                    root: null,
                    rootMargin: '50px 0px',
                    threshold: 0.1
                });
            }

            // Get all unloaded images
            const imageElements = document.querySelectorAll('img[data-src]');
            imageElements.forEach(img => {
                globalImageObserver.observe(img);
            });
        }

        // Add mobile touch handling
        let touchStartY = 0;
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].pageY;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            const touchY = e.touches[0].pageY;
            const difference = touchStartY - touchY;
            
            if (difference > 0) { // Scrolling up
                const nearBottom = window.innerHeight + window.pageYOffset >= 
                    document.documentElement.scrollHeight - 1000;
                if (nearBottom) {
                    loadMoreExamples();
                }
            }
        }, { passive: true });

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Page error:', e.error);
            ui.loading.classList.add('hidden');
            state.loading = false;
        });

        function initializeCodeHighlighting() {
            // Re-run Prism highlighting when new code is added
            document.querySelectorAll('pre code').forEach((block) => {
                Prism.highlightElement(block);
            });
        }

        // Initialize everything when the DOM is ready
        document.addEventListener('DOMContentLoaded', initializePage);
    </script>
</body>
</html>