<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BARC Examples</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <link rel="shortcut icon" href="https://naiimic.github.io/favicons/videogame-favicon.ico">
	<link rel="apple-touch-icon" href="https://naiimic.github.io/favicons/videogame-apple-touch-icon.png">
	<link rel="icon" type="image/png" href="https://naiimic.github.io/favicons/videogame-favicon-16x16.png" sizes="16x16">
	<link rel="icon" type="image/png" href="https://naiimic.github.io/favicons/videogame-favicon-32x32.png" sizes="32x32">
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');
        
        /* Base Styles */
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            font-family: 'Space Grotesk', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
            width: 100%;
            position: relative;
        }

        /* Hide Scrollbar */
        ::-webkit-scrollbar { display: none; }
        * { -ms-overflow-style: none; scrollbar-width: none; }

        /* Navigation Styles */
        .nav-glass {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(99, 102, 241, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .nav-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        @media (max-width: 768px) {
            
            .nav-group {
                width: 100%;
                justify-content: center;
            }
            
            .nav-group:last-child {
                flex-direction: row;
                gap: 0.5rem;
            }
        }

        @media (max-width: 768px) {
            /* Hide desktop controls */
            .nav-group:last-child {
                display: none !important;
            }

            .nav-group .flex.items-center.gap-2 {
                display: none !important;
            }

            /* Keep the Model Performance link visible */
            .nav-group a[href="arc.html"] {
                display: flex !important;
            }

            .nav-group a[href="seeds.html"] {
                display: flex !important;
            }
            
            /* Bottom navigation/controls */
            .mobile-model-select {
                position: fixed;
                bottom: 0;  /* Changed from 1rem to 0 */
                left: 0;
                right: 0;
                background: rgba(15, 23, 42, 0.98);
                backdrop-filter: blur(10px);
                padding: 0.75rem;
                z-index: 70;
                border-top: 1px solid rgba(99, 102, 241, 0.2);
            }

            .mobile-model-select select {
                width: 100%;
                padding: 0.75rem;
                background: rgba(30, 41, 59, 0.8);
                border: 1px solid rgba(99, 102, 241, 0.2);
                border-radius: 0.5rem;
                color: white;
                font-size: 0.875rem;
            }

            /* Floating action buttons - adjust position to be above model selector */
            .mobile-fab-container {
                position: fixed;
                bottom: 75px;
                right: 1rem;
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
                z-index: 51;
            }

            .mobile-fab {
                width: 48px;
                height: 48px;
                border-radius: 50%;
                background: rgba(99, 102, 241, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                border: none;
                color: white;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
                transition: all 0.3s ease;
            }

            .mobile-fab:active {
                transform: scale(0.95);
                background: rgba(99, 102, 241, 1);
            }
            
            .mobile-fab.hidden {
                display: none;
            }

            /* Add padding to main content to prevent content from being hidden */
            main {
                padding-bottom: calc(60px + 1rem) !important; /* Height of model selector + some padding */
            }
        }

        .logo-gradient {
            background: linear-gradient(45deg, #6366f1, #ec4899);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* Card Styles */
        .example-card {
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            overflow: hidden;
            min-height: 100%;
        }

        .example-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.15);
        }

        /* Grid Layout */
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 2rem;
            padding: 1rem;
        }

        /* Source Card Styles */
        .source-card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            transition: all 0.3s ease;
        }

        .source-card.active {
            border-color: #6366f1;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
        }

        /* Button Styles */
        .gradient-btn {
            height: 40px;
            min-width: 100px;
            padding: 0 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-weight: 500;
            letter-spacing: 0.025em;
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap;
        }

        .card-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            z-index: 1;
            background: rgba(24, 19, 60, 0.5);
            backdrop-filter: blur(0px);
            height: 70px;
            display: grid;
            grid-template-columns: auto 1fr auto;
            gap: 1rem;
        }

        .card-back .card-header .button-base:first-child {
            margin-right: auto;
        }

        .card-back .card-header .button-base:last-child {
            margin-left: auto;
        }

        .card-container {
            width: 100%;
            margin-bottom: 2rem;
            perspective: 1000px;
        }

        .card-flipper {
            width: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            position: relative;
        }

        .card-flipper.flipped {
            transform: rotateY(180deg);
        }

        /* Card Faces */
        .card-front {
            width: 100%;
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            backface-visibility: hidden;
        }

        .card-back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotateY(180deg);
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            backface-visibility: hidden;
            overflow: hidden; /* Contain the absolute positioned content */
        }

        .card-front {
            position: relative;
        }

        .card-back {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            transform: rotateY(180deg);
        }

        .code-content {
            position: absolute;
            top: 80px; /* Height of header */
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0 1.5rem 1.5rem;
            overflow: hidden; /* Hide container overflow */
        }

        .code-content pre code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.75rem !important;
            line-height: 1.4 !important;
        }

        .code-content code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.75rem !important;
            line-height: 1.4 !important;
        }

        .code-content pre {
            height: 100%;
            margin: 0;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.3) !important;
            border-radius: 0.5rem;
            overflow-y: auto; /* Only scroll the pre element */
            font-size: 0.5rem !important;
        }

        .button-base {
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            color: white;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            white-space: nowrap;
        }

        .button-base:hover {
            background: rgba(99, 102, 241, 0.3);
        }

        .copy-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(16, 185, 129, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            z-index: 9999;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: fadeInOut 2s ease forwards;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, 20px); }
            15% { opacity: 1; transform: translate(-50%, 0); }
            85% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        @keyframes toast {
            0% { 
                opacity: 0;
                transform: translate(-50%, -1rem);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -1rem);
            }
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .copy-tooltip {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            pointer-events: none;
            animation: fadeOut 1.5s forwards;
            white-space: nowrap;
        }

        /* Image Grid */
        .image-grid {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 0 1.5rem 1.5rem;
            margin-top: 80px; /* Match the space where code starts in back card */
        }

        .image-container {
            background: rgba(30, 41, 59, 0.3);
            padding: 1rem;
            border-radius: 0.75rem;
        }

        .image-pair {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .image-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            border-radius: 0.75rem;
            overflow: hidden; /* Ensure image respects container's border radius */
            padding: 0.25rem;
        }

        .image-wrapper img {
            width: 100%;
            height: auto;
            object-fit: contain;
            border-radius: 0.5rem;
            display: block; /* Remove any potential spacing */
        }

        .image-caption {
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
            text-align: center;
        }

        pre {
            margin: 0;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 0.5rem;
            overflow-x: auto;
        }

        .gradient-btn:focus {
            outline: none;
        }

        .gradient-btn:not(.active):hover {
            background: linear-gradient(45deg, rgba(236, 72, 153, 0.1), rgba(99, 102, 241, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .gradient-btn i,
        .gradient-btn span {
            color: inherit;
            position: relative;
        }

        .gradient-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Loading Animation */
        .loading-dots {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding: 2rem;
        }

        .loading-dot {
            width: 0.5rem;
            height: 0.5rem;
            background: linear-gradient(45deg, #6366f1, #ec4899);
            border-radius: 50%;
            animation: pulse 1s infinite ease-in-out;
        }

        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .examples-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .source-card {
                padding: 1rem;
            }

            #mobileInfoContent {
                height: calc(70vh - 60px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 0 0.5rem 80px 0.5rem;
            }

            #mobileInfoContent {
                transition: none;
                transform: none;
            }

            .info-panel-mobile {
                touch-action: none;
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spin-animation {
            animation: spin 1s linear;
        }

        .gradient-btn.shuffle-active {
            background: linear-gradient(45deg, rgba(236, 72, 153, 0.2), rgba(99, 102, 241, 0.2));
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .custom-scrollbar {
            position: fixed;
            right: 8px;
            top: 120px; /* Positioned below the nav bar */
            height: calc(100vh - 120px); /* Adjust height to account for nav */
            width: 12px;
            z-index: 50; /* Ensure it's below the nav which has z-index: 50 */
            pointer-events: none;
        }

        .scrollbar-track {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 100%;
            height: 70vh;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            pointer-events: all;
        }

        .scrollbar-thumb {
            position: absolute;
            width: 100%;
            border-radius: 6px;
            min-height: 40px;
            max-height: 15vh; 
            background: rgba(99, 102, 241, 0.3);
            cursor: pointer;
            transition: background 0.2s;
        }

        .scrollbar-thumb:hover,
        .scrollbar-thumb:active {
            background: rgba(99, 102, 241, 0.5);
        }

        .scrollbar-thumb.dragging {
            background: rgba(99, 102, 241, 0.6);
            cursor: grabbing;
        }

        @media (max-width: 768px) {
            .custom-scrollbar {
                display: none;
            }
        }

        /* 11/7 */
        .seeds-dropdown {
            position: relative;
            display: inline-block;
        }

        .seeds-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            min-width: 160px;
            border-radius: 0.5rem;
            padding: 0.5rem;
            z-index: 10;
            border: 1px solid rgba(99, 102, 241, 0.3);
            margin-top: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .seeds-content.show {
            display: block;
        }

        .seed-link {
            color: white;
            padding: 0.5rem;
            text-decoration: none;
            display: block;
            border-radius: 0.25rem;
            transition: all 0.2s ease;
        }

        .seed-link:hover {
            background: rgba(99, 102, 241, 0.2);
        }

        .info-toggle {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            z-index: 40;
            padding: 0.75rem;
            border-radius: 0.75rem;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(99, 102, 241, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
            color: #f8fafc;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-toggle:hover {
            background: rgba(30, 41, 59, 0.98);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        /* Info Panel */
        .info-panel-wrapper {
            position: fixed;
            bottom: 6rem;
            left: 2rem;
            z-index: 30;
            width: 32rem;
            max-width: calc(100vw - 4rem);
            transform: translateX(calc(-100% - 2rem));
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        .info-panel-wrapper.open {
            transform: translateX(0);
            opacity: 1;
            visibility: visible;
        }

        .info-panel {
            background: rgba(30, 41, 59, 0.98);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            padding: 1.5rem;
            margin-top: 1rem;
            max-height: calc(100vh - 20rem);
            overflow-y: auto;
        }

        .info-section {
            font-size: 0.95rem;
            line-height: 1.6;
        }

        /* Mobile Info Panel */
        .info-panel-mobile {
            position: fixed;
            left: 0;
            right: 0;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(10px);
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            padding: 1rem;
            z-index: 52;
            display: flex;
            flex-direction: column;
        }

        .info-panel-mobile {
            height: 80vh; /* Fixed height */
            bottom: 35px;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
        }

        .info-panel-mobile.open {
            transform: translateY(0);
            height: 80vh; /* Maintain fixed height when open */
        }

        #mobileInfoContent {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 0 0.5rem;
            padding-bottom: 80px;
        }

        #mobileInfoToggle {
            position: fixed;
            left: 1rem;
            bottom: 75px;
            z-index: 60;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            z-index: 60;
        }

        .bottom-sheet-handle {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin: 0 auto 16px;
            flex-shrink: 0;
        }

        .bottom-sheet-handle {
            pointer-events: none;
        }

        /* Hide desktop controls on mobile */
        @media (max-width: 768px) {
            .info-toggle {
                display: none !important;
            }
        }

        #sourceSelector {
            min-width: 200px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke='%236366f1'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M19 9l-7 7-7-7'%3E%3C/path%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 1.5rem;
            padding-right: 2.5rem;
        }

        #sourceSelector option {
            background: rgba(15, 23, 42, 0.95);
            padding: 0.5rem;
        }

        #sourceSelector optgroup {
            background: rgba(15, 23, 42, 0.95);
            padding: 0.5rem 0;
        }

        #sourceSelector:focus {
            border-color: #6366f1;
            box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.2);
        }

        /* Desktop Scaling (80%) */
        @media (min-width: 769px) {
            /* Container width */
            .container {
                max-width: 80% !important;
            }

            /* Text scaling */
            .text-2xl {
                font-size: 1.2rem !important; /* 80% of 1.5rem */
            }
            
            .text-3xl {
                font-size: 1.6rem !important; /* 80% of 2rem */
            }

            /* Button and input scaling */
            .gradient-btn {
                height: 32px !important; /* 80% of 40px */
                min-width: 80px !important; /* 80% of 100px */
                padding: 0 1rem !important; /* 80% of 1.25rem */
                font-size: 0.9rem !important;
            }

            /* Examples grid scaling */
            .examples-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)) !important; /* 80% of 350px */
                gap: 1.6rem !important; /* 80% of 2rem */
                padding: 0.8rem !important; /* 80% of 1rem */
            }

            /* Card scaling */
            .example-card {
                font-size: 0.9rem !important;
            }

            .card-header {
                height: 56px !important; /* 80% of 70px */
                padding: 0.8rem 1.2rem !important; /* 80% of padding */
            }

            /* Code content scaling */
            .code-content {
                top: 56px !important; /* 80% of header height */
            }

            .code-content pre code {
                font-size: 0.6rem !important; /* 80% of 0.75rem */
            }

            /* Image grid scaling */
            .image-grid {
                gap: 0.8rem !important; /* 80% of 1rem */
                padding: 0 1.2rem 1.2rem !important; /* 80% of padding */
                margin-top: 56px !important; /* 80% of 70px */
            }

            .image-container {
                padding: 0.8rem !important; /* 80% of 1rem */
            }

            .image-pair {
                gap: 0.8rem !important; /* 80% of 1rem */
            }

            /* Source overview cards */
            .source-card {
                padding: 1.2rem !important; /* 80% of 1.5rem */
            }

            /* Button base */
            .button-base {
                padding: 0.4rem 0.8rem !important; /* 80% of padding */
                font-size: 0.9rem !important;
                gap: 0.4rem !important;
            }

            /* Seeds dropdown */
            .seeds-content {
                min-width: 160px !important; /* 80% of original */
                padding: 0.4rem !important;
                margin-top: 0.4rem !important;
            }

            .seed-link {
                padding: 0.4rem !important;
                font-size: 0.9rem !important;
            }

            /* Source selector */
            #sourceSelector {
                transform: scale(0.8);
                transform-origin: right center;
                min-width: 160px !important; /* 80% of 200px */
            }

            /* Info panel scaling */
            .info-panel-wrapper {
                width: 25.6rem !important; /* 80% of 32rem */
            }

            .info-toggle {
                padding: 0.6rem !important;
                border-radius: 0.6rem !important;
                bottom: 1.6rem !important;
                left: 1.6rem !important;
            }

            /* Stats overview */
            .text-xl {
                font-size: 1.2rem !important; /* 80% of 1.5rem */
            }

            .text-2xl {
                font-size: 1.4rem !important; /* 80% of 1.75rem */
            }

            /* Grid gaps */
            .gap-6 {
                gap: 1.2rem !important; /* 80% of 1.5rem */
            }

            .gap-4 {
                gap: 0.8rem !important; /* 80% of 1rem */
            }

            /* Spacing */
            .mb-8 {
                margin-bottom: 1.6rem !important; /* 80% of 2rem */
            }

            .p-6 {
                padding: 1.2rem !important; /* 80% of 1.5rem */
            }
        }
    </style>
</head>
<body class="antialiased">
    <!-- Navigation -->
    <nav class="nav-glass sticky top-0 z-50">
        <div class="container mx-auto px-6">
            <div class="flex flex-col gap-4 py-3">
                <!-- Top Row - Title -->
                <div class="flex justify-center">
                    <h1 class="text-2xl md:text-3xl font-bold logo-gradient">BARC Synthetic Examples</h1>
                </div>
                
                <!-- Bottom Row - Controls -->
                <div class="flex justify-between items-center">
                    <div class="nav-group">
                        <a href="arc.html" class="gradient-btn px-4 py-2 rounded-lg">
                            <i class="fas fa-cube mr-2"></i>
                            <span>Model Performance</span>
                        </a>
                        <a href="seeds.html" class="gradient-btn px-4 py-2 rounded-lg">
                            <i class="fas fa-seedling mr-2"></i>
                            <span>Seeds</span>
                        </a>
                        <div class="flex items-center gap-2">
                            <button id="shuffleButton" class="gradient-btn px-4 py-2 rounded-lg">
                                <i class="fas fa-random mr-2"></i>
                                <span>Shuffle</span>
                            </button>
                            <button id="resetButton" class="gradient-btn px-3 py-2 rounded-lg hidden">
                                <i class="fas fa-rotate"></i>
                            </button>
                        </div>
                    </div>
                    <div class="nav-group">
                        <select id="sourceSelector" class="bg-slate-800/50 backdrop-blur-lg text-slate-200 rounded-lg border border-slate-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 px-4 py-2">
                            <option value="barc_gpt4_desc">GPT-4</option>
                            <option value="barc_gpt4o_mini_desc">GPT4o-mini</option>
                            <option value="barc_heavy">Heavy</option>
                            <option value="barc_heavy_suggest">Heavy with Suggestions</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-8">
        <!-- Source Overview -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div id="sourceStats" class="source-card p-6">
                <h2 class="text-xl font-bold text-slate-200 mb-4">Overview</h2>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <p class="text-slate-400">Total Examples</p>
                        <p class="text-2xl font-bold logo-gradient" id="totalCount">0</p>
                    </div>
                    <div>
                        <p class="text-slate-400">Current Source</p>
                        <p class="text-2xl font-bold logo-gradient" id="currentSource">All</p>
                    </div>
                </div>
            </div>
            <div id="sourceDescription" class="source-card p-6">
                <h2 class="text-xl font-bold text-slate-200 mb-4">Source Description</h2>
                <p class="text-slate-400" id="descriptionText">
                    Viewing all examples from different sources.
                </p>
            </div>
        </div>

        <!-- Examples Grid -->
        <div id="examplesGrid" class="examples-grid">
            <!-- Examples will be inserted here -->
        </div>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="loading-dots hidden">
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
        </div>

        <button id="infoToggle" class="info-toggle">
            <i class="fas fa-info-circle"></i>
            <span>Info</span>
        </button>
        
        <div class="info-panel-wrapper">
            <div id="infoDisplay" class="info-panel">
                <h3 class="text-xl font-bold mb-4 logo-gradient">About the ARC Challenge</h3>
                
                <div class="info-section">
                    <p class="text-slate-300 mb-4">
                        The <a href="https://arcprize.org/" target="_blank" class="text-indigo-400 hover:text-indigo-300 underline">Abstraction and Reasoning Corpus (ARC)</a> is a dataset that measures general fluid intelligence in AI systems. It consists of tasks where the AI must infer a pattern from a few examples and apply it to new situations.
                    </p>
                    
                    <p class="text-slate-300 mb-4">
                        Each task contains:
                    </p>
                    <ul class="list-disc list-inside text-slate-300 mb-4 space-y-2">
                        <li>Training examples showing input-output pairs that demonstrate the pattern</li>
                        <li>A test input where the AI must predict the correct output</li>
                        <li>The ground truth test output for evaluation</li>
                    </ul>
                    
                    <p class="text-slate-300 mb-4">
                        This page showcases different transduction / induction models attempting to solve the ARC validation set. For each task, models generate multiple candidate solutions, which are ranked based on various strategies including test-time fine-tuning and reranking approaches.
                    </p>
        
                    <p class="text-slate-300 mb-4">
                        The visualization allows you to:
                    </p>
                    <ul class="list-disc list-inside text-slate-300 mb-4 space-y-2">
                        <li>Compare different model variants and their performance</li>
                        <li>View training examples and test cases</li>
                        <li>Examine candidate solutions generated by the models</li>
                        <li>Track success rates and solution rankings</li>
                    </ul>
        
                    <div class="mt-6 p-4 bg-slate-800/50 rounded-lg">
                        <p class="text-slate-300">
                            For implementation details about the models and evaluation process, visit  <a href="https://github.com/xu3kev/BARC/tree/master" 
                               class="text-indigo-400 hover:text-indigo-300 underline break-all" 
                               target="_blank">
                                BARC</a>. For detailed analysis of induction vs transduction approaches, see <a href="https://www.cs.cornell.edu/~ellisk/documents/arc_induction_vs_transduction.pdf"
                            class="text-indigo-400 hover:text-indigo-300 underline break-all"
                            target="_blank">
                            our paper</a>.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div class="md:hidden">
            <button class="mobile-fab" id="mobileInfoToggle">
                <i class="fas fa-info-circle"></i>
            </button>
        </div>
        
        <div class="mobile-fab-container md:hidden">
            <button class="mobile-fab" id="mobileShuffleButton" onclick="handleShuffle()">
                <i class="fas fa-random"></i>
            </button>
            <button class="mobile-fab hidden" id="mobileResetButton" onclick="handleReset()">
                <i class="fas fa-rotate"></i>
            </button>
        </div>
        
        <div class="mobile-model-select md:hidden">
            <select id="mobileSourceSelector" onchange="handleSourceChange({ target: this })">
                <option value="barc_gpt4_desc">GPT-4</option>
                <option value="barc_gpt4o_mini_desc">GPT4o-mini</option>
                <option value="barc_heavy">Heavy</option>
                <option value="barc_heavy_suggest">Heavy with Suggestions</option>
            </select>
        </div>
    </main>

    <div class="custom-scrollbar">
        <div class="scrollbar-track">
            <div class="scrollbar-thumb">
                <div class="scrollbar-thumb-inner"></div>
            </div>
        </div>
    </div>

    <div id="mobileInfoPanel" class="info-panel-mobile md:hidden">
        <div class="bottom-sheet-handle"></div>
        <div id="mobileInfoContent">
            <!-- Info content will be copied here for mobile -->
        </div>
    </div>

    <script>
        // Data and State Management
        const examples = [{"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, size-based color transformation\n\n# description:\n# In the input, you will see a grid with several colored objects. \n# To make the output, change the color of the smallest object to blue, \n# the color of the largest object to red, and all other objects to green.\n\ndef main(input_grid):\n    # Find all connected components (objects) in the grid\n    objects = find_connected_components(grid=input_grid, monochromatic=True, background=Color.BLACK)\n\n    # Initialize output grid as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Determine the sizes of each object and identify the smallest and largest\n    sizes = [np.sum(obj != Color.BLACK) for obj in objects]\n    if not sizes:\n        return output_grid  # No objects found, return original grid\n\n    min_size = min(sizes)\n    max_size = max(sizes)\n\n    for obj in objects:\n        size = np.sum(obj != Color.BLACK)\n        if size == min_size:\n            output_grid[obj != Color.BLACK] = Color.BLUE\n        elif size == max_size:\n            output_grid[obj != Color.BLACK] = Color.RED\n        else:\n            output_grid[obj != Color.BLACK] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid with a black background\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly scatter colored objects in the grid\n    num_objects = np.random.randint(3, 6)\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.TEAL, Color.YELLOW]\n    \n    for _ in range(num_objects):\n        # Generate a random sprite (object) of a random size\n        sprite_height = np.random.randint(1, 4)\n        sprite_width = np.random.randint(1, 4)\n        sprite = random_sprite(sprite_height, sprite_width, density=1.0, color_palette=[np.random.choice(colors)])\n        \n        # Find a random free location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If no space is found, continue to the next object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/0/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/0/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/0/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/0/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/0/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/0/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/0/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/0/images/train_output_2.png"}]}, "index": 0, "seeds": ["aedd82e4", "941d9a10", "6e82a1ae", "0d3d703e"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, color mapping, grid transformation\n\n# description:\n# In the input, you will see a grid of colored pixels on a black background. Each color represents a different type of shape: \n# - Blue for circles\n# - Green for squares\n# - Red for triangles\n# The output should count how many of each shape color appear in the input and create a new grid where each color square represents \n# the count of that shape color. The output grid should be in the order of Blue, Green, and Red.\n\ndef main(input_grid):\n    # Count the occurrences of each color in the input grid\n    blue_count = np.sum(input_grid == Color.BLUE)\n    green_count = np.sum(input_grid == Color.GREEN)\n    red_count = np.sum(input_grid == Color.RED)\n\n    # Create an output grid with a single row for the counts\n    output_grid = np.zeros((1, 3), dtype=int)\n\n    # Map counts to colors in the output grid\n    output_grid[0, 0] = Color.BLUE if blue_count \u003e 0 else Color.BLACK\n    output_grid[0, 1] = Color.GREEN if green_count \u003e 0 else Color.BLACK\n    output_grid[0, 2] = Color.RED if red_count \u003e 0 else Color.BLACK\n\n    return output_grid\n\ndef generate_input():\n    # Create an empty black grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place colored shapes (circles, squares, triangles) in the grid\n    shape_colors = [Color.BLUE, Color.GREEN, Color.RED]\n    num_shapes = np.random.randint(5, 15)  # Random number of shapes between 5 and 15\n\n    for _ in range(num_shapes):\n        shape_color = np.random.choice(shape_colors)\n        # Random sprite (2x2) for each shape\n        shape_sprite = random_sprite(n=2, m=2, color_palette=[shape_color], density=1.0)\n        \n        # Find a random free location in the grid for the shape\n        try:\n            x, y = random_free_location_for_sprite(grid, shape_sprite)\n            blit_sprite(grid, shape_sprite, x=x, y=y)\n        except:\n            continue  # If no space found, skip this shape\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/1/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/1/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/1/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/1/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/1/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/1/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/1/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/1/images/train_output_2.png"}]}, "index": 1, "seeds": ["469497ad", "ff28f65a", "6e82a1ae", "25d8a9c8"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flipping, pattern replication\n\n# description:\n# In the input, you will see a pattern of colored pixels on a black background. \n# To make the output, flip the pattern vertically, and then replicate the flipped pattern to fill the output grid.\n\ndef main(input_grid):\n    # Find the connected components (the pattern) in the input grid\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    # Assuming there is only one main pattern, we take the first one\n    pattern = objects[0]\n\n    # Crop the pattern to remove black borders\n    cropped_pattern = crop(pattern)\n\n    # Flip the pattern vertically\n    flipped_pattern = cropped_pattern[::-1]\n\n    # Create the output grid with double the height of the flipped pattern and the same width\n    output_height = flipped_pattern.shape[0] * 2\n    output_width = flipped_pattern.shape[1]\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Blit the flipped pattern twice into the output grid\n    blit_sprite(output_grid, flipped_pattern, x=0, y=0, background=Color.BLACK)\n    blit_sprite(output_grid, flipped_pattern, x=0, y=flipped_pattern.shape[0], background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Make a random-sized grid with a black background\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random pattern within the grid\n    pattern_density = np.random.uniform(0.2, 0.8)\n    pattern = random_sprite(n, m, density=pattern_density, color_palette=[color], symmetry=\u0027not_symmetric\u0027)\n\n    # Place the pattern in the center of the grid with a black background\n    grid = blit_sprite(grid, pattern, x=0, y=0, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/2/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/2/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/2/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/2/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/2/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/2/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/2/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/2/images/train_output_2.png"}]}, "index": 2, "seeds": ["bc1d5164", "6fa7a44f", "bd4472b8", "3de23699"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, diagonal lines, color propagation\n\n# description:\n# In the input, you will see a grid with a single colored pixel. \n# To make the output, draw a diagonal line of the same color as the pixel, from the top left corner to the bottom right corner. \n# Then, reflect this line along the x-axis to achieve vertical symmetry.\n\ndef main(input_grid):\n    # Make output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the index of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n    \n    # Get color from colored pixel\n    color = input_grid[x, y]\n\n    # Draw diagonal line from (0, 0) to (min(width, height), min(width, height))\n    draw_line(output_grid, 0, 0, length=min(width, height), color=color, direction=(1, 1))\n    \n    # Reflect the diagonal line along the x-axis\n    for i in range(min(width, height)):\n        output_grid[i, i] = color  # Original diagonal\n        if i \u003c output_grid.shape[0]:  # Check if within bounds for reflection\n            output_grid[output_grid.shape[0] - 1 - i, i] = color  # Reflected diagonal\n\n    return output_grid\n\ndef generate_input():\n    # Make a square black grid for the background first\n    n = m = np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Put a randomly colored pixel at a random point on the grid\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/3/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/3/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/3/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/3/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/3/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/3/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/3/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/3/images/train_output_2.png"}]}, "index": 3, "seeds": ["623ea044", "ea786f4a", "44f52bb0", "8d510a79"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# duplication, color transformation\n\n# description:\n# In the input you will see a grid with a single colored pixel in the center of the grid. \n# To make the output, duplicate the center pixel in a cross pattern (up, down, left, right) and change each color to a different color based on predefined rules.\n# For example, if the original color is blue, the new colors will be red, green, yellow, and black for the four directions.\n\ndef main(input_grid):\n    # Find the position of the colored pixel (assumed to be the only colored pixel)\n    colored_pixel_positions = np.argwhere(input_grid != Color.BLACK)\n    \n    # Check if there is exactly one colored pixel in the grid\n    if colored_pixel_positions.shape[0] != 1:\n        raise ValueError(\"Input grid must contain exactly one colored pixel.\")\n\n    x, y = colored_pixel_positions[0]\n    original_color = input_grid[x, y]\n\n    # Create an output grid initialized with black\n    output_grid = np.zeros_like(input_grid)\n\n    # Define the color transformation rules\n    color_transform = {\n        Color.BLUE: [Color.RED, Color.GREEN, Color.YELLOW, Color.BLACK],\n        Color.RED: [Color.GREEN, Color.YELLOW, Color.BLACK, Color.BLUE],\n        Color.GREEN: [Color.YELLOW, Color.BLACK, Color.BLUE, Color.RED],\n        Color.YELLOW: [Color.BLACK, Color.BLUE, Color.RED, Color.GREEN],\n        Color.BLACK: [Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW]\n    }\n\n    # Get the colors for up, down, left, right based on the original pixel color\n    new_colors = color_transform.get(original_color, [Color.BLACK]*4)\n\n    # Place the original color and its duplicates in the output grid\n    output_grid[x, y] = original_color  # center\n    output_grid[x-1, y] = new_colors[0]  # up\n    output_grid[x+1, y] = new_colors[1]  # down\n    output_grid[x, y-1] = new_colors[2]  # left\n    output_grid[x, y+1] = new_colors[3]  # right\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size 5x5 with a black background\n    grid_size = 5\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly select a color for the single pixel in the center\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Set the center pixel\n    grid[grid_size // 2, grid_size // 2] = center_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/4/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/4/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/4/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/4/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/4/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/4/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/4/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/4/images/train_output_2.png"}]}, "index": 4, "seeds": ["46f33fce", "bc1d5164", "6cdd2623", "1fad071e"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, intersection, circles\n\n# description:\n# In the input, you will see a black grid with a single colored pixel. The pixel represents the center of a circle. \n# To make the output, draw a vertical and a horizontal line that intersect at the location of the colored pixel, \n# and draw a circle with the same color as the pixel around it.\n\ndef main(input_grid):\n    # Make output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the index of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n\n    # Get color from the colored pixel\n    color = input_grid[x, y]\n\n    # Draw the vertical line\n    draw_line(output_grid, x, y, length=None, color=color, direction=(0, 1))\n    # Draw the horizontal line\n    draw_line(output_grid, x, y, length=None, color=color, direction=(1, 0))\n\n    # Draw the circle with the same color as the pixel\n    radius = 2  # You can adjust the radius as needed\n    for dx in range(-radius, radius + 1):\n        for dy in range(-radius, radius + 1):\n            if dx**2 + dy**2 \u003c= radius**2:  # Equation of a circle\n                if 0 \u003c= x + dx \u003c output_grid.shape[0] and 0 \u003c= y + dy \u003c output_grid.shape[1]:\n                    output_grid[x + dx, y + dy] = color\n\n    return output_grid\n\ndef generate_input():\n    # Make a 10x10 black grid for the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Put a colored pixel at a random point on the grid\n    color = np.random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/5/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/5/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/5/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/5/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/5/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/5/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/5/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/5/images/train_output_2.png"}]}, "index": 5, "seeds": ["23581191", "623ea044", "8d510a79", "ea786f4a"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, region filling\n\n# description:\n# In the input, you will see a grid filled with various colors. \n# To create the output, you need to transform the grid as follows:\n# 1. For each region of adjacent same-colored pixels, change the color to a new color based on their current color:\n#    - red -\u003e green\n#    - green -\u003e blue\n#    - blue -\u003e red\n# 2. If a region contains any yellow pixels, change the whole region to orange.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = input_grid.copy()\n\n    # Find connected components\n    regions = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    for region in regions:\n        # Check if the region contains any yellow pixels\n        if Color.YELLOW in region:\n            # Color the whole region orange\n            x, y = np.where(region == Color.YELLOW)\n            flood_fill(output_grid, x[0], y[0], Color.ORANGE)\n        else:\n            # Determine the color of the region (assuming monochromatic regions)\n            unique_colors = np.unique(region)\n            if len(unique_colors) == 1:\n                current_color = unique_colors[0]\n                if current_color == Color.RED:\n                    flood_fill(output_grid, region[0][0], region[0][1], Color.GREEN)\n                elif current_color == Color.GREEN:\n                    flood_fill(output_grid, region[0][0], region[0][1], Color.BLUE)\n                elif current_color == Color.BLUE:\n                    flood_fill(output_grid, region[0][0], region[0][1], Color.RED)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size filled with random colors\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)  # Start with a black grid\n\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n    # Randomly fill the grid with colors\n    for i in range(n):\n        for j in range(m):\n            grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/6/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/6/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/6/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/6/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/6/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/6/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/6/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/6/images/train_output_2.png"}]}, "index": 6, "seeds": ["0d3d703e", "0ca9ddb6", "941d9a10", "7447852a"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color coding, object transformation\n\n# description:\n# In the input, you will see various colored objects on a 10x10 grid.\n# To make the output grid, check if each object is symmetric about its vertical axis.\n# If it is symmetric, color it green. If it is not symmetric, color it yellow.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # Check each object for vertical symmetry\n    for obj in objects:\n        # Crop the object to its bounding box\n        cropped_obj = crop(obj, background=Color.BLACK)\n        \n        # Check for vertical mirror symmetry\n        if detect_mirror_symmetry(cropped_obj, ignore_colors=[Color.BLACK]):\n            # If symmetric, color the object green\n            output_grid[obj != Color.BLACK] = Color.GREEN\n        else:\n            # If not symmetric, color the object yellow\n            output_grid[obj != Color.BLACK] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Create a 10x10 grid with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of objects\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Create a random sprite with a random symmetry (or not)\n        sprite = random_sprite(np.random.randint(2, 6), np.random.randint(2, 6), \n                               symmetry=np.random.choice([\"horizontal\", \"vertical\", \"not_symmetric\"]), \n                               color_palette=list(Color.NOT_BLACK))\n\n        # Find a random free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If no space is available, skip this object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/7/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/7/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/7/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/7/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/7/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/7/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/7/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/7/images/train_output_2.png"}]}, "index": 7, "seeds": ["44f52bb0", "aedd82e4", "6e82a1ae", "3345333e"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, concentric patterns\n\n# description:\n# In the input, you will see a grid with a single blue pixel. \n# To make the output, create a concentric pattern of colors that will radiate from the blue pixel; \n# the outer layer should be yellow, the next layer should be pink, and the innermost layer should be green. \n# Each layer should be 1 pixel thick and should fill in the area around the blue pixel, \n# ensuring that the pattern stays within the bounds of the grid.\n\ndef main(input_grid):\n    # Find the blue pixel\n    blue_pixel_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], allowed_dimensions=[(1, 1)], monochromatic=True, connectivity=4)\n    assert len(blue_pixel_objects) == 1\n    blue_pixel_object = blue_pixel_objects[0]\n\n    # Get the position of the blue pixel\n    blue_x, blue_y = object_position(blue_pixel_object, background=Color.BLACK, anchor=\"upper left\")\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Set the colors for each layer\n    layers = [Color.YELLOW, Color.PINK, Color.GREEN]\n\n    # Draw concentric layers around the blue pixel\n    for layer_color in layers:\n        # Draw surrounding layer\n        if blue_x \u003e 0:  # Top\n            output_grid[blue_x - 1, blue_y] = layer_color\n        if blue_x \u003c output_grid.shape[0] - 1:  # Bottom\n            output_grid[blue_x + 1, blue_y] = layer_color\n        if blue_y \u003e 0:  # Left\n            output_grid[blue_x, blue_y - 1] = layer_color\n        if blue_y \u003c output_grid.shape[1] - 1:  # Right\n            output_grid[blue_x, blue_y + 1] = layer_color\n        \n        # Move to the next inner layer for the next iteration\n        blue_x, blue_y = blue_x - 1, blue_y - 1  # Shift inward\n\n    # Place the blue pixel in the center\n    output_grid[blue_pixel_object[0][0], blue_pixel_object[0][1]] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a 5x5 black grid for the background\n    n, m = 5, 5\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select the position of the blue pixel\n    x, y = np.random.randint(1, n - 1), np.random.randint(1, m - 1)  # Ensure space for layers\n    grid[x, y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/8/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/8/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/8/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/8/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/8/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/8/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/8/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/8/images/train_output_2.png"}]}, "index": 8, "seeds": ["a9f96cdd", "995c5fa3", "3de23699", "23581191"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel transformation, color shifting\n\n# description:\n# In the input, you will see a grid with several colored pixels. Each pixel will be transformed based on its position:\n# 1. If a pixel is located in an even row, it will change to the next color in the color sequence (e.g., RED to GREEN).\n# 2. If a pixel is located in an odd row, it will change to the previous color in the color sequence (e.g., BLUE to RED).\n# The color sequence is: RED, GREEN, BLUE, YELLOW, ORANGE, TEAL, GREY, PINK, MAROON, BLACK.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Define the color sequence\n    color_sequence = [\n        Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, \n        Color.ORANGE, Color.TEAL, Color.GREY, Color.PINK, \n        Color.MAROON, Color.BLACK\n    ]\n    \n    # Create a mapping of color to its index for easy manipulation\n    color_index = {color: idx for idx, color in enumerate(color_sequence)}\n    \n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color in color_index:  # Only process known colors\n                if x % 2 == 0:\n                    # Even row: move to the next color\n                    next_index = (color_index[color] + 1) % len(color_sequence)\n                    output_grid[x, y] = color_sequence[next_index]\n                else:\n                    # Odd row: move to the previous color\n                    prev_index = (color_index[color] - 1) % len(color_sequence)\n                    output_grid[x, y] = color_sequence[prev_index]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)  # Grid size\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colors in the grid from the defined color sequence\n    for x in range(n):\n        for y in range(m):\n            if np.random.rand() \u003c 0.3:  # 30% chance to place a color\n                grid[x, y] = np.random.choice(Color.NOT_BLACK)  # Choose a random color that is not black\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/9/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/9/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/9/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/9/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/9/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/9/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/9/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/9/images/train_output_2.png"}]}, "index": 9, "seeds": ["6cdd2623", "d9f24cd1", "1f642eb9", "0ca9ddb6"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# intersecting lines, color extraction\n\n# description:\n# In the input, you will see a grid with multiple colored diagonal lines, intersecting at a central point. \n# To make the output grid, identify the color of the intersection pixel and draw a square around it, \n# filled with that same color. The square should be of size 3x3 centered on the intersection pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Make a copy of the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the coordinates of the intersection pixel (which is the only maroon pixel in the grid)\n    intersection_coords = np.argwhere(input_grid == Color.MAROON)\n    if intersection_coords.size == 0:\n        return output_grid  # If no intersection, return as is\n    \n    x, y = intersection_coords[0]\n\n    # Fill a 3x3 square around the intersection with its color\n    for i in range(-1, 2):\n        for j in range(-1, 2):\n            if 0 \u003c= x + i \u003c output_grid.shape[0] and 0 \u003c= y + j \u003c output_grid.shape[1]:\n                output_grid[x + i, y + j] = input_grid[x, y]  # Fill with the intersection color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid of random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color for the diagonal lines\n    colors = list(Color.NOT_BLACK)\n    color = random.choice(colors)\n\n    # Draw two diagonal lines that intersect at a random point\n    x, y = np.random.randint(1, n - 1), np.random.randint(1, m - 1)\n    draw_line(grid, x, y, length=None, color=color, direction=(1, 1))  # Diagonal from top-left to bottom-right\n    draw_line(grid, x, y, length=None, color=color, direction=(1, -1))  # Diagonal from bottom-left to top-right\n\n    # Set the intersection point to maroon\n    grid[x, y] = Color.MAROON\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/10/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/10/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/10/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/10/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/10/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/10/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/10/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/10/images/train_output_2.png"}]}, "index": 10, "seeds": ["623ea044", "23581191", "6cdd2623", "5daaa586"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, color transformation, grid manipulation\n\n# description:\n# In the input, you will see two distinct 5x5 patterns placed vertically with a black interval in between.\n# Each pattern consists of colored pixels (red, teal, yellow, or green). \n# The task is to identify each pattern and then create an output grid where the first pattern is transformed to a teal background,\n# and the second pattern is transformed to a yellow background, while preserving the original shapes of the patterns.\n\ndef main(input_grid):\n    # Define the colors\n    red, teal, yellow, green, black = Color.RED, Color.TEAL, Color.YELLOW, Color.GREEN, Color.BLACK\n\n    # Detect the two patterns in the input grid\n    patterns = detect_objects(grid=input_grid, colors=[red, teal, yellow, green], monochromatic=False, connectivity=8)\n\n    # Check if we found exactly two patterns\n    if len(patterns) != 2:\n        raise ValueError(\"There should be exactly two patterns in the input grid.\")\n\n    # Create an output grid with the same shape as the input grid, initially filled with black\n    output_grid = np.full(input_grid.shape, black)\n\n    # Transform the first pattern to teal background and second to yellow background\n    for i, pattern in enumerate(patterns):\n        # Crop the pattern to focus on the non-black pixels\n        sprite = crop(pattern, background=black)\n\n        # Determine the target color based on the pattern\u0027s index\n        target_color = teal if i == 0 else yellow\n        \n        # Draw the pattern with the new background color\n        for x, y in np.argwhere(sprite != black):\n            output_grid[x + object_position(pattern)[0], y + object_position(pattern)[1]] = target_color\n\n    return output_grid\n\ndef generate_input():\n    # Create an empty grid of size 12x7\n    n, m = 12, 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define colors to choose from\n    colors = [Color.RED, Color.TEAL, Color.YELLOW, Color.GREEN]\n    \n    # Randomly select two colors for the patterns\n    selected_colors = np.random.choice(colors, size=2, replace=False)\n\n    # Define the size of the patterns\n    pattern_size = 5\n\n    # Place the first pattern\n    x_offset = 1\n    y_offset = np.random.randint(0, m - pattern_size - 1)\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[x_offset + i, y_offset + j] = selected_colors[0] if np.random.random() \u003e 0.2 else Color.BLACK\n\n    # Place the second pattern\n    x_offset += pattern_size + 1  # Moving down for the second pattern\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[x_offset + i, y_offset + j] = selected_colors[1] if np.random.random() \u003e 0.2 else Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/11/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/11/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/11/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/11/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/11/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/11/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/11/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/11/images/train_output_2.png"}]}, "index": 11, "seeds": ["995c5fa3", "a9f96cdd", "bc1d5164", "6cdd2623"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# arrow drawing, grid transformation\n\n# description:\n# In the input, you will see a grid with a single blue pixel. \n# To make the output, draw a blue arrow pointing to the right, with the arrowhead located at the blue pixel.\n# The arrow should consist of a straight blue line leading to the arrowhead, and the arrowhead should be made of two diagonal lines extending down and up from the end of the arrow line.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the blue pixel\n    blue_x, blue_y = np.where(input_grid == Color.BLUE)\n\n    if len(blue_x) == 0:\n        return output_grid  # If no blue pixel found, return original grid\n\n    # Get the position of the blue pixel (assume there is only one)\n    blue_x, blue_y = blue_x[0], blue_y[0]\n\n    # Draw the straight line to the right from the blue pixel\n    draw_line(output_grid, blue_x, blue_y, length=3, color=Color.BLUE, direction=(0, 1))\n\n    # Draw the arrowhead (two diagonal lines)\n    # Diagonal down-left\n    draw_line(output_grid, blue_x + 0, blue_y + 3, length=1, color=Color.BLUE, direction=(1, -1))\n    # Diagonal down-right\n    draw_line(output_grid, blue_x + 0, blue_y + 3, length=1, color=Color.BLUE, direction=(1, 1))\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid as the background\n    n = np.random.randint(5, 15)\n    m = np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a random position for the blue pixel\n    blue_x = np.random.randint(0, n)\n    blue_y = np.random.randint(0, m - 3)  # Ensure there is space for the arrow\n\n    grid[blue_x, blue_y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/12/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/12/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/12/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/12/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/12/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/12/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/12/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/12/images/train_output_2.png"}]}, "index": 12, "seeds": ["d4a91cb9", "8d510a79", "23581191", "0ca9ddb6"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pixel manipulation\n\n# description:\n# In the input you will see a medium sized grid with individual colored pixels. \n# To make the output: \n# 1. For each red pixel, change it to blue \n# 2. For each blue pixel, change it to red \n# 3. For each green pixel, change it to yellow \n# 4. For each yellow pixel, change it to green\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Initialize output grid\n    output_grid = np.copy(input_grid)\n\n    # Perform color transformations\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.RED:\n                output_grid[x, y] = Color.BLUE\n            elif color == Color.BLUE:\n                output_grid[x, y] = Color.RED\n            elif color == Color.GREEN:\n                output_grid[x, y] = Color.YELLOW\n            elif color == Color.YELLOW:\n                output_grid[x, y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly fill the grid with colors\n    num_pixels = np.random.randint(10, 50)\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color_choice = np.random.choice([Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW])\n        grid[x, y] = color_choice\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/13/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/13/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/13/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/13/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/13/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/13/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/13/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/13/images/train_output_2.png"}]}, "index": 13, "seeds": ["0ca9ddb6", "0d3d703e", "0e206a2e", "1fad071e"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping, pattern recognition\n\n# description:\n# In the input, you will see a grid filled with colored pixels in a checkerboard pattern. \n# The first row and first column will indicate the color mapping: \n# The first cell (0,0) represents background color (black), \n# the first row will represent colors for even indexed columns, \n# and the first column will represent colors for even indexed rows. \n# To make the output grid, you should fill in the colors based on the mapping:\n# - (row_color, col_color) will be used to fill the grid such that:\n#   - If both row and column colors are the same, use that color.\n#   - Otherwise, use the color from the first row for even indexed columns and first column for even indexed rows.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Retrieve row colors and column colors\n    row_colors = input_grid[:, 0]\n    col_colors = input_grid[0, :]\n\n    # Fill the output grid based on the color mapping rules\n    for i in range(1, input_grid.shape[0]):\n        for j in range(1, input_grid.shape[1]):\n            row_color = row_colors[i]\n            col_color = col_colors[j]\n\n            if row_color == col_color:\n                output_grid[i, j] = row_color\n            else:\n                output_grid[i, j] = col_colors[j] if j % 2 == 0 else row_colors[i]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a checkerboard color layout\n    n, m = 6, 6  # Grid size\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define colors to be used\n    possible_colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.TEAL, Color.PINK]\n\n    # Fill the first row and first column with random colors from possible_colors\n    grid[0, 1:] = np.random.choice(possible_colors, size=m-1)\n    grid[1:, 0] = np.random.choice(possible_colors, size=n-1)\n\n    # Fill the rest of the grid in a checkerboard pattern\n    for i in range(1, n):\n        for j in range(1, m):\n            # Fill in the grid with the background color for now\n            if (i + j) % 2 == 0:\n                grid[i, j] = Color.BLACK  # Background color\n            else:\n                # Randomly assign one of the colors for the checkerboard\n                grid[i, j] = np.random.choice(possible_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/14/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/14/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/14/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/14/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/14/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/14/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/14/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/14/images/train_output_2.png"}]}, "index": 14, "seeds": ["3e980e27", "0d3d703e", "a9f96cdd", "995c5fa3"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color transformation, object size determination\n\n# description:\n# In the input, you will see several objects of different colors against a black background.\n# To make the output, extract all objects, count their size, and change their color to:\n# - green if they have an odd number of pixels,\n# - red if they have an even number of pixels but greater than zero,\n# - leave black if they have zero pixels.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the objects in the input grid\n    objects = find_connected_components(input_grid)\n\n    # Change colors based on the size of each object\n    for obj in objects:\n        num_pixels = np.sum(obj != Color.BLACK)  # Count non-black pixels\n        if num_pixels % 2 == 1 and num_pixels \u003e 0:  # Odd number of pixels\n            output_grid[obj != Color.BLACK] = Color.GREEN\n        elif num_pixels % 2 == 0 and num_pixels \u003e 0:  # Even number of pixels\n            output_grid[obj != Color.BLACK] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Make a black 10x10 grid as the background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a number of sprites\n    num_sprites = np.random.randint(3, 7)\n    for _ in range(num_sprites):\n        # Create a random sprite with random size and ensure it has a valid number of pixels\n        sprite = random_sprite(np.random.randint(1, 5), np.random.randint(1, 5), symmetry=\"not_symmetric\", color_palette=[Color.BLUE])\n        \n        # Ensure the sprite is not completely black\n        while np.sum(sprite != Color.BLACK) == 0:\n            sprite = random_sprite(np.random.randint(1, 5), np.random.randint(1, 5), symmetry=\"not_symmetric\", color_palette=[Color.BLUE])\n        \n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # Skip if there\u0027s no free space\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/15/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/15/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/15/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/15/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/15/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/15/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/15/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/15/images/train_output_2.png"}]}, "index": 15, "seeds": ["6e82a1ae", "137eaa0f", "aedd82e4", "1f642eb9"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swapping, striped patterns, grid manipulation\n\n# description:\n# In the input you will see a grid with horizontal stripes of two colors. \n# Each stripe has a fixed height. The task is to swap the colors of all the stripes.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    \n    # Identify the unique colors in the input grid (excluding black)\n    unique_colors = set(input_grid.flatten()) - {Color.BLACK}\n    \n    # If there are not exactly two colors, return the original grid (no valid transformation)\n    if len(unique_colors) != 2:\n        return output_grid\n    \n    # Identify the two colors\n    color1, color2 = list(unique_colors)\n    \n    # Swap the colors in the output grid\n    output_grid[input_grid == color1] = color2\n    output_grid[input_grid == color2] = color1\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Set the height of each stripe\n    STRIPE_HEIGHT = np.random.randint(1, 4)\n\n    # Randomly choose two colors (excluding black)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=2, replace=False)\n    \n    # Draw horizontal stripes\n    for i in range(0, n, STRIPE_HEIGHT):\n        if (i // STRIPE_HEIGHT) % 2 == 0:\n            draw_line(grid=grid, x=0, y=i, length=m, direction=(1, 0), color=colors[0])\n        else:\n            draw_line(grid=grid, x=0, y=i, length=m, direction=(1, 0), color=colors[1])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/16/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/16/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/16/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/16/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/16/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/16/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/16/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/16/images/train_output_2.png"}]}, "index": 16, "seeds": ["8e1813be", "d511f180", "6fa7a44f", "941d9a10"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color detection, object extraction\n\n# description:\n# In the input you will see a 2D grid with colored objects. Some objects are formed of multiple colors and are not connected but represent the same shape.\n# To make the output, you need to unify all sections of each object into one color, preserving the shape of the object. \n# If an object is composed of multiple colors, it will be converted to a single color (the first color encountered in the object).\n\ndef main(input_grid):\n    # Start by creating an output grid that will be filled in\n    output_grid = np.copy(input_grid)\n\n    # Detect all objects in the grid\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=8, background=Color.BLACK)\n\n    # Process each detected object\n    for obj in objects:\n        # Extract the color of the first pixel in the object\n        first_color = obj[obj != Color.BLACK][0]\n\n        # Get the coordinates of this object and fill it with the first color\n        coords = np.argwhere(obj != Color.BLACK)\n        for x, y in coords:\n            output_grid[x + obj.shape[0] - obj.shape[0], y + obj.shape[1] - obj.shape[1]] = first_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium-sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of objects\n    num_objects = np.random.randint(2, 5)\n    colors = random.sample(list(Color.NOT_BLACK), num_objects)  # Choose unique colors for each object\n\n    for color in colors:\n        # Create a random object\n        sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.5, color_palette=[color])\n        \n        # Place the sprite in a random free location on the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n        \n        # Randomly add disconnected parts of the object with different colors\n        for _ in range(np.random.randint(1, 4)):  # Add 1 to 3 disconnected parts\n            disconnected_sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), density=0.5, color_palette=[random.choice(Color.NOT_BLACK)])\n            dx, dy = random_free_location_for_sprite(grid, disconnected_sprite)\n            blit_sprite(grid, disconnected_sprite, dx, dy)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/17/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/17/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/17/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/17/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/17/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/17/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/17/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/17/images/train_output_2.png"}]}, "index": 17, "seeds": ["11852cab", "44f52bb0", "3345333e", "1b60fb0c"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, color blending\n\n# description:\n# In the input, you will see a grid containing a central colored object surrounded by a border of another color.\n# To create the output, remove the border and blend the central object with its surrounding color.\n\ndef main(input_grid):\n    # Find the shape of the grid\n    n, m = input_grid.shape\n    \n    # Identify the color of the border (which is assumed to be the same for pixels around the object)\n    border_color = input_grid[0, 0]  # Take the color from the top-left corner\n    \n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Remove the border pixels\n    output_grid[output_grid == border_color] = Color.BLACK\n\n    # Blend the central object with the border color\n    # Find the central object pixels which are not black\n    central_object_pixels = np.argwhere(output_grid != Color.BLACK)\n\n    # If there are central object pixels, blend them with the border color\n    if central_object_pixels.size \u003e 0:\n        for x, y in central_object_pixels:\n            output_grid[x, y] = (border_color if output_grid[x, y] == Color.BLACK else output_grid[x, y])\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 7x7 filled with black\n    n, m = 7, 7\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define colors for the object and the border\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    border_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Make sure the object color and border color are different\n    while object_color == border_color:\n        border_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a central object and place it in the middle of the grid\n    sprite = random_sprite(5, 5, density=0.5, symmetry=None, color_palette=[object_color])\n    blit_sprite(grid, sprite, x=1, y=1)\n\n    # Create a border around the object\n    for i in range(n):\n        for j in range(m):\n            if (i == 0 or i == n-1 or j == 0 or j == m-1) and grid[i, j] == Color.BLACK:\n                grid[i, j] = border_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/18/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/18/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/18/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/18/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/18/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/18/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/18/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/18/images/train_output_2.png"}]}, "index": 18, "seeds": ["aabf363d", "44f52bb0", "3345333e", "0dfd9992"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape expansion, color swap\n\n# description:\n# In the input you will see a black grid with a colored shape in the center. \n# To make the output, expand the shape by one pixel in all directions and swap its color with the color of the background.\n\ndef main(input_grid):\n    # Find connected components (the colored shape)\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4)\n    assert len(components) == 1  # There should be exactly one colored shape\n    shape = components[0]\n    \n    # Get the color of the shape and the background color\n    shape_color = shape[shape != Color.BLACK][0]  # The color of the shape\n    background_color = Color.BLACK  # The background is black\n    \n    # Create an output grid initialized to the background color\n    output_grid = np.full(input_grid.shape, background_color)\n    \n    # Get the bounding box of the shape\n    x, y, width, height = bounding_box(shape)\n    \n    # Draw the expanded shape on the output grid\n    for dx in range(-1, width + 1):\n        for dy in range(-1, height + 1):\n            target_x = x + dx\n            target_y = y + dy\n            if 0 \u003c= target_x \u003c output_grid.shape[0] and 0 \u003c= target_y \u003c output_grid.shape[1]:\n                output_grid[target_x, target_y] = shape_color\n    \n    # Swap the shape color with the background color\n    output_grid[output_grid == shape_color] = background_color\n    output_grid[output_grid == background_color] = shape_color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 12x12 black grid\n    grid_size = 12\n    input_grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Create a random colored shape (sprite) with a size of 3x3 to 5x5\n    shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape = random_sprite(shape_height, shape_width, color_palette=[shape_color], density=1.0)\n\n    # Find a random position to place the shape in the center of the grid\n    start_x = (grid_size - shape_height) // 2\n    start_y = (grid_size - shape_width) // 2\n    blit_sprite(input_grid, shape, x=start_x, y=start_y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/19/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/19/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/19/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/19/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/19/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/19/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/19/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/19/images/train_output_2.png"}]}, "index": 19, "seeds": ["ea786f4a", "1cf80156", "623ea044", "6d58a25d"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, rotation, color changing\n\n# description:\n# In the input, you will see a grid with a single yellow object. \n# To create the output, you should rotate the object 90 degrees clockwise and change its color to blue.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the yellow object (it\u0027s the only one)\n    # 2. Change its color to blue\n    # 3. Rotate it 90 degrees clockwise\n\n    # Get the single yellow object\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1\n    yellow_object = objects[0]\n\n    # Make a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change its color to blue\n    yellow_object[yellow_object != Color.BLACK] = Color.BLUE\n\n    # Rotate it 90 degrees clockwise\n    rotated_object = np.rot90(yellow_object, k=-1)  # k=-1 for clockwise rotation\n\n    # Blit the rotated object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=rotated_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_len = np.random.randint(4, 8)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Randomly generate the yellow object and place it on the grid.\n    sprite_width, sprite_height = np.random.randint(1, grid_len - 1), np.random.randint(1, grid_len - 1)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.YELLOW], density=0.5)\n    \n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/20/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/20/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/20/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/20/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/20/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/20/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/20/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/20/images/train_output_2.png"}]}, "index": 20, "seeds": ["a79310a0", "31aa019c", "137eaa0f", "a8c38be5"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, reversing pattern\n\n# description:\n# In the input, you will see a grid where the top row contains a sequence of colored pixels followed by a grey line.\n# To create the output, count the number of pixels of each color in the top row, and then fill the output grid\n# such that the colors are arranged in a single column in reverse order, starting from the bottom of the column.\n# The number of colored pixels in the output corresponds to the number of pixels of each color in the input.\n\ndef main(input_grid):\n    # Count the occurrences of each color in the top row\n    color_counts = {}\n    for color in input_grid[0]:\n        if color != Color.GREY:  # Skip the grey line\n            if color in color_counts:\n                color_counts[color] += 1\n            else:\n                color_counts[color] = 1\n\n    # Prepare the output grid initialized to background color\n    output_height = sum(color_counts.values())\n    output_grid = np.zeros((output_height, 1), dtype=int)\n\n    # Fill the output grid in reverse order\n    current_row = output_height - 1\n    for color, count in reversed(color_counts.items()):\n        output_grid[current_row - count + 1:current_row + 1, 0] = color\n        current_row -= count\n\n    return output_grid\n\ndef generate_input():\n    # Randomly decide how many colors to use in the top row\n    num_colors = np.random.randint(2, 6)\n\n    # Select unique colors for the sequence\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    # Create a grid that will fit the colors along the top row, a grey line below it, and at least one empty row below\n    n = 2  # Two rows\n    m = num_colors + 1  # One extra column for grey line\n    grid = np.zeros((n, m), dtype=int)\n\n    # Put the colors in the top row\n    grid[0, :num_colors] = colors\n\n    # Add a grey line in the second row\n    grid[1, :] = Color.GREY\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/21/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/21/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/21/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/21/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/21/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/21/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/21/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/21/images/train_output_2.png"}]}, "index": 21, "seeds": ["bd4472b8", "1fad071e", "ff28f65a", "8e1813be"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color transformation\n\n# description:\n# In the input, you will see a grid filled with colored pixels, where some pixels are orange or yellow.\n# To make the output:\n# 1. For each orange pixel, replace the pixel with a pink pixel and add blue pixels in its immediate diagonals (northeast, northwest, southeast, southwest).\n# 2. For each yellow pixel, replace the pixel with a pink pixel and add green pixels in its immediate neighbors (up, down, left, right).\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.ORANGE:\n                output_grid[x, y] = Color.PINK\n                # Place blue pixels in the diagonals\n                for dx in [-1, 1]:\n                    for dy in [-1, 1]:\n                        if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                            output_grid[x + dx, y + dy] = Color.BLUE\n            elif color == Color.YELLOW:\n                output_grid[x, y] = Color.PINK\n                # Place green pixels in the neighbors\n                for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                    if 0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]:\n                        output_grid[x + dx, y + dy] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place some orange and yellow pixels\n    num_orange = np.random.randint(1, 5)\n    num_yellow = np.random.randint(1, 5)\n    num_other = np.random.randint(5, 20)  # Other colors to fill the grid\n\n    for _ in range(num_orange):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.ORANGE\n    \n    for _ in range(num_yellow):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.YELLOW\n\n    for _ in range(num_other):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color not in [Color.ORANGE, Color.YELLOW]])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/22/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/22/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/22/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/22/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/22/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/22/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/22/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/22/images/train_output_2.png"}]}, "index": 22, "seeds": ["0ca9ddb6", "1fad071e", "0962bcdd", "f15e1fac"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, color replacement\n\n# description:\n# In the input grid, you will find a pattern of colored pixels surrounded by a border of black pixels. \n# The colors of the pixels in the pattern can be any of the available colors. \n# To create the output grid, replace the pixels of the pattern with a new color provided along with the input grid. \n# The new color will be the second parameter in the input grid\u0027s metadata.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Determine the new color from the metadata (the last entry of the grid)\n    new_color = input_grid[-1, -1]  # Assumes this is the color to replace the pattern\n\n    # Create an output grid which is a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Replace the colored pixels in the grid with the new color\n    # We assume the pattern is surrounded by black pixels\n    for x in range(input_grid.shape[0] - 1):  # Exclude last row for metadata\n        for y in range(input_grid.shape[1] - 1):  # Exclude last column for metadata\n            if input_grid[x, y] != Color.BLACK:  # Check if the pixel is part of the pattern\n                output_grid[x, y] = new_color  # Replace with the new color\n\n    return output_grid[:-1, :-1]  # Remove the metadata row and column\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a grid size randomly between 5x5 and 8x8\n    n = np.random.randint(5, 9)\n    m = np.random.randint(5, 9)\n    grid = np.zeros((n + 1, m + 1), dtype=int)  # +1 for the metadata row and column\n\n    # Randomly select a color for the pattern\n    pattern_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a pattern of random size in the grid\n    pattern_height = np.random.randint(1, n - 1)\n    pattern_width = np.random.randint(1, m - 1)\n\n    # Fill the pattern area with the selected pattern color\n    for i in range(pattern_height):\n        for j in range(pattern_width):\n            if np.random.rand() \u003c 0.5:  # Randomly decide to fill or leave black\n                grid[i, j] = pattern_color\n\n    # Set a black border around the pattern\n    for i in range(n + 1):\n        grid[i, 0] = Color.BLACK\n        grid[i, m] = Color.BLACK\n    for j in range(m + 1):\n        grid[0, j] = Color.BLACK\n        grid[n, j] = Color.BLACK\n\n    # Set the metadata at the bottom right corner with the new color\n    new_color = np.random.choice(list(Color.NOT_BLACK))\n    grid[n, m] = new_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/23/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/23/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/23/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/23/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/23/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/23/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/23/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/23/images/train_output_2.png"}]}, "index": 23, "seeds": ["bc1d5164", "3de23699", "6cdd2623", "a9f96cdd"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color change\n\n# description:\n# In the input you will see a colored shape on a black background.\n# To make the output, rotate the shape 90 degrees clockwise and change its color to orange.\n\ndef main(input_grid):\n    # Get the bounding box of the input shape\n    x, y, width, height = bounding_box(grid=input_grid)\n    \n    # Extract the shape from the input grid\n    shape = input_grid[x:x + width, y:y + height]\n    \n    # Rotate the shape 90 degrees clockwise\n    rotated_shape = np.rot90(shape, k=-1)  # k=-1 for 90 degrees clockwise\n    \n    # Make an output grid initialized to black\n    output_grid = np.zeros_like(input_grid)\n\n    # Replace the area of the output grid with the rotated shape and change its color to orange\n    output_shape = np.where(rotated_shape != Color.BLACK, Color.ORANGE, rotated_shape)\n    \n    # Calculate the position to place the rotated shape back into the output grid\n    output_grid[x:x + rotated_shape.shape[0], y:y + rotated_shape.shape[1]] = output_shape\n\n    return output_grid\n\ndef generate_input():\n    # Create a medium sized grid\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random colored shape with a specific color\n    shape_color = np.random.choice(list(Color.NOT_BLACK))\n    shape_sprite = random_sprite(np.random.randint(3, n-2), np.random.randint(3, m-2), density=0.5, color_palette=[shape_color])\n    \n    # Choose a random position to place the shape\n    x, y = random_free_location_for_sprite(grid, shape_sprite)\n    blit_sprite(grid, shape_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/24/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/24/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/24/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/24/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/24/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/24/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/24/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/24/images/train_output_2.png"}]}, "index": 24, "seeds": ["6f8cd79b", "d4a91cb9", "3345333e", "6d75e8bb"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color transformation\n\n# description:\n# In the input, you will see a grid with different colored shapes. Each shape is made up of colored pixels.\n# To create the output, rotate each shape 90 degrees clockwise and change their color according to this mapping:\n# red -\u003e blue, green -\u003e red, blue -\u003e green.\n\ndef main(input_grid):\n    # Initialize the output grid based on the input shape\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Define the color transformation mapping\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.RED,\n        Color.BLUE: Color.GREEN\n    }\n\n    # Get the shape of the input grid\n    rows, cols = input_grid.shape\n\n    # Rotate and transform colors\n    for x in range(rows):\n        for y in range(cols):\n            color = input_grid[x][y]\n            if color in color_map:\n                # Calculate new position after 90 degrees clockwise rotation\n                new_x = y\n                new_y = rows - 1 - x\n                output_grid[new_x, new_y] = color_map[color]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random colors with shapes\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate a few distinct shapes of different colors\n    num_shapes = np.random.randint(1, 5)\n    for _ in range(num_shapes):\n        w = np.random.randint(1, 5)\n        h = np.random.randint(1, 5)\n        sprite = random_sprite(w, h, density=0.5, color_palette=[Color.RED, Color.GREEN, Color.BLUE])\n\n        # Find a random location to place the sprite in the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/25/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/25/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/25/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/25/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/25/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/25/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/25/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/25/images/train_output_2.png"}]}, "index": 25, "seeds": ["0d3d703e", "1caeab9d", "0ca9ddb6", "44f52bb0"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color swapping, object manipulation\n\n# description:\n# In the input, you will see two distinct objects: a green object and a yellow object. \n# The yellow object will be surrounded by black pixels, while the green object will be surrounded by white pixels.\n# To make the output, swap the colors of the two objects such that the green object becomes yellow and the yellow object becomes green.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components for monochromatic objects\n    components = find_connected_components(input_grid, monochromatic=True)\n\n    # Initialize variables to hold the positions of the objects\n    green_object = None\n    yellow_object = None\n\n    # Identify the green and yellow objects\n    for component in components:\n        if np.any(component == Color.GREEN):\n            green_object = component\n        elif np.any(component == Color.YELLOW):\n            yellow_object = component\n\n    if green_object is not None:\n        # Swap the color of the green object to yellow\n        output_grid[green_object == Color.GREEN] = Color.YELLOW\n\n    if yellow_object is not None:\n        # Swap the color of the yellow object to green\n        output_grid[yellow_object == Color.YELLOW] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a green object\n    green_object = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[Color.GREEN])\n    \n    # Create a yellow object\n    yellow_object = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[Color.YELLOW])\n\n    # Place the green object in a random location\n    green_x, green_y = random_free_location_for_sprite(grid, green_object)\n    blit_sprite(grid, green_object, x=green_x, y=green_y)\n\n    # Place the yellow object in a different random location\n    yellow_x, yellow_y = random_free_location_for_sprite(grid, yellow_object)\n    blit_sprite(grid, yellow_object, x=yellow_x, y=yellow_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/26/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/26/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/26/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/26/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/26/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/26/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/26/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/26/images/train_output_2.png"}]}, "index": 26, "seeds": ["aabf363d", "0ca9ddb6", "3befdf3e", "0e206a2e"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object rotation, color mapping\n\n# description:\n# In the input, you will see a 3x3 pattern square of colors except for black.\n# To make the output, you should rotate the pattern square 90 degrees clockwise and then \n# map the colors of the rotated pattern to a new set of colors according to a given mapping.\n\ndef main(input_grid):\n    # Detect the 3x3 pattern square (assuming there is exactly one)\n    pattern_objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n    \n    # Extract the 3x3 pattern square\n    pattern = crop(pattern_objects[0], background=Color.BLACK)\n\n    # Rotate the pattern square 90 degrees clockwise\n    rotated_pattern = np.rot90(pattern, k=-1)\n\n    # Define the color mapping\n    color_mapping = {\n        Color.BLUE: Color.GREEN,\n        Color.RED: Color.YELLOW,\n        Color.GREEN: Color.RED,\n        Color.YELLOW: Color.BLUE,\n        Color.ORANGE: Color.PINK,\n        Color.PINK: Color.ORANGE,\n        Color.TEAL: Color.MAROON,\n        Color.MAROON: Color.TEAL,\n    }\n\n    # Create output grid by mapping colors from rotated pattern\n    output_grid = np.zeros_like(input_grid)\n    \n    for i in range(rotated_pattern.shape[0]):\n        for j in range(rotated_pattern.shape[1]):\n            original_color = rotated_pattern[i, j]\n            # Map color if it\u0027s in the mapping dictionary, otherwise keep it the same\n            new_color = color_mapping.get(original_color, original_color)\n            output_grid[i, j] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random pattern square of size 3x3\n    pattern = random_sprite(n=3, m=3, density=1.0, color_palette=Color.NOT_BLACK)\n\n    # Randomly place the 3x3 pattern in the grid\n    x, y = random_free_location_for_sprite(grid, pattern)\n    grid = blit_sprite(grid, pattern, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/27/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/27/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/27/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/27/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/27/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/27/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/27/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/27/images/train_output_2.png"}]}, "index": 27, "seeds": ["6b9890af", "6fa7a44f", "ff28f65a", "e9614598"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color transformation\n\n# description:\n# In the input, you will see a grid containing a central pattern surrounded by a frame of pixels that have the same color.\n# The inner pattern consists of pixels of various colors. \n# To make the output grid, you should:\n# 1. Extract the central pattern.\n# 2. Change all the colors in the central pattern to match the color of the surrounding frame.\n# 3. Return the modified central pattern as the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Crop the central pattern out by removing the surrounding border\n    output_grid = crop(input_grid, background=Color.BLACK)\n\n    # Get the border color from the original input grid\n    border_color = input_grid[0, 0]  # Assuming uniform border color\n\n    # Change the color of the central pattern to match the border color\n    output_grid[output_grid != Color.BLACK] = border_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the central pattern\n    n, m = random.randint(3, 10), random.randint(3, 10)\n\n    # Select a color for the border\n    border_color = random.choice(Color.NOT_BLACK)\n\n    # Generate a random central pattern with various colors\n    pattern_colors = random.sample(Color.NOT_BLACK, k=random.randint(1, 5))\n    pattern = random_sprite(n, m, color_palette=pattern_colors, density=0.5)\n\n    # Create a grid with a border of the border color around the central pattern\n    enlarged_pattern = np.zeros((n + 2, m + 2), dtype=int)\n\n    # Set the border pixels to the border color\n    enlarged_pattern[0, :] = border_color\n    enlarged_pattern[-1, :] = border_color\n    enlarged_pattern[:, 0] = border_color\n    enlarged_pattern[:, -1] = border_color\n\n    # Place the central pattern in the middle of the border\n    enlarged_pattern[1:-1, 1:-1] = pattern\n\n    return enlarged_pattern", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/28/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/28/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/28/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/28/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/28/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/28/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/28/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/28/images/train_output_2.png"}]}, "index": 28, "seeds": ["3de23699", "bc1d5164", "a9f96cdd", "995c5fa3"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping and pixel shifting\n\n# description:\n# The input is a grid where each column is of the same color. \n# To make the output, each color will shift downwards by one cell, and if there is a black pixel below a color pixel, \n# that color pixel will wrap around to the top of the same column.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the number of rows and columns\n    rows, cols = input_grid.shape\n\n    # Shift colors downwards\n    for col in range(cols):\n        for row in range(rows):\n            current_color = input_grid[row, col]\n            if current_color != Color.BLACK:\n                new_row = (row + 1) % rows  # wrap around to the top if we go below the last row\n                output_grid[new_row, col] = current_color\n                output_grid[row, col] = Color.BLACK  # clear the original position\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random height and fixed width with black background\n    n = np.random.randint(5, 15)  # height\n    m = np.random.randint(3, 10)   # width\n    grid = np.full((n, m), Color.BLACK)  # fill the grid with black pixels\n\n    # Randomly fill each column with a single color from the palette (avoiding black)\n    for col in range(m):\n        color = np.random.choice(list(Color.NOT_BLACK))  # choose a random color excluding black\n        grid[:, col] = color  # fill the entire column with this color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/29/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/29/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/29/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/29/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/29/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/29/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/29/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/29/images/train_output_2.png"}]}, "index": 29, "seeds": ["0d3d703e", "00d62c1b", "0ca9ddb6", "f15e1fac"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines, color mapping, grid transformation\n\n# description:\n# In the input you will see a grid with several colored pixels, where each colored pixel will dictate the direction of a diagonal line drawn from that pixel.\n# The colors map to diagonal directions as follows:\n# - Red pixels draw a diagonal line to the top-right corner (northeast)\n# - Blue pixels draw a diagonal line to the top-left corner (northwest)\n# - Green pixels draw a diagonal line to the bottom-left corner (southwest)\n# - Yellow pixels draw a diagonal line to the bottom-right corner (southeast)\n# The lines should extend until they either hit the edge of the grid or overlap with another color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.RED:\n                draw_line(output_grid, x, y, direction=(1, 1), color=Color.RED)  # top-right\n            elif color == Color.BLUE:\n                draw_line(output_grid, x, y, direction=(1, -1), color=Color.BLUE)  # top-left\n            elif color == Color.GREEN:\n                draw_line(output_grid, x, y, direction=(-1, -1), color=Color.GREEN)  # bottom-left\n            elif color == Color.YELLOW:\n                draw_line(output_grid, x, y, direction=(-1, 1), color=Color.YELLOW)  # bottom-right\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels\n    num_pixels = np.random.randint(5, 15)  # total number of colored pixels\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        # Randomly assign color (excluding black)\n        color = np.random.choice([Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW])\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/30/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/30/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/30/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/30/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/30/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/30/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/30/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/30/images/train_output_2.png"}]}, "index": 30, "seeds": ["0ca9ddb6", "ea786f4a", "8d510a79", "d9f24cd1"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation\n\n# description:\n# In the input, you will see several objects of different colors on a black background.\n# To create the output grid, flip the colors of each object: \n# - Change red to green\n# - Change green to blue\n# - Change blue to red\n# - Leave all other colors unchanged\n\ndef main(input_grid):\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the connected components in the input grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Define the color mapping\n    color_map = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.RED\n    }\n\n    # Flip the colors based on the defined mapping\n    for obj in objects:\n        for color, new_color in color_map.items():\n            if np.any(obj == color):\n                output_grid[obj == color] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black background grid of size 12x12\n    n, m = 12, 12\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the number of objects to create\n    num_objects = np.random.randint(3, 6)\n\n    for _ in range(num_objects):\n        # Randomly generate dimensions for the new object\n        w, h = np.random.randint(2, 5), np.random.randint(2, 5)\n        # Create a random color for the object, choosing from red, green, or blue\n        color_palette = [Color.RED, Color.GREEN, Color.BLUE]\n        color = np.random.choice(color_palette)\n        \n        # Create a sprite (object) with the chosen color\n        sprite = random_sprite(w, h, color_palette=[color])\n\n        # Find a random free location to place the sprite\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/31/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/31/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/31/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/31/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/31/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/31/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/31/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/31/images/train_output_2.png"}]}, "index": 31, "seeds": ["46f33fce", "1cf80156", "264363fd_Kevin", "6e82a1ae"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, cropping, color matching\n\n# description:\n# In the input you will see a grid with a specific colored square surrounded by a border of another color. \n# The task is to extract the inner colored square and change its color to match the border color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid to produce the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the input grid\n    components = find_connected_components(output_grid, monochromatic=False, connectivity=4)\n\n    # We assume there is only one border and one inner square based on the description\n    border_color = None\n    inner_square = None\n\n    for component in components:\n        # Crop the component to analyze its contents\n        cropped_component = crop(component)\n\n        # If the component has a color that is not black, we assume it\u0027s the inner square\n        if np.any(cropped_component != Color.BLACK):\n            inner_square = cropped_component\n        elif border_color is None:  # Assume the first color found is the border color\n            border_color = component[0, 0]\n\n    # Ensure we have both parts\n    if inner_square is not None and border_color is not None:\n        # Change the color of the inner square to match the border color\n        inner_square[:] = border_color\n\n    # Return the modified inner square\n    return inner_square\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size n x m\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select colors for the border and inner square\n    border_color = np.random.choice(Color.NOT_BLACK)\n    inner_color = np.random.choice([c for c in Color.NOT_BLACK if c != border_color])\n\n    # Create the border (1 pixel thick)\n    grid[0, :] = border_color\n    grid[-1, :] = border_color\n    grid[:, 0] = border_color\n    grid[:, -1] = border_color\n\n    # Create the inner square in the center\n    inner_size = np.random.randint(1, min(n, m) - 2)  # Ensure there\u0027s a border\n    start_x, start_y = (n - inner_size) // 2, (m - inner_size) // 2\n    grid[start_x:start_x + inner_size, start_y:start_y + inner_size] = inner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/32/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/32/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/32/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/32/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/32/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/32/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/32/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/32/images/train_output_2.png"}]}, "index": 32, "seeds": ["3de23699", "6b9890af", "5daaa586", "bc1d5164"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, color, symmetry\n\n# description:\n# In the input, you will see a blue pixel and a red pixel. \n# To create the output, draw a diagonal yellow line from the blue pixel to the red pixel, \n# and then draw a green line that is symmetric to the yellow line about the vertical line that passes through the midpoint of the blue and red pixels.\n\ndef main(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # find the blue and red pixels\n    blue_pixel = np.where(input_grid == Color.BLUE)\n    red_pixel = np.where(input_grid == Color.RED)\n\n    # extract coordinates of blue and red pixels\n    blue_x, blue_y = blue_pixel[0][0], blue_pixel[1][0]\n    red_x, red_y = red_pixel[0][0], red_pixel[1][0]\n\n    # draw yellow diagonal line from blue to red\n    draw_line(output_grid, blue_x, blue_y, end_x=red_x, end_y=red_y, color=Color.YELLOW)\n\n    # calculate the midpoint for symmetry\n    mid_x = (blue_x + red_x) // 2\n    mid_y = (blue_y + red_y) // 2\n\n    # calculate the direction for the green line (symmetric)\n    # The slope of the yellow line is (red_y - blue_y) / (red_x - blue_x)\n    # The symmetric line will have the same vertical distance but in the opposite horizontal direction\n    if blue_x != red_x:  # prevent division by zero\n        slope = (red_y - blue_y) / (red_x - blue_x)\n        # Calculate the new endpoints by mirroring across the midpoint\n        new_red_y = mid_y + (mid_y - blue_y)\n        new_blue_y = mid_y - (red_y - mid_y)\n        \n        # Draw the green symmetric line\n        draw_line(output_grid, mid_x, new_red_y, end_x=mid_x, end_y=new_blue_y, color=Color.GREEN)\n\n    return output_grid\n\ndef generate_input():\n    # create a black grid for the background\n    n = np.random.randint(6, 15)\n    m = np.random.randint(6, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # select a random position for the blue pixel\n    blue_x = np.random.randint(0, n)\n    blue_y = np.random.randint(0, m)\n    grid[blue_x, blue_y] = Color.BLUE\n\n    # select a random position for the red pixel\n    red_x = np.random.randint(0, n)\n    red_y = np.random.randint(0, m)\n    grid[red_x, red_y] = Color.RED\n\n    # ensure blue and red are not in the same row or column\n    while blue_x == red_x or blue_y == red_y:\n        red_x = np.random.randint(0, n)\n        red_y = np.random.randint(0, m)\n        grid[red_x, red_y] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/33/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/33/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/33/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/33/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/33/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/33/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/33/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/33/images/train_output_2.png"}]}, "index": 33, "seeds": ["d4a91cb9", "23581191", "8d510a79", "623ea044"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, rotation, grid manipulation\n\n# description:\n# In the input you will see a grid with a repeated pattern. For each repetition of the pattern,\n# rotate it 90 degrees clockwise in the output grid. The output grid will maintain the size of the input grid.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n    \n    # Calculate the number of pattern repetitions (assuming square patterns)\n    pattern_size = 3  # Size of the repeated pattern (3x3)\n    output_grid = np.full((n, m), Color.BLACK)  # Initialize output grid with black\n\n    # Process the input grid in blocks of pattern_size x pattern_size\n    for i in range(0, n, pattern_size):\n        for j in range(0, m, pattern_size):\n            # Extract the pattern block\n            pattern_block = input_grid[i:i + pattern_size, j:j + pattern_size]\n            \n            # Rotate the pattern block 90 degrees clockwise\n            rotated_block = np.rot90(pattern_block, k=-1)  # k=-1 for clockwise rotation\n            \n            # Place the rotated block in the output grid\n            output_grid[i:i + pattern_size, j:j + pattern_size] = rotated_block\n\n    return output_grid\n\ndef generate_input():\n    # Make a random grid size\n    n = np.random.randint(6, 12)  # Total rows\n    m = np.random.randint(6, 12)  # Total columns\n    \n    # Ensure that the dimensions are multiples of the pattern size\n    n = (n // 3) * 3\n    m = (m // 3) * 3\n    \n    # Create a grid to fill with patterns\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Generate a repeated pattern\n    pattern = random_sprite(n=3, m=3, density=0.5, color_palette=Color.NOT_BLACK)\n    \n    # Fill the grid with the repeated pattern\n    for i in range(0, n, 3):\n        for j in range(0, m, 3):\n            blit_sprite(grid, pattern, x=i, y=j)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/34/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/34/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/34/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/34/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/34/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/34/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/34/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/34/images/train_output_2.png"}]}, "index": 34, "seeds": ["6fa7a44f", "bc1d5164", "6b9890af", "44f52bb0"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirroring, color assignment\n\n# description:\n# In the input, you will see a colored pattern on the left half of the grid, with a color pixel in the top right corner. \n# To create the output, mirror the left half of the grid to the right half and color it with the color of the pixel in the top right corner.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the width and height of the input grid\n    height, width = input_grid.shape\n    \n    # Create an output grid with the same size\n    output_grid = np.copy(input_grid)\n\n    # Get the color from the top right corner pixel\n    color_to_use = input_grid[0, width - 1]\n\n    # Mirror the left half to the right half\n    for y in range(height):\n        for x in range(width // 2):\n            output_grid[y, width - 1 - x] = input_grid[y, x]\n\n    # Color the mirrored pixels with the color from the top right corner\n    for y in range(height):\n        for x in range(width // 2, width):\n            output_grid[y, x] = color_to_use\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly define the size of the grid\n    height = np.random.randint(3, 6)\n    width = np.random.randint(6, 10)\n\n    # Create a grid\n    grid = np.zeros((height, width), dtype=int)\n\n    # Randomly select a color for the left half patterns\n    left_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Fill the left half of the grid with the selected color, leaving the right half initially blank\n    for y in range(height):\n        for x in range(width // 2):\n            grid[y, x] = np.random.choice([left_color, Color.BLACK])\n\n    # Select a color for the top right corner pixel\n    color_for_corner = np.random.choice(list(Color.NOT_BLACK))\n    grid[0, width - 1] = color_for_corner\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/35/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/35/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/35/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/35/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/35/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/35/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/35/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/35/images/train_output_2.png"}]}, "index": 35, "seeds": ["bc1d5164", "3de23699", "a9f96cdd", "bd4472b8"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color tracing, symmetry\n\n# description:\n# In the input, you will see a grid containing a pattern of colored pixels with a symmetric arrangement.\n# The pattern must be traced and mirrored across both the vertical and horizontal axes. \n# To make the output, create a grid that includes the original pattern and its mirrored counterpart at the \n# corresponding positions, maintaining symmetry.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Create the output grid, initially filled with black\n    output_grid = np.full((n * 2, m * 2), Color.BLACK)\n\n    # Fill the output grid with the original pattern\n    output_grid[0:n, 0:m] = input_grid\n\n    # Mirror the pattern across the vertical axis\n    output_grid[0:n, m:m * 2] = np.flip(input_grid, axis=1)\n\n    # Mirror the pattern across the horizontal axis\n    output_grid[n:n * 2, 0:m] = np.flip(input_grid, axis=0)\n\n    # Mirror the pattern across both the vertical and horizontal axes\n    output_grid[n:n * 2, m:m * 2] = np.flip(np.flip(input_grid, axis=0), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random sized grid with a black background\n    n = np.random.randint(3, 6)\n    m = np.random.randint(3, 6)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random pattern density\n    density = np.random.uniform(0.3, 0.7)\n\n    # Generate a random pattern\n    colors = np.random.choice(list(Color.NOT_BLACK), size=int(n * m * density), replace=True)\n    for color in colors:\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/36/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/36/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/36/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/36/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/36/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/36/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/36/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/36/images/train_output_2.png"}]}, "index": 36, "seeds": ["bc1d5164", "a9f96cdd", "3de23699", "995c5fa3"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, color averaging\n\n# description:\n# In the input, you will see a grid consisting of various 2x2 colored squares. \n# To create the output grid, replace each 2x2 colored square with a single pixel of the \n# average color of the square. The average color is computed by averaging the RGB values \n# of the colors in the square, but since we\u0027re limited to the defined colors, round \n# the average to the nearest defined color.\n\ndef color_average(colors):\n    # Function to compute the average color and round to the nearest defined color\n    color_map = {\n        Color.RED: [255, 0, 0],\n        Color.GREEN: [0, 255, 0],\n        Color.BLUE: [0, 0, 255],\n        Color.YELLOW: [255, 255, 0],\n        Color.PINK: [255, 192, 203],\n        Color.ORANGE: [255, 165, 0],\n        Color.TEAL: [0, 128, 128],\n        Color.GRAY: [128, 128, 128],\n        Color.MAROON: [128, 0, 0],\n        Color.BLACK: [0, 0, 0]\n    }\n    \n    r, g, b = 0, 0, 0\n    for color in colors:\n        r += color_map[color][0]\n        g += color_map[color][1]\n        b += color_map[color][2]\n    \n    avg_color = [r // len(colors), g // len(colors), b // len(colors)]\n    \n    # Find the closest defined color\n    closest_color = min(color_map.keys(), key=lambda c: (color_map[c][0] - avg_color[0])**2 + \n                                                              (color_map[c][1] - avg_color[1])**2 + \n                                                              (color_map[c][2] - avg_color[2])**2)\n    \n    return closest_color\n\ndef main(input_grid):\n    # Get input grid shape\n    n, m = input_grid.shape\n\n    # Prepare output grid\n    output_grid = np.zeros((n // 2, m // 2), dtype=int)\n\n    # Loop through the input grid in steps of 2\n    for x in range(0, n, 2):\n        for y in range(0, m, 2):\n            # Extract the 2x2 block\n            block = input_grid[x:x + 2, y:y + 2]\n            # Compute the average color of the block\n            avg_color = color_average(block.flatten())\n            # Place the average color in the output grid\n            output_grid[x // 2, y // 2] = avg_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random 2x2 squares of colors\n    n, m = 20, 20\n    grid = np.zeros((n, m), dtype=int)\n\n    # The number of 2x2 squares to place\n    square_count = 10\n\n    # Place 2x2 squares randomly\n    for _ in range(square_count):\n        color = np.random.choice(Color.NOT_BLACK)\n        x = np.random.randint(0, n - 1, dtype=int) // 2 * 2\n        y = np.random.randint(0, m - 1, dtype=int) // 2 * 2\n        \n        # Blit the 2x2 square\n        square = np.full((2, 2), color)\n        grid = blit_sprite(grid=grid, sprite=square, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/37/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/37/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/37/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/37/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/37/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/37/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/37/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/37/images/train_output_2.png"}]}, "index": 37, "seeds": ["6cf79266", "a9f96cdd", "25d8a9c8", "995c5fa3"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color blending\n\n# description:\n# In the input, you will see a grid with several colored objects. Each object is a single connected component of color. \n# To create the output grid, you should find all objects and blend their colors together to create a new color. \n# If the blended color is unique in the grid, change the object color to that blended color; otherwise, change it to black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find all connected components (objects) in the grid.\n    # 2. For each object, blend its color and determine if it\u0027s unique.\n    # 3. Update the color of the object based on the blending.\n\n    output_grid = np.zeros_like(input_grid)\n\n    # 1. Find all objects\n    objects = find_connected_components(input_grid, background=Color.BLACK)\n\n    # 2. For each object, blend its color\n    for obj in objects:\n        # Get the unique color of the object (assuming monochromatic)\n        unique_colors = np.unique(obj)\n        unique_colors = unique_colors[unique_colors != Color.BLACK]  # Exclude background\n\n        # Blend the colors - simple average for this example\n        if len(unique_colors) \u003e 0:\n            blended_color = np.mean(unique_colors)\n            blended_color = blended_color.astype(int)\n\n            # Check if this blended color is unique in the input grid\n            if np.count_nonzero(input_grid == blended_color) == 1:\n                # If unique, assign the blended color to the object in the output grid\n                output_grid[obj != Color.BLACK] = blended_color\n            else:\n                # If not unique, turn the object black\n                output_grid[obj != Color.BLACK] = Color.BLACK\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black background grid of size n x m\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate various colored objects\n    colors = list(Color.NOT_BLACK)  # All possible colors except black\n    num_objects = np.random.randint(3, 6)  # Number of objects to create\n\n    for _ in range(num_objects):\n        # Generate a random object and place it on the grid\n        sprite_width, sprite_height = np.random.randint(1, 4), np.random.randint(1, 4)\n        sprite_color = np.random.choice(colors)\n\n        # Create the random sprite\n        sprite = random_sprite(n=sprite_height, m=sprite_width, color_palette=[sprite_color], density=1.0)\n\n        # Find a random free location for the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass  # If no space is available, skip this object creation\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/38/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/38/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/38/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/38/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/38/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/38/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/38/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/38/images/train_output_2.png"}]}, "index": 38, "seeds": ["aedd82e4", "31aa019c", "a79310a0", "6e82a1ae"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, pattern duplication\n\n# description:\n# In the input you will see a grid with a colored object that forms a pattern (e.g., a shape made of colored pixels).\n# To make the output grid, you should rotate the entire grid by 180 degrees, effectively flipping it upside down and reversing its left and right sides.\n\ndef main(input_grid):\n    # Rotate the grid by 180 degrees\n    output_grid = np.flipud(np.fliplr(input_grid))\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n = np.random.randint(4, 8)\n    m = np.random.randint(4, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random pattern in the grid\n    density = 0.3  # Percentage of the grid that will be filled with colors\n    sprite = random_sprite(n=n, m=m, density=density, color_palette=Color.NOT_BLACK)\n    \n    # Blit the randomly generated sprite onto the grid at a random position\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/39/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/39/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/39/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/39/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/39/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/39/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/39/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/39/images/train_output_2.png"}]}, "index": 39, "seeds": ["a79310a0", "6fa7a44f", "a8c38be5", "1f642eb9"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean logical operations, grid partition, overlay\n\n# description:\n# Compute the AND operation of where the two grids are green, turning the output red in those locations. \n# In the input, you should see two 8x7 green patterns on top and bottom separated by a horizontal yellow line in the middle of the grid. \n# To make the output, you have to overlap the two patterns. If the overlapping cells are the same color, then the corresponding cell is colored red; \n# otherwise, if the overlapping cells are not the same color, then the corresponding cell is colored black.\n\ndef main(input_grid):\n    height, width = input_grid.shape\n    \n    # Find the horizontal yellow separator\n    for y_bar in range(height):\n        if np.all(input_grid[y_bar, :] == Color.YELLOW):\n            break\n\n    # Extract the top and bottom patterns\n    top_pattern = input_grid[:y_bar, :]\n    bottom_pattern = input_grid[y_bar + 1:, :]\n\n    # Initialize output grid\n    output_grid = np.zeros_like(top_pattern)\n\n    # Apply the AND operation\n    output_grid[(top_pattern == Color.GREEN) \u0026 (bottom_pattern == Color.GREEN)] = Color.RED\n    output_grid[(top_pattern != bottom_pattern)] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    # Define grid size\n    width = 8  \n    height = 15  # 7 top + 1 yellow line + 7 bottom\n\n    # Initialize an empty grid\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Randomly assign green or black to the top and bottom patterns\n    for x in range(width):\n        for y in range(7):\n            input_grid[y, x] = np.random.choice([Color.BLACK, Color.GREEN])\n            input_grid[y + 8, x] = np.random.choice([Color.BLACK, Color.GREEN])\n\n    # Set the yellow horizontal line\n    input_grid[7, :] = Color.YELLOW\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/40/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/40/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/40/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/40/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/40/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/40/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/40/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/40/images/train_output_2.png"}]}, "index": 40, "seeds": ["3428a4f5", "ff28f65a", "7447852a", "00d62c1b"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color guide, layering, grid transformation\n\n# description:\n# In the input, you will see a colored object in the center and a colored border around it, with a black background.\n# To make the output, change the color of the border to match the color of the object in the center.\n\ndef main(input_grid):\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the object in the center\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    center_color = output_grid[center_x, center_y]\n\n    # Change the color of the border (the outermost layer) to the center color\n    # Define the border area\n    border_color_change = [\n        (0, slice(0, -1)),  # Top border\n        (-1, slice(0, -1)),  # Bottom border\n        (slice(1, -1), 0),  # Left border\n        (slice(1, -1), -1)  # Right border\n    ]\n    \n    for idx in border_color_change:\n        if isinstance(idx[0], int):  # Row-based border\n            output_grid[idx[0], idx[1]] = center_color\n        else:  # Column-based border\n            output_grid[idx[0], idx[1]] = center_color\n\n    return output_grid\n\ndef generate_input():\n    # Make a black grid for the background\n    n, m = 7, 7  # Fixed size for simplicity\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the center object\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Create the center object in the grid\n    grid[n//2, m//2] = center_color\n    \n    # Set the border color (should be different than center)\n    border_color = np.random.choice([color for color in Color.NOT_BLACK if color != center_color])\n    \n    # Set the border pixels around the center\n    # Top border\n    grid[0, 1:-1] = border_color\n    # Bottom border\n    grid[-1, 1:-1] = border_color\n    # Left border\n    grid[1:-1, 0] = border_color\n    # Right border\n    grid[1:-1, -1] = border_color\n\n    # Return the generated grid\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/41/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/41/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/41/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/41/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/41/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/41/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/41/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/41/images/train_output_2.png"}]}, "index": 41, "seeds": ["aabf363d", "0e206a2e", "623ea044", "264363fd_Kevin"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color filling\n\n# description:\n# In the input, you will see a grid with colored shapes on a black background. \n# To create the output grid, you should fill each detected shape with a specific color depending on its size:\n# - Shapes with an area of 1 pixel should be filled with blue\n# - Shapes with an area of 2 pixels should be filled with green\n# - Shapes with an area of 3 pixels should be filled with yellow\n# - Shapes with an area greater than 3 pixels should be filled with red\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a blank output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect all colored shapes in the input grid\n    shapes = detect_objects(grid=input_grid, colors=Color.NOT_BLACK, monochromatic=False, connectivity=8)\n\n    # Color mapping based on area\n    color_mapping = {\n        1: Color.BLUE,\n        2: Color.GREEN,\n        3: Color.YELLOW\n    }\n\n    # Fill the shapes in the output grid based on their sizes\n    for shape in shapes:\n        area = np.sum(shape != Color.BLACK)  # Count the number of pixels in the shape\n        fill_color = color_mapping.get(area, Color.RED)  # Default to red for shapes larger than 3 pixels\n\n        # Fill the shape in the output grid\n        for x, y in np.argwhere(shape != Color.BLACK):\n            output_grid[x, y] = fill_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize a 10x10 black grid\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create shapes with varying sizes\n    for _ in range(np.random.randint(3, 6)):  # Create 3 to 5 shapes\n        # Randomly determine the size of the shape (1 to 5 pixels)\n        shape_size = np.random.randint(1, 6)\n        \n        # Randomly select a position for the shape\n        x_start = np.random.randint(0, n)\n        y_start = np.random.randint(0, m)\n\n        # Draw the shape in a random way\n        for _ in range(shape_size):\n            x_offset = np.random.choice([-1, 0, 1])\n            y_offset = np.random.choice([-1, 0, 1])\n            x, y = x_start + x_offset, y_start + y_offset\n            \n            if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m and grid[x, y] == Color.BLACK:\n                grid[x, y] = Color.RED  # Fill the shape with red color (can be any color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/42/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/42/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/42/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/42/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/42/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/42/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/42/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/42/images/train_output_2.png"}]}, "index": 42, "seeds": ["6cdd2623", "31aa019c", "0d3d703e", "1f642eb9"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, shape formation, grid manipulation\n\n# description:\n# In the input, you will see a 3x3 blue square and a 3x3 red square.\n# To create the output grid, you should form a new shape by placing a yellow triangle \n# that occupies the same space as the intersection of the blue and red squares.\n\ndef main(input_grid):\n    # Detect the blue and red squares.\n    blue_square = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    red_square = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n\n    # Initialize the output grid as a copy of the input grid.\n    output_grid = np.copy(input_grid)\n\n    # Assuming there\u0027s exactly one blue and one red square, we can find their positions.\n    blue_x, blue_y = object_position(blue_square[0], background=Color.BLACK, anchor=\u0027upper left\u0027)\n    red_x, red_y = object_position(red_square[0], background=Color.BLACK, anchor=\u0027upper left\u0027)\n\n    # Calculate the intersection area of the two squares.\n    intersection_x1 = max(blue_x, red_x)\n    intersection_y1 = max(blue_y, red_y)\n    intersection_x2 = min(blue_x + 3, red_x + 3)  # Both are 3x3 squares\n    intersection_y2 = min(blue_y + 3, red_y + 3)\n\n    # Create a yellow triangle pattern to fill the intersection\n    yellow_triangle = np.zeros((3, 3), dtype=int)\n    yellow_triangle[0, :] = Color.YELLOW  # Fill the top row\n    yellow_triangle[1, :2] = Color.YELLOW  # Fill the left two of the second row\n    yellow_triangle[2, :1] = Color.YELLOW  # Fill the leftmost of the last row\n\n    # Calculate position to place the triangle in the output grid\n    triangle_x = intersection_x1\n    triangle_y = intersection_y1\n\n    # Blit the yellow triangle onto the output grid in the intersection\n    blit_sprite(output_grid, yellow_triangle, x=triangle_x, y=triangle_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid of size 10x10.\n    n, m = 10, 10\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a 3x3 blue square and place it randomly on the grid\n    blue_square = np.full((3, 3), Color.BLUE)\n    blue_x, blue_y = random_free_location_for_sprite(grid, blue_square, background=Color.BLACK)\n    blit_sprite(grid, blue_square, blue_x, blue_y)\n\n    # Create a 3x3 red square and place it ensuring it touches the blue square\n    red_square = np.full((3, 3), Color.RED)\n\n    # Ensure it is placed such that it intersects with the blue square\n    # Randomly determine the overlap position\n    overlap_x = np.random.randint(blue_x, blue_x + 3)\n    overlap_y = np.random.randint(blue_y, blue_y + 3)\n\n    # Calculate new position for the red square to ensure it overlaps\n    red_x = overlap_x if overlap_x + 3 \u003c= n else overlap_x - 3\n    red_y = overlap_y if overlap_y + 3 \u003c= m else overlap_y - 3\n\n    # Blit the red square onto the grid\n    blit_sprite(grid, red_square, red_x, red_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/43/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/43/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/43/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/43/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/43/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/43/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/43/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/43/images/train_output_2.png"}]}, "index": 43, "seeds": ["05f2a901", "ff28f65a", "e9614598", "1fad071e"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, symmetry, reflection\n\n# description:\n# In the input, you will see a symmetric pattern with colored and black pixels.\n# To make the output, invert the colors of the pixels (black becomes colored, colored becomes black) \n# and then reflect the pattern across the vertical axis.\n\ndef main(input_grid):\n    # Step 1: Invert the colors of the input grid\n    inverted_grid = np.copy(input_grid)\n    inverted_grid[inverted_grid == Color.BLACK] = Color.RED  # Change black to a color (Red used as an example)\n    inverted_grid[inverted_grid != Color.RED] = Color.BLACK  # Change all colored pixels to black\n\n    # Step 2: Reflect the inverted grid across the vertical axis\n    output_grid = inverted_grid[:, ::-1]\n\n    return output_grid\n\ndef generate_input():\n    # Create a random symmetric pattern with colors and black pixels\n    n = m = np.random.randint(3, 6)  # Randomly chosen size for the grid\n    grid = random_sprite(n, m, density=0.5, symmetry=\"vertical\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/44/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/44/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/44/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/44/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/44/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/44/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/44/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/44/images/train_output_2.png"}]}, "index": 44, "seeds": ["6fa7a44f", "0dfd9992", "3e980e27", "f9012d9b"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, filling, vertical alignment\n\n# description:\n# In the input, you will see a row with colored pixels followed by a pink line.\n# To create the output grid, copy the first two rows of the input. \n# Then, starting just below the pink line, fill in the grid by drawing vertical columns of colors corresponding to each pixel in the top row.\n# Each column should alternate between the colors in the top row until the grid is filled.\n# Repeat this pattern down to the bottom of the grid.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the colors from the top row\n    colors = input_grid[0, :]\n    num_colors = len(colors)\n\n    # Get the y-coordinate of the pink line\n    pink_line_y = np.where(input_grid[1] == Color.PINK)[0][0]\n\n    # Fill the output grid below the pink line\n    for col in range(num_colors):\n        for row in range(pink_line_y + 1, output_grid.shape[0]):\n            output_grid[row, col] = colors[col]\n\n    return output_grid\n\ndef generate_input():\n    # Decide how many colors to use (between 3 and 6)\n    num_colors = np.random.randint(3, 7)\n\n    # Select colors for the sequence\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    # Create a grid with 2 rows for the colors and a pink line\n    # The height of the grid will be 2 + a random height for the colored area\n    height = np.random.randint(5, 10)\n    grid = np.zeros((height + 2, num_colors), dtype=int)\n\n    # Fill the top row with selected colors\n    grid[0, :] = colors\n\n    # Fill the second row with a pink line\n    grid[1, :] = Color.PINK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/45/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/45/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/45/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/45/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/45/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/45/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/45/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/45/images/train_output_2.png"}]}, "index": 45, "seeds": ["bd4472b8", "bbc9ae5d", "bc1d5164", "d9f24cd1"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, grid masking, pixel filtering\n\n# description:\n# In the input grid, there are random colored pixels and a specific border color that creates a frame.\n# To produce the output, extract all pixels that are the same color as the border and replace the rest with black pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)  # Start with a black grid\n\n    # Identify the border color\n    border_color = None\n    # Check the first row and first column for the border color\n    for color in input_grid[0, :]:\n        if color != Color.BLACK:\n            border_color = color\n            break\n        \n    if border_color is None:\n        for color in input_grid[:, 0]:\n            if color != Color.BLACK:\n                border_color = color\n                break\n    \n    # Extract pixels that match the border color\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] == border_color:\n                output_grid[x, y] = border_color  # Keep the border color\n            else:\n                output_grid[x, y] = Color.BLACK  # Replace with black\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    grid_size = 20\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly choose a border color\n    border_color = np.random.choice(Color.NOT_BLACK)\n\n    # Draw the border color around the grid\n    grid[0, :] = border_color  # Top border\n    grid[-1, :] = border_color  # Bottom border\n    grid[:, 0] = border_color  # Left border\n    grid[:, -1] = border_color  # Right border\n\n    # Fill the inner area with random colors\n    for x in range(1, grid_size - 1):\n        for y in range(1, grid_size - 1):\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/46/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/46/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/46/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/46/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/46/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/46/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/46/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/46/images/train_output_2.png"}]}, "index": 46, "seeds": ["06df4c85", "941d9a10", "5daaa586", "6cf79266"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# adjacency, color transformation, pixel manipulation\n\n# description:\n# In the input, you will see a grid filled with 2x2 colored squares and some mixed-color noise pixels. \n# The goal is to transform the grid such that all colored squares are turned green, \n# noise pixels adjacent to any square turn into a lighter shade of their color, \n# and noise pixels not adjacent to any squares are removed (turned black).\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all colored squares (2x2 blocks).\n    # 2. Change the color of each square to green.\n    # 3. For each noise pixel, check if it is adjacent to any colored square.\n    # 4. If adjacent, change the noise pixel to a lighter shade of the adjacent square\u0027s color.\n    # 5. If not adjacent to any square, turn the noise pixel black.\n\n    output_grid = np.copy(input_grid)\n\n    # Step 1: Identify colored squares\n    squares = []\n    rows, cols = input_grid.shape\n\n    for r in range(rows - 1):\n        for c in range(cols - 1):\n            if (input_grid[r, c] != Color.BLACK and \n                input_grid[r, c] == input_grid[r + 1, c] == input_grid[r, c + 1] == input_grid[r + 1, c + 1]):\n                # Found a colored square\n                squares.append((r, c, input_grid[r, c]))  # (row, col, color)\n                # Change square color to green\n                output_grid[r:r + 2, c:c + 2] = Color.GREEN\n\n    # Step 3: Check noise pixels\n    for r in range(rows):\n        for c in range(cols):\n            if output_grid[r, c] == Color.BLACK and input_grid[r, c] != Color.BLACK:\n                # It\u0027s a noise pixel\n                adjacent_to_square = False\n                for dr in [-1, 0, 1]:\n                    for dc in [-1, 0, 1]:\n                        if (0 \u003c= r + dr \u003c rows and 0 \u003c= c + dc \u003c cols and \n                            input_grid[r + dr, c + dc] != Color.BLACK and\n                            input_grid[r + dr, c + dc] != Color.GREEN):\n                            adjacent_to_square = True\n                            # Change noise pixel to lighter color\n                            output_grid[r, c] = lighten_color(input_grid[r + dr, c + dc])\n                            break\n                    if adjacent_to_square:\n                        break\n                if not adjacent_to_square:\n                    # Not adjacent to any square, so remains black\n                    output_grid[r, c] = Color.BLACK\n\n    return output_grid\n\n\ndef lighten_color(color):\n    # Lighter shade of a color can be achieved by mixing it with white\n    if color == Color.RED:\n        return Color.PINK\n    elif color == Color.GREEN:\n        return Color.BLUE  # Assuming there\u0027s a light green color in the Color class\n    elif color == Color.BLUE:\n        return Color.YELLOW\n    elif color == Color.YELLOW:\n        return Color.TEAL  # Assuming there\u0027s a light yellow color in the Color class\n    elif color == Color.ORANGE:\n        return Color.GRAY  # Assuming there\u0027s a light orange color in the Color class\n    elif color == Color.MAROON:\n        return Color.ORANGE  # Assuming there\u0027s a orange color in the Color class\n    return color  # Default fallback\n\ndef generate_input():\n    # Plan:\n    # 1. Create a grid with a black background.\n    # 2. Randomly place a few colored squares (2x2 blocks).\n    # 3. Randomly sprinkle some noise pixels around.\n\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create colored squares\n    colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(3, 6), replace=False)\n    for color in colors:\n        for _ in range(np.random.randint(1, 4)):\n            x, y = np.random.randint(0, width - 1), np.random.randint(0, height - 1)\n            if grid[x, y] == Color.BLACK and grid[x + 1, y] == Color.BLACK and grid[x, y + 1] == Color.BLACK and grid[x + 1, y + 1] == Color.BLACK:\n                grid[x:x + 2, y:y + 2] = color\n\n    # Add noise pixels\n    for _ in range(np.random.randint(5, 15)):\n        x, y = np.random.randint(width), np.random.randint(height)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/47/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/47/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/47/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/47/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/47/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/47/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/47/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/47/images/train_output_2.png"}]}, "index": 47, "seeds": ["7e0986d6", "7f4411dc", "2c608aff", "264363fd_Kevin"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# radial symmetry, color transformation\n\n# description:\n# In the input grid, you will see several circles of the same color centered at different points. The goal is to transform the grid by looking at each circle and filling in its surrounding area with a new color based on its distance from the center. If the distance from the center is less than or equal to 2, fill it with a new color (e.g., yellow); if the distance is greater than 2 but less than or equal to 4, fill it with another color (e.g., orange). Areas further than 4 units from the center remain unchanged.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components in the grid (the circles)\n    circles = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n\n    for circle in circles:\n        # Find the bounding box of the circle\n        x, y, w, h = bounding_box(circle)\n\n        # Get the center of the circle\n        center_x = x + w // 2\n        center_y = y + h // 2\n\n        # Iterate through the area surrounding the center point\n        for i in range(max(0, center_x - 5), min(output_grid.shape[0], center_x + 5)):\n            for j in range(max(0, center_y - 5), min(output_grid.shape[1], center_y + 5)):\n                # Calculate the distance from the center\n                distance = np.sqrt((i - center_x) ** 2 + (j - center_y) ** 2)\n\n                # Fill the output grid based on the distance\n                if distance \u003c= 2:\n                    output_grid[i, j] = Color.YELLOW\n                elif distance \u003c= 4:\n                    output_grid[i, j] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    grid = np.full((20, 20), Color.BLACK)\n\n    # Choose a color for the circles\n    circle_color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly generate a number of circles\n    for _ in range(np.random.randint(3, 6)):\n        # Define a random radius for the circle\n        radius = np.random.randint(1, 3)\n\n        # Choose a random center point ensuring circles fit within the grid\n        center_x = np.random.randint(radius, 20 - radius)\n        center_y = np.random.randint(radius, 20 - radius)\n\n        # Draw the circle on the grid\n        for x in range(center_x - radius, center_x + radius + 1):\n            for y in range(center_y - radius, center_y + radius + 1):\n                if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                    grid[x, y] = circle_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/48/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/48/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/48/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/48/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/48/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/48/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/48/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/48/images/train_output_2.png"}]}, "index": 48, "seeds": ["6e19193c", "8d510a79", "941d9a10", "6d58a25d"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid expansion, color mapping\n\n# description:\n# The input is a grid where each square is of the same color. \n# To make the output, double the size of the grid and change each color according to the following mapping:\n# red -\u003e blue, green -\u003e yellow, blue -\u003e red, yellow -\u003e green.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = np.full((input_grid.shape[0] * 2, input_grid.shape[1] * 2), Color.BLACK)\n\n    # Create color mapping\n    color_map = {\n        Color.RED: Color.BLUE,\n        Color.GREEN: Color.YELLOW,\n        Color.BLUE: Color.RED,\n        Color.YELLOW: Color.GREEN\n    }\n\n    # Fill the output grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x, y]\n            mapped_color = color_map.get(color, color)\n            output_grid[x*2:(x*2)+2, y*2:(y*2)+2] = mapped_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random colors\n    n = np.random.randint(1, 6)  # Random height\n    m = np.random.randint(1, 6)  # Random width\n    grid = np.zeros((n, m), dtype=int)\n\n    # Fill the grid with random colors from the allowable set\n    color_choices = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]\n    for x in range(n):\n        for y in range(m):\n            grid[x, y] = np.random.choice(color_choices)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4_desc/49/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4_desc/49/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4_desc/49/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4_desc/49/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/49/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4_desc/49/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4_desc/49/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4_desc/49/images/train_output_2.png"}]}, "index": 49, "seeds": ["0d3d703e", "0ca9ddb6", "1fad071e", "00d62c1b"], "source": "barc_gpt4_desc", "source_description": "Examples generated by GPT-4o with descriptive prompting", "source_display_name": "BARC GPT-4", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel expansion, growth\n\n# description:\n# In the input, you will see a small colored shape surrounded by a non-black background. \n# To create the output, expand the shape outward by one pixel in all directions, \n# filling the newly created spaces with the original color of the shape.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color.\n    # 2. Find the connected components in the grid.\n    # 3. Identify the colored shape and expand its boundaries by one pixel.\n\n    # Identify the background color (the most common color)\n    background_color = np.bincount(input_grid.flatten()).argmax()\n\n    # Get the connected components\n    components = find_connected_components(input_grid, background=background_color, connectivity=8)\n    \n    # The colored shape should be the largest component\n    colored_shape = max(components, key=lambda obj: np.sum(obj != background_color))\n\n    # Prepare the output grid\n    output_grid = np.full(input_grid.shape, fill_value=background_color)\n\n    # Get the coordinates of the colored shape\n    shape_coords = np.argwhere(colored_shape != background_color)\n\n    # Expand the shape by one pixel in all directions\n    for x, y in shape_coords:\n        # Fill the neighboring pixels with the shape\u0027s color\n        for dx in [-1, 0, 1]:\n            for dy in [-1, 0, 1]:\n                if dx == 0 and dy == 0:\n                    continue  # Skip the center pixel\n                new_x, new_y = x + dx, y + dy\n                # Ensure we\u0027re within bounds\n                if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                    output_grid[new_x, new_y] = colored_shape[x, y]\n    \n    # Place the original shape back into the output grid\n    output_grid[shape_coords[:, 0], shape_coords[:, 1]] = colored_shape[shape_coords[:, 0], shape_coords[:, 1]]\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Randomly select a color for the shape and background.\n    # 2. Create a grid filled with the background color.\n    # 3. Randomly generate a small shape and place it in the grid.\n\n    background_color = np.random.choice(Color.NOT_BLACK)\n    shape_color = np.random.choice([color for color in Color.NOT_BLACK if color != background_color])\n    \n    # Create a random grid size\n    width, height = np.random.randint(5, 15, size=2)\n    input_grid = np.full((width, height), fill_value=background_color)\n\n    # Generate a small shape (between 2x2 and 4x4)\n    shape_width, shape_height = np.random.randint(2, 5, size=2)\n    shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=1)\n\n    # Randomly place the shape in the grid\n    x, y = random_free_location_for_sprite(input_grid, shape_sprite, background=background_color, padding=1)\n    blit_sprite(input_grid, shape_sprite, x, y, background=background_color)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/0/images/train_output_2.png"}]}, "index": 0, "seeds": ["2c608aff", "623ea044", "ea786f4a", "264363fd_Kevin"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color expansion, shape transformation\n\n# description:\n# In the input, you will see a colored shape on a black background. To make the output, expand the shape by one pixel in all directions, ensuring that the new pixels take on the same color as the original shape.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color (black)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find connected components in the input grid\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Iterate through each component found\n    for component in components:\n        # Get the bounding box of the current component\n        x, y, width, height = bounding_box(component)\n\n        # Get the color of the current component\n        color = component[x, y]\n\n        # Expand the shape by drawing a border of the same color around it\n        for i in range(-1, width + 1):\n            for j in range(-1, height + 1):\n                if (0 \u003c= x + i \u003c output_grid.shape[0]) and (0 \u003c= y + j \u003c output_grid.shape[1]):\n                    output_grid[x + i, y + j] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid (background)\n    n, m = np.random.randint(5, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly create a colored shape (sprite) in the grid\n    shape_color = np.random.choice(list(Color.NOT_BLACK))\n    shape_width, shape_height = np.random.randint(1, n//2), np.random.randint(1, m//2)\n\n    # Generate a random shape and place it in the grid\n    shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=0.5)\n    shape_x, shape_y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK)\n    blit_sprite(grid, shape_sprite, x=shape_x, y=shape_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/1/images/train_output_2.png"}]}, "index": 1, "seeds": ["623ea044", "2c608aff", "ea786f4a", "aabf363d"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, transparency\n\n# description:\n# In the input, you will see several layers of colored rectangles on a red background. Each rectangle has a certain level of transparency.\n# To make the output, layer the rectangles according to their transparency level, creating a composite image where the colors blend based on their transparency.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify each colored rectangle and its transparency level.\n    # 2. Create a new output grid initialized to red (Color.RED).\n    # 3. For each rectangle, layer it onto the output grid using its transparency level.\n    \n    # Initialize the output grid to red (Color.RED)\n    output_grid = np.full(input_grid.shape, Color.RED)\n    \n    # Find connected components to locate rectangles\n    rectangles = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=Color.RED)\n\n    for rectangle in rectangles:\n        # Calculate the color and transparency level of the rectangle\n        color = np.argmax(np.bincount(rectangle[rectangle != Color.RED]))\n        \n        # Calculate the transparency level based on the number of pixels\n        transparency = np.sum(rectangle != Color.RED) / rectangle.size \n        \n        # Blend the rectangle onto the output grid based on its transparency\n        for x, y in np.argwhere(rectangle != Color.RED):\n            # Get the original color at the output grid position\n            original_color = output_grid[x, y]\n            blended_color = blend_colors(original_color, color, transparency)\n            output_grid[x, y] = blended_color\n    \n    return output_grid\n\ndef blend_colors(color1, color2, alpha):\n    \"\"\"\n    Blend two colors based on the transparency level (alpha).\n    color1: base color (the one in the output grid)\n    color2: new color (rectangle color)\n    alpha: transparency level (0 to 1)\n    \"\"\"\n    if color1 == Color.RED:\n        return color2  # If the original color is red, just take the new color\n    \n    # Simple averaging for blending\n    return color2 if np.random.rand() \u003c alpha else color1\n\ndef generate_input():\n    # Plan:\n    # 1. Create a grid with a red background.\n    # 2. Randomly generate rectangles with varying transparency.\n    # 3. Ensure rectangles overlap and are placed randomly on the grid.\n\n    w, h = np.random.randint(10, 25, size=2)\n    grid = np.full((w, h), Color.RED)\n    \n    n_rectangles = np.random.randint(3, 5)\n    \n    for _ in range(n_rectangles):\n        # Generate random rectangle properties\n        rw, rh = np.random.randint(3, 8), np.random.randint(3, 8)\n        color = np.random.choice(Color.NOT_BLACK)\n        \n        # Create a rectangle\n        rectangle = np.full((rw, rh), color)\n        \n        # Random transparency level between 0.2 and 1.0 (0.2 means 20% opaque)\n        transparency = np.random.uniform(0.2, 1.0)\n        \n        # Use random position to place the rectangle, ensuring it fits within the grid\n        x, y = np.random.randint(0, w - rw), np.random.randint(0, h - rh)\n        blit_sprite(grid, rectangle, x, y, background=Color.RED)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/2/images/train_output_2.png"}]}, "index": 2, "seeds": ["7e0986d6", "2c608aff", "7f4411dc", "264363fd_Kevin"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, depth perception, transparency blending\n\n# description:\n# In the input, you will see multiple overlapping transparent shapes on a colored background.\n# To make the output grid, create a new layer for each shape and adjust their opacities based on their overlap,\n# giving the appearance of depth and layering in the output grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all shapes in the input grid\n    # 2. Create an output grid initialized to the background color\n    # 3. For each shape, compute its overlap with other shapes and adjust opacity\n    # 4. Blend shapes into the output grid based on adjusted opacities\n\n    # Determine the background color (most frequent color)\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    output_grid = np.full(input_grid.shape, background_color)\n\n    # Detect all connected components (shapes)\n    shapes = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # For each shape, determine its color and draw it with adjusted opacity\n    for shape in shapes:\n        # Get color of the shape (assuming it\u0027s a single color)\n        shape_color = shape[0, 0]\n\n        # Create a mask for the current shape\n        mask = (shape == shape_color)\n\n        # Calculate overlap with existing shapes in the output grid\n        overlap_count = np.sum(output_grid == shape_color)\n        if overlap_count \u003e 0:  # If there\u0027s overlap\n            # Adjust opacity (for simplicity, let\u0027s say each overlap reduces opacity)\n            opacity = max(0, 255 - (overlap_count * 50))  # Reduce by 50 for each overlap\n            blended_color = blend_colors(shape_color, background_color, opacity)\n            output_grid[mask] = blended_color\n        else:\n            output_grid[mask] = shape_color  # No overlap, use the original color\n\n    return output_grid\n\ndef blend_colors(color1, color2, opacity):\n    \"\"\"\n    Blend color1 with color2 based on opacity.\n    Opacity is a value from 0 (transparent) to 255 (opaque).\n    \"\"\"\n    return int((opacity * color1 + (255 - opacity) * color2) / 255)\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a random background.\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly assign a background color (not black)\n    background_color = random.choice(Color.NOT_BLACK)\n    grid[:, :] = background_color\n\n    # Create a random number of transparent shapes (2 to 5)\n    num_shapes = np.random.randint(2, 6)\n\n    for _ in range(num_shapes):\n        # Random size for the shape between 2x2 and 5x5\n        width, height = np.random.randint(2, 6), np.random.randint(2, 6)\n        shape_color = random.choice(Color.NOT_BLACK)  # Random color for the shape\n        shape = np.full((width, height), shape_color)\n\n        # Find a free location for the shape\n        x, y = random_free_location_for_sprite(grid, shape, background=background_color, border_size=1)\n        blit_sprite(grid, shape, x, y, background=background_color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/3/images/train_output_2.png"}]}, "index": 3, "seeds": ["1f642eb9", "1cf80156", "137eaa0f", "264363fd_Kevin"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contour tracing, area filling, shape recognition\n\n# description:\n# In the input you will see a black background with various colored shapes. \n# To create the output grid, trace the contours of each shape and fill the area inside \n# the contours with a single color that matches the color of the shape.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the background color (which is black)\n    # 2. Extract all colored shapes using connected components\n    # 3. For each shape, find its contour and fill the interior with the shape\u0027s color\n\n    output_grid = np.copy(input_grid)\n\n    # Assume the background is black\n    background = Color.BLACK\n\n    # Find connected components (shapes) in the grid\n    shapes = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=background)\n\n    for shape in shapes:\n        # Get the color of the shape (assumes monochromatic for each shape)\n        shape_color = np.unique(shape[shape != background])[0]\n\n        # Get the bounding box of the shape\n        x, y, w, h = bounding_box(shape, background=background)\n\n        # Create a filled shape of the same size as the bounding box\n        filled_shape = np.full((w, h), shape_color)\n\n        # Fill the area inside the contour with the shape\u0027s color\n        blit_object(output_grid, filled_shape, background=background)\n\n    return output_grid\n\ndef generate_input():\n    # Plan:\n    # 1. Create a grid filled with black\n    # 2. Randomly generate colored shapes of varying sizes and positions\n    # 3. Ensure that shapes don\u0027t overlap\n\n    n, m = np.random.randint(10, 20, size=2)  # dimensions of the grid\n    grid = np.full((n, m), Color.BLACK)\n\n    num_shapes = np.random.randint(3, 6)  # Number of shapes to generate\n\n    for _ in range(num_shapes):\n        # Random dimensions for the shape\n        shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        shape_color = np.random.choice(Color.NOT_BLACK)\n\n        # Create a random shape sprite\n        shape_sprite = random_sprite(shape_width, shape_height, color_palette=[shape_color], density=1)\n\n        # Find a random free location for this shape\n        x, y = random_free_location_for_sprite(grid, shape_sprite, background=Color.BLACK, padding=1, border_size=1)\n        blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/4/images/train_output_2.png"}]}, "index": 4, "seeds": ["2c608aff", "1f642eb9", "1cf80156", "941d9a10"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, symmetry, borders\n\n# description:\n# In the input you will see a grid with a central object that is a colored square (size 3x3) surrounded by a black border.\n# To create the output grid, you should reflect the colors of the central object to the four borders of the grid,\n# while keeping the original colors in the center and changing the central object\u0027s color to yellow. \n\ndef main(input_grid):\n    # The central object is assumed to be a 3x3 square.\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    central_object = input_grid[center_x-1:center_x+2, center_y-1:center_y+2]\n\n    # Change the central object color to yellow\n    output_grid = np.copy(input_grid)\n    output_grid[center_x-1:center_x+2, center_y-1:center_y+2] = Color.YELLOW\n\n    # Reflect the colors of the central object to the borders\n    for dx in range(3):\n        for dy in range(3):\n            color = central_object[dx, dy]\n            if color != Color.BLACK:  # Don\u0027t reflect black to the border\n                output_grid[dx, 0] = color  # Top border\n                output_grid[dx, -1] = color  # Bottom border\n                output_grid[0, dy] = color  # Left border\n                output_grid[-1, dy] = color  # Right border\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a black background\n    n, m = 7, 7\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random colored central object of size 3x3\n    colors = list(Color.NOT_BLACK)\n    central_color = np.random.choice(colors)\n    central_object = np.full((3, 3), central_color)\n\n    # Place the central object in the middle of the grid\n    grid[2:5, 2:5] = central_object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/5/images/train_output_2.png"}]}, "index": 5, "seeds": ["941d9a10", "1f642eb9", "41e4d17e", "a9f96cdd"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filling, adjacency, region growing\n\n# description:\n# The input grid consists of a background color and a special color (e.g., red). \n# The task is to identify all connected regions of the special color, and for each region, fill the entire area with a new color (e.g., yellow). \n# The regions are defined as contiguous groups of special color pixels connected either horizontally or vertically.\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    special_color = Color.RED\n    fill_color = Color.YELLOW\n\n    # Find all connected components of the special color\n    components = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # For each component, fill the area with fill_color\n    for component in components:\n        for x, y in np.argwhere(component):\n            output_grid[x, y] = fill_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of random size between 10x10 and 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the background color and scatter the special color (e.g., red)\n    background_color = Color.BLACK\n    special_color = Color.RED\n\n    # Randomly scatter the special color throughout the grid\n    density = 0.2  # 20% of the grid may be the special color\n    grid = random_scatter_points(grid=grid, color=special_color, density=density, background=background_color)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/6/images/train_output_2.png"}]}, "index": 6, "seeds": ["6cdd2623", "00d62c1b", "0ca9ddb6", "6d58a25d"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color separation, shape detection\n\n# description:\n# In the input you will see a grid with various colored shapes, some of which are composed of a specific color (red).\n# To create the output, you should identify connected regions of red pixels and change their color to green, while leaving all other pixels unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to modify\n    output_grid = np.copy(input_grid)\n    \n    # Get the shape of the grid\n    rows, cols = output_grid.shape\n    \n    # A function to perform a flood fill to change the color of connected red pixels to green\n    def flood_fill(x, y):\n        # Check if the current position is within bounds and is red\n        if x \u003c 0 or x \u003e= rows or y \u003c 0 or y \u003e= cols or output_grid[x, y] != Color.RED:\n            return\n        # Change the color to green\n        output_grid[x, y] = Color.GREEN\n        \n        # Recursively call flood_fill in all 4 directions\n        flood_fill(x + 1, y)  # down\n        flood_fill(x - 1, y)  # up\n        flood_fill(x, y + 1)  # right\n        flood_fill(x, y - 1)  # left\n\n    # Iterate through the grid to find connected regions of red pixels\n    for i in range(rows):\n        for j in range(cols):\n            if output_grid[i, j] == Color.RED:  # Found a new region of red\n                flood_fill(i, j)  # Change the color of this region to green\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter several colors in the grid\n    available_colors = [Color.BLACK, Color.BLUE, Color.GREEN, Color.YELLOW, Color.PINK, Color.ORANGE]\n    # Fill the grid with random colors (not red)\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.7:  # 70% chance of being a non-red color\n                grid[i, j] = np.random.choice(available_colors)\n    \n    # Randomly create connected regions of red pixels\n    for _ in range(np.random.randint(1, 5)):  # Create 1 to 4 red regions\n        # Create a random size for the red region\n        region_height = np.random.randint(2, 5)\n        region_width = np.random.randint(2, 5)\n        \n        # Get random start position\n        start_x = np.random.randint(0, n - region_height)\n        start_y = np.random.randint(0, m - region_width)\n\n        # Fill the selected area with red pixels\n        for i in range(region_height):\n            for j in range(region_width):\n                grid[start_x + i, start_y + j] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/7/images/train_output_2.png"}]}, "index": 7, "seeds": ["6cf79266", "3de23699", "5daaa586", "3eda0437"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# isolation, boundary detection, transformation\n\n# description:\n# In the input, you will see a grid with colored pixels scattered throughout. Among these colors, one color will be completely surrounded by black pixels with no direct path to the edge of the grid. \n# To make the output, convert all pixels of the surrounded color to a new color (e.g., green) and leave all other pixels unchanged. \n# If no color is surrounded, the output remains identical to the input.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Find the background color\n    background_color = Color.BLACK\n    \n    # Identify potential surrounded colors\n    unique_colors = set(np.unique(input_grid)) - {background_color}\n    surrounded_colors = []\n\n    for color in unique_colors:\n        # Find positions of the current color\n        positions = np.argwhere(input_grid == color)\n        \n        # Check if all positions are surrounded by the background\n        if all((0 \u003c x \u003c input_grid.shape[0] - 1 and 0 \u003c y \u003c input_grid.shape[1] - 1) for x, y in positions):\n            # Check all neighboring positions for background color\n            is_surrounded = True\n            for x, y in positions:\n                # Check 4-connectivity\n                if not (input_grid[x-1, y] == background_color and\n                        input_grid[x+1, y] == background_color and\n                        input_grid[x, y-1] == background_color and\n                        input_grid[x, y+1] == background_color):\n                    is_surrounded = False\n                    break\n            \n            if is_surrounded:\n                surrounded_colors.append(color)\n\n    # If we found a surrounded color, color it green\n    if surrounded_colors:\n        for color in surrounded_colors:\n            output_grid[output_grid == color] = Color.GREEN\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a black grid first as background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose colors for our grid\n    colors = random.sample(Color.NOT_BLACK, k=3)  # Pick 3 distinct colors\n\n    # Scatter colors on the grid, ensuring one color is surrounded\n    surrounded_color = colors[0]\n    non_surrounded_colors = colors[1:]\n\n    # Fill grid with non-surrounded colors\n    for color in non_surrounded_colors:\n        grid = random_scatter_points(grid, color, density=0.3)\n\n    # Place the surrounded color in a way that surrounds it with black\n    # Choose a random position in the grid that is not on an edge\n    while True:\n        pos_x = np.random.randint(1, n-1)\n        pos_y = np.random.randint(1, m-1)\n        \n        if grid[pos_x, pos_y] == Color.BLACK:  # Ensure it\u0027s a valid position\n            grid[pos_x, pos_y] = surrounded_color\n            break\n\n    # Create a surrounding barrier of black pixels\n    grid[pos_x-1, pos_y] = Color.BLACK\n    grid[pos_x+1, pos_y] = Color.BLACK\n    grid[pos_x, pos_y-1] = Color.BLACK\n    grid[pos_x, pos_y+1] = Color.BLACK\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/8/images/train_output_2.png"}]}, "index": 8, "seeds": ["31aa019c", "f15e1fac", "2c608aff", "6cdd2623"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color filling\n\n# description:\n# In the input, you will see a square pattern of colored pixels. \n# To create the output, rotate the pattern by 90 degrees clockwise, \n# and fill the empty spaces with a new color that corresponds to the original colors of the pattern.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the size of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid with the same dimensions as the input grid\n    output_grid = np.full((m, n), Color.BLACK)  # note: the output grid is transposed\n\n    # Fill the output grid by rotating the input grid 90 degrees clockwise\n    for i in range(n):\n        for j in range(m):\n            output_grid[j, n - 1 - i] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random size for the square pattern\n    size = np.random.randint(3, 7)\n    \n    # Create a square grid with a black background\n    grid = np.zeros((size, size), dtype=int)\n    \n    # Generate a random color palette excluding black\n    color_palette = np.random.choice(list(Color.NOT_BLACK), size=np.random.randint(1, 6), replace=False)\n    \n    # Randomly fill the grid with colors from the color palette\n    for i in range(size):\n        for j in range(size):\n            if np.random.rand() \u003c 0.8:  # 80% chance to fill a color\n                grid[i, j] = np.random.choice(color_palette)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/9/images/train_output_2.png"}]}, "index": 9, "seeds": ["6fa7a44f", "8e1813be", "bc1d5164", "3de23699"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, color preservation\n\n# description:\n# In the input, you will see a colored pattern that is rotated 90 degrees clockwise. \n# To create the output, rotate the pattern back to its original orientation (0 degrees), ensuring that the colors are preserved in their original positions.\n\ndef main(input_grid):\n    # Rotate the input grid 90 degrees counterclockwise to restore to original orientation\n    output_grid = np.rot90(input_grid, k=3)  # k=3 means 90 degrees counterclockwise\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    n = np.random.randint(4, 7)\n    m = np.random.randint(4, 7)\n\n    # Create a base grid with a black background\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random sprite pattern to be rotated\n    pattern_size = np.random.randint(2, min(n, m) // 2 + 1)\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create a random pattern in the center of the grid\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[i + (n - pattern_size) // 2, j + (m - pattern_size) // 2] = color\n\n    # Rotate the pattern 90 degrees clockwise for the input\n    input_grid = np.rot90(grid, k=1)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/10/images/train_output_2.png"}]}, "index": 10, "seeds": ["bc1d5164", "6fa7a44f", "3de23699", "995c5fa3"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connectivity, border detection\n\n# description:\n# In the input, you will see a colored irregular shape filled with one color on a black background. \n# To create the output, detect the border of the shape and color it with a contrasting color (e.g., blue) to emphasize the shape\u0027s outline.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the background color.\n    # 2. Find the connected component representing the shape.\n    # 3. Get the border of the shape.\n    # 4. Color the border with a contrasting color (blue).\n\n    background = np.bincount(input_grid.flatten()).argmax()\n    \n    # Find the shape (connected component)\n    shape_objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=background)\n    shape_object = max(shape_objects, key=lambda obj: np.sum(obj != background))\n    \n    # Create output grid and fill with the original input\n    output_grid = np.copy(input_grid)\n    \n    # Get the border of the shape\n    border_mask = object_neighbors(shape_object, background=background, connectivity=4)\n    \n    # Color the border with blue (Color.BLUE)\n    output_grid[border_mask] = Color.BLUE\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a black grid as the background.\n    # 2. Generate a random shape with a single color.\n    # 3. Ensure the shape doesn\u0027t fill the entire grid.\n\n    width, height = np.random.randint(7, 20, size=2)\n    input_grid = np.full((width, height), fill_value=Color.BLACK)\n\n    # Generate a random shape\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_sprite = random_sprite(np.random.randint(3, 8), np.random.randint(3, 8), color_palette=[shape_color], density=0.7)\n    \n    # Randomly place the shape on the grid\n    x, y = random_free_location_for_sprite(input_grid, shape_sprite, background=Color.BLACK)\n    blit_sprite(input_grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/11/images/train_output_2.png"}]}, "index": 11, "seeds": ["2c608aff", "623ea044", "1cf80156", "7e0986d6"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pixel replacement\n\n# description:\n# In the input, you will see a grid with a pattern that is symmetric along the vertical axis \n# but has a single pixel that breaks the symmetry. To make the output, \n# replace that pixel with the color of the pixel directly opposite it to restore symmetry.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the height and width of the input grid\n    height, width = input_grid.shape\n    \n    # We will check each row to find the pixel that breaks symmetry\n    for y in range(height):\n        left_color = input_grid[y, :width // 2]\n        right_color = input_grid[y, width // 2 + (width % 2):][::-1]\n        \n        # If the left side is not equal to the reflected right side\n        if not np.array_equal(left_color, right_color):\n            # Find the index of the breaking pixel\n            breaking_pixel_index = (width - 1) // 2\n            \n            # Replace the breaking pixel with the color of the corresponding symmetric pixel\n            input_grid[y, breaking_pixel_index] = input_grid[y, width - 1 - breaking_pixel_index]\n    \n    return input_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid size\n    n = np.random.randint(3, 7)\n    m = np.random.randint(3, 7)\n    \n    # Create a random grid\n    grid = random_sprite(n, m, density=0.5, color_palette=Color.NOT_BLACK)\n    \n    # Ensure the grid is symmetric along the vertical axis with one pixel breaking the symmetry\n    for y in range(n):\n        if y == n // 2:  # On the middle row, make an asymmetric pixel\n            grid[y, m // 2] = Color.BLACK  # Introducing a breaking pixel\n            grid[y, m // 2 + 1] = grid[y, m // 2 - 1]  # Mirroring the color to maintain symmetry\n        else:\n            grid[y, m // 2:] = grid[y, :m // 2][::-1]  # Mirror left side to right side\n            \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/12/images/train_output_2.png"}]}, "index": 12, "seeds": ["6fa7a44f", "44f52bb0", "bc1d5164", "3de23699"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pixel manipulation\n\n# description:\n# In the input, you will see a grid filled with colored pixels. To make the output, invert the colors in the grid. \n# The color inversion means that each color in the grid will be replaced by a corresponding color from a predefined mapping.\n# For example, if the mapping is:\n# Color.RED -\u003e Color.GREEN\n# Color.GREEN -\u003e Color.RED\n# Color.BLUE -\u003e Color.YELLOW\n# Color.YELLOW -\u003e Color.BLUE\n# Color.GREY -\u003e Color.PINK\n# Color.PINK -\u003e Color.GREY\n# Color.ORANGE -\u003e Color.MAROON\n# Color.MAROON -\u003e Color.ORANGE\n# Color.TEAL -\u003e Color.BLACK\n# Color.BLACK -\u003e Color.GRAY\n# The output will be the grid with all colors replaced according to this mapping.\n\ndef main(input_grid):\n    # Define the color mapping for inversion\n    color_mapping = {\n        Color.RED: Color.GREEN,\n        Color.GREEN: Color.RED,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE,\n        Color.GREY: Color.PINK,\n        Color.PINK: Color.GREY,\n        Color.ORANGE: Color.MAROON,\n        Color.MAROON: Color.ORANGE,\n        Color.TEAL: Color.BLACK,\n        Color.BLACK: Color.GRAY,\n        Color.GRAY: Color.BLACK  # Assuming we add a WHITE color in the mapping too\n    }\n\n    # Create a new output grid by inverting the colors\n    output_grid = np.copy(input_grid)\n    for original_color, inverted_color in color_mapping.items():\n        output_grid[input_grid == original_color] = inverted_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid of colors\n    n, m = 5, 5  # Define size of the grid\n    grid = np.random.choice(list(Color.NOT_BLACK), size=(n, m))  # Fill grid with random colors (not black)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/13/images/train_output_2.png"}]}, "index": 13, "seeds": ["44f52bb0", "6fa7a44f", "6d58a25d", "8d510a79"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid slicing, spiral rearrangement\n\n# description:\n# In the input, you will see a grid made up of a repeating pattern. To create the output, slice the grid into smaller sections based on the repeating pattern size and rearrange the sections in a spiral layout, keeping the colors intact.\n\ndef main(input_grid):\n    # Determine the size of the repeating pattern (assuming it\u0027s a square pattern)\n    pattern_height = input_grid.shape[0] // 3\n    pattern_width = input_grid.shape[1] // 3\n\n    # Create a list to hold the patterns\n    patterns = []\n\n    # Slice the grid into patterns\n    for i in range(3):\n        for j in range(3):\n            start_y = i * pattern_height\n            start_x = j * pattern_width\n            pattern = input_grid[start_y:start_y + pattern_height, start_x:start_x + pattern_width]\n            patterns.append(pattern)\n\n    # Create the output grid with appropriate size (larger than the input grid)\n    output_height = pattern_height * 3\n    output_width = pattern_width * 3\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Define the spiral order to fill the output grid\n    spiral_order = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2), (2, 1), (2, 0), (1, 0), (1, 1)]\n\n    # Place the patterns in the output grid according to the spiral order\n    for idx, (row, col) in enumerate(spiral_order):\n        pattern = patterns[idx]\n        blit_sprite(output_grid, pattern, row * pattern_height, col * pattern_width, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Randomly choose the size of the input grid ensuring it\u0027s a multiple of 3\n    height = np.random.randint(3, 10) * 3\n    width = np.random.randint(3, 10) * 3\n    grid = np.zeros((height, width), dtype=int)\n\n    # Fill the grid with a repeating pattern of random colors\n    colors = np.random.choice(list(Color.NOT_BLACK), size=9, replace=False)\n    for i in range(3):\n        for j in range(3):\n            start_y = i * (height // 3)\n            start_x = j * (width // 3)\n            color = colors[i * 3 + j]\n            sprite = np.full((height // 3, width // 3), color)\n            grid[start_y:start_y + (height // 3), start_x:start_x + (width // 3)] = sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/14/images/train_output_2.png"}]}, "index": 14, "seeds": ["8e1813be", "bc1d5164", "bd4472b8", "6fa7a44f"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, growth, branching\n\n# description:\n# In the input, you will see a single colored pixel on a black grid. \n# To make the output, grow branches from that pixel in four cardinal directions (up, down, left, right), \n# making each branch 3 pixels long and coloring them the same as the original pixel.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    colored_pixel_location = colored_pixel_locations[0]\n    pixel_x, pixel_y = colored_pixel_location\n\n    # Create a new output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the original pixel\n    color = output_grid[pixel_x, pixel_y]\n\n    # Draw branches in all four cardinal directions\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # down, up, right, left\n    for dx, dy in directions:\n        for length in range(1, 4):  # each branch is 3 pixels long\n            new_x = pixel_x + dx * length\n            new_y = pixel_y + dy * length\n            # Only draw if within bounds\n            if 0 \u003c= new_x \u003c input_grid.shape[0] and 0 \u003c= new_y \u003c input_grid.shape[1]:\n                output_grid[new_x, new_y] = color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Place a single colored pixel (not black) in a random position\n    color = np.random.choice(Color.NOT_BLACK)\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/15/images/train_output_2.png"}]}, "index": 15, "seeds": ["0962bcdd", "ea786f4a", "6cdd2623", "0ca9ddb6"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, replication, grid transformation\n\n# description:\n# In the input you will see a grid with a 5x5 colored pattern located in the center, surrounded by a uniform black background.\n# To make the output, detect the 5x5 pattern and replicate it to all four corners of the grid, maintaining the same orientation and color.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # 1. Detect the central 5x5 pattern\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    pattern = input_grid[center_x - 2:center_x + 3, center_y - 2:center_y + 3]\n\n    # 2. Create the output grid with the same dimensions as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # 3. Place the detected pattern in all four corners of the output grid\n    output_grid[0:5, 0:5] = pattern  # Top-left corner\n    output_grid[0:5, -5:] = pattern  # Top-right corner\n    output_grid[-5:, 0:5] = pattern  # Bottom-left corner\n    output_grid[-5:, -5:] = pattern  # Bottom-right corner\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a 5x5 pattern at the center of a larger grid\n    grid_size = 15  # Define the size of the grid\n    grid = np.zeros((grid_size, grid_size), dtype=int)  # Start with a black grid\n\n    # Define the center for the 5x5 pattern\n    center_x, center_y = grid_size // 2, grid_size // 2\n\n    # Randomly generate a 5x5 colored pattern\n    available_colors = list(Color.NOT_BLACK)\n    pattern_colors = np.random.choice(available_colors, size=(5, 5), replace=True)\n\n    # Place the 5x5 pattern in the center of the grid\n    grid[center_x - 2:center_x + 3, center_y - 2:center_y + 3] = pattern_colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/16/images/train_output_2.png"}]}, "index": 16, "seeds": ["3de23699", "bc1d5164", "6cf79266", "995c5fa3"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mirroring, grid reflection\n\n# description:\n# In the input, you will see a grid that contains randomly colored pixels. \n# To create the output grid, you should mirror the colors of the pixels along the vertical axis of the grid. \n# This means that each pixel on the left side of the grid should be reflected to the corresponding position on the right side, \n# while keeping the colors on the left unchanged and filling the right side accordingly.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n    \n    # Create an output grid initialized to the same size\n    output_grid = np.copy(input_grid)\n\n    # Iterate through each row and mirror the pixels across the vertical axis\n    for x in range(n):\n        for y in range(m // 2):\n            # The position to mirror to is (x, m - 1 - y)\n            output_grid[x, m - 1 - y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly assign colors to the pixels in the grid\n    available_colors = list(Color.NOT_BLACK)  # Exclude black\n    color_density = 0.5  # 50% of the grid can be colored\n\n    for i in range(n):\n        for j in range(m):\n            if np.random.random() \u003c color_density:  # Randomly decide whether to color the pixel\n                grid[i, j] = np.random.choice(available_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/17/images/train_output_2.png"}]}, "index": 17, "seeds": ["a9f96cdd", "6cf79266", "0b148d64", "3eda0437"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color quantization\n\n# description:\n# In the input, you will see several colored objects on a black background. \n# To create the output, detect all unique colors of the objects and quantize each color to the nearest primary color (red, blue, or yellow), \n# replacing the original colors in the output with their quantized versions.\n\ndef quantize_color(color):\n    \"\"\"Quantize the given color to the nearest primary color.\"\"\"\n    primary_colors = {\n        Color.RED: np.array([255, 0, 0]),\n        Color.BLUE: np.array([0, 0, 255]),\n        Color.YELLOW: np.array([255, 255, 0]),\n    }\n    \n    min_distance = float(\u0027inf\u0027)\n    nearest_color = Color.BLACK\n\n    for pc, rgb in primary_colors.items():\n        distance = np.linalg.norm(np.array(color) - rgb)\n        if distance \u003c min_distance:\n            min_distance = distance\n            nearest_color = pc\n            \n    return nearest_color\n\ndef main(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # get the objects in the input grid\n    objects = find_connected_components(input_grid)\n\n    # create a set to keep track of unique colors\n    unique_colors = set()\n\n    # collect unique colors from the objects\n    for obj in objects:\n        unique_colors.update(np.unique(obj[obj != Color.BLACK]))\n\n    # quantize each unique color and apply it to the output grid\n    color_mapping = {color: quantize_color(color) for color in unique_colors}\n\n    # replace original colors with quantized colors in the output grid\n    for original_color, quantized_color in color_mapping.items():\n        output_grid[output_grid == original_color] = quantized_color\n\n    return output_grid\n\ndef generate_input():\n    # make a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # make a random number of sprites\n    num_sprites = np.random.randint(3, 7)\n    for _ in range(num_sprites):\n        sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n        \n        # make sure the sprite has at least 1 colored pixel\n        while np.count_nonzero(sprite != Color.BLACK) \u003c 1:\n            sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/18/images/train_output_2.png"}]}, "index": 18, "seeds": ["6e82a1ae", "0e206a2e", "aabf363d", "31aa019c"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connectivity, boundary detection, color filling\n\n# description:\n# In the input, you will see a grid containing connected colored regions surrounded by a black background. \n# To produce the output grid, you need to identify the boundaries of each colored region and fill in the outer layer of black pixels surrounding these boundaries with a distinct color, say grey.\n\ndef main(input_grid):\n    # Create an output grid initialized to the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (colored regions)\n    components = find_connected_components(input_grid, background=Color.BLACK)\n\n    # For each component, find its boundary and fill surrounding black pixels with a new color\n    for component in components:\n        # Get the boundary of the current component\n        boundary_mask = object_boundary(component, background=Color.BLACK)\n\n        # Fill the outer layer of black pixels surrounding the boundary with grey\n        for x, y in np.argwhere(boundary_mask):\n            # Check the 8 connectivity around (x, y)\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    if (dx != 0 or dy != 0):  # Skip the center pixel\n                        nx, ny = x + dx, y + dy\n                        if 0 \u003c= nx \u003c output_grid.shape[0] and 0 \u003c= ny \u003c output_grid.shape[1]:\n                            if output_grid[nx, ny] == Color.BLACK:\n                                output_grid[nx, ny] = Color.GREY\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a random grid size between 10x10 and 20x20\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly determine the number of colored regions\n    num_regions = np.random.randint(1, 4)\n\n    for _ in range(num_regions):\n        # Generate a random sprite (colored region)\n        sprite_size = np.random.randint(3, 8)\n        sprite = random_sprite(sprite_size, sprite_size, color_palette=[np.random.choice(Color.NOT_BLACK)], connectivity=4)\n\n        # Find a free location for the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1)\n            blit_sprite(grid, sprite, x, y)\n        except:\n            continue  # Skip if no free location is available\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/19/images/train_output_2.png"}]}, "index": 19, "seeds": ["6cdd2623", "00d62c1b", "0ca9ddb6", "7447852a"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel clustering, color blending\n\n# description:\n# In the input, you will see a grid filled with colored pixels. To make the output, \n# identify clusters of adjacent pixels of the same color and blend them into a single pixel \n# of a new color that is the average of the colors in that cluster. The new color should \n# be displayed in the center of the cluster in the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Step 1: Find connected components in the grid\n    connected_components = find_connected_components(input_grid, monochromatic=True)\n    \n    # Step 2: Create an empty output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # Step 3: For each connected component, calculate the average color and place it in the output grid\n    for component in connected_components:\n        # Calculate the average color of the cluster\n        avg_color = np.mean(component[component != Color.BLACK])  # Avoid background color\n        \n        # Find the center of the cluster for placing the average color\n        coords = np.argwhere(component != Color.BLACK)\n        center_x, center_y = np.mean(coords, axis=0).astype(int)\n\n        # Place the averaged color in the output grid at the calculated center coordinate\n        output_grid[center_x, center_y] = avg_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid with clusters of colors\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter colored pixels across the grid\n    num_colors = np.random.randint(2, 6)\n    colors = random.sample(list(Color.NOT_BLACK), num_colors)\n\n    # Create several clusters of these colors\n    for color in colors:\n        # Randomly decide the number of clusters for this color\n        num_clusters = np.random.randint(1, 4)\n        \n        for _ in range(num_clusters):\n            # Randomly select a starting point in the grid\n            start_x, start_y = np.random.randint(0, n), np.random.randint(0, m)\n            # Randomly determine the size of the cluster\n            cluster_size = np.random.randint(2, 6)  # Size of the cluster\n\n            # Randomly create a cluster by drawing pixels of the same color\n            for _ in range(cluster_size):\n                # Randomly determine the position of the new pixel in the cluster\n                dx, dy = np.random.choice([-1, 0, 1]), np.random.choice([-1, 0, 1])\n                new_x, new_y = start_x + dx, start_y + dy\n                \n                # Check bounds and color placement\n                if 0 \u003c= new_x \u003c n and 0 \u003c= new_y \u003c m:\n                    grid[new_x, new_y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/20/images/train_output_2.png"}]}, "index": 20, "seeds": ["0e206a2e", "0ca9ddb6", "6cdd2623", "137eaa0f"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# contour detection, shape filling\n\n# description:\n# In the input, you will see a filled shape (a single color) on a black background.\n# To make the output, detect the contour of the shape and fill it with a new color while leaving the area outside the contour black.\n\ndef main(input_grid):\n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK, dtype=int)\n\n    # Find the contour of the filled shape\n    contours = object_neighbors(input_grid, background=Color.BLACK, connectivity=4)\n\n    # Get the color of the filled shape\n    shape_color = np.unique(input_grid[~contours])[0]\n\n    # Fill the contour in the output grid with a new color (e.g., Color.RED)\n    new_color = Color.RED\n    output_grid[contours] = new_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid\n    n = np.random.randint(12, 20)\n    m = np.random.randint(12, 20)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a filled shape (sprite) with a random size\n    w = np.random.randint(3, 8)\n    h = np.random.randint(3, 8)\n    sprite_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(w, h, color_palette=[sprite_color], density=1)\n\n    # Place the sprite on a random location on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/21/images/train_output_2.png"}]}, "index": 21, "seeds": ["1cf80156", "2c608aff", "623ea044", "7f4411dc"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color blending, overlap, area calculation\n\n# description:\n# In the input, you will see two overlapping circular objects of different colors. Each object occupies a certain area on the grid.\n# To make the output, combine the colors of the two overlapping regions based on their area, creating a blended color in the overlapping section while keeping the rest of the objects intact.\n\ndef blend_colors(color1, color2):\n    \"\"\"\n    This function blends two colors by averaging their RGB values. \n    Here, we assume colors are represented as tuples of RGB values.\n    \"\"\"\n    # Convert color strings to RGB tuples (R, G, B)\n    color_map = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.ORANGE: (255, 165, 0),\n        Color.PINK: (255, 192, 203),\n        Color.GREY: (128, 128, 128),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.BLACK: (0, 0, 0)\n    }\n    \n    rgb1 = np.array(color_map[color1])\n    rgb2 = np.array(color_map[color2])\n    \n    blended_rgb = (rgb1 + rgb2) // 2  # Simple average for blending\n    blended_color = min(color_map.keys(), key=lambda k: np.linalg.norm(color_map[k] - blended_rgb))\n    \n    return blended_color\n\ndef main(input_grid):\n    output_grid = np.copy(input_grid)\n    \n    # Find connected components to identify circular objects\n    objects = find_connected_components(input_grid, monochromatic=False)\n    \n    # Filter objects to keep only those with more than a small number of pixels\n    valid_objects = [obj for obj in objects if np.count_nonzero(obj != Color.BLACK) \u003e 5]\n    \n    if len(valid_objects) \u003c 2:\n        return output_grid  # Not enough objects to blend\n    \n    obj1, obj2 = valid_objects[0], valid_objects[1]\n\n    # Create a mask for the overlapping area\n    overlap_mask = (input_grid == obj1) \u0026 (input_grid == obj2)\n    \n    # Count areas\n    area_obj1 = np.count_nonzero(obj1 != Color.BLACK)\n    area_obj2 = np.count_nonzero(obj2 != Color.BLACK)\n    \n    # Calculate blended color based on area\n    color1 = np.unique(obj1[obj1 != Color.BLACK])[0]\n    color2 = np.unique(obj2[obj2 != Color.BLACK])[0]\n    blended_color = blend_colors(color1, color2)\n    \n    # Fill the overlapping area with the blended color\n    output_grid[overlap_mask] = blended_color\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create two random circular objects\n    for _ in range(2):\n        center_x = np.random.randint(2, n - 2)\n        center_y = np.random.randint(2, m - 2)\n        radius = np.random.randint(2, 5)\n        color = np.random.choice(list(Color.NOT_BLACK))\n\n        for x in range(n):\n            for y in range(m):\n                if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/22/images/train_output_2.png"}]}, "index": 22, "seeds": ["0e206a2e", "aabf363d", "264363fd_Kevin", "1f642eb9"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, area filling, color transformation\n\n# description:\n# In the input, you will see a grid with random colored pixels forming a closed shape. \n# To make the output, fill the entire area enclosed by the shape with a new color, \n# making sure to change the color of the shape outline to black.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect the shape (connected component) in the grid\n    # 2. Determine the outline of the shape\n    # 3. Fill the area inside the shape with a new color\n    # 4. Change the outline to black\n\n    # Create a blank output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Step 1: Find the shape (assuming the shape is the largest connected component)\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    shape_component = max(components, key=lambda obj: np.count_nonzero(obj != Color.BLACK))\n\n    # Step 2: Get the outline of the shape\n    outline = np.zeros_like(input_grid)\n    for x, y in np.argwhere(shape_component != Color.BLACK):\n        # Check if any of the adjacent pixels are background (not part of the shape)\n        if np.any(input_grid[x-1:x+2, y-1:y+2] == Color.BLACK):\n            outline[x, y] = 1  # Mark outline position\n\n    # Step 3: Fill the area inside the shape with a new color (e.g., Color.YELLOW)\n    fill_color = Color.YELLOW\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if outline[x, y] == 0 and shape_component[x, y] != Color.BLACK:\n                output_grid[x, y] = fill_color\n\n    # Step 4: Change the outline to black\n    output_grid[outline == 1] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a grid with a black background\n    # 2. Randomly generate a closed shape using the draw_line function\n    # 3. Optionally sprinkle some random colors around the shape\n    \n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomize the shape\u0027s outline color\n    shape_color = random.choice(Color.NOT_BLACK)\n\n    # Create a random closed shape using lines\n    start_x, start_y = random.randint(1, n-2), random.randint(1, m-2)\n    draw_line(grid, start_x, start_y, length=random.randint(2, 5), direction=(1, 0), color=shape_color)  # Horizontal line\n    draw_line(grid, start_x + 1, start_y, length=random.randint(2, 5), direction=(0, 1), color=shape_color)  # Vertical line\n\n    # Randomly scatter some additional colors inside the grid, ensuring they don\u0027t overwrite the shape\n    density = random.uniform(0.1, 0.3)\n    grid = random_scatter_points(grid=grid, color=random.choice(Color.NOT_BLACK), density=density)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/23/images/train_output_2.png"}]}, "index": 23, "seeds": ["31aa019c", "2c608aff", "3eda0437", "1f642eb9"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# overlapping patterns, extraction\n\n# description:\n# In the input, you will see a grid with two overlapping patterns in different colors. \n# The output should extract the regions where the two patterns overlap and color them a new color (e.g., blue), \n# while leaving the non-overlapping sections of the original colors intact.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the unique colors in the input grid\n    unique_colors = np.unique(input_grid)\n    overlapping_color = Color.BLUE  # New color for overlaps\n\n    # Create a mask for the overlapping regions\n    overlap_mask = np.zeros_like(input_grid, dtype=bool)\n\n    # Loop through each pixel to find overlapping colors\n    for color in unique_colors:\n        if color != Color.BLACK and color != overlapping_color:\n            # Check if pixel has the current color\n            color_mask = (input_grid == color)\n            # Update overlap mask if the color exists in the grid\n            overlap_mask = overlap_mask | color_mask\n\n    # Set overlapping regions to the new color\n    output_grid[overlap_mask] = overlapping_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Initialize the grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define colors for patterns\n    color_a = np.random.choice(list(Color.NOT_BLACK))\n    color_b = np.random.choice([c for c in Color.NOT_BLACK if c != color_a])\n\n    # Randomly place the first pattern\n    for _ in range(np.random.randint(5, 20)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color_a\n    \n    # Randomly place the second pattern\n    for _ in range(np.random.randint(5, 20)):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = color_b\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/24/images/train_output_2.png"}]}, "index": 24, "seeds": ["cf98881b", "3de23699", "7447852a", "8e1813be"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layered patterns, extraction\n\n# description:\n# In the input, you will see several layers of patterns with some colors overlapping. \n# The output should extract the topmost pattern, which is defined as the first non-background color encountered in a vertical slice from top to bottom, \n# and display it separately, removing all other layers beneath it.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Create an empty grid to store the extracted topmost pattern\n    topmost_pattern = np.full(output_grid.shape, Color.BLACK)\n\n    # Iterate through each column of the grid\n    for col in range(output_grid.shape[1]):\n        for row in range(output_grid.shape[0]):\n            # If we find a non-background color, we mark that position in the topmost pattern\n            if output_grid[row, col] != Color.BLACK:\n                topmost_pattern[row, col] = output_grid[row, col]\n                break  # Move to the next column after finding the topmost color\n\n    return topmost_pattern\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly determine the size of the grid\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n\n    # Create a base grid filled with the background color\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly define the number of layers\n    num_layers = np.random.randint(3, 6)\n\n    # For each layer, draw a random sprite and overlay it on the grid\n    for _ in range(num_layers):\n        layer_color = np.random.choice(Color.NOT_BLACK)  # Choose a random color for the layer\n        layer_sprite = random_sprite(n=np.random.randint(3, 6), m=np.random.randint(3, 6), density=0.5, color_palette=[layer_color])\n        \n        # Randomly position the layer sprite in the grid\n        x_offset = np.random.randint(0, n - layer_sprite.shape[0])\n        y_offset = np.random.randint(0, m - layer_sprite.shape[1])\n        grid = blit_sprite(grid=grid, sprite=layer_sprite, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/25/images/train_output_2.png"}]}, "index": 25, "seeds": ["3de23699", "cf98881b", "1e32b0e9", "6fa7a44f"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layering, color averaging\n\n# description:\n# In the input, you will see a grid with multiple layers of colored pixels that partially overlap. \n# To create the output grid, blend the colors where they overlap by averaging the RGB values of the overlapping pixels while maintaining their original colors elsewhere.\n\ndef main(input_grid):\n    # Create an output grid initialized to black (background)\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Get the unique colors in the input grid that are not black\n    unique_colors = set(input_grid.flatten()) - {Color.BLACK}\n\n    # For each unique color, we need to add it to the output grid\n    for color in unique_colors:\n        # Create a mask where the current color exists\n        color_mask = (input_grid == color)\n\n        # Get the RGB values for the current color\n        r, g, b = get_rgb(color)\n\n        # Blend with the output grid where there is already a color\n        for x in range(input_grid.shape[0]):\n            for y in range(input_grid.shape[1]):\n                if color_mask[x, y]:  # If the current cell has the current color\n                    if output_grid[x, y] != Color.BLACK:  # If there\u0027s already a color, blend\n                        existing_color = output_grid[x, y]\n                        existing_r, existing_g, existing_b = get_rgb(existing_color)\n                        # Average the RGB values\n                        r = (r + existing_r) // 2\n                        g = (g + existing_g) // 2\n                        b = (b + existing_b) // 2\n                    # Set the blended color in the output grid\n                    output_grid[x, y] = create_color(r, g, b)\n\n    return output_grid\n\ndef get_rgb(color):\n    # Helper function to return RGB values based on color\n    if color == Color.RED:\n        return 255, 0, 0\n    elif color == Color.GREEN:\n        return 0, 255, 0\n    elif color == Color.BLUE:\n        return 0, 0, 255\n    elif color == Color.YELLOW:\n        return 255, 255, 0\n    elif color == Color.GREY:\n        return 128, 128, 128\n    elif color == Color.PINK:\n        return 255, 192, 203\n    elif color == Color.ORANGE:\n        return 255, 165, 0\n    elif color == Color.TEAL:\n        return 0, 128, 128\n    elif color == Color.MAROON:\n        return 128, 0, 0\n    elif color == Color.BLACK:\n        return 0, 0, 0\n\ndef create_color(r, g, b):\n    # Helper function to create a color from RGB values\n    # This is a simplification since we are using a limited color palette\n    if r \u003e 200 and g \u003c 50 and b \u003c 50:\n        return Color.RED\n    elif r \u003c 50 and g \u003e 200 and b \u003c 50:\n        return Color.GREEN\n    elif r \u003c 50 and g \u003c 50 and b \u003e 200:\n        return Color.BLUE\n    elif r \u003e 200 and g \u003e 200 and b \u003c 50:\n        return Color.YELLOW\n    elif r \u003e 100 and g \u003e 100 and b \u003e 100:\n        return Color.GREY\n    elif r \u003e 200 and g \u003c 100 and b \u003c 100:\n        return Color.PINK\n    elif r \u003e 200 and g \u003c 100 and b \u003c 50:\n        return Color.ORANGE\n    elif r \u003c 50 and g \u003e 100 and b \u003e 100:\n        return Color.TEAL\n    elif r \u003e 100 and g \u003c 50 and b \u003c 50:\n        return Color.MAROON\n    return Color.BLACK\n\ndef generate_input():\n    # Create a grid with random layers of colored pixels\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Decide on the number of layers (randomly between 3 to 5)\n    num_layers = np.random.randint(3, 6)\n\n    for _ in range(num_layers):\n        # Create a random sprite of colored pixels\n        sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), density=0.5, color_palette=Color.NOT_BLACK)\n        # Find a random location to blit this sprite onto the grid\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/26/images/train_output_2.png"}]}, "index": 26, "seeds": ["1f642eb9", "137eaa0f", "0e206a2e", "bd4472b8"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, pixel filling\n\n# description:\n# In the input, you will see a grid with a pattern that is almost vertically symmetric, \n# with a single missing pixel disrupting the symmetry. \n# To create the output, identify the position of the missing pixel and fill it in \n# to restore vertical symmetry.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the grid\n    n, m = input_grid.shape\n\n    # Prepare the output grid as a copy of the input\n    output_grid = np.copy(input_grid)\n\n    # Iterate through the grid to find the missing pixel\n    for i in range(n):\n        for j in range(m):\n            # Check if the pixel is not black (potentially a part of the pattern)\n            if output_grid[i, j] != Color.BLACK:\n                # Check the corresponding pixel on the other side for symmetry\n                if j \u003c m // 2:\n                    mirror_j = m - 1 - j\n                    if output_grid[i, mirror_j] == Color.BLACK:\n                        # Fill in the missing pixel to restore symmetry\n                        output_grid[i, mirror_j] = output_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size\n    n = np.random.randint(5, 8)\n    m = np.random.randint(5, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the initial pattern\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly fill half of the grid to create the pattern\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.5:  # 50% chance to set a color\n                grid[i, j] = color\n\n    # Introduce a missing pixel by setting one corresponding pixel to black\n    for i in range(n):\n        for j in range(m // 2):\n            if grid[i, j] != Color.BLACK and grid[i, m - 1 - j] != Color.BLACK:\n                grid[i, m - 1 - j] = Color.BLACK  # Make one pixel black to break symmetry\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/27/images/train_output_2.png"}]}, "index": 27, "seeds": ["bc1d5164", "44f52bb0", "6fa7a44f", "3de23699"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color detection, concentric circles\n\n# description:\n# In the input, you will see a single colored pixel in the middle of a black background.\n# To create the output, draw concentric circles around the colored pixel, using the same color as the pixel, with increasing radii.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color (black)\n    output_grid = np.copy(input_grid)\n    \n    # Get the location of the colored pixel\n    colored_pixel_coords = np.argwhere(input_grid != Color.BLACK)\n    if len(colored_pixel_coords) != 1:\n        raise ValueError(\"The input grid must contain exactly one colored pixel.\")\n\n    x, y = colored_pixel_coords[0]\n    \n    # Get the color of the pixel\n    color = input_grid[x, y]\n\n    # Draw concentric circles around the colored pixel\n    for radius in range(1, min(input_grid.shape) // 2):  # Limit the radius to half the grid size\n        for angle in range(0, 360, 10):  # Draw every 10 degrees\n            rad = np.radians(angle)\n            circle_x = x + int(radius * np.cos(rad))\n            circle_y = y + int(radius * np.sin(rad))\n            if 0 \u003c= circle_x \u003c input_grid.shape[0] and 0 \u003c= circle_y \u003c input_grid.shape[1]:\n                output_grid[circle_x, circle_y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    n, m = np.random.randint(7, 20), np.random.randint(7, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Choose a random color for the pixel\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Place the colored pixel in the center of the grid\n    grid[n // 2, m // 2] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/28/images/train_output_2.png"}]}, "index": 28, "seeds": ["2c608aff", "6cdd2623", "aabf363d", "623ea044"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, color replacement, cropping\n\n# description:\n# In the input, you will see a pattern of colored pixels surrounded by a thick black border. \n# To make the output, remove the black border and replace it with a blue border of the same thickness.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to work on\n    output_grid = np.copy(input_grid)\n\n    # Find the bounding box of the non-black area\n    x, y, width, height = bounding_box(output_grid, background=Color.BLACK)\n\n    # Crop the grid to remove the black border\n    cropped_grid = output_grid[x:x + width, y:y + height]\n\n    # Create a new grid for the output with the same dimensions as the cropped grid plus the border\n    bordered_grid = np.zeros((width + 2, height + 2), dtype=int)\n\n    # Fill the outer border with blue\n    bordered_grid[:, :] = Color.BLUE\n\n    # Place the cropped grid in the center of the new grid\n    bordered_grid[1:-1, 1:-1] = cropped_grid\n\n    return bordered_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly select the size of the grid\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n\n    # Create a grid full of black\n    grid = np.zeros((width, height), dtype=int)\n\n    # Define the size of the border\n    border_size = 2\n\n    # Generate a random colored pattern to fill the interior, ensuring there is space for the border\n    pattern_width, pattern_height = width - 2 * border_size, height - 2 * border_size\n    pattern = random_sprite(pattern_width, pattern_height, density=0.5)\n\n    # Place the colored pattern in the center of the grid\n    grid[border_size:border_size + pattern_width, border_size:border_size + pattern_height] = pattern\n\n    # Add a black border around the colored pattern\n    grid[0, :] = grid[-1, :] = Color.BLACK\n    grid[:, 0] = grid[:, -1] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/29/images/train_output_2.png"}]}, "index": 29, "seeds": ["7447852a", "623ea044", "2c608aff", "3de23699"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color filling\n\n# description:\n# In the input, you will see a shape that is missing sections along its horizontal axis. \n# To make the output, identify the missing sections that would make the shape horizontally symmetrical \n# and fill those sections with the same color as the adjacent pixels.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the center of symmetry on the horizontal axis.\n    # 2. For each colored pixel, fill in the corresponding pixels on the opposite side of the center.\n    \n    output_grid = input_grid.copy()\n    \n    # Get the bounding box of the non-black area\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n    \n    # Calculate the center of symmetry (horizontal axis)\n    center_y = (y + height) / 2\n    \n    # Find all colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n    \n    # Fill in missing pixels to achieve horizontal symmetry\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        \n        # Calculate the symmetric y-coordinate\n        symmetric_y = int(center_y * 2 - y)\n        \n        # Fill in the pixel if it lies within the bounds and is black\n        if 0 \u003c= symmetric_y \u003c output_grid.shape[1]:\n            if output_grid[x, symmetric_y] == Color.BLACK:\n                output_grid[x, symmetric_y] = color\n\n    return output_grid\n\n\ndef generate_input():\n    # Initialize a 10x10 grid\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Create a random sprite with vertical symmetry\n    sprite = random_sprite(5, 5, density=0.5, symmetry=\u0027vertical\u0027, color_palette=list(Color.NOT_BLACK))\n\n    # Randomly remove pixels from sprite to create asymmetry\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if np.random.random() \u003c 0.4:  # 40% chance to remove a pixel\n                sprite[i, j] = Color.BLACK\n\n    # Place sprite randomly onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/30/images/train_output_2.png"}]}, "index": 30, "seeds": ["11852cab", "623ea044", "8e1813be", "1caeab9d"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, central filling, color mirroring\n\n# description:\n# In the input, you will see a grid with colored pixels along the edges and a central region that is blank. \n# To make the output, check for symmetry in the colored pixels along the edges and fill the central region with a pattern that mirrors the edge colors.\n\ndef main(input_grid):\n    # Extract the edge colors\n    top_edge = input_grid[0, :]\n    bottom_edge = input_grid[-1, :]\n    left_edge = input_grid[:, 0]\n    right_edge = input_grid[:, -1]\n    \n    # Create a central region with the mirrored edge colors\n    central_region = np.full((len(top_edge) - 2, len(top_edge) - 2), Color.BLACK)\n\n    # Fill the central region with the mirrored pattern of the edges\n    for i in range(len(central_region)):\n        for j in range(len(central_region)):\n            central_region[i, j] = top_edge[j + 1] if i == 0 else (\n                bottom_edge[j + 1] if i == len(central_region) - 1 else (\n                    left_edge[i + 1] if j == 0 else (\n                        right_edge[i + 1] if j == len(central_region) - 1 else Color.BLACK)))\n\n    # Create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[1:-1, 1:-1] = central_region\n\n    return output_grid\n\ndef generate_input():\n    # Make a grid with colored pixels along the edges\n    n = np.random.randint(5, 10)  # Height of the grid\n    m = np.random.randint(5, 10)  # Width of the grid\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define colors for the edges\n    edge_colors = np.random.choice(list(Color.NOT_BLACK), size=4, replace=False)\n\n    # Fill the top edge, bottom edge, left edge, and right edge with colors\n    grid[0, 1:m-1] = edge_colors[0]  # Top edge\n    grid[-1, 1:m-1] = edge_colors[1]  # Bottom edge\n    grid[1:n-1, 0] = edge_colors[2]  # Left edge\n    grid[1:n-1, -1] = edge_colors[3]  # Right edge\n\n    # Ensure the central region remains uncolored (black)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/31/images/train_output_2.png"}]}, "index": 31, "seeds": ["bc1d5164", "3de23699", "44f52bb0", "6fa7a44f"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, pattern extraction, replication\n\n# description:\n# In the input, you will see a grid with a central pattern that may have some pixels in a symmetric arrangement around it. \n# The task is to extract the central pattern and replicate it in a symmetric manner across the grid.\n# The output will have the same dimensions as the input grid, but with the original central pattern mirrored across the vertical and horizontal axes.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Crop the central pattern from the input grid\n    central_pattern = crop(input_grid)\n\n    # Get the dimensions of the central pattern\n    central_height, central_width = central_pattern.shape\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Place the central pattern in the original position\n    blit_sprite(output_grid, central_pattern, x=(output_grid.shape[0] - central_height) // 2, y=(output_grid.shape[1] - central_width) // 2)\n\n    # Create mirrored patterns\n    # Horizontal mirror\n    output_grid[(output_grid.shape[0] - central_height) // 2 + central_height:, (output_grid.shape[1] - central_width) // 2:(output_grid.shape[1] - central_width) // 2 + central_width] = central_pattern\n\n    # Vertical mirror\n    output_grid[(output_grid.shape[0] - central_height) // 2: (output_grid.shape[0] - central_height) // 2 + central_height, \n                 (output_grid.shape[1] - central_width) // 2 + central_width:] = central_pattern\n\n    # Diagonal mirror\n    output_grid[(output_grid.shape[0] - central_height) // 2 + central_height:, (output_grid.shape[1] - central_width) // 2 + central_width:] = central_pattern\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the size of the grid and central pattern\n    n, m = np.random.randint(7, 12), np.random.randint(7, 12)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the size for the central pattern\n    central_pattern_size = np.random.randint(3, min(n, m) // 2)\n\n    # Generate a random pattern\n    central_pattern = random_sprite(n=central_pattern_size, m=central_pattern_size, density=0.5, connectivity=8)\n\n    # Place the central pattern in the middle of the grid\n    start_x = (n - central_pattern_size) // 2\n    start_y = (m - central_pattern_size) // 2\n    blit_sprite(grid, central_pattern, start_x, start_y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/32/images/train_output_2.png"}]}, "index": 32, "seeds": ["bc1d5164", "3de23699", "1e32b0e9", "6b9890af"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object layering, color blending\n\n# description:\n# In the input, you will see several colored circular objects scattered around on a black grid. \n# The circles may overlap, and each circle has a transparent background. \n# To make the output, blend the colors of the overlapping circles together, creating a new color at each pixel based on the number of overlapping colors.\n# If a pixel is covered by no circles, it should remain black; otherwise, it should show the blended result of the overlapping colors.\n\ndef blend_colors(colors):\n    # Simple color blending function - averages the RGB values of the colors\n    if not colors:\n        return Color.BLACK\n    \n    # Create a dictionary to map colors to RGB values\n    color_map = {\n        Color.RED: (255, 0, 0),\n        Color.GREEN: (0, 255, 0),\n        Color.BLUE: (0, 0, 255),\n        Color.YELLOW: (255, 255, 0),\n        Color.PINK: (255, 192, 203),\n        Color.ORANGE: (255, 165, 0),\n        Color.TEAL: (0, 128, 128),\n        Color.MAROON: (128, 0, 0),\n        Color.GREY: (128, 128, 128),\n        Color.BLACK: (0, 0, 0)\n    }\n\n    total_r = total_g = total_b = count = 0\n    for color in colors:\n        if color in color_map:\n            r, g, b = color_map[color]\n            total_r += r\n            total_g += g\n            total_b += b\n            count += 1\n            \n    if count == 0:\n        return Color.BLACK\n    \n    # Average the RGB values\n    avg_r = total_r // count\n    avg_g = total_g // count\n    avg_b = total_b // count\n    \n    # Find the closest color match from the blended RGB\n    blended_color = min(color_map.keys(), key=lambda c: np.linalg.norm(np.array(color_map[c]) - np.array([avg_r, avg_g, avg_b])))\n    \n    return blended_color\n\n\ndef main(input_grid):\n    # Create an empty output grid with the same shape as input\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all circular objects in the input grid\n    objects = detect_objects(input_grid, background=Color.BLACK, monochromatic=False, connectivity=8)\n\n    # For each object, determine its color and its coverage on the output grid\n    for obj in objects:\n        # Get the color of the object (assuming it\u0027s the color of the non-black pixels)\n        color = obj[obj != Color.BLACK][0]  # Get the first color found in the object\n        \n        # Create a mask for the object\u0027s area\n        mask = np.zeros(input_grid.shape, dtype=bool)\n        mask[tuple(np.argwhere(obj != Color.BLACK).T)] = True\n\n        # Blend the colors on the output grid\n        output_grid[mask] = blend_colors([output_grid[mask][0], color])  # Blend existing colors with the new color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a random number of colored circles\n    num_circles = np.random.randint(3, 8)\n\n    for _ in range(num_circles):\n        # Randomly choose a color for the circle\n        color = np.random.choice([c for c in Color.NOT_BLACK])\n\n        # Randomly determine the center and radius of the circle\n        center_x, center_y = np.random.randint(0, n), np.random.randint(0, m)\n        radius = np.random.randint(1, 4)\n\n        # Draw the circle on the grid\n        for dx in range(-radius, radius + 1):\n            for dy in range(-radius, radius + 1):\n                if dx**2 + dy**2 \u003c= radius**2:\n                    x, y = center_x + dx, center_y + dy\n                    if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m:\n                        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/33/images/train_output_2.png"}]}, "index": 33, "seeds": ["8e1813be", "137eaa0f", "a8c38be5", "941d9a10"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, pixel shifting\n\n# description:\n# In the input, you will see a grid with multiple colored pixels. \n# To create the output, perform the following transformations:\n# 1. For each pixel, if its color is among the predefined list (red, green, blue, yellow),\n#    invert its color to the corresponding opposite color (red -\u003e teal, green -\u003e maroon, blue -\u003e yellow, yellow -\u003e blue).\n# 2. Shift the entire grid one pixel downwards. The top row of the output grid should be filled with black pixels.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a color mapping for inversion\n    color_map = {\n        Color.RED: Color.TEAL,\n        Color.GREEN: Color.MAROON,\n        Color.BLUE: Color.YELLOW,\n        Color.YELLOW: Color.BLUE\n    }\n\n    # Create the output grid, initially filled with black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Invert colors in the grid\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            original_color = input_grid[x][y]\n            if original_color in color_map:\n                inverted_color = color_map[original_color]\n                # Shift the inverted color one pixel down\n                if x + 1 \u003c input_grid.shape[0]:  # Avoid going out of bounds\n                    output_grid[x + 1, y] = inverted_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size (between 5x5 to 10x10)\n    n, m = np.random.randint(5, 11), np.random.randint(5, 11)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors, including some from the predefined list\n    num_colors = n * m // 2  # Fill about half of the grid with colors\n    for _ in range(num_colors):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.BLACK])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/34/images/train_output_2.png"}]}, "index": 34, "seeds": ["a9f96cdd", "bc1d5164", "995c5fa3", "0ca9ddb6"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry transformation, rotation, color enhancement\n\n# description:\n# In the input, you will see a colorful pattern that has a partially symmetric structure. \n# To create the output, rotate the pattern 90 degrees clockwise and color the newly exposed areas \n# with a contrasting color to enhance the transformation.\n\ndef main(input_grid):\n    # Rotate the input pattern 90 degrees clockwise\n    output_grid = np.rot90(input_grid, -1)  # -1 indicates clockwise rotation\n\n    # Get the size of the original grid\n    n, m = input_grid.shape\n    \n    # Determine the color to fill the newly exposed areas\n    # Here we choose a contrasting color; for simplicity, we will use Color.RED\n    contrasting_color = Color.RED\n\n    # Fill the new exposed areas in the output grid\n    for i in range(m):\n        for j in range(n):\n            if output_grid[i, j] == Color.BLACK:  # Assuming black represents the absence of color\n                output_grid[i, j] = contrasting_color\n    \n    return output_grid\n\ndef generate_input():\n    # Create a random grid size\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate a colorful pattern with density\n    density = np.random.uniform(0.3, 0.7)\n    color_palette = random.sample(list(Color.NOT_BLACK), np.random.randint(2, 6))  # Choosing 2 to 5 colors\n\n    # Fill the grid with random colors based on the density\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c density:\n                grid[i, j] = np.random.choice(color_palette)\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/35/images/train_output_2.png"}]}, "index": 35, "seeds": ["6fa7a44f", "3e980e27", "3de23699", "8e1813be"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal symmetry, reflection\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels that exhibits diagonal symmetry. \n# To make the output, reflect the pattern across the diagonal (top-left to bottom-right), creating a mirrored effect in the grid.\n\ndef main(input_grid):\n    # Reflect the input grid across the diagonal\n    output_grid = np.zeros_like(input_grid)\n\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            output_grid[j, i] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with diagonal symmetry\n    n = np.random.randint(3, 6)  # Random size for the grid\n    grid = np.zeros((n, n), dtype=int)\n\n    # Fill the grid with a pattern that has diagonal symmetry\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    for i in range(n):\n        for j in range(n):\n            if i \u003c= j:  # Fill the upper triangle and the diagonal\n                grid[i, j] = color\n                grid[j, i] = color  # Ensure diagonal symmetry by mirroring\n\n    # Randomly scatter some black pixels to ensure not every pixel is filled\n    num_black_pixels = np.random.randint(1, n*n//2)\n    for _ in range(num_black_pixels):\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, n)\n        grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/36/images/train_output_2.png"}]}, "index": 36, "seeds": ["6fa7a44f", "44f52bb0", "bc1d5164", "bd4472b8"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, gradient shifting\n\n# description:\n# In the input, you\u0027ll see a grid filled with a gradient of colors progressing from one color to another.\n# To make the output, shift each color in the gradient to the next color in a predefined sequence:\n# red -\u003e orange -\u003e yellow -\u003e green -\u003e blue -\u003e maroon. If a color is at the end of the sequence, it wraps around to the beginning.\n\ndef main(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Define the color shift mapping\n    color_shift = {\n        Color.RED: Color.ORANGE,\n        Color.ORANGE: Color.YELLOW,\n        Color.YELLOW: Color.GREEN,\n        Color.GREEN: Color.BLUE,\n        Color.BLUE: Color.MAROON,\n        Color.MAROON: Color.RED,\n        # Keep background colors unchanged\n        Color.BLACK: Color.BLACK,\n    }\n\n    # Perform color shifting\n    output_grid = np.vectorize(lambda color: color_shift.get(color, color))(output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Define grid size\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose two colors to create a gradient\n    start_color = np.random.choice(list(Color.NOT_BLACK))\n    end_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Create a gradient from start_color to end_color\n    for i in range(n):\n        for j in range(m):\n            # Determine the blended color based on the position\n            ratio = (i + j) / (n + m - 2)  # Normalize the position\n            blended_color = blend_colors(start_color, end_color, ratio)\n            grid[i, j] = blended_color\n\n    return grid\n\ndef blend_colors(color1, color2, ratio):\n    # A simple blend function that combines two colors\n    # Here you can implement a basic blending logic\n    # For simplicity, we assume colors are represented as integers\n    return color1 if np.random.rand() \u003c ratio else color2", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/37/images/train_output_2.png"}]}, "index": 37, "seeds": ["8e1813be", "0d3d703e", "bd4472b8", "f15e1fac"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# color counting, majority voting, pixel replacement\n\n# description:\n# In the input, you will see a grid with a random distribution of colored pixels on a black background. \n# To create the output grid, you should replace all pixels with the most frequently occurring color. \n# In the case of a tie, the color that appears first in the grid (from top-left to bottom-right) should be preserved.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a dictionary to count occurrences of each color\n    color_count = {}\n    \n    # Count the occurrences of each color\n    for row in input_grid:\n        for color in row:\n            if color != Color.BLACK:  # Ignore black pixels\n                color_count[color] = color_count.get(color, 0) + 1\n\n    # Identify the most frequently occurring color\n    max_count = -1\n    most_frequent_color = Color.BLACK\n\n    for color in color_count.keys():\n        count = color_count[color]\n        if count \u003e max_count:\n            max_count = count\n            most_frequent_color = color\n        elif count == max_count:\n            # Check for first appearance in case of tie\n            if np.argwhere(input_grid == color).min() \u003c np.argwhere(input_grid == most_frequent_color).min():\n                most_frequent_color = color\n\n    # Create output grid filled with the most frequent color\n    output_grid = np.full_like(input_grid, fill_value=Color.BLACK)\n    output_grid[input_grid != Color.BLACK] = most_frequent_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of specified dimensions\n    n, m = random.randint(10, 15), random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels in the grid, ensuring some colors appear multiple times\n    colors = random.sample(Color.NOT_BLACK, k=random.randint(3, 6))  # Pick a few random colors\n    for color in colors:\n        frequency = random.randint(5, 20)  # Each color will appear a random number of times\n        for _ in range(frequency):\n            empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.BLACK]\n            if empty_cells:  # If there are still empty cells\n                x, y = random.choice(empty_cells)\n                grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/38/images/train_output_2.png"}]}, "index": 38, "seeds": ["31aa019c", "3de23699", "3eda0437", "2c608aff"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color filtering, counting, background retention\n\n# description:\n# In the input, you will see a grid filled with colored pixels on a black background. The task is to filter out all colors that occur less than a specified threshold (e.g., three). \n# The output should only retain colors that meet this threshold while leaving the background intact (black).\n\ndef main(input_grid: np.ndarray, threshold: int = 3) -\u003e np.ndarray:\n    # Create a new output grid initialized to black (background)\n    output_grid = np.zeros_like(input_grid)\n\n    # Count occurrences of each color\n    unique_colors, counts = np.unique(input_grid, return_counts=True)\n\n    # Create a set of colors that meet the threshold criteria\n    colors_to_keep = {color for color, count in zip(unique_colors, counts) if count \u003e= threshold and color != Color.BLACK}\n\n    # Fill the output grid with the colors that meet the threshold\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            if input_grid[i, j] in colors_to_keep:\n                output_grid[i, j] = input_grid[i, j]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 10x10 grid as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a number of colors and their frequencies\n    num_colors = np.random.randint(2, 6)  # Choose between 2 to 5 different colors\n    colors = random.sample(Color.NOT_BLACK, num_colors)\n\n    # Randomly assign colors to the grid ensuring some have at least threshold occurrences\n    for color in colors:\n        # Set a random frequency for the color but ensure it\u0027s at least the threshold\n        frequency = np.random.randint(1, 10)  # Random frequency between 1 and 9\n        for _ in range(frequency):\n            empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.BLACK]\n            if empty_cells:\n                x, y = random.choice(empty_cells)\n                grid[x, y] = color\n\n    # Add colors that will not meet the threshold\n    for color in colors:\n        if np.random.rand() \u003e 0.5:  # 50% chance to add low-frequency colors\n            frequency = np.random.randint(1, 3)  # Frequency between 1 and 2\n            for _ in range(frequency):\n                empty_cells = [(i, j) for i in range(n) for j in range(m) if grid[i, j] == Color.BLACK]\n                if empty_cells:\n                    x, y = random.choice(empty_cells)\n                    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/39/images/train_output_2.png"}]}, "index": 39, "seeds": ["31aa019c", "25d8a9c8", "6e82a1ae", "6cdd2623"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal stripes, color mirroring\n\n# description:\n# In the input, you will see a grid with a diagonal stripe pattern of alternating colors. Each diagonal stripe runs from the top left to the bottom right.\n# To make the output, replicate the diagonal stripes symmetrically across the vertical axis of the grid, creating a mirrored effect.\n\ndef main(input_grid):\n    # Create an output grid of the same shape as input\n    output_grid = np.copy(input_grid)\n\n    # Get the number of rows and columns\n    rows, cols = input_grid.shape\n\n    # Mirror the diagonal stripes across the vertical axis\n    for i in range(rows):\n        for j in range(cols):\n            color = input_grid[i, j]\n            if color != Color.BLACK:\n                # Set the mirrored position\n                output_grid[i, cols - j - 1] = color\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid with black background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose colors for the diagonal stripes\n    available_colors = list(Color.NOT_BLACK)\n    colors = np.random.choice(available_colors, size=2, replace=False)\n\n    # Draw diagonal stripes of alternating colors\n    for i in range(min(n, m)):\n        if i % 2 == 0:\n            draw_line(grid, i, 0, length=min(n, m - i), direction=(1, 1), color=colors[0])\n        else:\n            draw_line(grid, i, 0, length=min(n, m - i), direction=(1, 1), color=colors[1])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/40/images/train_output_2.png"}]}, "index": 40, "seeds": ["8e1813be", "bc1d5164", "bd4472b8", "05269061"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern duplication, grid transformation\n\n# description:\n# In the input you will see a grid with a pattern of colored pixels in the center.\n# The output should duplicate this pattern in each quadrant of the output grid while maintaining the original colors.\n# The output grid size should be double the size of the input grid.\n\ndef main(input_grid):\n    # Get the dimensions of the input grid\n    input_height, input_width = input_grid.shape\n    # Create an output grid with double the size\n    output_grid = np.full((input_height * 2, input_width * 2), Color.BLACK)\n\n    # Define the coordinates for the four quadrants\n    quadrants = [\n        (0, 0),  # top-left\n        (0, input_width),  # top-right\n        (input_height, 0),  # bottom-left\n        (input_height, input_width)  # bottom-right\n    ]\n\n    # Blit the original input_grid pattern into each quadrant in the output_grid\n    for x_offset, y_offset in quadrants:\n        output_grid = blit_sprite(grid=output_grid, sprite=input_grid, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a base grid size\n    grid_size = np.random.randint(3, 6)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly create a pattern in the center of the grid\n    pattern_size = np.random.randint(1, grid_size // 2 + 1)\n    start_x = grid_size // 2 - pattern_size // 2\n    start_y = grid_size // 2 - pattern_size // 2\n\n    # Fill the center of the grid with random colors\n    colors = Color.NOT_BLACK\n    for i in range(start_x, start_x + pattern_size):\n        for j in range(start_y, start_y + pattern_size):\n            grid[i, j] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/41/images/train_output_2.png"}]}, "index": 41, "seeds": ["46f33fce", "bc1d5164", "6b9890af", "1fad071e"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color fill, boundary detection, shape transformation\n\n# description:\n# In the input grid, you will see a colored shape surrounded by black pixels. The shape can be any color except black. \n# To create the output grid, detect the boundary of the shape and fill the area inside the boundary with a new color (e.g., pink), \n# while leaving the boundary intact.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = input_grid.copy()\n\n    # Detect the boundary of the shape\n    boundary_mask = object_boundary(input_grid)\n    \n    # Create a mask for the interior of the shape\n    interior_mask = object_interior(input_grid)\n\n    # Fill the interior area with the new color (Pink)\n    for x, y in np.argwhere(interior_mask):\n        output_grid[x, y] = Color.PINK\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid of size between 10x10 to 20x20\n    n, m = np.random.randint(10, 21), np.random.randint(10, 21)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Create a random colored shape\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_sprite = random_sprite(np.random.randint(3, 8), np.random.randint(3, 8), color_palette=[shape_color])\n    \n    # Hollow out the interior of the shape\n    interior_mask = object_interior(shape_sprite)\n    boundary_mask = object_boundary(shape_sprite)\n    interior_but_not_edges = interior_mask \u0026 ~boundary_mask\n    shape_sprite[interior_but_not_edges] = Color.BLACK\n\n    # Find a random free location for the shape in the grid\n    x, y = random_free_location_for_sprite(grid, shape_sprite, border_size=1, padding=1)\n    blit_sprite(grid, shape_sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/42/images/train_output_2.png"}]}, "index": 42, "seeds": ["00d62c1b", "6cdd2623", "8d510a79", "1f642eb9"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# environmental mapping, gradient transformation\n\n# description:\n# In the input, there is a colored object in the center of the grid surrounded by various colored pixels.\n# To create the output, replace all the surrounding pixels with a gradient that transitions from the color of the object to black as it moves away from the object.\n\ndef main(input_grid):\n    # Get the color of the central object\n    color_of_object = input_grid[1:-1, 1:-1].max()  # Assume the object is surrounded by the background (black)\n    \n    # Initialize the output grid with the input grid\n    output_grid = np.copy(input_grid)\n\n    # Generate the gradient from the color of the object to black\n    height, width = output_grid.shape\n    for i in range(height):\n        for j in range(width):\n            if output_grid[i, j] != Color.BLACK:  # If it\u0027s not the background\n                # Calculate the distance from the object (1, 1) to the current pixel (i, j)\n                distance = max(abs(i - 1), abs(j - 1))  # Using Chebyshev distance\n                # Calculate the gradient color based on distance\n                gradient_color = blend_colors(color_of_object, Color.BLACK, distance / (height + width))\n                output_grid[i, j] = gradient_color\n\n    # Restore the color of the central object in the output grid\n    output_grid[1:-1, 1:-1] = color_of_object\n\n    return output_grid\n\ndef blend_colors(color_a, color_b, ratio):\n    \"\"\"\n    Blends two colors based on a ratio and returns the resulting color.\n    The blending is done linearly, where `ratio` is between 0 and 1.\n    \"\"\"\n    if ratio \u003c 0:\n        return color_a\n    elif ratio \u003e 1:\n        return color_b\n    else:\n        return color_a if ratio \u003c 0.5 else color_b\n\ndef generate_input():\n    # Create a black grid\n    grid_size = np.random.randint(7, 15)\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Select a color for the central object\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # Draw the object in the center of the grid\n    grid[1:-1, 1:-1] = object_color  # Central object\n\n    # Randomly surround the object with colored pixels\n    for i in range(grid_size):\n        for j in range(grid_size):\n            if grid[i, j] == Color.BLACK and np.random.rand() \u003c 0.3:  # 30% chance to color the surrounding pixels\n                grid[i, j] = np.random.choice(list(Color.NOT_BLACK))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/43/images/train_output_2.png"}]}, "index": 43, "seeds": ["aabf363d", "2c608aff", "264363fd_Kevin", "f15e1fac"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color pattern detection, transformation based on color proximity\n\n# description:\n# In the input, you will see a grid filled with colored pixels. Each pixel can be one of the ten colors.\n# To create the output grid, you should detect clusters of adjacent colored pixels (8-connectivity).\n# Color the pixels in the output grid based on the colors of the largest cluster detected. \n# If two or more clusters are of the same size, use the color of the cluster that appears first (top to bottom, left to right).\n# If the input grid is completely black, output a grid filled with black.\n\ndef main(input_grid):\n    components = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=False)\n\n    # If there are no components, return a black grid\n    if not components:\n        return np.zeros(input_grid.shape, dtype=int)\n\n    # Find the largest component\n    largest_component = max(components, key=lambda x: x.size)\n\n    # Get the color of the largest component\n    color_of_largest = largest_component[0][0]\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Color the pixels of the largest component in the output grid\n    for x, y in np.argwhere(input_grid == color_of_largest):\n        output_grid[x][y] = color_of_largest\n\n    return output_grid\n\ndef generate_input():\n    n, m = np.random.randint(5, 8), np.random.randint(5, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly fill the grid with colors, ensuring some connected components\n    num_colors = len(Color.NOT_BLACK)\n    for i in range(n):\n        for j in range(m):\n            if np.random.rand() \u003c 0.3:  # 30% chance to color the pixel\n                grid[i][j] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/44/images/train_output_2.png"}]}, "index": 44, "seeds": ["44f52bb0", "995c5fa3", "25d8a9c8", "bc1d5164"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color gradient, spreading, blending\n\n# description:\n# In the input, you will see a grid with a single colored pixel surrounded by black pixels. \n# To create the output, transform this pixel into a color gradient that spreads outwards, blending into black as it reaches the edges of the grid.\n\ndef main(input_grid):\n    # Find the location of the colored pixel\n    colored_pixel_locations = np.argwhere(input_grid != Color.BLACK)\n    assert len(colored_pixel_locations) == 1\n    colored_x, colored_y = colored_pixel_locations[0]\n\n    # Create the output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Calculate the maximum distance from the colored pixel to the corners of the grid\n    max_distance = np.max([colored_x, colored_y, input_grid.shape[0] - 1 - colored_x, input_grid.shape[1] - 1 - colored_y])\n\n    # Create the gradient by calculating the color intensity based on distance\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            # Calculate the Euclidean distance from the colored pixel\n            distance = np.sqrt((x - colored_x) ** 2 + (y - colored_y) ** 2)\n            # Normalize the distance to a value between 0 and 1\n            normalized_distance = distance / max_distance\n            # Determine the color based on the distance\n            if normalized_distance \u003c 1:\n                # Blend towards black based on the normalized distance\n                output_grid[x, y] = blend_color(input_grid[colored_x, colored_y], Color.BLACK, normalized_distance)\n\n    return output_grid\n\ndef blend_color(color_a, color_b, ratio):\n    # Simple blending function between two colors based on a ratio\n    # Assuming colors are represented as strings, we will just return a simple average for demonstration purposes.\n    # In a full implementation, you would handle actual RGB values or a similar representation.\n    return color_a if ratio \u003c 0.5 else color_b\n\ndef generate_input():\n    # Create a random grid size\n    width, height = np.random.randint(3, 30, size=2)\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Choose a random color for the single colored pixel\n    colored_pixel_color = np.random.choice(Color.NOT_BLACK)\n\n    # Place a colored pixel in a random location not on the edges\n    colored_x = np.random.randint(1, width-1)\n    colored_y = np.random.randint(1, height-1)\n    input_grid[colored_x, colored_y] = colored_pixel_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/45/images/train_output_2.png"}]}, "index": 45, "seeds": ["ea786f4a", "6d58a25d", "f15e1fac", "8d510a79"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object attraction, movement towards center\n\n# description:\n# In the input, you will see two different colored objects on a grid. \n# To create the output, draw a line connecting the centers of the two objects, \n# and alter their positions slightly to be closer together based on the color of the objects. \n# If both colors are warm (red, orange, yellow), move them closer by two cells; \n# if both are cool (blue, teal), move them closer by one cell; \n# if one is warm and the other is cool, move them closer by one cell as well.\n\ndef main(input_grid):\n    # Make a copy of the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components (objects) in the grid\n    objects = find_connected_components(grid=input_grid, monochromatic=False, connectivity=4)\n    \n    # We expect two objects in the input\n    assert len(objects) == 2\n\n    # Get the centers of the two objects\n    centers = []\n    for obj in objects:\n        # Calculate the center of the object\n        y, x = np.argwhere(obj)[0]  # Get the first pixel of the object\n        centers.append((y, x))\n\n    # Extract the colors of the objects\n    colors = [output_grid[y, x] for (y, x) in centers]\n\n    # Determine the attraction distance based on object colors\n    warm_colors = {Color.RED, Color.ORANGE, Color.YELLOW}\n    cool_colors = {Color.BLUE, Color.TEAL}\n    \n    if set(colors).issubset(warm_colors):\n        move_distance = 2\n    elif set(colors).issubset(cool_colors):\n        move_distance = 1\n    else:\n        move_distance = 1\n\n    # Calculate the new positions for the objects\n    def move_towards(a, b, distance):\n        ay, ax = a\n        by, bx = b\n        dy = np.sign(by - ay) * distance\n        dx = np.sign(bx - ax) * distance\n        return (ay + dy, ax + dx)\n\n    new_centers = [move_towards(centers[0], centers[1], move_distance), \n                   move_towards(centers[1], centers[0], move_distance)]\n\n    # Move the objects to their new positions\n    for i, (y, x) in enumerate(centers):\n        new_y, new_x = new_centers[i]\n        translated_object = translate(objects[i], new_x - x, new_y - y, background=Color.BLACK)\n        output_grid = blit_object(output_grid, translated_object, background=Color.BLACK)\n\n    # Draw a line connecting the two new centers\n    draw_line(output_grid, new_centers[0][0], new_centers[0][1], new_centers[1][0], new_centers[1][1], color=Color.RED)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    n, m = np.random.randint(8, 15), np.random.randint(8, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define two colors for the objects\n    colors = [Color.RED, Color.BLUE]  # One warm, one cool\n\n    # Generate two random positions for the objects ensuring they do not overlap\n    for color in colors:\n        while True:\n            y, x = np.random.randint(1, n-1), np.random.randint(1, m-1)\n            if grid[y, x] == Color.BLACK:\n                # Create a small object (e.g., 2x2 square)\n                obj = np.full((2, 2), color)\n                blit_sprite(grid, obj, x, y, background=Color.BLACK)\n                break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/46/images/train_output_2.png"}]}, "index": 46, "seeds": ["941d9a10", "23581191", "1f642eb9", "6cdd2623"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape merging, color majority\n\n# description:\n# In the input, you will see various colored shapes on a grid, some overlapping. Each shape is a solid color, and they might touch each other at the edges or corners. \n# The output grid should merge overlapping shapes of the same color into a single shape, and the color of the merged shape should be determined by the majority color of the overlapping areas.\n\ndef main(input_grid):\n    # Find all the connected components in the grid\n    components = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n    \n    # Create a grid to store the output\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # For each component, determine its color and merge accordingly\n    for component in components:\n        # Get the colors present in the connected component\n        colors = np.unique(component[component != Color.BLACK])\n        \n        # Count the occurrences of each color\n        color_count = {color: np.sum(component == color) for color in colors}\n        \n        # Determine the majority color (if there\u0027s a tie, select the first one)\n        majority_color = max(color_count, key=color_count.get)\n        \n        # Create the bounding box for this component\n        x, y, w, h = bounding_box(component, background=Color.BLACK)\n        \n        # Fill the output grid with the majority color in the bounding box area\n        output_grid[x:x+w, y:y+h] = majority_color\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random dimensions\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter a random number of colored shapes on the grid\n    shape_count = np.random.randint(5, 15)\n    colors_used = set()\n    \n    for _ in range(shape_count):\n        # Choose a random color (not black)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        colors_used.add(color)\n\n        # Generate a random sprite shape\n        shape_height = np.random.randint(2, 5)\n        shape_width = np.random.randint(2, 5)\n        sprite = random_sprite(shape_height, shape_width, density=0.8, color_palette=[color])\n\n        # Place the shape randomly on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/47/images/train_output_2.png"}]}, "index": 47, "seeds": ["6cdd2623", "1caeab9d", "941d9a10", "a8c38be5"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, radial gradient\n\n# description:\n# In the input grid, you will see a single pixel of one color in the center of the grid. The rest of the grid is filled with another color. \n# To create the output grid, generate a radial gradient that blends from the center color to the background color, \n# filling the entire grid with this gradient based on the distance from the center pixel.\n\ndef main(input_grid):\n    # Get the dimensions of the grid\n    height, width = input_grid.shape\n    center_color = input_grid[height // 2, width // 2]\n    background_color = Color.BLACK if center_color != Color.BLACK else Color.RED  # Avoid blending to the same color\n    \n    output_grid = np.full((height, width), background_color)\n\n    # Calculate the maximum distance from the center to the corners\n    max_distance = np.sqrt((height // 2) ** 2 + (width // 2) ** 2)\n\n    for x in range(height):\n        for y in range(width):\n            # Calculate the distance from the center pixel\n            distance = np.sqrt((x - height // 2) ** 2 + (y - width // 2) ** 2)\n            # Calculate the blending factor based on the distance\n            blend_factor = distance / max_distance\n            # Determine the color based on the blend factor\n            if blend_factor \u003c 1:\n                # Blend proportionally\n                output_grid[x, y] = blend_colors(center_color, background_color, blend_factor)\n            else:\n                output_grid[x, y] = background_color\n\n    return output_grid\n\ndef blend_colors(color1, color2, factor):\n    # Simple function to blend two colors\n    return color1 if factor \u003c 0.5 else color2  # This basic blending assumes two colors\n\ndef generate_input():\n    # Create a 20x20 grid filled with a background color\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Choose a center color\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Set the center pixel to the selected color\n    input_grid[10, 10] = center_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/48/images/train_output_2.png"}]}, "index": 48, "seeds": ["6d58a25d", "bc1d5164", "8d510a79", "6cdd2623"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel aggregation, pixel counting\n\n# description:\n# In the input, you will see a grid filled with colored pixels. The challenge is to count how many times each color appears in the grid.\n# To make the output grid, represent the counts of the colors in a 1xN grid where N is the number of unique colors,\n# with each cell filled with the respective color, filled from left to right based on the count.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Count the occurrence of each color\n    color_counts = {}\n    \n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color != Color.BLACK:  # Ignore the background color\n                if color in color_counts:\n                    color_counts[color] += 1\n                else:\n                    color_counts[color] = 1\n\n    # Create the output grid with a height of 1 and width equal to the number of unique colors\n    unique_colors = list(color_counts.keys())\n    output_grid = np.zeros((1, len(unique_colors)), dtype=int)\n\n    # Fill the output grid with the respective colors based on their counts\n    for index, color in enumerate(unique_colors):\n        count = color_counts[color]\n        output_grid[0, index] = color  # Fill the color in the output grid\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random grid with colored pixels\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly scatter colored pixels in the grid\n    total_pixels = np.random.randint(10, 50)  # Total colored pixels to scatter\n\n    for _ in range(total_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice(Color.NOT_BLACK)  # Choose a random color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/test_input.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_input_0.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_input_1.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_input_2.png", "output": "output/synthetic_examples/barc_gpt4o_mini_desc/49/images/train_output_2.png"}]}, "index": 49, "seeds": ["0ca9ddb6", "1fad071e", "6cdd2623", "46f33fce"], "source": "barc_gpt4o_mini_desc", "source_description": "Examples generated by GPT-4o Mini with minimal descriptive prompting", "source_display_name": "BARC GPT-4o Mini", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, transformation\n\n# description:\n# In the input, you will see a colorful pattern. To create the output, \n# you should reflect the pattern across the y-axis and then reflect the \n# resulting pattern across the x-axis.\n\ndef main(input_grid):\n    # Reflect the pattern across the y-axis\n    reflected_y = input_grid[:, ::-1]\n    \n    # Reflect the result across the x-axis\n    output_grid = reflected_y[::-1]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random square pattern of random size and colors\n    n = m = np.random.randint(3, 6)  # Size of the pattern (between 3 and 5)\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/0/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/0/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/0/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/0/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/0/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/0/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/0/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/0/images/train_output_2.png"}]}, "index": 0, "seeds": ["6fa7a44f", "4c5c2cf0", "3e980e27", "3ac3eb23"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cropping, resizing, scaling\n\n# description:\n# In the input, you will see a colored object on a black background. The object can be of any size, but it should not exceed a certain maximum size.\n# The output grid should resize the object to a fixed size (for example, 5x5) and place it in the center of a new black background grid.\n# If the object is smaller than the target size, it should be scaled up; if it is larger, it should be scaled down.\n\ndef main(input_grid):\n    # Crop the object from the input grid\n    object_cropped = crop(input_grid, background=Color.BLACK)\n    \n    # Resize the object to a fixed size of 5x5\n    target_size = (5, 5)\n    resized_object = np.full(target_size, Color.BLACK, dtype=int)\n\n    # Calculate the scaling factors\n    scale_x = target_size[0] / object_cropped.shape[0]\n    scale_y = target_size[1] / object_cropped.shape[1]\n\n    # Create a scaled version of the object\n    for x in range(target_size[0]):\n        for y in range(target_size[1]):\n            # Calculate the original coordinates for the scaling\n            orig_x = int(x / scale_x)\n            orig_y = int(y / scale_y)\n\n            # Check if the original coordinates are within bounds of the cropped object\n            if orig_x \u003c object_cropped.shape[0] and orig_y \u003c object_cropped.shape[1]:\n                resized_object[x, y] = object_cropped[orig_x, orig_y]\n\n    return resized_object\n\ndef generate_input():\n    # Create a grid of random size (8x8 to 12x12)\n    n = np.random.randint(8, 13)\n    m = np.random.randint(8, 13)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # Create a random sprite with dimensions between 2 and 6\n    sprite_width = np.random.randint(2, 7)\n    sprite_height = np.random.randint(2, 7)\n    sprite = random_sprite(n=sprite_height, m=sprite_width, color_palette=[np.random.choice(Color.NOT_BLACK)])\n\n    # Place the sprite in a random location in the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/1/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/1/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/1/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/1/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/1/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/1/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/1/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/1/images/train_output_2.png"}]}, "index": 1, "seeds": ["1cf80156", "48d8fb45", "137eaa0f", "1f642eb9"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# path creation, color filling, grid manipulation\n\n# description:\n# In the input you will see a grid with a single colored pixel surrounded by empty pixels. \n# To make the output, create a path from the colored pixel to all four edges of the grid. \n# The path should be colored with the same color as the original pixel. \n# The path must be drawn horizontally and vertically until it hits the edge of the grid.\n\ndef main(input_grid):\n    # Find the single colored pixel in the grid\n    colored_pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(colored_pixel)\n    pixel_color = object_colors(colored_pixel)[0]\n    \n    # Initialize the output grid with the same background\n    output_grid = np.zeros_like(input_grid)\n\n    # Draw paths to all four edges\n    # Draw to the top edge\n    draw_line(output_grid, x=pixel_x, y=pixel_y, direction=(0, -1), color=pixel_color)\n    # Draw to the bottom edge\n    draw_line(output_grid, x=pixel_x, y=pixel_y, direction=(0, 1), color=pixel_color)\n    # Draw to the left edge\n    draw_line(output_grid, x=pixel_x, y=pixel_y, direction=(-1, 0), color=pixel_color)\n    # Draw to the right edge\n    draw_line(output_grid, x=pixel_x, y=pixel_y, direction=(1, 0), color=pixel_color)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a color for the pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place a single colored pixel in the grid\n    x, y = np.random.randint(1, n-1), np.random.randint(1, m-1)  # Avoid edges\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/2/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/2/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/2/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/2/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/2/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/2/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/2/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/2/images/train_output_2.png"}]}, "index": 2, "seeds": ["6cdd2623", "834ec97d", "feca6190", "e21d9049"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# repeating pattern, rotation\n\n# description:\n# In the input grid, you will see a pattern consisting of three dots of the same color in a perfect 45 degree diagonal, but equally spaced apart from each other.\n# To create the output grid, rotate the pattern 90 degrees clockwise and repeat it to fill the grid.\n\ndef main(input_grid):\n    # 1. Identify the three colored dots in the input grid.\n    # 2. Determine the positions of the dots.\n    # 3. Create a new output grid and fill it by rotating the pattern.\n\n    # Identify the colored pixels\n    pixel_xs, pixel_ys = np.where(input_grid != Color.BLACK)\n    pixel_locations = list(zip(pixel_xs, pixel_ys))\n    assert len(pixel_locations) == 3  # Ensure there are exactly 3 dots\n\n    # Sort the pixel locations to identify the pattern\n    pixel_locations.sort()  # Sort by y-coordinate (or x) to maintain order\n    color = input_grid[pixel_locations[0]]  # Get the color of the dots\n\n    # Calculate the distance between the dots\n    distance = pixel_locations[1][0] - pixel_locations[0][0]  # Distance in x or y\n\n    # Create the output grid\n    output_size = input_grid.shape[0] + (distance * 2)\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # Function to draw a dot\n    def draw_dot(grid, x, y, color):\n        if 0 \u003c= x \u003c grid.shape[0] and 0 \u003c= y \u003c grid.shape[1]:\n            grid[x, y] = color\n\n    # Fill the output grid by repeating the rotated pattern\n    for i in range(0, output_size, distance):\n        for j in range(0, output_size, distance):\n            # Draw the original pattern\n            draw_dot(output_grid, i, j, color)  # Original position\n            draw_dot(output_grid, i + distance, j, color)  # Top-right\n            draw_dot(output_grid, i, j + distance, color)  # Bottom-left\n            draw_dot(output_grid, i + distance, j + distance, color)  # Bottom-right\n\n    return output_grid\n\ndef generate_input():\n    # 1. Create a 28x28 black grid\n    # 2. Randomly select a distance for the dots\n    # 3. Place three dots in a 45-degree diagonal pattern\n\n    input_grid = np.full((28, 28), Color.BLACK)\n    distance = np.random.randint(3, 8)  # Random distance between 3 and 8\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly select a starting point for the first dot\n    start_x = np.random.randint(0, 28 - 2 * distance)\n    start_y = np.random.randint(0, 28 - 2 * distance)\n\n    # Place the dots in a 45-degree diagonal\n    input_grid[start_x, start_y] = color\n    input_grid[start_x + distance, start_y + distance] = color\n    input_grid[start_x + 2 * distance, start_y + 2 * distance] = color\n\n    # Randomly rotate the input grid sometimes\n    if np.random.rand() \u003c 0.5:\n        input_grid = np.rot90(input_grid)\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/3/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/3/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/3/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/3/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/3/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/3/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/3/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/3/images/train_output_2.png"}]}, "index": 3, "seeds": ["5c2c9af4", "bc1d5164", "eb281b96", "3ac3eb23"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color identification, object isolation\n\n# description:\n# In the input, you will see a grid with several colored objects. \n# Each object is a single solid color, with one object having a unique color that does not appear elsewhere.\n# To create the output grid, extract this uniquely colored object and fill the rest of the grid with a black background.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a blank output grid\n    # 2. Identify the unique color in the input grid\n    # 3. Extract the connected component of the uniquely colored object\n    # 4. Fill the output grid with the extracted object, while the rest remains black\n\n    output_grid = np.zeros_like(input_grid)\n\n    # 2. Identify the unique color\n    color_counts = {}\n    for color in Color.NOT_BLACK:\n        color_counts[color] = np.count_nonzero(input_grid == color)\n\n    unique_color = None\n    for color, count in color_counts.items():\n        if count == 1:\n            unique_color = color\n            break\n\n    if unique_color is None:\n        raise ValueError(\"No unique color found in the input grid.\")\n\n    # 3. Extract the uniquely colored object\n    objects = detect_objects(input_grid, colors=[unique_color], monochromatic=True, connectivity=4)\n    if not objects:\n        raise ValueError(\"No objects found for the unique color.\")\n\n    unique_object = objects[0]  # Assuming the first object is the unique one\n    unique_object_cropped = crop(unique_object, background=Color.BLACK)\n\n    # 4. Place the unique object in the output grid\n    x_offset, y_offset = 0, 0  # Output grid starts from the top-left corner\n    blit_sprite(output_grid, unique_object_cropped, x_offset, y_offset, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid where one color is unique and appears only once\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select a unique color from Color.NOT_BLACK\n    unique_color = random.choice(Color.NOT_BLACK)\n\n    # Ensure the unique color appears only once\n    unique_position = (np.random.randint(0, n), np.random.randint(0, m))\n    grid[unique_position] = unique_color\n\n    # Fill the rest of the grid with other colors\n    remaining_colors = [color for color in Color.NOT_BLACK if color != unique_color]\n\n    for i in range(n):\n        for j in range(m):\n            if (i, j) != unique_position:\n                # Randomly assign a color from the remaining colors\n                grid[i, j] = random.choice(remaining_colors)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/4/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/4/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/4/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/4/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/4/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/4/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/4/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/4/images/train_output_2.png"}]}, "index": 4, "seeds": ["31aa019c", "aedd82e4", "48d8fb45", "137eaa0f"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, resizing, mirroring\n\n# description:\n# In the input, you will see a grid with colored pixels, including a red square in the top left corner.\n# To create the output:\n# 1. Count the number of distinct colors in the grid, excluding red.\n# 2. Enlarge every pixel in the input grid by a factor equal to the count of distinct colors.\n# 3. Mirror the enlarged grid horizontally.\n\ndef main(input_grid):\n    # 1. Count the number of distinct colors excluding red\n    distinct_colors = len(set(input_grid.flatten()) - {Color.RED})\n\n    # 2. Enlarge the input grid by the number of distinct colors\n    output_grid = np.repeat(np.repeat(input_grid, distinct_colors, axis=0), distinct_colors, axis=1)\n\n    # 3. Mirror the enlarged grid horizontally\n    output_grid = np.flip(output_grid, axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 6x6 grid filled with red color\n    n, m = 6, 6\n    grid = np.full((n, m), Color.RED)\n\n    # Randomly scatter a few colors in the grid while avoiding red\n    colors = list(Color.NOT_BLACK)\n    num_colors = np.random.randint(2, 6)  # at least 2 colors\n    chosen_colors = np.random.choice(colors, num_colors, replace=False)\n\n    # Scatter colored pixels randomly in the grid\n    for color in chosen_colors:\n        num_pixels = np.random.randint(5, 15)  # random number of pixels for this color\n        for _ in range(num_pixels):\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            grid[x, y] = color\n\n    # Place a red square in the top left corner\n    red_square = np.full((2, 2), Color.RED)\n    blit_sprite(grid, red_square, 0, 0)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/5/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/5/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/5/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/5/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/5/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/5/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/5/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/5/images/train_output_2.png"}]}, "index": 5, "seeds": ["469497ad", "1fad071e", "3eda0437", "44d8ac46"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, color mapping\n\n# description:\n# In the input, you will see a grid with several distinct shapes represented by different colors.\n# To create the output, color the shapes based on their area: \n# shapes with an area less than 5 will be colored blue, \n# areas between 5 and 10 will be colored green, \n# and shapes with an area greater than 10 will be colored red.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all the colored shapes in the grid\n    background_color = Color.BLACK\n    shapes = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background_color)\n\n    for shape in shapes:\n        area = np.sum(shape != background_color)\n\n        # Determine the new color based on the area of the shape\n        if area \u003c 5:\n            new_color = Color.BLUE\n        elif 5 \u003c= area \u003c= 10:\n            new_color = Color.GREEN\n        else:\n            new_color = Color.RED\n\n        # Color the shape with the new color\n        shape[shape != background_color] = new_color\n        output_grid = blit_object(output_grid, shape, background=background_color)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate shapes and place them in the grid\n    for _ in range(np.random.randint(3, 6)):\n        # Random dimensions for the shape\n        w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n        \n        # Generate a random shape with a random color (not black)\n        shape_color = np.random.choice(list(Color.NOT_BLACK))\n        shape = random_sprite(w, h, color_palette=[shape_color], density=0.5)\n\n        # Place the shape randomly within the grid\n        x, y = random_free_location_for_sprite(grid, shape)\n        grid = blit_sprite(grid, shape, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/6/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/6/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/6/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/6/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/6/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/6/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/6/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/6/images/train_output_2.png"}]}, "index": 6, "seeds": ["e509e548", "941d9a10", "d2abd087", "eb5a1d5d"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, color transformation\n\n# description:\n# In the input, you will see a grid containing several colored objects on a black background. Each object is represented by a single color.\n# To make the output, change the color of all boundary pixels of each object to gray, while keeping the inner pixels of each object the same color as in the input.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Detect all connected components (objects) in the grid.\n    # 2. For each object, change its boundary pixels to gray while keeping the inner pixels the same color.\n\n    output_grid = np.copy(input_grid)\n    \n    # 1. Find connected components (objects)\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj)\n        \n        # Change the boundary pixels to gray\n        for i in range(x, x + width):\n            for j in range(y, y + height):\n                if output_grid[i, j] == Color.BLACK:  # Only change if the pixel is part of the background\n                    continue\n                # Check if it is a boundary pixel\n                is_boundary = (i == x or i == x + width - 1 or j == y or j == y + height - 1)\n                if is_boundary:\n                    output_grid[i, j] = Color.GRAY\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid with random colored objects on a black background.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Number of objects to create\n    num_objects = np.random.randint(2, 5)\n\n    for _ in range(num_objects):\n        # Random size for the object\n        width, height = np.random.randint(2, 4), np.random.randint(2, 4)\n        color = random.choice(Color.NOT_BLACK)\n\n        # Find a random free location for the object\n        x, y = random_free_location_for_sprite(grid, np.full((width, height), color), background=Color.BLACK)\n\n        # Draw the object onto the grid\n        blit_sprite(grid, np.full((width, height), color), x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/7/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/7/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/7/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/7/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/7/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/7/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/7/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/7/images/train_output_2.png"}]}, "index": 7, "seeds": ["31aa019c", "1f642eb9", "ea786f4a", "137eaa0f"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid tiling, pattern repetition\n\n# description:\n# In the input grid, you will see a small square pattern located in the center of the grid. \n# To make the output, you should tile this pattern to fill the entire grid. \n# The output grid should have the same dimensions as the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the dimensions of the input grid\n    n, m = input_grid.shape\n\n    # Calculate the size of the pattern by finding the bounding box of the non-black pixels\n    pattern_objects = find_connected_components(input_grid, background=Color.BLACK)\n    assert len(pattern_objects) == 1, \"Input should contain exactly one pattern\"\n    \n    # Crop the pattern\n    pattern = crop(pattern_objects[0], background=Color.BLACK)\n    pattern_height, pattern_width = pattern.shape\n\n    # Create the output grid with the same size as the input grid\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # Tile the pattern across the output grid\n    for i in range(0, n, pattern_height):\n        for j in range(0, m, pattern_width):\n            blit_sprite(output_grid, pattern, x=j, y=i, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size 10x10 with a black background\n    grid_size = 10\n    grid = np.full((grid_size, grid_size), Color.BLACK)\n\n    # Randomly choose the size of the pattern (2 to 4)\n    pattern_size = np.random.randint(2, 5)\n\n    # Randomly select a color for the pattern\n    pattern_color = np.random.choice(Color.NOT_BLACK)\n\n    # Place the pattern in the center of the grid\n    start_x = (grid_size - pattern_size) // 2\n    start_y = (grid_size - pattern_size) // 2\n\n    # Fill the center pattern with the selected color\n    for i in range(pattern_size):\n        for j in range(pattern_size):\n            grid[start_x + i, start_y + j] = pattern_color if np.random.rand() \u003c 0.7 else Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/8/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/8/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/8/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/8/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/8/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/8/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/8/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/8/images/train_output_2.png"}]}, "index": 8, "seeds": ["bc1d5164", "46f33fce", "e21d9049", "1e32b0e9"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mixing, area calculation, filling shapes\n\n# description:\n# In the input, you will see several colored shapes (circles or squares) on a black background.\n# To make the output, you should calculate the area of each shape and fill it with a mixed color based on the area:\n# - If the area is 1, fill with YELLOW.\n# - If the area is 4, fill with GREEN.\n# - If the area is 9, fill with BLUE.\n# - If the area is greater than 9, fill with RED.\n\ndef main(input_grid):\n    # Initialize the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Find the connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Process each shape to calculate the area and fill with the appropriate color\n    for shape in shapes:\n        area = np.sum(shape != Color.BLACK)  # Calculate the area of the shape\n        color = Color.BLACK  # Default color\n        \n        # Determine the fill color based on the area\n        if area == 1:\n            color = Color.YELLOW\n        elif area == 4:\n            color = Color.GREEN\n        elif area == 9:\n            color = Color.BLUE\n        elif area \u003e 9:\n            color = Color.RED\n\n        # Fill the shape in the output grid with the determined color\n        output_grid[shape != Color.BLACK] = color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10 with a black background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly create a number of shapes\n    num_shapes = np.random.randint(3, 7)\n    for _ in range(num_shapes):\n        # Randomly choose a shape (circle or square)\n        shape_type = np.random.choice([\u0027circle\u0027, \u0027square\u0027])\n        shape_size = np.random.randint(1, 4)  # Size of the shape (1x1, 2x2, or 3x3)\n        \n        # Create the shape sprite\n        if shape_type == \u0027circle\u0027:\n            # Create a circular sprite using a mask\n            sprite = np.zeros((shape_size, shape_size), dtype=int)\n            rr, cc = np.ogrid[:shape_size, :shape_size]\n            mask = (rr - shape_size // 2) ** 2 + (cc - shape_size // 2) ** 2 \u003c= (shape_size // 2) ** 2\n            sprite[mask] = 1  # Fill the circle\n\n        elif shape_type == \u0027square\u0027:\n            sprite = np.ones((shape_size, shape_size), dtype=int)\n\n        # Try to place the shape on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            # If no space was available, skip this shape\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/9/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/9/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/9/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/9/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/9/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/9/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/9/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/9/images/train_output_2.png"}]}, "index": 9, "seeds": ["6e82a1ae", "ff28f65a", "db93a21d", "8e1813be"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel transformation, color filling, grid manipulation\n\n# description:\n# In the input you will see a grid with a single colored pixel in the center.\n# To make the output, you should expand outwards from the pixel, coloring all pixels in a diamond pattern.\n# The diamond pattern should alternate colors, starting from the pixel\u0027s color and changing to a different color on each layer.\n\ndef main(input_grid):\n    # Identify the center pixel and its color\n    center_color = input_grid[input_grid.shape[0] // 2, input_grid.shape[1] // 2]\n    if center_color == Color.BLACK:\n        raise ValueError(\"Center pixel must be colored.\")\n\n    # Create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # Get the dimensions of the grid\n    rows, cols = input_grid.shape\n    center_x, center_y = rows // 2, cols // 2\n\n    # Initialize the current color and the layer index\n    current_color = center_color\n    layer = 0\n\n    # Expand outwards in a diamond shape\n    while True:\n        # Calculate the boundaries of the current layer\n        if center_x - layer \u003c 0 or center_x + layer \u003e= rows or center_y - layer \u003c 0 or center_y + layer \u003e= cols:\n            break  # Stop if we go out of bounds\n        \n        # Color the diamond layer\n        for dx in range(-layer, layer + 1):\n            output_grid[center_x + dx, center_y + (layer - abs(dx))] = current_color\n            output_grid[center_x + dx, center_y - (layer - abs(dx))] = current_color\n\n        # Alternate color for the next layer\n        current_color = Color.BLACK if current_color != Color.BLACK else Color.RED  # Switch between two colors\n        layer += 1\n    \n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a single colored pixel in the center\n    n, m = np.random.randint(5, 11, size=2)\n    # Ensure n and m are odd for a center pixel\n    n += n % 2 == 0\n    m += m % 2 == 0\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly choose a color for the center pixel\n    center_color = np.random.choice(Color.NOT_BLACK)\n    grid[n // 2, m // 2] = center_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/10/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/10/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/10/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/10/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/10/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/10/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/10/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/10/images/train_output_2.png"}]}, "index": 10, "seeds": ["bc1d5164", "1bfc4729", "3ac3eb23", "6cdd2623"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern expansion, color transformation\n\n# description:\n# In the input you will see a grid with a circular pattern of colored pixels. \n# To make the output, you should expand the circular pattern outward, \n# filling in the surrounding area with the same color as the outermost pixels of the circle.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Find the circular pattern in the input grid\n    # 2. Identify the outermost pixels of the circle\n    # 3. Create a new output grid and fill in the outer area with the outermost color\n\n    # Find the connected components (the circular pattern)\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1, \"exactly one circular pattern expected\"\n    \n    circle = objects[0]\n    outer_color = object_colors(circle, background=Color.BLACK)[0]  # Get the color of the outermost pixels\n\n    # Get the bounding box of the circle to determine its location\n    x, y, width, height = bounding_box(circle)\n    output_grid = np.full_like(input_grid, Color.BLACK)  # Create an output grid filled with black\n\n    # Expand the circle outwards\n    for i in range(x - 1, x + width + 1):\n        for j in range(y - 1, y + height + 1):\n            if 0 \u003c= i \u003c output_grid.shape[0] and 0 \u003c= j \u003c output_grid.shape[1]:\n                # If the current pixel is outside the original circle\n                if (i \u003c x or i \u003e= x + width) or (j \u003c y or j \u003e= y + height):\n                    output_grid[i, j] = outer_color  # Fill with the outermost color\n\n    # Overlay the original circular pattern on the output grid\n    blit_sprite(output_grid, circle, x, y)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate a random sized grid with black background\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly select a color for the circle\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Generate a random radius for the circle\n    radius = np.random.randint(2, min(width, height) // 4)\n\n    # Create a circular pattern\n    for i in range(-radius, radius + 1):\n        for j in range(-radius, radius + 1):\n            if i**2 + j**2 \u003c= radius**2:\n                x, y = radius + i, radius + j  # Center the circle in the grid\n                if 0 \u003c= x \u003c width and 0 \u003c= y \u003c height:\n                    grid[x, y] = color  # Set the pixel color to the chosen color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/11/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/11/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/11/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/11/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/11/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/11/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/11/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/11/images/train_output_2.png"}]}, "index": 11, "seeds": ["3de23699", "bc1d5164", "e21d9049", "3ac3eb23"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, transformation, alignment\n\n# description:\n# In the input, you will see a grid containing various multicolored shapes. Each shape is made of connected pixels of the same color, and the shapes can vary in size and form. To make the output, place each shape into a designated area within a fixed-size output grid such that all shapes are arranged in a compact manner, maintaining their original orientation and color. The output should fill the grid as much as possible without overlap.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify all the distinct shapes in the input grid.\n    # 2. Create an output grid of fixed size.\n    # 3. Arrange the identified shapes in the output grid, ensuring they do not overlap and are placed as close together as possible.\n\n    # Step 1: Extract shapes from the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False, connectivity=4)\n\n    # Step 2: Create an output grid of fixed size (10x10)\n    output_grid = np.full((10, 10), Color.BLACK)\n\n    # Track the current position to place shapes in the output grid\n    current_x, current_y = 0, 0\n\n    for shape in shapes:\n        # Step 3: Crop the shape to get its sprite representation\n        sprite = crop(shape, background=Color.BLACK)\n\n        # Check for space in the output grid and place the sprite\n        try:\n            # Blit the sprite into the output grid\n            blit_sprite(output_grid, sprite, x=current_x, y=current_y, background=Color.BLACK)\n\n            # Move to the next position in the output grid\n            current_y += sprite.shape[1]\n            if current_y \u003e= output_grid.shape[1]:  # If we exceed the row length, move to the next row\n                current_y = 0\n                current_x += sprite.shape[0]\n\n            # If current_x exceeds the grid height, break the loop\n            if current_x \u003e= output_grid.shape[0]:\n                break\n\n        except ValueError:\n            # If we cannot place a shape, we skip to the next shape\n            continue\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size (15x15) filled with shapes\n    n, m = 15, 15\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define the number of shapes to create\n    num_shapes = np.random.randint(5, 10)\n\n    for _ in range(num_shapes):\n        # Randomly generate a shape of random dimensions\n        shape_width = np.random.randint(3, 6)\n        shape_height = np.random.randint(3, 6)\n        shape = random_sprite(shape_height, shape_width, color_palette=Color.NOT_BLACK, density=0.5)\n\n        # Find a free location to place the shape in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, shape, padding=1, background=Color.BLACK)\n            blit_sprite(grid, shape, x=x, y=y)\n        except ValueError:\n            # If no free location is found, we skip to the next shape\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/12/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/12/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/12/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/12/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/12/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/12/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/12/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/12/images/train_output_2.png"}]}, "index": 12, "seeds": ["137eaa0f", "0e206a2e", "e509e548", "a8c38be5"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel growing, directional change\n\n# description:\n# In the input grid, you will see a single colored pixel. To produce the output, grow the pixel to the right by three pixels, \n# then change direction upwards and grow by three pixels, forming a right-angled line.\n\ndef main(input_grid):\n    # Find the single colored pixel in the input grid\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # Create an output grid based on the input grid\n    output_grid = input_grid.copy()\n\n    # Step 1: Grow the pixel to the right by 3 pixels\n    for dx in range(4):  # 0 to 3 inclusive\n        if pixel_x + dx \u003c output_grid.shape[0]:\n            output_grid[pixel_x + dx, pixel_y] = pixel_color\n\n    # Step 2: Change direction upwards and grow by 3 pixels\n    for dy in range(1, 4):  # 1 to 3 inclusive\n        if pixel_y - dy \u003e= 0:\n            output_grid[pixel_x + 3, pixel_y - dy] = pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # Randomly choose a color for the pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place a single colored pixel\n    x, y = np.random.randint(0, 20), np.random.randint(0, 20)\n    input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/13/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/13/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/13/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/13/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/13/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/13/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/13/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/13/images/train_output_2.png"}]}, "index": 13, "seeds": ["0962bcdd", "834ec97d", "feca6190", "6d58a25d"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# sliding objects, collision detection\n\n# description:\n# In the input you will see a red 2x2 square and a blue object (which can be of any shape).\n# Slide the blue object down by one pixel until it just touches the red square.\n\ndef main(input_grid):\n    # Find the red object\n    red_object = np.zeros_like(input_grid)\n    red_object[input_grid == Color.RED] = Color.RED\n\n    # Find the blue object\n    blue_object = np.zeros_like(input_grid)\n    blue_object[input_grid == Color.BLUE] = Color.BLUE\n\n    # Start the output grid with the red object\n    output_grid = np.copy(red_object)\n\n    # Consider sliding the blue object down\n    for slide_distance in range(input_grid.shape[0]):\n        # Translate the blue object down\n        translated_blue_object = translate(blue_object, 0, slide_distance, background=Color.BLACK)\n        \n        # Check for contact with the red object\n        if contact(object1=red_object, object2=translated_blue_object):\n            # Place the blue object where it touches the red object\n            blit_object(output_grid, translated_blue_object, background=Color.BLACK)\n            return output_grid\n\n    # If no valid slide found, this should not happen given correct input\n    assert 0, \"No valid slide found\"\n\ndef generate_input():\n    # Create a black grid of size 5x5 to 10x10\n    n, m = random.randint(5, 10), random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a 2x2 red square\n    red_square = np.full((2, 2), Color.RED)\n    x_red, y_red = random_free_location_for_sprite(grid, red_square, background=Color.BLACK, padding=1)\n    blit_sprite(grid, red_square, x_red, y_red, background=Color.BLACK)\n\n    # Generate a random sprite for the blue object (size 2x2 to 4x4)\n    blue_sprite = random_sprite(random.randint(2, 4), random.randint(2, 4), symmetry=\"not_symmetric\", color_palette=[Color.BLUE])\n\n    # Place the blue sprite somewhere random on the grid\n    x_blue, y_blue = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, blue_sprite, x_blue, y_blue, background=Color.BLACK)\n\n    # Ensure the blue object can slide to touch the red square\n    # There should be a straight column below the red square for the blue object to slide down\n    bottom_red_y = y_red + 1  # The row immediately below the red square\n    if bottom_red_y \u003c n:  # Ensure it is within bounds\n        for col in range(x_red, x_red + 2):  # Check the columns where the red square is\n            grid[bottom_red_y, col] = Color.BLUE  # Make a spot for the blue object to slide down\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/14/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/14/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/14/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/14/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/14/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/14/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/14/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/14/images/train_output_2.png"}]}, "index": 14, "seeds": ["25ff71a9", "e9614598", "05f2a901", "6cf79266"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color counting, vertical bars, grid transformation\n\n# description:\n# In the input, you will see a grid filled with pixels in a single row (1 x n).\n# To make the output grid, count how many times each color appears in the input row.\n# Then create a vertical bar for each color in the output grid, where the height of the bar corresponds to the number of pixels of that color.\n# The output should be arranged from left to right.\n\ndef main(input_grid):\n    # Count occurrences of each color in the single row input\n    color_counts = {}\n    \n    for color in input_grid.flatten():\n        if color != Color.BLACK:  # Exclude the background color\n            if color in color_counts:\n                color_counts[color] += 1\n            else:\n                color_counts[color] = 1\n\n    # Determine the output grid size\n    num_colors = len(color_counts)\n    max_height = max(color_counts.values()) if color_counts else 0\n\n    # Create an output grid with a height equal to max_height and a width equal to the number of unique colors\n    output_grid = np.full((max_height, num_colors), Color.BLACK)\n\n    # Fill the output grid with vertical bars\n    for idx, (color, count) in enumerate(color_counts.items()):\n        output_grid[max_height - count:max_height, idx] = color  # Fill from the bottom up\n\n    return output_grid\n\ndef generate_input():\n    # Generate a row of random colors\n    width = np.random.randint(5, 15)  # Width of the input grid (1 x n)\n    grid = np.full((1, width), Color.BLACK)\n\n    # Randomly choose colors for each pixel, ensuring some colors appear multiple times\n    colors = np.random.choice(Color.NOT_BLACK, size=width, replace=True)\n    for x in range(width):\n        grid[0, x] = colors[x]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/15/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/15/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/15/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/15/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/15/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/15/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/15/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/15/images/train_output_2.png"}]}, "index": 15, "seeds": ["1fad071e", "ff28f65a", "feca6190", "90c28cc7"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, shape detection, object framing\n\n# description:\n# In the input grid, you will see various colored objects. Some are \"hollow\" and contain a fully-enclosed region, while others are solid without any enclosed regions.\n# To create the output grid, copy the input grid. Then, change the color of all \"hollow\" shapes to be green and all the \"solid\" shapes to be red.\n\ndef main(input_grid):\n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=4)\n    \n    # Create an output grid initialized to the same background color\n    output_grid = input_grid.copy()\n    \n    for obj in objects:\n        # Determine if the object is hollow or solid\n        if is_hollow(obj):\n            # Change hollow shapes to green\n            obj[obj != Color.BLACK] = Color.GREEN\n        else:\n            # Change solid shapes to red\n            obj[obj != Color.BLACK] = Color.RED\n        \n        # Place the modified object back into the output grid\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef is_hollow(object):\n    # Check if the object has a fully enclosed region\n    interior_mask = object_interior(object)\n    object_mask = object != Color.BLACK\n    hollow_mask = interior_mask \u0026 ~object_mask\n    return np.any(hollow_mask)\n\ndef generate_input():\n    n = np.random.randint(10, 20)  # size of the grid\n    input_grid = np.full((n, n), Color.BLACK)\n\n    def random_hollow_object():\n        size = np.random.randint(3, 7)\n        obj = np.full((size, size), Color.BLUE)\n        obj[1:size-1, 1:size-1] = Color.BLACK  # creating a hollow square\n        return obj\n\n    def random_solid_object():\n        size = np.random.randint(3, 7)\n        obj = np.full((size, size), Color.BLUE)\n        # making the entire object solid by not changing any inner pixel\n        return obj\n\n    # Ensure at least one hollow and one solid object\n    try:\n        # Add one hollow object\n        hollow_obj = random_hollow_object()\n        x, y = random_free_location_for_sprite(input_grid, hollow_obj, padding=1)\n        blit_sprite(input_grid, hollow_obj, x=x, y=y)\n\n        # Add one solid object\n        solid_obj = random_solid_object()\n        x, y = random_free_location_for_sprite(input_grid, solid_obj, padding=1)\n        blit_sprite(input_grid, solid_obj, x=x, y=y)\n    except ValueError:\n        return generate_input()\n\n    # Add random objects until the grid is reasonably filled\n    while True:\n        obj_choice = np.random.choice([random_hollow_object, random_solid_object])\n        obj = obj_choice()\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            return input_grid  # Return the filled grid if no more space is available", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/16/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/16/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/16/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/16/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/16/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/16/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/16/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/16/images/train_output_2.png"}]}, "index": 16, "seeds": ["810b9b61", "941d9a10", "db93a21d", "aedd82e4"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection, color transformation, grid manipulation\n\n# description:\n# In the input, you will see colored pixels arranged in a pattern at the top half of a black grid.\n# To make the output, reflect the upper pattern downwards into the lower half of the grid.\n# The reflected pixels should maintain their color, but we will replace every pixel\u0027s color with a new one determined by a transformation rule: \n# If the original color is RED, it changes to BLUE; if it\u0027s GREEN, it changes to YELLOW; if it\u0027s BLUE, it changes to RED; \n# If a pixel is BLACK, it remains BLACK. All other colors will turn to GREY.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the size of the input grid and create an output grid of the same size.\n    # 2. Iterate through the upper half of the input grid and reflect the colors to the lower half.\n    # 3. Apply the color transformation rule to each pixel as we copy them.\n\n    # Step 1: Determine the size of the input grid and create the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 2: Reflect the upper half downwards\n    rows, cols = input_grid.shape\n    for x in range(rows // 2):\n        for y in range(cols):\n            original_color = input_grid[x, y]\n            reflected_color = Color.BLACK  # Default to BLACK\n\n            # Step 3: Apply the transformation rules\n            if original_color == Color.RED:\n                reflected_color = Color.BLUE\n            elif original_color == Color.GREEN:\n                reflected_color = Color.YELLOW\n            elif original_color == Color.BLUE:\n                reflected_color = Color.RED\n            elif original_color == Color.BLACK:\n                reflected_color = Color.BLACK\n            else:\n                reflected_color = Color.GREY\n\n            # Place the transformed color in the lower half\n            output_grid[rows - 1 - x, y] = reflected_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a black grid of random size\n    height = np.random.randint(5, 11) * 2  # Ensure even height for upper-lower reflection\n    width = np.random.randint(5, 11)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Fill the upper half of the grid with random colors\n    for x in range(height // 2):\n        for y in range(width):\n            if np.random.rand() \u003c 0.5:  # 50% chance to place a color\n                grid[x, y] = np.random.choice([Color.RED, Color.GREEN, Color.BLUE])\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/17/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/17/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/17/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/17/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/17/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/17/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/17/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/17/images/train_output_2.png"}]}, "index": 17, "seeds": ["a8c38be5", "137eaa0f", "db93a21d", "feca6190"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines, alternating patterns, grid manipulation\n\n# description:\n# In the input, you will see a square grid with a diagonal line from the top left to the bottom right.\n# To create the output grid, color the diagonal line in alternating colors: red, blue, green.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Get the dimensions of the grid\n    n, m = input_grid.shape\n    \n    # Iterate through the diagonal line\n    for i in range(min(n, m)):\n        # Color the diagonal line with alternating colors\n        if i % 3 == 0:\n            output_grid[i, i] = Color.RED\n        elif i % 3 == 1:\n            output_grid[i, i] = Color.BLUE\n        else:\n            output_grid[i, i] = Color.GREEN\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a square grid with black background\n    grid_len = np.random.randint(5, 15)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Draw a diagonal line from top left to bottom right\n    for i in range(grid_len):\n        grid[i, i] = Color.BLACK  # Keep it black for input\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/18/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/18/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/18/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/18/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/18/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/18/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/18/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/18/images/train_output_2.png"}]}, "index": 18, "seeds": ["941d9a10", "7447852a", "feca6190", "0ca9ddb6"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color transformation, size-based transformation\n\n# description:\n# In the input grid, you will see several yellow objects of varying sizes.\n# To create the output grid, change all yellow objects with an area greater than 3 to blue, \n# and all yellow objects with an area of 3 or less to pink.\n\ndef main(input_grid):\n    # Extract all connected components (objects) in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4)\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Process each detected object\n    for obj in objects:\n        area = np.sum(obj != Color.BLACK)  # Calculate the area of the object\n\n        if area \u003e 3:\n            # Change color to blue for objects with area greater than 3\n            obj[obj != Color.BLACK] = Color.BLUE\n        else:\n            # Change color to pink for objects with area 3 or less\n            obj[obj != Color.BLACK] = Color.PINK\n        \n        # Place the modified object back into the output grid\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a number of yellow objects with varying sizes\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        # Randomly create a sprite (object) of random size\n        w, h = np.random.randint(1, 5), np.random.randint(1, 5)\n        sprite = random_sprite(w, h, color_palette=[Color.YELLOW], density=0.5)\n\n        # Ensure the sprite is placed in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n            grid = blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no space, try creating a new object\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/19/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/19/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/19/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/19/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/19/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/19/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/19/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/19/images/train_output_2.png"}]}, "index": 19, "seeds": ["aedd82e4", "d2abd087", "e509e548", "a79310a0"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, pattern generation, alignment\n\n# description:\n# In the input you will see a grid with several pixels of different colors in a random arrangement.\n# To make the output grid, count the number of pixels of each color and then generate a line of squares for each color.\n# The number of squares should match the count of each color, arranged in a straight line horizontally across the output grid.\n\ndef main(input_grid):\n    # Count the pixels of each color\n    color_counts = {}\n    for row in input_grid:\n        for color in row:\n            if color != Color.BLACK:  # Ignore background\n                if color in color_counts:\n                    color_counts[color] += 1\n                else:\n                    color_counts[color] = 1\n\n    # Determine the width of the output grid based on color counts\n    total_squares = sum(color_counts.values())\n    output_width = total_squares + 1  # Add one for the background color\n    output_grid = np.full((1, output_width), Color.BLACK)\n\n    # Fill the output grid with squares according to the counts\n    current_index = 0\n    for color, count in color_counts.items():\n        for _ in range(count):\n            output_grid[0, current_index] = color\n            current_index += 1\n    \n    return output_grid\n\n\ndef generate_input():\n    # Randomly generate a grid size\n    n = np.random.randint(5, 10)\n    m = np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose a number of colored pixels\n    num_pixels = np.random.randint(5, 20)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=True)\n\n    # Randomly place the colored pixels in the grid\n    for color in colors:\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/20/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/20/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/20/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/20/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/20/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/20/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/20/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/20/images/train_output_2.png"}]}, "index": 20, "seeds": ["bc1d5164", "3ac3eb23", "ff28f65a", "90c28cc7"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern replication, diagonal mirroring\n\n# description:\n# In the input, you will see a grid with a central pattern surrounded by a border of black pixels. \n# The central pattern will have pixels of varying colors. \n# To make the output, you should replicate the central pattern in each quadrant of the output grid, \n# mirroring it diagonally. The output grid should be twice the size of the input grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the shape of the input grid\n    n, m = input_grid.shape\n\n    # Create an output grid that is twice the size of the input grid\n    output_grid = np.full((2 * n, 2 * m), Color.BLACK)\n\n    # Copy the central pattern into each quadrant of the output grid\n    for i in range(n):\n        for j in range(m):\n            if input_grid[i, j] != Color.BLACK:\n                output_grid[i, j] = input_grid[i, j]  # Top-left\n                output_grid[i, j + m] = input_grid[i, j]  # Top-right\n                output_grid[i + n, j] = input_grid[i, j]  # Bottom-left\n                output_grid[i + n, j + m] = input_grid[i, j]  # Bottom-right\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Randomly generate the size of the central pattern\n    n, m = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    # Create a grid for the central pattern with a black border\n    grid = np.full((n, m), Color.BLACK)\n\n    # Populate the central pattern with random colors\n    colors = np.random.choice(Color.NOT_BLACK, size=(n, m), replace=True)\n    grid = colors\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/21/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/21/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/21/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/21/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/21/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/21/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/21/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/21/images/train_output_2.png"}]}, "index": 21, "seeds": ["bc1d5164", "3de23699", "3ac3eb23", "bd4472b8"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color sorting, alignment\n\n# description:\n# In the input, you will see a black grid with several colored squares randomly placed. \n# To make the output, align the squares from left to right, top to bottom, in order of their colors in the rainbow (red, orange, yellow, green, blue, pink, maroon).\n\ndef main(input_grid):\n    # Find the colored squares in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=False, background=Color.BLACK, connectivity=4)\n\n    # Sort the colors in the order of the rainbow\n    rainbow_order = [Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.BLUE, Color.PINK, Color.MAROON]\n    \n    # Create a dictionary to hold squares by color\n    color_dict = {color: [] for color in rainbow_order}\n\n    # Organize objects by their color\n    for obj in objects:\n        color = obj[0, 0]  # Assuming each object is monochromatic\n        if color in color_dict:\n            color_dict[color].append(obj)\n\n    # Create the output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Place the squares according to the sorted colors\n    current_y = 0\n    current_x = 0\n    for color in rainbow_order:\n        for obj in color_dict[color]:\n            # Get the dimensions of the object\n            obj_height, obj_width = obj.shape\n            # Check if the object fits in the current position\n            if current_x + obj_width \u003e output_grid.shape[1]:\n                current_x = 0\n                current_y += obj_height  # Move to the next row\n            # Blit the object onto the output grid\n            blit_sprite(output_grid, obj, current_x, current_y)\n            current_x += obj_width  # Move to the next column position\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly determine number of colored squares to place\n    num_squares = np.random.randint(5, 15)\n\n    # Available colors excluding black\n    available_colors = Color.NOT_BLACK\n\n    for _ in range(num_squares):\n        color = np.random.choice(available_colors)\n        square = random_sprite(2, 2, density=1.0, color_palette=[color])\n        x, y = random_free_location_for_sprite(grid, square, padding=1)\n        grid = blit_sprite(grid, square, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/22/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/22/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/22/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/22/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/22/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/22/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/22/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/22/images/train_output_2.png"}]}, "index": 22, "seeds": ["8e1813be", "6455b5f5", "7447852a", "fcc82909"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bouncing, reflection\n\n# description:\n# In the input, you will see a red diagonal line pointing at a blue square on a black background.\n# To make the output, shoot outward from the red line, but change the color to orange. Reflect off the blue square.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the objects: the red line and the blue square.\n    # 2. Determine the orientation of the red line and its endpoints.\n    # 3. Shoot an orange line outward until it hits the blue square.\n    # 4. Reflect the orange line off the blue square, continuing in orange.\n\n    red_line = detect_objects(input_grid, colors=[Color.RED], monochromatic=True, connectivity=8)\n    assert len(red_line) == 1, \"There should be exactly one red line\"\n    red_line = list(red_line)[0]\n    blue_square = detect_objects(input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=8)\n    assert len(blue_square) == 1, \"There should be exactly one blue square\"\n    blue_square = list(blue_square)[0]\n\n    output_grid = input_grid.copy()\n\n    # Get the endpoints of the red line\n    x1, y1 = max((x, y) for x, y in np.argwhere(red_line == Color.RED))\n    x2, y2 = min((x, y) for x, y in np.argwhere(red_line == Color.RED))\n    direction12 = (int(np.sign(x2 - x1)), int(np.sign(y2 - y1)))\n    direction21 = (-direction12[0], -direction12[1])\n\n    # Try both (direction, x2, y2) and (-direction, x1, y1) as starting points\n    for (dx, dy), start_x, start_y in [(direction12, x2, y2), (direction21, x1, y1)]:\n        start_x += dx\n        start_y += dy\n        # Loop, shooting lines off the blue square until we run out of the canvas\n        while 0 \u003c= start_x \u003c output_grid.shape[0] and 0 \u003c= start_y \u003c output_grid.shape[1]:\n            stop_x, stop_y = draw_line(output_grid, start_x, start_y, direction=(dx, dy), color=Color.ORANGE, stop_at_color=[Color.BLUE])\n\n            # Reflection geometry depends on if we hit the blue square on our left/right/up/down\n            # did we hit the blue square on our right? \n            if stop_x + 1 \u003c output_grid.shape[0] and output_grid[stop_x + 1, stop_y] != Color.BLACK:\n                dx = -dx\n            # did we hit the blue square on our left?\n            elif stop_x - 1 \u003e= 0 and output_grid[stop_x - 1, stop_y] != Color.BLACK:\n                dx = -dx\n            # did we hit the blue square on our bottom?\n            elif stop_y + 1 \u003c output_grid.shape[1] and output_grid[stop_x, stop_y + 1] != Color.BLACK:\n                dy = -dy\n            # did we hit the blue square on our top?\n            elif stop_y - 1 \u003e= 0 and output_grid[stop_x, stop_y - 1] != Color.BLACK:\n                dy = -dy\n            else:\n                # didn\u0027t do any reflections, so stop\n                break\n\n            start_x, start_y = stop_x + dx, stop_y + dy\n\n    return output_grid\n\ndef generate_input():\n    # Make a grid with a blue square in the center and a red diagonal line pointing at it.\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a blue square in the center\n    square_size = np.random.randint(2, 5)\n    square_x = width // 2 - square_size // 2\n    square_y = height // 2 - square_size // 2\n    grid[square_x:square_x + square_size, square_y:square_y + square_size] = Color.BLUE\n\n    # Create a diagonal line pointing at the blue square\n    line_x_start = np.random.randint(max(0, square_x - 5), min(width, square_x + square_size + 5))\n    line_y_start = 0\n    draw_line(grid, line_x_start, line_y_start, direction=(1, 1), color=Color.RED, length=5)\n\n    # Randomly rotate to get a variety of orientations\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/23/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/23/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/23/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/23/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/23/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/23/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/23/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/23/images/train_output_2.png"}]}, "index": 23, "seeds": ["508bd3b6", "a3df8b1e", "e179c5f4", "6fa7a44f"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection, flipping\n\n# description:\n# In the input, you will see several objects of different colors. Each object is positioned in a way that they can be reflected across a vertical line. \n# To make the output, reflect each object across the vertical midline of the bounding box that contains it.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all the objects in the input grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=background)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj, background=background)\n        sprite = crop(obj, background=background)\n\n        # Reflect the sprite across its vertical midline\n        reflected_sprite = np.fliplr(sprite)\n\n        # Place the reflected sprite in the output grid\n        blit_sprite(output_grid, reflected_sprite, x=x+w, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate between 1 and 5 objects\n    num_objects = np.random.randint(1, 6)\n\n    for _ in range(num_objects):\n        # Randomly generate dimensions for the object\n        width, height = np.random.randint(2, 6), np.random.randint(2, 6)\n\n        # Create a random sprite\n        color = np.random.choice(Color.NOT_BLACK)\n        sprite = random_sprite(width, height, color_palette=[color], density=1.0)\n\n        # Randomly place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=1)\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/24/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/24/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/24/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/24/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/24/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/24/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/24/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/24/images/train_output_2.png"}]}, "index": 24, "seeds": ["e509e548", "8e5a5113", "681b3aeb", "6e19193c"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, rotation, reflection, grid manipulation\n\n# description:\n# In the input you will see a grid with a diamond pattern. Each pixel in the diamond has a different color.\n# To make the output, you should create a new grid where the diamond is rotated 90 degrees clockwise and then reflected horizontally.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the diamond pattern from the input grid\n    # 2. Rotate the diamond 90 degrees clockwise\n    # 3. Reflect the rotated diamond horizontally\n    # 4. Place the transformed diamond in the center of a new output grid\n\n    # 1. Extract the diamond pattern\n    objects = find_connected_components(input_grid, monochromatic=False)\n    assert len(objects) == 1, \"exactly one diamond expected\"\n    diamond = objects[0]\n    diamond_x, diamond_y = object_position(diamond)\n\n    # Create output grid based on the input grid dimensions\n    output_width = input_grid.shape[1]\n    output_height = input_grid.shape[0]\n    output_grid = np.full((output_height, output_width), Color.BLACK)\n\n    # Crop the diamond\n    sprite = crop(diamond)\n\n    # 2. Rotate the diamond 90 degrees clockwise\n    rotated_sprite = np.rot90(sprite, k=-1)\n\n    # 3. Reflect the rotated diamond horizontally\n    reflected_sprite = np.flip(rotated_sprite, axis=1)\n\n    # 4. Place the transformed diamond in the center of the output grid\n    diamond_width, diamond_height = reflected_sprite.shape\n    start_x = (output_width - diamond_width) // 2\n    start_y = (output_height - diamond_height) // 2\n    blit_sprite(output_grid, reflected_sprite, x=start_x, y=start_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colors\n    num_colors = np.random.randint(3, 6)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    # Create a diamond shape in the grid\n    diamond_size = np.random.randint(3, min(width, height) // 2)\n    center_x, center_y = width // 2, height // 2\n\n    for i in range(diamond_size):\n        # Fill the diamond pattern: expanding outwards from the center\n        for j in range(-i, i + 1):\n            if 0 \u003c= center_x + j \u003c width and 0 \u003c= center_y + i \u003c height:\n                grid[center_y + i, center_x + j] = colors[i % num_colors]\n            if 0 \u003c= center_x + j \u003c width and 0 \u003c= center_y - i \u003c height:\n                grid[center_y - i, center_x + j] = colors[i % num_colors]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/25/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/25/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/25/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/25/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/25/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/25/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/25/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/25/images/train_output_2.png"}]}, "index": 25, "seeds": ["e21d9049", "bc1d5164", "3ac3eb23", "feca6190"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid traversal, color filling\n\n# description:\n# In the input, you will see a grid containing two distinct colors representing regions and a single maroon starting point. \n# Your task is to fill the entire region connected to the maroon point with a new color (yellow). \n# If the connected region is blocked by any other color, the fill should stop there.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = input_grid.copy()\n\n    # Identify the start point (maroon)\n    start_point = np.argwhere(output_grid == Color.MAROON)\n\n    assert len(start_point) == 1, \"There should be exactly one starting point (maroon)\"\n\n    start_x, start_y = start_point[0]\n    fill_color = Color.YELLOW\n    original_color = output_grid[start_x, start_y]\n\n    # Using a stack for depth-first search (DFS) to fill the connected region\n    stack = [(start_x, start_y)]\n\n    while stack:\n        x, y = stack.pop()\n        \n        # If we\u0027ve already filled this pixel or it\u0027s not the original color, skip it\n        if output_grid[x, y] != original_color:\n            continue\n        \n        # Fill the pixel with the fill color\n        output_grid[x, y] = fill_color\n\n        # Check all four directions (up, down, left, right)\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_x, new_y = x + dx, y + dy\n            \n            # Ensure we stay within grid bounds\n            if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                stack.append((new_x, new_y))\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of random size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly assign two distinct colors for regions\n    region_colors = [Color.RED, Color.GREEN]\n\n    # Fill the grid with the two colors randomly, ensuring they create distinct regions\n    for _ in range(np.random.randint(3, 6)):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        color = np.random.choice(region_colors)\n\n        # Randomly make a region of size 3x3 or 4x4\n        region_size = np.random.randint(3, 5)\n        for i in range(region_size):\n            for j in range(region_size):\n                if 0 \u003c= x + i \u003c width and 0 \u003c= y + j \u003c height:\n                    grid[x + i, y + j] = color\n\n    # Add a single maroon starting point\n    while True:\n        start_x, start_y = np.random.randint(0, width), np.random.randint(0, height)\n        if grid[start_x, start_y] not in region_colors:  # Ensure it\u0027s not in the existing regions\n            grid[start_x, start_y] = Color.MAROON\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/26/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/26/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/26/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/26/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/26/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/26/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/26/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/26/images/train_output_2.png"}]}, "index": 26, "seeds": ["b782dc8a", "2dd70a9a", "e509e548", "6a1e5592"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, rotation\n\n# description:\n# In the input, you will see a grid containing a shape that is rotated 90 degrees clockwise.\n# To make the output, rotate the shape back to its original orientation (90 degrees counterclockwise).\n\ndef main(input_grid):\n    # Rotate the input grid 90 degrees counterclockwise\n    output_grid = np.rot90(input_grid, k=1)  # k=1 rotates 90 degrees counterclockwise\n    return output_grid\n\ndef generate_input():\n    # Randomly generate a grid with a shape that is rotated 90 degrees clockwise\n    original_width = np.random.randint(3, 6)\n    original_height = np.random.randint(3, 6)\n    \n    # Create an original grid with a shape (not just a random fill)\n    original_shape = random_sprite(original_width, original_height, density=0.5, symmetry=\u0027not_symmetric\u0027, color_palette=Color.NOT_BLACK)\n    \n    # Rotate the original shape 90 degrees clockwise to create the input grid\n    input_grid = np.rot90(original_shape, k=-1)  # k=-1 rotates 90 degrees clockwise\n    \n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/27/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/27/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/27/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/27/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/27/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/27/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/27/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/27/images/train_output_2.png"}]}, "index": 27, "seeds": ["eb281b96", "6fa7a44f", "9f236235", "44f52bb0"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color blending, pattern separation, grid manipulation\n\n# description:\n# In the input, you will see two separate vertical patterns of blue pixels each 5 cells tall, \n# with a separator of black pixels in between. The patterns are on the left and right sides of the grid. \n# To create the output grid, you should blend the colors of the two patterns where they occur. \n# The blending rule is as follows: \n# - If both patterns are blue, the output should be yellow.\n# - If one pattern is blue and the other is black, the output should be blue.\n# - If both patterns are black, the output should be black.\n# The output grid will have the same height as the input but will only have one column width.\n\ndef main(input_grid):\n    height = input_grid.shape[0]\n    \n    # Initialize the output grid\n    output_grid = np.zeros((height, 1), dtype=int)\n\n    # Split the input grid into left and right patterns\n    left_pattern = input_grid[:, :input_grid.shape[1] // 2]\n    right_pattern = input_grid[:, input_grid.shape[1] // 2 + 1:]\n\n    # Process each row and determine the output color based on the blending rules\n    for y in range(height):\n        left_color = left_pattern[y, 0]\n        right_color = right_pattern[y, 0]\n        \n        if left_color == Color.BLUE and right_color == Color.BLUE:\n            output_grid[y, 0] = Color.YELLOW  # Both patterns are blue\n        elif left_color == Color.BLUE:\n            output_grid[y, 0] = Color.BLUE  # Left pattern blue, right black\n        elif right_color == Color.BLUE:\n            output_grid[y, 0] = Color.BLUE  # Right pattern blue, left black\n        else:\n            output_grid[y, 0] = Color.BLACK  # Both patterns are black\n\n    return output_grid\n\n\ndef generate_input():\n    # Define grid dimensions\n    width = 6  # 3 for the left pattern + 1 for separator + 3 for the right pattern\n    height = 5  # Fixed height for the patterns\n\n    # Create an empty grid\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Randomly assign blue or black to the left and right patterns\n    for y in range(height):\n        # Left pattern (first 3 columns)\n        left_color = np.random.choice([Color.BLUE, Color.BLACK])\n        input_grid[y, :3] = left_color\n\n        # Right pattern (last 3 columns)\n        right_color = np.random.choice([Color.BLUE, Color.BLACK])\n        input_grid[y, 4:] = right_color\n\n    # Set the separator column to black\n    input_grid[:, 3] = Color.BLACK\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/28/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/28/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/28/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/28/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/28/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/28/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/28/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/28/images/train_output_2.png"}]}, "index": 28, "seeds": ["3428a4f5", "ff28f65a", "db3e9e38", "995c5fa3"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nimport random\nfrom typing import *\n\n# concepts:\n# horizontal bars, longest segment extraction\n\n# description:\n# In the input you will see several horizontal bars of different colors.\n# To make the output, find the longest horizontal bar and output it.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    longest_length = 0\n    longest_bar_color = None\n\n    # Iterate over each row to find the longest horizontal bar\n    for row in input_grid:\n        current_color = None\n        current_length = 0\n        \n        for pixel in row:\n            if pixel != Color.BLACK:\n                if pixel == current_color:\n                    current_length += 1\n                else:\n                    # Check if the current bar is longer than the longest found so far\n                    if current_length \u003e longest_length:\n                        longest_length = current_length\n                        longest_bar_color = current_color\n                    \n                    # Reset for the new color\n                    current_color = pixel\n                    current_length = 1\n            else:\n                # If we encounter a black pixel, check for the longest bar\n                if current_length \u003e longest_length:\n                    longest_length = current_length\n                    longest_bar_color = current_color\n                \n                # Reset on encountering black\n                current_color = None\n                current_length = 0\n\n        # Final check at the end of the row\n        if current_length \u003e longest_length:\n            longest_length = current_length\n            longest_bar_color = current_color\n    \n    # If we found a longest bar, fill it in the output grid\n    if longest_bar_color is not None:\n        for i in range(input_grid.shape[1]):\n            output_grid[0, i] = longest_bar_color  # Place the longest bar at the first row for visibility\n        # Draw the longest bar in the output grid\n        output_grid[0, :longest_length] = longest_bar_color\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    grid_height = np.random.randint(5, 10)\n    grid_width = np.random.randint(10, 20)\n    grid = np.zeros((grid_height, grid_width), dtype=int)\n\n    # Randomly generate horizontal bars\n    for i in range(grid_height):\n        # Randomly decide on the length of the bar and the color\n        bar_length = np.random.randint(1, grid_width // 2)\n        color = random.choice(Color.NOT_BLACK)\n\n        # Random position to place the bar\n        start_col = np.random.randint(0, grid_width - bar_length)\n        grid[i, start_col:start_col + bar_length] = color\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/29/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/29/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/29/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/29/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/29/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/29/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/29/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/29/images/train_output_2.png"}]}, "index": 29, "seeds": ["06df4c85", "0a938d79", "1a07d186", "178fcbfb"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# concentric shapes, non-black background\n\n# description:\n# In the input you will see a non-black background with a single colored pixel located at the center of the grid.\n# To create the output, draw concentric squares around this pixel, each square being one pixel wider than the last, using the same color as the center pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the center pixel and its color\n    # 2. Draw concentric squares around the center pixel\n\n    # Find the center pixel (assuming the grid size is odd)\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    center_color = input_grid[center_x, center_y]\n\n    # Create a copy of the input grid to draw on\n    output_grid = input_grid.copy()\n\n    # Draw concentric squares\n    for size in range(1, min(center_x, center_y) + 1):\n        for dx in range(-size, size + 1):\n            output_grid[center_x + dx, center_y - size] = center_color  # top edge\n            output_grid[center_x + dx, center_y + size] = center_color  # bottom edge\n        for dy in range(-size, size + 1):\n            output_grid[center_x - size, center_y + dy] = center_color  # left edge\n            output_grid[center_x + size, center_y + dy] = center_color  # right edge\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a random non-black background\n    background_color = np.random.choice(Color.NOT_BLACK)\n    width, height = np.random.randint(3, 30, size=2)\n    # Ensure the grid has odd dimensions to have a clear center\n    if width % 2 == 0:\n        width += 1\n    if height % 2 == 0:\n        height += 1\n    \n    input_grid = np.full((width, height), background_color)\n\n    # Place a colored pixel in the center\n    center_color = np.random.choice(Color.NOT_BLACK)\n    input_grid[width // 2, height // 2] = center_color\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/30/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/30/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/30/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/30/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/30/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/30/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/30/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/30/images/train_output_2.png"}]}, "index": 30, "seeds": ["ea786f4a", "623ea044", "2c608aff", "feca6190"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity, color matching, horizontal/vertical lines\n\n# description:\n# In the input, you will see a pair of horizontal lines on the edges of the canvas and yellow pixels randomly placed in between these lines. \n# Change the color of each yellow pixel to match the color of the line it is closest to.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Copy the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the positions of the horizontal lines by removing yellow pixels\n    line_positions = np.where((input_grid != Color.YELLOW) \u0026 (input_grid != Color.BLACK))\n    \n    # Get the unique y-coordinates of the horizontal lines\n    horizontal_line_y = set(line_positions[0])\n\n    # Iterate through the grid to find yellow pixels and change their color\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] == Color.YELLOW:\n                # Find the closest horizontal line\n                closest_line_y = min(horizontal_line_y, key=lambda line_y: abs(line_y - x))\n                # Get the color of the closest line\n                output_grid[x, y] = input_grid[closest_line_y, y]\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a black grid as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose two colors for the horizontal lines\n    line_colors = random.sample([color for color in Color.ALL_COLORS if color != Color.BLACK and color != Color.YELLOW], 2)\n\n    # Draw two horizontal lines at random rows\n    top_line_row = np.random.randint(0, n//2)\n    bottom_line_row = np.random.randint(n//2, n)\n\n    grid[top_line_row, :] = line_colors[0]\n    grid[bottom_line_row, :] = line_colors[1]\n\n    # Sprinkle yellow pixels randomly between the two lines\n    for _ in range(random.randint(5, 20)):\n        x = np.random.randint(top_line_row + 1, bottom_line_row)  # Ensure yellow pixels are between the lines\n        y = np.random.randint(0, m)\n        grid[x, y] = Color.YELLOW\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/31/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/31/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/31/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/31/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/31/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/31/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/31/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/31/images/train_output_2.png"}]}, "index": 31, "seeds": ["2204b7a8", "2c608aff", "8d510a79", "23581191"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, radial expansion, color sequence\n\n# description:\n# In the input you will see a grid with a central point that has a different color. Each surrounding pixel of the central pixel has a different color. \n# To make the output, you should expand those surrounding colors radially outward in all directions, repeating the color sequence as you go.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the central pixel and surrounding colors in the input grid.\n    # 2. Create an output grid that is larger than the input grid to accommodate the expansion.\n    # 3. For each surrounding color, expand it radially outward from the central pixel according to its position.\n\n    # 1. Identify the central pixel\n    objects = find_connected_components(input_grid, monochromatic=False)\n    assert len(objects) == 1, \"exactly one central object expected\"\n    central_object = objects[0]\n    central_x, central_y = object_position(central_object)\n\n    # Create output grid, larger than the input grid\n    output_width = input_grid.shape[0] + 6  # adding space for expansion\n    output_height = input_grid.shape[1] + 6\n    output_grid = np.full((output_width, output_height), Color.BLACK)\n\n    # 2. Extract surrounding colors\n    surrounding_colors = []\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx != 0 or dy != 0):\n                if (0 \u003c= central_x + dx \u003c input_grid.shape[0] and\n                    0 \u003c= central_y + dy \u003c input_grid.shape[1]):\n                    color = input_grid[central_x + dx, central_y + dy]\n                    if color != Color.BLACK:\n                        surrounding_colors.append(color)\n\n    # 3. Expanding each surrounding color radially outward\n    for index, color in enumerate(surrounding_colors):\n        radius = index + 1  # radius starts from 1\n        # Draw in a diamond shape (Manhattan distance)\n        for x_offset in range(-radius, radius + 1):\n            for y_offset in range(-radius, radius + 1):\n                if abs(x_offset) + abs(y_offset) == radius:  # diamond shape condition\n                    output_grid[central_x + x_offset + 3, central_y + y_offset + 3] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = 5, 5\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose colors for the central and surrounding pixels\n    central_color = np.random.choice(Color.NOT_BLACK)\n    surrounding_colors = np.random.choice(Color.NOT_BLACK, size=8, replace=False)\n\n    # Set the central pixel\n    grid[2, 2] = central_color\n\n    # Set the surrounding pixels\n    offsets = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    for idx, (dx, dy) in enumerate(offsets):\n        grid[2 + dx, 2 + dy] = surrounding_colors[idx]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/32/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/32/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/32/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/32/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/32/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/32/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/32/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/32/images/train_output_2.png"}]}, "index": 32, "seeds": ["e21d9049", "3ac3eb23", "feca6190", "bc1d5164"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object separation, color matching, boundary detection\n\n# description:\n# In the input, you will see a grid with several objects of different colors, some of which overlap with a specific color (blue).\n# To make the output, separate any objects that overlap with the blue object, and change their color to match the color of the blue object.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Detect the blue object in the grid\n    blue_objects = detect_objects(input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=8)\n    \n    # There should only be one blue object detected in the grid.\n    assert len(blue_objects) == 1\n    blue_object = blue_objects[0]\n\n    # Detect all other objects that overlap with the blue object\n    other_objects = detect_objects(input_grid, colors=Color.NOT_BLACK, monochromatic=True, connectivity=8)\n\n    # Change the color of any overlapping objects to match the blue object\n    for obj in other_objects:\n        if contact(object1=blue_object, object2=obj, connectivity=8):\n            # Change color to match blue\n            obj_color = object_colors(blue_object)[0]\n            mask = obj != Color.BLACK\n            output_grid[mask] = obj_color\n            \n    return output_grid\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a black background.\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Create a blue object\n    blue_sprite = random_sprite(n=3, m=3, density=0.5, color_palette=[Color.BLUE])\n    \n    # Place the blue object at a random location\n    x, y = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK)\n    blit_sprite(grid, blue_sprite, x, y)\n\n    # Randomly generate overlapping objects of different colors\n    num_objects = np.random.randint(3, 6)\n    for _ in range(num_objects):\n        sprite = random_sprite(n=3, m=3, density=0.5, color_palette=[c for c in Color.NOT_BLACK if c != Color.BLUE])\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        \n        # Blit the sprite onto the grid, allowing overlapping\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/33/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/33/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/33/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/33/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/33/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/33/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/33/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/33/images/train_output_2.png"}]}, "index": 33, "seeds": ["1f642eb9", "48d8fb45", "776ffc46", "e509e548"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# Largest area detection, filling\n\n# description:\n# In the input you will see a grid filled with random colored pixels (mostly blue).\n# The goal is to identify the largest contiguous area of black cells \n# (where a cell is adjacent to another black cell either vertically or horizontally)\n# and fill that area with the color yellow.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find all connected components of black pixels\n    black_components = find_connected_components(input_grid, background=Color.BLUE, connectivity=4, monochromatic=True)\n\n    # Identify the largest component\n    largest_component = max(black_components, key=lambda component: np.sum(component == Color.BLACK))\n\n    # Create an output grid based on the input grid\n    output_grid = np.copy(input_grid)\n\n    # Fill the largest component with yellow\n    output_grid[largest_component == Color.BLACK] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Set the random seed for reproducibility\n    np.random.seed()\n\n    # Generate a grid of random size\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((n, m), Color.BLUE)  # Fill the grid with blue pixels\n\n    # Randomly scatter black pixels in the grid\n    # The density of black pixels will determine the size of the largest area\n    density = np.random.uniform(0.2, 0.5)\n    num_black_pixels = int(density * n * m)\n\n    for _ in range(num_black_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLACK  # Assign black color to randomly chosen cells\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/34/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/34/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/34/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/34/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/34/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/34/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/34/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/34/images/train_output_2.png"}]}, "index": 34, "seeds": ["6455b5f5", "db93a21d", "3eda0437", "8e1813be"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sorting, size classification\n\n# description:\n# In the input, you will see a grid filled with various colored objects of different sizes. \n# To produce the output grid, sort the objects by their area from left to right and color them according \n# to a preset color sequence: small objects are colored red, medium objects are colored yellow, \n# and large objects are colored blue.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find all objects in the input grid\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n\n    # Classify objects by size\n    small_objects = []\n    medium_objects = []\n    large_objects = []\n    \n    for obj in objects:\n        area = np.sum(obj == Color.GREEN)  # Assuming the objects are initially colored green\n        if area \u003c 10:\n            small_objects.append(obj)\n        elif area \u003c 20:\n            medium_objects.append(obj)\n        else:\n            large_objects.append(obj)\n\n    # Define the color mapping\n    color_mapping = {Color.RED: small_objects, Color.YELLOW: medium_objects, Color.BLUE: large_objects}\n    sorted_objects = [(Color.RED, small_objects), (Color.YELLOW, medium_objects), (Color.BLUE, large_objects)]\n\n    # Calculate the current x position for placing objects in the output grid\n    current_x = 0\n    \n    for color, objects_list in sorted_objects:\n        for obj in objects_list:\n            # Calculate the bounding box and crop the object\n            x, y, w, h = bounding_box(obj)\n            sprite = crop(obj, background=Color.BLACK)\n\n            # Color the object with the designated color\n            sprite[sprite == Color.GREEN] = color\n            \n            # Place the object in the output grid\n            blit_sprite(output_grid, sprite, x=current_x, y=(output_grid.shape[0] - h) // 2, background=Color.BLACK)\n\n            # Move current_x to the right for the next object\n            current_x += w\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.full((n, m), Color.BLACK)\n\n    # The objects will be green\n    object_color = Color.GREEN\n\n    for _ in range(random.randint(3, 6)):\n        # Randomly generate an object with a certain area\n        area = np.random.randint(1, 40)\n        width = np.random.randint(1, 8)\n        height = area // width if area % width == 0 else area // width + 1\n\n        # Generate sprite with the object color\n        sprite = random_sprite(width, height, color_palette=[object_color], density=0.5, symmetry=\"not_symmetric\")\n\n        # Randomly place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8)\n\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/35/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/35/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/35/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/35/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/35/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/35/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/35/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/35/images/train_output_2.png"}]}, "index": 35, "seeds": ["e509e548", "6455b5f5", "8e1813be", "137eaa0f"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color inversion\n\n# description:\n# In the input you will see a grid with various colored objects.\n# To produce the output grid, identify all the objects that are blue and change their color to orange. \n# Additionally, invert the colors of all non-blue pixels in the grid.\n\ndef main(input_grid):\n    # First, we find all the connected components in the grid.\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change color of blue objects to orange and invert other colors\n    for obj in objects:\n        if np.any(obj == Color.BLUE):\n            # Change blue to orange\n            obj[obj == Color.BLUE] = Color.ORANGE\n            # Blit this modified object to output grid\n            output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n        else:\n            # Invert the color of non-blue objects\n            inverted_colors = np.where(obj != Color.BLACK, Color.NOT_BLACK - obj, Color.BLACK)\n            output_grid = blit_object(output_grid, inverted_colors, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid size of 8x8\n    grid_size = 8\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # Randomly place colored objects in the grid\n    colors = [Color.BLUE, Color.RED, Color.GREEN, Color.YELLOW, Color.ORANGE, Color.GREY, Color.PINK]\n    num_objects = np.random.randint(1, 6)  # Number of objects to create\n\n    for _ in range(num_objects):\n        # Create a random sprite with a random color from the palette\n        sprite_width, sprite_height = np.random.randint(1, 4), np.random.randint(1, 4)\n        sprite_color = np.random.choice(colors)\n        sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[sprite_color], density=1)\n\n        # Randomly place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n            blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n        except ValueError:\n            continue  # If no space is found, skip this sprite\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/36/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/36/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/36/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/36/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/36/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/36/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/36/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/36/images/train_output_2.png"}]}, "index": 36, "seeds": ["a79310a0", "6455b5f5", "aedd82e4", "6e82a1ae"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, color replacement, grid manipulation\n\n# description:\n# In the input, you will see a colored object in the center of the grid and a single pixel in the bottom right corner of a different color.\n# To make the output, remove the pixel from the bottom right corner and color the object in the center with the color from the pixel you removed.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the pixel in the bottom right corner\n    color = output_grid[-1, -1]\n\n    # Remove the pixel from the bottom right corner\n    output_grid[-1, -1] = Color.BLACK\n\n    # Color the object in the middle with the color of the pixel from the bottom right corner\n    # First, we find the bounding box of the object\n    x, y, width, height = bounding_box(output_grid != Color.BLACK)\n\n    # Use flood fill to color the object with the new color\n    output_grid = np.where(output_grid == Color.BLACK, output_grid, color)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid with a defined size\n    n = m = 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the sprite\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Select a color for the corner pixel\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Ensure colors are different\n    if sprite_color == corner_color:\n        return generate_input()\n    \n    # Generate random sprite and place it in the middle of the grid\n    sprite = random_sprite(n - 2, m - 2, density=0.5, color_palette=[sprite_color])\n    blit_sprite(grid, sprite, x=1, y=1)\n\n    # Place a single pixel in the bottom right corner\n    grid[-1, -1] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/37/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/37/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/37/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/37/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/37/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/37/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/37/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/37/images/train_output_2.png"}]}, "index": 37, "seeds": ["aabf363d", "623ea044", "3de23699", "264363fd_Kevin"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color diffusion\n\n# description:\n# In the input you will see a grid with several colored pixels, some of which are green. \n# To make the output, for each green pixel, change the color of the four adjacent pixels (up, down, left, right) to a new color (for example, orange). \n# If the adjacent pixel is already a color, it will remain unchanged.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x][y] == Color.GREEN:\n                # Change the colors of adjacent pixels to orange if they are not already colored\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    neighbor_x = x + dx\n                    neighbor_y = y + dy\n                    if 0 \u003c= neighbor_x \u003c input_grid.shape[0] and 0 \u003c= neighbor_y \u003c input_grid.shape[1]:\n                        if output_grid[neighbor_x, neighbor_y] == Color.BLACK:\n                            output_grid[neighbor_x, neighbor_y] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly scatter green pixels in the grid\n    num_green_pixels = np.random.randint(1, 6)\n    for _ in range(num_green_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.GREEN\n\n    # Optionally scatter some other colors (not black or green)\n    num_other_pixels = np.random.randint(5, 20)\n    for _ in range(num_other_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = np.random.choice([color for color in Color.NOT_BLACK if color != Color.GREEN])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/38/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/38/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/38/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/38/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/38/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/38/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/38/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/38/images/train_output_2.png"}]}, "index": 38, "seeds": ["29c11459", "834ec97d", "0ca9ddb6", "6cdd2623"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color inversion, object detection\n\n# description:\n# In the input you will see a grid with multicolored objects on a yellow background. \n# To make the output, invert the colors of each object, changing yellow to black and vice versa.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find all connected components (objects) in the grid that are not the background (yellow).\n    # 2. For each object, invert its colors. Change yellow pixels to black and all other colors to their inverted counterparts.\n\n    background = Color.YELLOW\n    objects = find_connected_components(input_grid, background=background, connectivity=8, monochromatic=False)\n\n    # Create a copy of the input grid to draw on\n    output_grid = input_grid.copy()\n\n    # Invert colors for each object found\n    for obj in objects:\n        # Get the colors of the object\n        obj_colors = object_colors(obj, background=background)\n        \n        # Create a color inversion mapping\n        inversion_map = {color: Color.YELLOW if color == Color.BLACK else Color.BLACK for color in Color.ALL_COLORS}\n        for color in obj_colors:\n            if color != background:\n                inverted_color = inversion_map[color]\n                # Apply the inverted color to the object in the output grid\n                output_grid[obj == color] = inverted_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with a yellow background and a few randomly placed colored objects\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.YELLOW)\n\n    num_objects = np.random.randint(1, 5)  # Random number of objects\n    for _ in range(num_objects):\n        # Create a random sprite object\n        sprite_width, sprite_height = np.random.randint(2, 6), np.random.randint(2, 6)\n        colors = np.random.choice(Color.NOT_BLACK, size=np.random.randint(1, 4), replace=False)  # Choose random colors\n        \n        sprite = random_sprite(sprite_width, sprite_height, color_palette=colors, symmetry=\"not_symmetric\")\n        \n        # Find a free location in the grid to place the sprite\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.YELLOW)\n        blit_sprite(grid, sprite, x, y, background=Color.YELLOW)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/39/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/39/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/39/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/39/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/39/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/39/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/39/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/39/images/train_output_2.png"}]}, "index": 39, "seeds": ["b775ac94", "1f642eb9", "6455b5f5", "e8dc4411"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape completion, color propagation\n\n# description:\n# In the input, you will see a grid with an incomplete circular shape. \n# To produce the output grid, complete the circle using the color of the existing part of the circle.\n\ndef main(input_grid):\n    # Find the bounding box of the incomplete circle to extract the sprite\n    x, y, width, height = bounding_box(grid=input_grid)\n    circle_sprite = input_grid[x:x + width, y:y + height]\n\n    # Identify the color of the existing part of the circle\n    circle_color = np.unique(circle_sprite[circle_sprite != Color.BLACK])\n\n    if len(circle_color) == 0:\n        return input_grid  # If no color found, return the input grid as is.\n\n    circle_color = circle_color[0]  # Take the first color found\n\n    # Complete the circle by replacing the black pixels with the circle color\n    completed_circle_sprite = np.where(circle_sprite == Color.BLACK, circle_color, circle_sprite)\n\n    # Make the output by copying the sprite to a new canvas\n    output_grid = np.copy(input_grid)\n    output_grid = blit_sprite(grid=output_grid, sprite=completed_circle_sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a size of n x m\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a circle with a small radius\n    radius = np.random.randint(2, 5)\n\n    # Create the center of the circle\n    center_x, center_y = np.random.randint(radius, n - radius), np.random.randint(radius, m - radius)\n\n    # Draw a circle with a certain density\n    for x in range(center_x - radius, center_x + radius + 1):\n        for y in range(center_y - radius, center_y + radius + 1):\n            if (x - center_x) ** 2 + (y - center_y) ** 2 \u003c= radius ** 2:\n                if np.random.rand() \u003c 0.5:  # 50% chance to leave the pixel black (incomplete circle)\n                    grid[x, y] = Color.BLACK\n                else:\n                    grid[x, y] = Color.TEAL  # Color of the existing part of the circle\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/40/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/40/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/40/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/40/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/40/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/40/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/40/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/40/images/train_output_2.png"}]}, "index": 40, "seeds": ["6d75e8bb", "941d9a10", "eb5a1d5d", "6455b5f5"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, perimeter calculation, color change\n\n# description:\n# The input consists of a grid containing several yellow and black objects. \n# To create the output, find all yellow objects and change the color of the objects \n# with a perimeter of 8 or greater to red, while changing the color of all other yellow objects to green.\n\ndef main(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all yellow objects in the grid\n    yellow_objects = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    for obj in yellow_objects:\n        # Get the bounding box of the yellow object\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        \n        # Calculate the perimeter of the object\n        perimeter = 2 * (w + h)\n\n        # Change color based on perimeter\n        if perimeter \u003e= 8:\n            obj[obj != Color.BLACK] = Color.RED\n        else:\n            obj[obj != Color.BLACK] = Color.GREEN\n\n        # Place the colored object back into the output grid\n        blit_sprite(output_grid, obj, x=x, y=y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size n x m\n    n, m = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly generate yellow objects in the grid\n    for _ in range(np.random.randint(2, 6)):\n        while True:\n            # Create a random sprite representing a yellow object\n            sprite = random_sprite(np.random.randint(2, 5), np.random.randint(2, 5), color_palette=[Color.YELLOW])\n            x, y = random_free_location_for_sprite(grid, sprite)\n\n            # Place the object in the grid\n            grid = blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n            # Break the loop after placing the object\n            break\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/41/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/41/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/41/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/41/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/41/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/41/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/41/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/41/images/train_output_2.png"}]}, "index": 41, "seeds": ["aedd82e4", "d2abd087", "e509e548", "6455b5f5"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern detection, corner filling\n\n# description:\n# In the input you will see a grid with a pattern in the center surrounded by black pixels.\n# To make the output, you should replicate the pattern in each of the four corners of the output grid.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Determine the size of the input grid\n    height, width = input_grid.shape\n\n    # Calculate the center of the grid\n    center_x, center_y = height // 2, width // 2\n\n    # Define the size of the pattern (assume it\u0027s a square pattern)\n    # This assumes the pattern is the largest monochromatic connected component in the center\n    pattern_size = min(center_x, center_y)\n\n    # Crop the pattern from the center\n    pattern = crop(input_grid[center_x - pattern_size // 2:center_x + pattern_size // 2 + 1,\n                              center_y - pattern_size // 2:center_y + pattern_size // 2 + 1])\n\n    # Fill the four corners with the detected pattern\n    blit_sprite(output_grid, pattern, x=0, y=0)  # Top-left corner\n    blit_sprite(output_grid, pattern, x=0, y=height - pattern.shape[0])  # Bottom-left corner\n    blit_sprite(output_grid, pattern, x=width - pattern.shape[1], y=0)  # Top-right corner\n    blit_sprite(output_grid, pattern, x=width - pattern.shape[1], y=height - pattern.shape[0])  # Bottom-right corner\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of random size between 7x7 and 15x15\n    size = np.random.randint(7, 16)\n    grid = np.full((size, size), Color.BLACK)\n\n    # Define the size of the pattern in the center\n    pattern_size = np.random.randint(3, size // 2)\n\n    # Create a random pattern in the center\n    center_x, center_y = size // 2, size // 2\n    pattern = random_sprite(n=pattern_size, m=pattern_size, density=0.5, connectivity=4)\n\n    # Place the pattern in the center of the grid\n    blit_sprite(grid, pattern, x=center_x - pattern_size // 2, y=center_y - pattern_size // 2)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/42/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/42/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/42/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/42/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/42/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/42/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/42/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/42/images/train_output_2.png"}]}, "index": 42, "seeds": ["1e32b0e9", "bc1d5164", "28e73c20", "eb281b96"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boolean logical operations, bitmasks with separator\n\n# description:\n# Compute the OR operation of two grids separated by a yellow line. In the output, color the cells blue where at least one of the grids has that color, \n# and color the cells black where both grids are black. The input consists of two patterns, one on top and one on the bottom separated by a horizontal yellow line.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    height, width = input_grid.shape\n\n    # Locate the yellow horizontal separator\n    for y_bar in range(height):\n        if np.all(input_grid[y_bar, :] == Color.YELLOW):\n            break\n\n    # Extract the top and bottom patterns\n    top_pattern = input_grid[:y_bar, :]\n    bottom_pattern = input_grid[y_bar + 1:, :]\n\n    output_grid = np.zeros_like(top_pattern)\n\n    # Apply the OR operation\n    output_grid[(top_pattern != Color.BLACK) | (bottom_pattern != Color.BLACK)] = Color.BLUE\n    output_grid[(top_pattern == Color.BLACK) \u0026 (bottom_pattern == Color.BLACK)] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the grid size\n    width = 5  \n    height = 13  # 6 top + 1 yellow line + 6 bottom\n\n    # Initialize an empty grid\n    input_grid = np.full((height, width), Color.BLACK)\n\n    # Randomly assign colors to the top and bottom patterns\n    for x in range(width):\n        for y in range(height):\n            if y \u003c height // 2:  # Top pattern\n                input_grid[y, x] = np.random.choice([Color.BLACK, Color.BLUE, Color.RED, Color.GREEN])\n            elif y \u003e height // 2:  # Bottom pattern\n                input_grid[y, x] = np.random.choice([Color.BLACK, Color.BLUE, Color.RED, Color.GREEN])\n\n    # Set the yellow horizontal line\n    input_grid[height // 2, :] = Color.YELLOW\n\n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/43/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/43/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/43/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/43/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/43/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/43/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/43/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/43/images/train_output_2.png"}]}, "index": 43, "seeds": ["3428a4f5", "06df4c85", "7447852a", "00d62c1b"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color extraction, pixel stacking, grid transformation\n\n# description:\n# In the input you will see a grid containing several vertical columns of colored pixels.\n# To make the output, create a new grid where each column of the output corresponds to a column of the input. \n# Each pixel in the output will be stacked vertically, filling from the bottom up, and the colors will be in the order they appear from left to right.\n\ndef main(input_grid):\n    # Determine the size of the input grid\n    input_height, input_width = input_grid.shape\n    \n    # Create an output grid with the same width but height equal to the sum of the non-black pixels in each column\n    output_height = 0\n    for x in range(input_width):\n        output_height += np.count_nonzero(input_grid[:, x] != Color.BLACK)\n\n    output_grid = np.full((output_height, input_width), Color.BLACK)\n\n    # Fill the output grid by stacking the colors from the bottom up\n    current_row = output_height - 1\n    for x in range(input_width):\n        # Get the colors in the column, ignoring black pixels\n        column_colors = input_grid[:, x][input_grid[:, x] != Color.BLACK]\n        for color in column_colors:\n            output_grid[current_row, x] = color\n            current_row -= 1\n    \n    return output_grid\n\ndef generate_input():\n    # Initialize the grid with random dimensions\n    height = np.random.randint(5, 10)\n    width = np.random.randint(3, 6)\n    grid = np.full((height, width), Color.BLACK)\n\n    # Randomly choose colors for vertical columns\n    for x in range(width):\n        # Randomly decide the number of colored pixels in this column\n        num_colored_pixels = np.random.randint(1, height + 1)\n        colors = np.random.choice(Color.NOT_BLACK, size=num_colored_pixels, replace=False)\n        \n        # Fill the column from the bottom up\n        for y in range(num_colored_pixels):\n            grid[height - 1 - y, x] = colors[y]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/44/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/44/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/44/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/44/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/44/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/44/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/44/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/44/images/train_output_2.png"}]}, "index": 44, "seeds": ["746b3537", "8e1813be", "feca6190", "3ac3eb23"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, rotation, stacking\n\n# description:\n# In the input you will see several colored shapes scattered around a grid filled with black pixels. Each shape has a distinct color and is represented with a 3x3 area. The task is to stack these shapes on top of each other, aligning them by their centers, while ensuring that the output grid contains all stacked shapes in the smallest possible bounding box. The colors of the shapes should remain distinct in the output.\n\ndef main(input_grid):\n    # Step 1: Detect all shapes in the input grid\n    shapes = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n\n    # Step 2: Create a list to hold the cropped shapes\n    cropped_shapes = [crop(shape, background=Color.BLACK) for shape in shapes]\n\n    # Step 3: Create a new output grid\n    max_height = sum(sprite.shape[0] for sprite in cropped_shapes)\n    max_width = max(sprite.shape[1] for sprite in cropped_shapes)\n    output_grid = np.full((max_height, max_width), Color.BLACK)\n\n    # Step 4: Stack each shape on top of each other\n    current_y = 0\n    for sprite in cropped_shapes:\n        # Calculate the center of the output grid\n        center_x = output_grid.shape[1] // 2\n        # Calculate the x offset to center the sprite\n        x_offset = center_x - (sprite.shape[1] // 2)\n        \n        # Blit the sprite onto the output grid\n        blit_sprite(output_grid, sprite, x=x_offset, y=current_y)\n        current_y += sprite.shape[0]  # Move down for the next shape\n\n    # Step 5: Crop to the smallest bounding box containing all shapes\n    return crop(output_grid, background=Color.BLACK)\n\ndef generate_input():\n    # Create a grid and randomly place several distinct colored shapes in it\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Generate a random number of distinct shapes\n    num_shapes = np.random.randint(3, 6)\n    for _ in range(num_shapes):\n        color = random.choice(Color.NOT_BLACK)\n        # Create a 3x3 sprite with the chosen color\n        sprite = random_sprite(3, 3, density=0.5, color_palette=[color], background=Color.BLACK)\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=4)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            continue  # Skip if there\u0027s no free location\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/45/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/45/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/45/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/45/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/45/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/45/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/45/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/45/images/train_output_2.png"}]}, "index": 45, "seeds": ["48d8fb45", "1cf80156", "97a05b5b", "137eaa0f"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern generation, concentric shapes\n\n# description:\n# In the input you will see a grid with a single colored pixel.\n# To make the output, you should create concentric squares around the pixel:\n# step 1: draw a square of the pixel\u0027s color, centered at the pixel\u0027s position.\n# step 2: draw additional squares of increasing size around the original square (with a period of 2 pixels), alternating colors from a predefined color palette.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Extract the pixel\u0027s position and color.\n    # 2. Draw concentric squares around the pixel.\n\n    # 1. Extract the pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # Prepare the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[pixel_x, pixel_y] = pixel_color  # Set the center pixel\n\n    # 2. Draw concentric squares\n    colors = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW]  # Predefined colors for squares\n    square_size = 1  # Start with 1 pixel square\n    color_index = 0  # To alternate colors\n\n    while True:\n        # The top-left and bottom-right corners of the square\n        top_left_x = pixel_x - square_size\n        top_left_y = pixel_y - square_size\n        bottom_right_x = pixel_x + square_size\n        bottom_right_y = pixel_y + square_size\n        \n        # Check if we are still within the grid boundaries\n        if (top_left_x \u003c 0 or top_left_y \u003c 0 or \n            bottom_right_x \u003e= output_grid.shape[0] or \n            bottom_right_y \u003e= output_grid.shape[1]):\n            break  # Stop if the next square goes out of bounds\n\n        # Draw the square using the current color\n        square_color = colors[color_index % len(colors)]\n        \n        # Draw the top and bottom sides\n        draw_line(output_grid, x=top_left_x, y=top_left_y, direction=(1, 0), color=square_color, length=square_size*2)\n        draw_line(output_grid, x=top_left_x, y=bottom_right_y, direction=(1, 0), color=square_color, length=square_size*2)\n        \n        # Draw the left and right sides\n        draw_line(output_grid, x=top_left_x, y=top_left_y, direction=(0, 1), color=square_color, length=square_size*2)\n        draw_line(output_grid, x=bottom_right_x, y=top_left_y, direction=(0, 1), color=square_color, length=square_size*2)\n\n        # Increase square size and change color for the next square\n        square_size += 2  # Increase size for the next square\n        color_index += 1  # Move to next color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the color for the center pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the pixel anywhere in the grid\n    x = np.random.randint(0, width)\n    y = np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/46/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/46/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/46/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/46/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/46/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/46/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/46/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/46/images/train_output_2.png"}]}, "index": 46, "seeds": ["3ac3eb23", "1bfc4729", "8403a5d5", "834ec97d"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reflection, vertical mirroring\n\n# description:\n# In the input you will see a grid with a pattern of colors and a black border. \n# To make the output, reflect the pattern vertically (mirror it) and place the mirrored pattern next to the original pattern.\n\ndef main(input_grid):\n    # Extract the pattern from the input grid (assuming a black border)\n    pattern = input_grid[1:-1, 1:-1]  # Remove the black border\n\n    # Reflect the pattern vertically\n    mirrored_pattern = pattern[::-1, :]\n\n    # Create the output grid\n    output_height, output_width = pattern.shape\n    output_grid = np.full((output_height, output_width * 2), Color.BLACK)\n\n    # Place the original pattern on the left\n    output_grid[:, :output_width] = pattern\n\n    # Place the mirrored pattern on the right\n    output_grid[:, output_width:] = mirrored_pattern\n\n    return output_grid\n\ndef generate_input():\n    # Create a random pattern of colors with a black border\n    n = np.random.randint(3, 6)  # height of the pattern\n    m = np.random.randint(3, 6)  # width of the pattern\n    pattern = random_sprite(n, m, density=1.0, color_palette=Color.NOT_BLACK)\n\n    # Create an output grid with a black border\n    grid = np.full((n + 2, m + 2), Color.BLACK)  # Add 2 for the border\n\n    # Place the pattern in the center of the grid\n    grid[1:-1, 1:-1] = pattern\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/47/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/47/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/47/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/47/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/47/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/47/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/47/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/47/images/train_output_2.png"}]}, "index": 47, "seeds": ["eb281b96", "8e5a5113", "6fa7a44f", "bc1d5164"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity, color transformation, stacking\n\n# description:\n# In the input, you will see a grid with several colored pixels scattered across the grid. To make the output, make all the colored pixels fall to the bottom of the grid like gravity is pulling them. If multiple colored pixels fall into the same column, they will stack on top of each other, and their color will change to yellow upon stacking.\n\ndef main(input_grid):\n    # Create an output grid initialized with the background color (black)\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    width, height = input_grid.shape\n\n    # Process each column to let colored pixels fall\n    for x in range(width):\n        # Keep track of the current height for stacking\n        current_height = height - 1\n        \n        # Iterate from the bottom to the top of the column\n        for y in range(height - 1, -1, -1):\n            if input_grid[x, y] != Color.BLACK:\n                # When a colored pixel is found, place it at the current height\n                output_grid[x, current_height] = Color.YELLOW  # Change color to yellow upon stacking\n                current_height -= 1  # Move up to the next stack position\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid with random colored pixels scattered throughout\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly determine how many colored pixels to add\n    num_pixels = np.random.randint(5, 20)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=True)\n\n    # Scatter the colored pixels randomly in the grid\n    for color in colors:\n        x = np.random.randint(0, width)\n        y = np.random.randint(0, height)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/48/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/48/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/48/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/48/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/48/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/48/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/48/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/48/images/train_output_2.png"}]}, "index": 48, "seeds": ["3ac3eb23", "f15e1fac", "4093f84a", "3618c87e"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation, circular rotation\n\n# description:\n# In the input, you will see a grid with a single colored pixel.\n# To create the output, generate a circular pattern around the colored pixel with the same color, \n# and rotate it 45 degrees counter-clockwise.\n\ndef main(input_grid):\n    # Extract the single colored pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n    \n    # Define the output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    \n    # Define the size of the circular pattern\n    radius = 3  # You can change this value for different sizes\n\n    # Draw the circular pattern around the pixel\n    for angle in range(0, 360, 45):\n        # Convert angle to radians\n        rad = np.radians(angle)\n        # Calculate the x, y offsets using polar coordinates\n        offset_x = int(radius * np.cos(rad))\n        offset_y = int(radius * np.sin(rad))\n        # Position to place the pixel in the output grid\n        output_x = pixel_x + offset_x\n        output_y = pixel_y + offset_y\n        \n        # Check if the position is within grid boundaries\n        if 0 \u003c= output_x \u003c output_grid.shape[0] and 0 \u003c= output_y \u003c output_grid.shape[1]:\n            output_grid[output_x, output_y] = pixel_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose one color\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the pixel on the grid\n    x, y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy/49/images/test_input.png", "output": "output/synthetic_examples/barc_heavy/49/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy/49/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy/49/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy/49/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy/49/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy/49/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy/49/images/train_output_2.png"}]}, "index": 49, "seeds": ["3ac3eb23", "834ec97d", "a9f96cdd", "6fa7a44f"], "source": "barc_heavy", "source_description": "Examples generated by the Heavy model", "source_display_name": "BARC Heavy", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, pattern manipulation, color matching\n\n# description:\n# In the input, you will see a pattern composed of a small grid of colored pixels and a larger grid below it filled with a single color. \n# To make the output, you should scale the small grid by a factor of 2 and attempt to fit it into the larger grid. \n# The output should replace the original color of the larger grid with the colors from the scaled small grid wherever they overlap.\n\ndef main(input_grid):\n    # Step 1: Identify the small pattern and the larger grid\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    small_pattern = max(objects, key=lambda obj: obj.size)  # Assume the largest connected component is the small pattern\n    small_sprite = crop(small_pattern, background=Color.BLACK)\n\n    # Step 2: Scale the small pattern\n    scaled_sprite = scale_sprite(small_sprite, factor=2)\n\n    # Step 3: Create output grid based on the size of the larger grid\n    output_grid = input_grid.copy()\n\n    # Identify the position of the small pattern in the input grid\n    small_x, small_y = object_position(small_pattern, background=Color.BLACK)\n\n    # Step 4: Attempt to overlay the scaled pattern onto the output grid\n    for x in range(scaled_sprite.shape[0]):\n        for y in range(scaled_sprite.shape[1]):\n            input_x = small_x + x\n            input_y = small_y + y\n\n            # Only replace the pixels in the output grid if they are not black\n            if 0 \u003c= input_x \u003c output_grid.shape[0] and 0 \u003c= input_y \u003c output_grid.shape[1]:\n                if scaled_sprite[x, y] != Color.BLACK:\n                    output_grid[input_x, input_y] = scaled_sprite[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a small sprite and a large canvas to hold it\n    small_sprite_size = np.random.randint(2, 4)\n    colors = np.random.choice(list(Color.NOT_BLACK), size=small_sprite_size, replace=False)\n\n    # Create a small random sprite with the chosen colors\n    small_sprite = np.random.choice(colors + [Color.BLACK], size=(small_sprite_size, small_sprite_size))\n\n    # Create a larger grid (at least 2x the size of the small sprite)\n    large_grid_size = small_sprite_size * 2\n    output_grid = np.full((large_grid_size, large_grid_size), Color.BLACK)\n\n    # Randomly place the small sprite in the larger grid\n    x, y = random_free_location_for_sprite(output_grid, small_sprite, background=Color.BLACK)\n    blit_sprite(output_grid, small_sprite, x, y)\n\n    return output_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/0/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/0/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/0/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/0/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/0/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/0/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/0/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/0/images/train_output_2.png"}]}, "index": 0, "seeds": ["bc1d5164", "bd4472b8", "3ac3eb23", "e21d9049"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color matching, object transformation, overlapping\n\n# description:\n# In the input, you will see a grid with a small object (a colored sprite) and several colored tags scattered around.\n# Your task is to match the colors of the object to the tags by moving, rotating, and scaling the object, covering as many tags as possible.\n# The output should contain the tags covered by the transformed object, with the object\u0027s color replacing the tags\u0027 colors.\n\ndef main(input_grid):\n    # Step 1: Detect the small object and the tags\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, background=background, monochromatic=False)\n    \n    # Identify the main object by detecting the one with the most variety of colors\n    main_object = max(objects, key=lambda obj: len(object_colors(obj, background=background)))\n    main_colors = object_colors(main_object, background=background)\n\n    output_grid = np.copy(input_grid)\n\n    # Step 2: Generate transformations of the main object\n    transformations = []\n    for scale in range(1, 5):  # Scale from 1 to 4\n        for rotation in range(4):  # Rotate 0 to 3 times (90 degrees)\n            transformed_object = np.rot90(scale_sprite(main_object, scale), rotation)\n            transformations.append(transformed_object)\n\n    # Step 3: Try to place each transformation on the grid\n    for transformed_object in transformations:\n        for x in range(output_grid.shape[0] - transformed_object.shape[0] + 1):\n            for y in range(output_grid.shape[1] - transformed_object.shape[1] + 1):\n                # Check if the transformed object can be placed\n                can_place = True\n                for dx in range(transformed_object.shape[0]):\n                    for dy in range(transformed_object.shape[1]):\n                        if transformed_object[dx, dy] != background:\n                            if output_grid[x + dx, y + dy] == background:\n                                continue\n                            elif output_grid[x + dx, y + dy] in main_colors:\n                                continue\n                            else:\n                                can_place = False\n                                break\n                    if not can_place:\n                        break\n                \n                # Place the transformed object if it can\n                if can_place:\n                    blit_sprite(output_grid, transformed_object, x, y, background=background)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid and place a small object and several colored tags\n    width, height = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a small object with multiple colors\n    object_sprite = random_sprite(n=[2, 3], m=[2, 3], density=1, color_palette=list(Color.NOT_BLACK), background=Color.BLACK)\n    x, y = random_free_location_for_sprite(grid, object_sprite, background=Color.BLACK)\n    blit_sprite(grid, object_sprite, x, y, background=Color.BLACK)\n\n    # Add colored tags around\n    n_tags = np.random.randint(5, 15)\n    for _ in range(n_tags):\n        tag_color = np.random.choice(list(Color.NOT_BLACK))\n        tag = np.array([[tag_color]])\n        tag_x, tag_y = random_free_location_for_sprite(grid, tag, background=Color.BLACK)\n        blit_sprite(grid, tag, tag_x, tag_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/1/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/1/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/1/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/1/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/1/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/1/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/1/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/1/images/train_output_2.png"}]}, "index": 1, "seeds": ["d4a91cb9", "23581191", "834ec97d", "2dd70a9a"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object placement, line drawing, color matching\n\n# description:\n# In the input, you will see a grid with a single green pixel and a single red pixel.\n# To make the output, draw a vertical line from the green pixel to the bottom of the grid\n# and a horizontal line from the red pixel to the right edge of the grid. \n# Finally, place a blue square (2x2 pixels) at the intersection of these two lines.\n\ndef main(input_grid):\n    # Make a copy of the input grid to create the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the positions of the green and red pixels\n    green_pixel = np.argwhere(input_grid == Color.GREEN)[0]\n    red_pixel = np.argwhere(input_grid == Color.RED)[0]\n\n    green_x, green_y = green_pixel\n    red_x, red_y = red_pixel\n\n    # Draw vertical line from the green pixel to the bottom of the grid\n    for y in range(green_y, output_grid.shape[0]):\n        output_grid[green_x, y] = Color.GREEN\n\n    # Draw horizontal line from the red pixel to the right edge of the grid\n    for x in range(red_x, output_grid.shape[1]):\n        output_grid[x, red_y] = Color.RED\n\n    # Place a blue 2x2 square at the intersection of the two lines\n    intersection_x = green_x\n    intersection_y = red_y\n    \n    # Ensure we don\u0027t go out of bounds when placing the blue square\n    if intersection_x + 1 \u003c output_grid.shape[0] and intersection_y + 1 \u003c output_grid.shape[1]:\n        blit_object(output_grid, np.full((2, 2), Color.BLUE), background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black grid as the background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly place a green pixel\n    green_x, green_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[green_x, green_y] = Color.GREEN\n\n    # Randomly place a red pixel but not in the same row or column as the green pixel\n    red_x, red_y = np.random.randint(0, n), np.random.randint(0, m)\n    while red_x == green_x or red_y == green_y:\n        red_x, red_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[red_x, red_y] = Color.RED\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/2/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/2/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/2/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/2/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/2/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/2/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/2/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/2/images/train_output_2.png"}]}, "index": 2, "seeds": ["6cdd2623", "834ec97d", "623ea044", "23581191"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, connected components, color transformation\n\n# description:\n# The input consists of a black grid with a few colored irregular shapes (connected components).\n# To produce the output grid, fill in the smallest colored shapes with green, and fill in the largest colored shapes with yellow.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # 1. Find all colored connected components (non-black)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n\n    # 2. Get the areas of each object\n    object_areas = [np.sum(obj != Color.BLACK) for obj in objects]\n\n    # 3. Find the smallest and largest areas\n    smallest_area = min(object_areas)\n    largest_area = max(object_areas)\n\n    # 4. Create a new output grid filled with black background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 5. Fill in the smallest and largest colored shapes with their respective colors\n    for obj in objects:\n        area = np.sum(obj != Color.BLACK)\n        if area == smallest_area:\n            obj[obj != Color.BLACK] = Color.GREEN  # Fill smallest with green\n        elif area == largest_area:\n            obj[obj != Color.BLACK] = Color.YELLOW  # Fill largest with yellow\n\n        # Blit the transformed object back onto the output grid\n        blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a grid of size between 10x10 and 20x20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_shapes = np.random.randint(3, 8)  # Number of colored shapes\n\n    for _ in range(num_shapes):\n        # Random color for the shape\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Random size for the shape (width and height)\n        width = np.random.randint(3, 6)\n        height = np.random.randint(3, 6)\n\n        # Create a random shape with a filled rectangle\n        shape = np.full((width, height), color)\n        \n        # Randomly place the shape in the grid\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK)\n\n        # Blit the shape into the grid\n        blit_sprite(grid, shape, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/3/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/3/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/3/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/3/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/3/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/3/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/3/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/3/images/train_output_2.png"}]}, "index": 3, "seeds": ["025d127b", "834ec97d", "6d58a25d", "feca6190"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, object placement, color manipulation\n\n# description:\n# In the input, you will see a small 3x3 blue object and a large green square that is a multiple of the size of the blue object.\n# The task is to scale the blue object to match the size of the green square and place it inside the green square.\n# Return just the green square (with the rescaled blue object placed inside it).\n\ndef main(input_grid):\n    # Step 1: Detect the large green square and the small blue object\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n    \n    # Step 2: Separate them into the green square and the blue object\n    for obj in objects:\n        sprite = obj\n        if Color.GREEN in object_colors(sprite):\n            green_square = sprite\n        elif Color.BLUE in object_colors(sprite):\n            blue_object = sprite\n            \n    # Step 3: Calculate the scaling factor\n    scale = (green_square.shape[0] - 2) // blue_object.shape[0]  # minus border pixels\n\n    # Step 4: Scale the blue object\n    scaled_blue_object = scale_sprite(blue_object, factor=scale)\n\n    # Step 5: Create the output grid and place the green square and the scaled blue object\n    output_grid = np.full(green_square.shape, Color.BLACK)\n    blit_sprite(output_grid, green_square, x=0, y=0, background=Color.BLACK)\n    blit_sprite(output_grid, scaled_blue_object, x=1, y=1, background=Color.BLACK)  # center the scaled object\n\n    return output_grid\n\ndef generate_input():\n    # Step 1: Initialize the grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)    \n\n    # Step 2: Create the small blue object and the large green square\n    small_object_size = 3\n    availabe_scales = range(2, 5)  # scaling factors for the green square\n    scale = np.random.choice(availabe_scales)\n\n    # Step 3: Create the green square frame\n    big_green_square = np.full((scale * small_object_size + 2, scale * small_object_size + 2), Color.GREEN)\n    big_green_square[1:-1, 1:-1] = Color.BLACK  # inner part is black\n\n    # Step 4: Randomly place the green square in the grid\n    x_square, y_square = random_free_location_for_sprite(grid, big_green_square)\n    grid = blit_sprite(grid, big_green_square, x=x_square, y=y_square, background=Color.BLACK)\n\n    # Step 5: Create the small blue object and place it in the grid\n    blue_object = np.full((small_object_size, small_object_size), Color.BLUE)\n    x, y = random_free_location_for_sprite(grid, blue_object)\n    grid = blit_sprite(grid, blue_object, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/4/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/4/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/4/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/4/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/4/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/4/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/4/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/4/images/train_output_2.png"}]}, "index": 4, "seeds": ["834ec97d", "8d510a79", "1fad071e", "0ca9ddb6"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# circular patterns, concentric circles\n\n# description:\n# In the input, you will see a grid with various colored circular patterns. The goal is to identify any circular patterns and draw concentric circles around their centers, \n# where the radius of the concentric circles will increase by 1 for each additional circle drawn. The circles will have the color blue.\n\ndef main(input_grid):\n    output_grid = input_grid.copy()\n    \n    # Find all connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n\n    for obj in objects:\n        # Check if the bounding box of the object forms a circular pattern\n        obj_x, obj_y, obj_width, obj_height = bounding_box(obj, background=Color.BLACK)\n        if obj_width == obj_height:  # Check for circular shape\n            # Calculate the center of the object\n            center_x = obj_x + obj_width // 2\n            center_y = obj_y + obj_height // 2\n            \n            # Draw concentric circles around the center of the circular pattern\n            for radius in range(1, 4):  # Draw 3 concentric circles\n                circle_sprite = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n                for x in range(-radius, radius + 1):\n                    for y in range(-radius, radius + 1):\n                        if x ** 2 + y ** 2 \u003c= radius ** 2:  # Check if inside the circle\n                            circle_sprite[y + radius, x + radius] = Color.BLUE\n                \n                # Blit the circle sprite to the output grid\n                x_offset = center_x - radius\n                y_offset = center_y - radius\n                output_grid = blit_sprite(output_grid, circle_sprite, x=x_offset, y=y_offset, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a black 10x10 grid as background\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Randomly generate circular patterns\n    num_circles = np.random.randint(1, 5)\n    for _ in range(num_circles):\n        # Randomly choose a size for the circular pattern\n        radius = np.random.randint(2, 4)\n        circular_sprite = np.zeros((2 * radius + 1, 2 * radius + 1), dtype=int)\n\n        # Fill the circular sprite with a random color\n        color = np.random.choice(Color.NOT_BLACK)\n        for x in range(-radius, radius + 1):\n            for y in range(-radius, radius + 1):\n                if x ** 2 + y ** 2 \u003c= radius ** 2:  # Check if inside the circle\n                    circular_sprite[y + radius, x + radius] = color\n        \n        # Place the circular sprite randomly on the grid\n        x, y = random_free_location_for_sprite(grid, circular_sprite, padding=1)\n        grid = blit_sprite(grid, circular_sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/5/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/5/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/5/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/5/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/5/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/5/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/5/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/5/images/train_output_2.png"}]}, "index": 5, "seeds": ["44f52bb0", "72ca375d", "4c5c2cf0", "6855a6e4"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, color tracking\n\n# description:\n# In the input, you will see a grid with multiple colored pixels. Among these, one pixel is designated as the \"anchor\" - this is indicated by a blue pixel.\n# To make the output, for every other colored pixel, you should draw a yellow line from that pixel towards the anchor pixel (the blue pixel) until it reaches the anchor.\n# If the line intersects with another colored pixel, it should stop at that pixel\u0027s position and change that pixel to orange.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Find the position of the anchor pixel (blue)\n    anchor_pos = np.argwhere(input_grid == Color.BLUE)\n    if anchor_pos.size == 0:\n        return output_grid  # No anchor found, return the original grid\n\n    anchor_x, anchor_y = anchor_pos[0]\n\n    # Iterate through the grid to find all colored pixels\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if (x, y) != (anchor_x, anchor_y) and input_grid[x, y] != Color.BLACK:\n                # Draw a line from (x, y) towards the anchor (anchor_x, anchor_y)\n                dx = np.sign(anchor_x - x)\n                dy = np.sign(anchor_y - y)\n\n                # Move towards the anchor\n                curr_x, curr_y = x, y\n                while (0 \u003c= curr_x \u003c input_grid.shape[0]) and (0 \u003c= curr_y \u003c input_grid.shape[1]):\n                    # Stop if we hit the anchor\n                    if (curr_x, curr_y) == (anchor_x, anchor_y):\n                        break\n\n                    # If we encounter another colored pixel, stop and change it to orange\n                    if output_grid[curr_x, curr_y] != Color.BLACK and (curr_x, curr_y) != (x, y):\n                        output_grid[curr_x, curr_y] = Color.ORANGE\n                        break\n\n                    # Move towards the anchor\n                    curr_x += dx\n                    curr_y += dy\n\n                # Finally color the pixel we started from with yellow if it is not already colored\n                if output_grid[x, y] != Color.ORANGE:\n                    output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Scatter some colored pixels\n    num_pixels = np.random.randint(5, 15)\n    for _ in range(num_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.BLUE])\n        grid[x, y] = color\n    \n    # Place one blue pixel as the anchor\n    anchor_x, anchor_y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[anchor_x, anchor_y] = Color.BLUE\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/6/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/6/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/6/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/6/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/6/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/6/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/6/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/6/images/train_output_2.png"}]}, "index": 6, "seeds": ["0ca9ddb6", "d9f24cd1", "834ec97d", "b527c5c6"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# grid transformation, bounding box, color inversion\n\n# description:\n# In the input, you\u0027ll see a grid containing a colored pattern (a collection of pixels).\n# To make the output, first, find the bounding box of the colored pixels, then invert the colors of the pixels within this bounding box.\n# Finally, replace the original grid with the transformed area, leaving the rest of the grid unchanged.\n\ndef main(input_grid):\n    # 1. Find the bounding box of the colored pixels\n    bounding_box = bounding_box_mask(input_grid, background=Color.BLACK)\n    \n    # 2. Create an output grid that is identical to the input grid\n    output_grid = input_grid.copy()\n\n    # 3. Invert the colors within the bounding box\n    for x in range(bounding_box.shape[0]):\n        for y in range(bounding_box.shape[1]):\n            if bounding_box[x, y]:\n                # Get the current color\n                current_color = input_grid[x, y]\n                # Invert the color: if it\u0027s not black, set it to black, otherwise set it to a random color\n                if current_color != Color.BLACK:\n                    output_grid[x, y] = Color.BLACK\n                else:\n                    output_grid[x, y] = Color.RED  # Example of replacing black with a specific color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random dimensions\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly determine the number of colored pixels\n    num_colored_pixels = np.random.randint(1, width * height // 2)\n    \n    # Randomly color some pixels in the grid\n    for _ in range(num_colored_pixels):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/7/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/7/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/7/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/7/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/7/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/7/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/7/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/7/images/train_output_2.png"}]}, "index": 7, "seeds": ["9f236235", "29c11459", "44f52bb0", "834ec97d"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel connection, border detection\n\n# description:\n# In the input you will see a grid with various colored pixels and black background.\n# To make the output, retain only the colored pixels that are connected to at least one other colored pixel.\n# This means that isolated colored pixels should be removed, leaving only groups of connected colors.\n\ndef main(input_grid):\n    # Create an output grid initialized to the background color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Find all colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    for x, y in colored_pixels:\n        # Create an object for the current pixel\n        obj = np.full(input_grid.shape, Color.BLACK)\n        obj[x, y] = input_grid[x, y]\n\n        # Find the neighbors of this object\n        neighbors_mask = object_neighbors(obj, connectivity=4, background=Color.BLACK)\n\n        # Check if there are colored neighbors\n        if np.any(input_grid[neighbors_mask] != Color.BLACK):\n            # If it has at least one colored neighbor, keep this pixel\n            output_grid[x, y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random grid size\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colored pixels\n    num_pixels = np.random.randint(20, 50)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=True)\n\n    # Randomly place colored pixels in the grid\n    for color in colors:\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/8/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/8/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/8/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/8/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/8/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/8/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/8/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/8/images/train_output_2.png"}]}, "index": 8, "seeds": ["8e1813be", "746b3537", "3ac3eb23", "6fa7a44f"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# border detection, pattern transformation, pixel manipulation\n\n# description:\n# In the input, you will see a grid with various colored pixel shapes. Each shape has a border of black pixels.\n# To create the output grid, you should find the outer border of each shape, and then fill in the inner area with the same color as the border pixels.\n# Additionally, the black border itself should be removed from the output.\n\ndef main(input_grid):\n    # Step 1: Find connected components (shapes) in the input grid\n    shapes = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    \n    # Create an output grid with the same shape as the input, initially filled with black\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    for shape in shapes:\n        # Step 2: Detect the color of the shape\n        shape_color = object_colors(shape)[0]\n\n        # Step 3: Find the border pixels of the shape\n        border_mask = object_neighbors(shape, background=Color.BLACK)\n\n        # Step 4: Fill the inner area of the shape with the shape\u0027s color\n        for x in range(input_grid.shape[0]):\n            for y in range(input_grid.shape[1]):\n                if shape[x, y] == shape_color and not border_mask[x, y]:\n                    output_grid[x, y] = shape_color\n                elif border_mask[x, y]:\n                    output_grid[x, y] = shape_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with random shapes\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n    \n    # Randomly create several shapes\n    num_shapes = np.random.randint(1, 5)  # Number of shapes to create\n    for _ in range(num_shapes):\n        shape_color = np.random.choice(Color.NOT_BLACK)\n        shape_size = np.random.randint(2, 5)\n\n        # Create a shape (e.g., a filled rectangle) with a black border\n        start_x = np.random.randint(0, width - shape_size)\n        start_y = np.random.randint(0, height - shape_size)\n\n        # Draw a shape with a black border\n        for x in range(shape_size):\n            for y in range(shape_size):\n                if x == 0 or x == shape_size - 1 or y == 0 or y == shape_size - 1:\n                    grid[start_x + x, start_y + y] = Color.BLACK\n                else:\n                    grid[start_x + x, start_y + y] = shape_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/9/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/9/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/9/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/9/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/9/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/9/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/9/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/9/images/train_output_2.png"}]}, "index": 9, "seeds": ["46f33fce", "bc1d5164", "e21d9049", "3ac3eb23"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# drawing, filling, connected components\n\n# description:\n# In the input grid, you will see several disconnected gray shapes on a black background.\n# To create the output, draw a blue border around each gray shape and fill each shape with green.\n# Additionally, if a shape is surrounded by any gray shapes, fill it with yellow instead.\n\ndef main(input_grid):\n    # Step 1: Find all the gray shapes in the input grid\n    gray_shapes = find_connected_components(input_grid, background=Color.BLACK, monochromatic=True)\n\n    # Step 2: Initialize the output grid with a black background\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for shape in gray_shapes:\n        # Step 3: Draw a blue border around the gray shape\n        x, y, width, height = bounding_box(shape)\n        border_coordinates = [(x-1, y-1), (x+width, y-1), (x-1, y+height), (x+width, y+height)]\n        \n        # Draw top and bottom borders\n        draw_line(output_grid, x-1, y-1, x+width, y-1, color=Color.BLUE)\n        draw_line(output_grid, x-1, y+height, x+width, y+height, color=Color.BLUE)\n        \n        # Draw left and right borders\n        draw_line(output_grid, x-1, y-1, x-1, y+height, color=Color.BLUE)\n        draw_line(output_grid, x+width, y-1, x+width, y+height, color=Color.BLUE)\n\n        # Step 4: Fill the shape with green or yellow based on surrounding shapes\n        # Check for surrounding gray shapes\n        surrounding_shapes = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n        is_surrounded = any(np.any(shape == surrounding_shape) for surrounding_shape in surrounding_shapes if surrounding_shape is not shape)\n\n        # Fill with yellow if surrounded by gray shapes, otherwise fill with green\n        fill_color = Color.YELLOW if is_surrounded else Color.GREEN\n        shape[shape == Color.GREY] = fill_color  # Fill the shape with the chosen color\n\n        # Blit the filled shape back onto the output grid\n        blit_object(output_grid, shape, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid of size 10x10\n    grid = np.full((10, 10), Color.BLACK)\n\n    # Randomly generate gray shapes in the grid\n    # The number of shapes\n    num_shapes = np.random.randint(3, 6)\n\n    for _ in range(num_shapes):\n        # Generate a random sprite (shape) and place it on the grid\n        shape = random_sprite(n=list(range(2, 5)), m=list(range(2, 5)), density=0.5, color_palette=[Color.GREY])\n        \n        # Find a random free location for the shape\n        x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n        \n        # Blit the shape onto the grid\n        grid = blit_sprite(grid, shape, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/10/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/10/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/10/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/10/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/10/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/10/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/10/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/10/images/train_output_2.png"}]}, "index": 10, "seeds": ["d2abd087", "6455b5f5", "137eaa0f", "941d9a10"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry restoration, color propagation\n\n# description:\n# In the input you will see a symmetric pattern of colors that has been partially occluded by a black rectangle.\n# The output should be the missing part of the pattern, filled in with the appropriate colors from the original symmetric pattern.\n# The output should have the same dimensions as the black rectangle, and restore the color symmetry.\n\ndef main(input_grid):\n    # Step 1: Identify the black rectangle that occludes part of the grid\n    occlusion_color = Color.BLACK\n    black_rectangle_mask = (input_grid == occlusion_color)\n\n    # Step 2: Detect the symmetries in the input grid (excluding the occlusion color)\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n\n    # Step 3: For each point in the black rectangle, find its symmetric points and restore the color\n    for occluded_x, occluded_y in np.argwhere(black_rectangle_mask):\n        for symmetric_x, symmetric_y in orbit(input_grid, occluded_x, occluded_y, symmetries):\n            if input_grid[symmetric_x, symmetric_y] != occlusion_color:\n                input_grid[occluded_x, occluded_y] = input_grid[symmetric_x, symmetric_y]\n                break\n\n    # Step 4: Extract the filled-in region that corresponds to the black rectangle\n    filled_in_region = np.full_like(input_grid, occlusion_color)\n    filled_in_region[black_rectangle_mask] = input_grid[black_rectangle_mask]\n    filled_in_region = crop(filled_in_region, background=occlusion_color)\n\n    return filled_in_region\n\ndef generate_input():\n    # Step 1: Create a random sprite\n    w, h = np.random.randint(2, 5, size=(2))\n    sprite = random_sprite(w, h, color_palette=Color.NOT_BLACK, density=1)\n\n    # Step 2: Tile the sprite to create a symmetric pattern\n    horizontal_repetitions, vertical_repetitions = np.random.randint(2, 5, size=(2))\n    pattern = np.tile(sprite, (horizontal_repetitions, vertical_repetitions))\n\n    # Step 3: Randomly occlude part of the pattern with a black rectangle\n    w_occluder, h_occluder = np.random.randint(2, 5, size=(2))\n    x_occluder, y_occluder = np.random.randint(0, pattern.shape[0] - w_occluder + 1), np.random.randint(0, pattern.shape[1] - h_occluder + 1)\n    black_rectangle_sprite = np.full((w_occluder, h_occluder), Color.BLACK)\n    blit_sprite(pattern, black_rectangle_sprite, x_occluder, y_occluder, background=None)\n\n    return pattern", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/11/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/11/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/11/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/11/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/11/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/11/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/11/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/11/images/train_output_2.png"}]}, "index": 11, "seeds": ["e21d9049", "746b3537", "8e1813be", "90c28cc7"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, rotation, spatial transformation\n\n# description:\n# In the input grid, you will see a monochromatic pattern that is symmetric along the y-axis. \n# To make the output, rotate the pattern 90 degrees clockwise and maintain the symmetry.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the symmetric pattern along the y-axis.\n    # 2. Rotate the identified pattern 90 degrees clockwise.\n    # 3. Use blit_object to place the rotated pattern into the output grid.\n\n    # 1. Find connected components that are symmetric\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    assert len(objects) == 1, \"There should be exactly one symmetric object.\"\n    \n    symmetric_object = objects[0]\n    \n    # 2. Rotate the symmetric object 90 degrees clockwise\n    rotated_pattern = np.rot90(symmetric_object, k=-1)  # k = -1 for 90 degrees clockwise\n\n    # Create the output grid, which should have the same size as the input grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # 3. Use blit_object to place the rotated pattern into the output grid\n    blit_object(output_grid, rotated_pattern, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Create a random grid of a symmetric monochromatic object\n    grid = np.full((np.random.randint(10, 20), np.random.randint(10, 20)), Color.BLACK)\n\n    # Generate a symmetric pattern\n    symmetric_sprite = random_sprite(range(3, 6), range(3, 6),\n                                     color_palette=[random.choice(Color.NOT_BLACK)], connectivity=4, \n                                     symmetry=\"vertical\")    \n\n    # Randomly place the symmetric object in the grid\n    x, y = random_free_location_for_sprite(grid, symmetric_sprite, background=Color.BLACK)\n    blit_sprite(grid, symmetric_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/12/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/12/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/12/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/12/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/12/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/12/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/12/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/12/images/train_output_2.png"}]}, "index": 12, "seeds": ["4c5c2cf0", "6fa7a44f", "681b3aeb", "caa06a1f"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, object detection, color transformation\n\n# description:\n# In the input you will see a grid with a large blue frame and a small pattern in the center.\n# The output should be a new grid where the small pattern is scaled to fit inside the blue frame,\n# and the blue frame should be turned into green.\n\ndef main(input_grid):\n    # Detect the blue frame and the inner pattern\n    objects = detect_objects(input_grid, monochromatic=True, connectivity=8)\n    \n    # Initialize variables to store the frames and patterns\n    blue_frame = None\n    inner_pattern = None\n    \n    for obj in objects:\n        sprite = crop(obj, background=Color.BLACK)\n        colors = object_colors(sprite, background=Color.BLACK)\n        \n        if Color.BLUE in colors:\n            blue_frame = sprite\n        elif len(colors) \u003e 0:\n            inner_pattern = sprite\n    \n    # Calculate the scaling factor based on the size of the blue frame and the pattern\n    scale = (len(blue_frame) - 2) // len(inner_pattern)\n    \n    # Scale the inner pattern to fit into the blue frame\n    scaled_pattern = scale_sprite(inner_pattern, factor=scale)\n    \n    # Create the output grid, changing the blue frame to green\n    output_grid = np.full(blue_frame.shape, Color.BLACK)\n    output_grid[blue_frame == Color.BLUE] = Color.GREEN\n    \n    # Place the scaled pattern into the green frame\n    blit_sprite(output_grid, scaled_pattern, x=1, y=1, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a random size\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)    \n\n    # Create a blue frame around the grid\n    blue_frame_size = np.random.randint(3, 6) * 2 + 1  # Ensure it\u0027s odd to have a center\n    blue_frame = np.full((blue_frame_size, blue_frame_size), Color.BLUE)\n    blue_frame[1:-1, 1:-1] = Color.BLACK  # Inner part is black\n    \n    # Randomly place the blue frame in the grid\n    x_pos = np.random.randint(0, n - blue_frame_size)\n    y_pos = np.random.randint(0, m - blue_frame_size)\n    grid = blit_sprite(grid, blue_frame, x=x_pos, y=y_pos, background=Color.BLACK)\n\n    # Generate a small pattern inside the blue frame\n    inner_pattern_size = 3  # Fixed size for simplicity\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.BLUE]\n    random_color = np.random.choice(available_colors)\n\n    # Create a random pattern\n    inner_pattern = random_sprite(n=inner_pattern_size, m=inner_pattern_size, color_palette=[random_color], density=0.5)\n    \n    # Place the inner pattern in the center of the blue frame\n    center_x = x_pos + (blue_frame_size // 2) - (inner_pattern_size // 2)\n    center_y = y_pos + (blue_frame_size // 2) - (inner_pattern_size // 2)\n    grid = blit_sprite(grid, inner_pattern, x=center_x, y=center_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/13/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/13/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/13/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/13/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/13/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/13/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/13/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/13/images/train_output_2.png"}]}, "index": 13, "seeds": ["3de23699", "25d8a9c8", "780d0b14", "6cdd2623"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shapes, reflection, transformation\n\n# description:\n# In the input, you will see a grid consisting of various colored shapes.\n# The goal is to reflect each shape across the vertical axis of the grid and draw the mirrored shapes next to the originals.\n\ndef main(input_grid):\n    # Create a copy of the input grid for the output\n    output_grid = np.copy(input_grid)\n\n    # Find connected components (shapes) in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=Color.BLACK)\n\n    # Get the width of the input grid\n    input_width = input_grid.shape[1]\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, w, h = bounding_box(obj)\n\n        # Crop the object to extract the sprite\n        sprite = crop(obj)\n\n        # Calculate the position where the mirrored shape should be placed\n        mirror_x = input_width - (x + w)\n\n        # Use blit_sprite to place the mirrored sprite in the output grid\n        blit_sprite(output_grid, sprite, x=mirror_x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a blank grid\n    grid_width, grid_height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((grid_height, grid_width), Color.BLACK)\n\n    # Generate a number of random shapes\n    num_shapes = np.random.randint(3, 6)  # Number of shapes to create\n\n    for _ in range(num_shapes):\n        # Create a random shape (object)\n        shape_width, shape_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Generate a random sprite\n        sprite = random_sprite(shape_width, shape_height, density=1, color_palette=[color])\n\n        # Find a random free position for the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite)\n\n        # Blit the sprite onto the grid\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/14/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/14/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/14/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/14/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/14/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/14/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/14/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/14/images/train_output_2.png"}]}, "index": 14, "seeds": ["b782dc8a", "2dd70a9a", "6e19193c", "7447852a"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, topology, color transformation\n\n# description:\n# The input is a grid containing several colored squares, each having a \"hole\" represented by a contiguous black region of pixels.\n# To create the output, fill in the hole of each colored square with a color that corresponds to the original color of the square if the hole is a square.\n# If the hole is not a square, leave it as is.\n\ndef main(input_grid):\n    # Find all colored squares in the input grid (excluding black)\n    colored_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=False)\n    \n    # Create an output grid initialized to black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # For each colored square, check if it contains a square hole and fill it appropriately\n    for obj in colored_objects:\n        # Crop the object to analyze its content\n        sprite = crop(obj)\n        # Identify the interior of the object\n        hole_mask = (sprite == Color.BLACK) \u0026 (object_interior(sprite, background=Color.BLACK))\n        \n        # Check if the hole is square\n        def is_square(thing):\n            \"\"\"Determine if the thing is a square shape.\"\"\"\n            thing = crop(thing)\n            return np.sum(thing != Color.BLACK) == thing.shape[0] * thing.shape[1] and thing.shape[0] == thing.shape[1]\n\n        # Get the original object\u0027s color (assuming the object is monochromatic)\n        original_color = sprite[0, 0]  # Get the color of the top-left pixel\n        \n        if is_square(hole_mask):\n            # Fill the square hole with the original color\n            sprite[hole_mask] = original_color\n\n        # Get the location of the object in the original grid\n        x, y = object_position(obj, background=Color.BLACK)\n        # Blit the possibly modified sprite back to the output grid\n        blit_sprite(output_grid, sprite, x, y)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid that will contain colored squares with holes\n    width, height = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colored squares\n    num_squares = np.random.randint(2, 5)\n\n    for _ in range(num_squares):\n        # Random size for the square\n        size = np.random.randint(3, 6)\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # Try to find a random location for the square\n        try:\n            x, y = random_free_location_for_sprite(grid, np.full((size, size), color), padding=1)\n        except ValueError:\n            continue  # If no space found, skip to next iteration\n\n        # Place the colored square on the grid\n        blit_sprite(grid, np.full((size, size), color), x, y)\n\n        # Create a hole (contiguous black region) in the middle of the square\n        hole_size = np.random.randint(1, size - 1)\n        hole_x, hole_y = np.random.randint(1, size - hole_size), np.random.randint(1, size - hole_size)\n        grid[x + hole_x:x + hole_x + hole_size, y + hole_y:y + hole_y + hole_size] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/15/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/15/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/15/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/15/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/15/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/15/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/15/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/15/images/train_output_2.png"}]}, "index": 15, "seeds": ["6cdd2623", "29c11459", "feca6190", "e21d9049"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, connections, noise filtering\n\n# description:\n# In the input you will see several colored pixels scattered across a black background. One color forms a closed boundary (like a simple polygon) while the others are random noise pixels. \n# To make the output, identify the closed boundary and fill it with a solid color. Noise pixels that touch the boundary should also be filled with the boundary color. \n# Noise pixels that do not touch the boundary should be erased.\n\ndef main(input_grid):\n    # Step 1: Find all connected components in the grid\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=4, background=Color.BLACK)\n\n    output_grid = np.copy(input_grid)\n\n    # Step 2: Identify the boundary color and fill the boundary\n    boundary_color = None\n    for obj in objects:\n        # Check if the object is a boundary (at least 4 pixels)\n        if np.sum(obj != Color.BLACK) \u003e= 4:\n            boundary_mask = object_neighbors(obj, connectivity=4, background=Color.BLACK)\n            if np.any(boundary_mask):\n                boundary_color = obj[obj != Color.BLACK][0]  # Get the color of the boundary\n                break\n\n    if boundary_color is not None:\n        # Step 3: Fill the boundary color and handle noise\n        for obj in objects:\n            obj_mask = obj != Color.BLACK\n            if np.sum(obj_mask) \u003e= 4:  # Only consider larger objects\n                neighbors = object_neighbors(obj, connectivity=4, background=Color.BLACK)\n                if np.any(neighbors):  # If neighbors exist\n                    output_grid[obj_mask] = boundary_color\n                else:  # If no neighbors, erase the noise\n                    output_grid[obj_mask] = Color.BLACK\n    \n    return output_grid\n\ndef generate_input():\n    # Create a black grid\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Generate a random color for the boundary\n    boundary_color = np.random.choice(Color.NOT_BLACK)\n\n    # Create a simple closed boundary\n    boundary_width, boundary_height = np.random.randint(5, 10), np.random.randint(5, 10)\n    x_start = np.random.randint(2, width - boundary_width - 2)\n    y_start = np.random.randint(2, height - boundary_height - 2)\n\n    # Draw a closed rectangle as the boundary\n    for x in range(x_start, x_start + boundary_width):\n        grid[x, y_start] = boundary_color\n        grid[x, y_start + boundary_height - 1] = boundary_color\n    for y in range(y_start, y_start + boundary_height):\n        grid[x_start, y] = boundary_color\n        grid[x_start + boundary_width - 1, y] = boundary_color\n\n    # Scatter noise pixels\n    noise_color = np.random.choice(Color.NOT_BLACK)\n    n_noise = np.random.randint(10, 20)\n    for _ in range(n_noise):\n        x, y = np.random.randint(0, width), np.random.randint(0, height)\n        grid[x, y] = noise_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/16/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/16/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/16/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/16/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/16/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/16/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/16/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/16/images/train_output_2.png"}]}, "index": 16, "seeds": ["b7249182", "623ea044", "feca6190", "6cdd2623"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, bounding box, connected components\n\n# description:\n# The input consists of a black grid divided by blue lines into multiple black rectangles. \n# In order to produce the output grid, fill in all the black rectangles that are at least 4x4 in size with orange, \n# while filling all the smaller rectangles with light green.\n\ndef main(input_grid):\n    # First, find all the black rectangles separated by blue lines\n    objects = find_connected_components(input_grid, background=Color.BLUE, connectivity=4)\n\n    # Create an output grid initialized to the input grid\n    output_grid = np.copy(input_grid)\n\n    for obj in objects:\n        # Get the bounding box of the object\n        x, y, width, height = bounding_box(obj, background=Color.BLUE)\n\n        # Calculate the area of the rectangle\n        area = width * height\n\n        # Determine if it is a small or large rectangle\n        if width \u003e= 4 and height \u003e= 4:\n            # Fill large rectangles with orange\n            obj[obj == Color.BLACK] = Color.ORANGE\n        else:\n            # Fill smaller rectangles with light green\n            obj[obj == Color.BLACK] = Color.GREY\n\n        # Blit the modified object back into the output grid\n        blit_object(output_grid, obj, background=Color.BLUE)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_lines = np.random.randint(3, 15)\n\n    for i in range(num_lines):\n        # add a blue line to divide the grid somewhere\n        x, y = np.random.randint(2, n-1), np.random.randint(2, m-1)\n        # make sure we\u0027re not neighboring a blue line already\n        if Color.BLUE in [grid[x, y+1], grid[x, y-1], grid[x+1, y], grid[x-1, y]]:\n            continue\n\n        horizontal = np.random.choice([True, False])\n        if horizontal:\n            draw_line(grid, x, y, direction=(1, 0), color=Color.BLUE, stop_at_color=[Color.BLUE])\n            draw_line(grid, x-1, y, direction=(-1, 0), color=Color.BLUE, stop_at_color=[Color.BLUE])\n        else:\n            draw_line(grid, x, y, direction=(0, 1), color=Color.BLUE, stop_at_color=[Color.BLUE])\n            draw_line(grid, x, y-1, direction=(0, -1), color=Color.BLUE, stop_at_color=[Color.BLUE])\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/17/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/17/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/17/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/17/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/17/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/17/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/17/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/17/images/train_output_2.png"}]}, "index": 17, "seeds": ["6455b5f5", "e73095fd", "7447852a", "00d62c1b"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, circular pattern completion\n\n# description:\n# In the input, you will see a circular design that is partially complete. The design consists of pixels of different colors on a black background.\n# To make the output, find the center of the circular design and use the rotational symmetry to fill in missing pixels to complete the circular pattern.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the center of the circular design and find its symmetry.\n    # 2. Fill in missing pixels by rotating existing colored pixels around the center.\n\n    # Find the rotational symmetry\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Create a copy of the input grid for output\n    output_grid = np.copy(input_grid)\n\n    # Find the colored pixels (not black)\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Fill in missing parts by rotating existing colors\n    for x, y in colored_pixels:\n        color = input_grid[x, y]\n        \n        # Loop over all rotations, going 90 degrees each time (so four times)\n        for i in range(1, 4):\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n\n            # Fill in the missing pixel if it is black\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n            else:\n                assert output_grid[rotated_x, rotated_y] == color, \"The pattern is not consistent with rotational symmetry\"\n\n    return output_grid\n\ndef generate_input():\n    # Initialize a 20x20 grid\n    grid = np.zeros((20, 20), dtype=int)\n\n    # Create a circular sprite with some color pixels\n    radius = 8\n    center_x, center_y = 10, 10  # Center of the grid\n\n    for angle in range(0, 360, 30):  # Add pixels in a circular pattern\n        rad = np.radians(angle)\n        x = int(center_x + radius * np.cos(rad))\n        y = int(center_y + radius * np.sin(rad))\n\n        # Randomly fill the pixel with a color\n        if np.random.rand() \u003e 0.5:  # 50% chance to color the pixel\n            grid[x, y] = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly remove some pixels to create an incomplete design\n    for _ in range(15):  # Remove 15 random pixels\n        x, y = np.random.randint(0, 20), np.random.randint(0, 20)\n        grid[x, y] = Color.BLACK  # Set to black to simulate missing parts\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/18/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/18/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/18/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/18/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/18/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/18/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/18/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/18/images/train_output_2.png"}]}, "index": 18, "seeds": ["6e82a1ae", "178fcbfb", "09629e4f", "90c28cc7"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, merging, color transformation\n\n# description:\n# In the input you will see a grid with a grey rectangle and colored pixels scattered around it.\n# To make the output, move each colored pixel toward the grey rectangle until it touches. \n# If multiple colored pixels collide, they stack. Once they touch the grey rectangle, they merge into it, taking on the color of the pixel.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the grey rectangle and colored pixels\n    # 2. Move each colored pixel towards the grey rectangle until they touch\n    # 3. Change the color of the pixel to grey upon touching, and merge it into the rectangle\n    \n    # Step 1: Find the grey object and other colored pixels\n    objects = find_connected_components(input_grid, connectivity=4)\n    grey_objects = [obj for obj in objects if Color.GREY in object_colors(obj)]\n    colored_objects = [obj for obj in objects if Color.GREY not in object_colors(obj)]\n\n    assert len(grey_objects) == 1, \"There should be exactly one grey rectangle\"\n    \n    grey_object = grey_objects[0]\n\n    # Create output grid starting as a black grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    blit_sprite(output_grid, grey_object, 0, 0)\n\n    # Step 2: Move the colored objects towards the grey rectangle\n    for colored_object in colored_objects:\n        # Move the colored object towards the grey rectangle until contact\n        moving = True\n        while moving:\n            # Check all possible displacements\n            possible_displacements = [(dx, dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1] if (dx, dy) != (0, 0)]\n            valid_displacements = []\n\n            for dx, dy in possible_displacements:\n                # Check potential new position\n                new_x = object_position(colored_object)[0] + dx\n                new_y = object_position(colored_object)[1] + dy\n                \n                # Check if the movement will cause contact with the grey rectangle\n                if contact(object1=translate(colored_object, dx, dy), object2=grey_object):\n                    valid_displacements.append((dx, dy))\n\n            if valid_displacements:\n                # Pick the first valid displacement and move\n                dx, dy = valid_displacements[0]\n                colored_object = translate(colored_object, dx, dy)\n                \n                # Stop moving if it has contacted the grey rectangle\n                if contact(object1=colored_object, object2=grey_object):\n                    # Change the color to grey to indicate merging\n                    colored_object[colored_object != Color.BLACK] = Color.GREY\n                    blit_sprite(output_grid, colored_object, 0, 0)  # Merge into grey rectangle\n                    moving = False\n            else:\n                moving = False  # No valid moves left, stop trying to move\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a grey rectangle and scattered colored pixels\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a horizontal grey rectangle in the middle\n    rectangle_y1 = height // 3\n    rectangle_y2 = 2 * height // 3\n    grid[:, rectangle_y1:rectangle_y2] = Color.GREY\n\n    # Scatter some colored pixels around the grey rectangle\n    for _ in range(np.random.randint(5, 15)):\n        random_color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.GREY])\n        pixel_sprite = np.full((1, 1), random_color)\n        x, y = random_free_location_for_sprite(grid, pixel_sprite, background=Color.BLACK)\n        blit_sprite(grid, pixel_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/19/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/19/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/19/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/19/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/19/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/19/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/19/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/19/images/train_output_2.png"}]}, "index": 19, "seeds": ["3ac3eb23", "834ec97d", "bc1d5164", "1bfc4729"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, radial pattern generation\n\n# description:\n# In the input you will see a grid with a single colored pixel.\n# To make the output grid, move the colored pixel one pixel down, \n# then create a radial pattern of alternating colors around the new pixel position. \n# The pattern should have a radius of 2 pixels and alternate between green and pink.\n\ndef main(input_grid):\n    # Step 1: Find the colored pixel in the input grid\n    colored_pixels = find_connected_components(input_grid, monochromatic=True)\n    assert len(colored_pixels) == 1\n    colored_pixel = colored_pixels[0]\n\n    # Step 2: Get the position and color of the pixel\n    pixel_x, pixel_y = object_position(colored_pixel)\n    pixel_color = object_colors(colored_pixel)[0]\n\n    # Step 3: Move the colored pixel down one pixel\n    output_grid = input_grid.copy()\n    new_pixel_y = pixel_y + 1\n    output_grid[pixel_x, new_pixel_y] = pixel_color\n    output_grid[pixel_x, pixel_y] = Color.BLACK  # Clear the original pixel position\n\n    # Step 4: Create a radial pattern around the new pixel position\n    radius = 2\n    colors = [Color.GREEN, Color.PINK]\n    \n    for r in range(1, radius + 1):  # For each radius from 1 to 2\n        for angle in range(0, 360, 90):  # Create points at 0, 90, 180, and 270 degrees\n            x_offset = int(r * np.cos(np.radians(angle)))\n            y_offset = int(r * np.sin(np.radians(angle)))\n\n            # Determine the color based on the radius\n            color_to_use = colors[r % len(colors)]\n            output_grid[pixel_x + x_offset, new_pixel_y + y_offset] = color_to_use\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose one color\n    color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.YELLOW])\n\n    # Randomly place the pixel on the grid, ensuring it can be moved down\n    x, y = np.random.randint(0, width - 1), np.random.randint(0, height - 2)  # Ensuring space to move down\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/20/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/20/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/20/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/20/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/20/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/20/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/20/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/20/images/train_output_2.png"}]}, "index": 20, "seeds": ["834ec97d", "3ac3eb23", "a9f96cdd", "feca6190"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color fill, object expansion\n\n# description:\n# In the input, you will see a grid with a single colored object in the center and a different colored pixel in the top left corner.\n# To make the output, remove the pixel in the top left corner and fill the colored object with the color from that pixel. \n# The filling should expand to fill the entire connected region of the original object.\n\ndef main(input_grid):\n    # Copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # Get the color of the pixel in the top left corner\n    color = output_grid[0, 0]\n\n    # Remove the pixel from the top left corner\n    output_grid[0, 0] = Color.BLACK\n\n    # Find the coordinates of the object in the center\n    object_x, object_y = np.where(output_grid != Color.BLACK)\n\n    # Use flood_fill to fill the object with the color from the top left corner\n    for x, y in zip(object_x, object_y):\n        flood_fill(output_grid, x, y, color, connectivity=4)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 7x7 grid with a black background\n    n = m = 7\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select a color for the object, ensuring it\u0027s not black\n    object_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Select a color for the corner pixel, ensuring it\u0027s different from the object color\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n    while corner_color == object_color:\n        corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Create the object by filling a connected region in the center of the grid\n    center_x, center_y = n // 2, m // 2\n    flood_fill(grid, center_x, center_y, object_color, connectivity=4)\n\n    # Place the corner pixel in the top left corner\n    grid[0, 0] = corner_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/21/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/21/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/21/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/21/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/21/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/21/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/21/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/21/images/train_output_2.png"}]}, "index": 21, "seeds": ["6cdd2623", "8d510a79", "746b3537", "feca6190"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, interior detection, color transformation\n\n# description:\n# In the input grid, you will see various colored objects, some of which are \"hollow\" and contain a fully-enclosed region, while others are \"solid\" and do not have a separate middle. \n# To create the output grid, copy the input grid. Then, change the color of all \"hollow\" shapes to be yellow, while keeping the colors of \"solid\" shapes unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid to hold the output\n    output_grid = np.copy(input_grid)\n    \n    # Find all connected objects in the input grid\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=4)\n    \n    # Iterate through detected objects to check if they are hollow\n    for obj in objects:\n        if is_hollow(obj):\n            # Change the color of hollow objects to yellow\n            output_grid[output_grid == obj[0, 0]] = Color.YELLOW\n    \n    return output_grid\n\ndef is_hollow(object):\n    # To check if the object is hollow, we examine its interior\n    interior_mask = object_interior(object)\n    object_mask = object != Color.BLACK\n    # A hollow object will have interior pixels that are not part of the object\n    hollow_mask = interior_mask \u0026 ~object_mask\n    return np.any(hollow_mask)\n\ndef generate_input():\n    n = np.random.randint(10, 28)\n    input_grid = np.full((n, n), Color.BLACK)\n\n    # Function to create a hollow object\n    def random_hollow_object():\n        width, height = np.random.randint(3, 7), np.random.randint(3, 7)\n        obj = np.full((width, height), Color.BLUE)\n        obj[1:width-1, 1:height-1] = Color.BLACK  # Create a hollow rectangle\n        return obj\n\n    # Function to create a solid object\n    def random_solid_object():\n        width, height = np.random.randint(3, 6), np.random.randint(3, 6)\n        obj = np.full((width, height), Color.BLUE)\n        return obj  # Solid, filled with blue\n\n    # Place at least one hollow and one solid object\n    try:\n        # Add one hollow object\n        hollow_obj = random_hollow_object()\n        x, y = random_free_location_for_sprite(input_grid, hollow_obj, padding=1)\n        blit_sprite(input_grid, hollow_obj, x=x, y=y)\n\n        # Add one solid object\n        solid_obj = random_solid_object()\n        x, y = random_free_location_for_sprite(input_grid, solid_obj, padding=1)\n        blit_sprite(input_grid, solid_obj, x=x, y=y)\n    except ValueError:\n        return generate_input()  # Retry if there\u0027s no free location\n\n    # Continue adding random objects until the grid is somewhat full\n    while True:\n        obj = random_hollow_object() if np.random.rand() \u003c 0.5 else random_solid_object()\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            return input_grid  # Return the current grid when no more can be added", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/22/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/22/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/22/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/22/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/22/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/22/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/22/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/22/images/train_output_2.png"}]}, "index": 22, "seeds": ["e179c5f4", "3de23699", "6fa7a44f", "1f642eb9"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, replication, color matching\n\n# description:\n# In the input, you will see a colored shape surrounded by a black background.\n# To make the output, identify the bounding box of the colored shape and replicate it at different locations in the grid.\n# Each replication should be in a different color from a predetermined color palette.\n\ndef main(input_grid):\n    # Step 1: Identify the bounding box of the colored shape\n    background_color = Color.BLACK\n    x, y, width, height = bounding_box(input_grid, background=background_color)\n\n    # Step 2: Extract the shape from the input grid using the bounding box\n    shape = input_grid[x:x + width, y:y + height]\n\n    # Step 3: Create an output grid filled with the background color\n    output_grid = np.full(input_grid.shape, background_color)\n\n    # Step 4: Replicate the shape at different positions in the output grid\n    # Defining positions for replication\n    replication_positions = [\n        (0, 0),  # Top-left corner\n        (0, input_grid.shape[1] - height),  # Top-right corner\n        (input_grid.shape[0] - width, 0),  # Bottom-left corner\n        (input_grid.shape[0] - width, input_grid.shape[1] - height),  # Bottom-right corner\n        ((input_grid.shape[0] // 2) - (width // 2), (input_grid.shape[1] // 2) - (height // 2))  # Center\n    ]\n    \n    # Step 5: Choose a color palette for replication\n    color_palette = [Color.RED, Color.GREEN, Color.BLUE, Color.YELLOW, Color.PINK]\n    \n    for i, (rep_x, rep_y) in enumerate(replication_positions):\n        # Choose a color from the palette\n        color = color_palette[i % len(color_palette)]\n        # Create a colored version of the extracted shape\n        colored_shape = np.where(shape != background_color, color, background_color)\n        # Place the colored shape into the output grid\n        output_grid[rep_x:rep_x + width, rep_y:rep_y + height] = colored_shape\n    \n    return output_grid\n\ndef generate_input():\n    # Step 1: Create a grid with a black background\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Step 2: Define the shape\u0027s size and position\n    shape_width, shape_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    shape_color = np.random.choice(Color.NOT_BLACK)\n\n    # Step 3: Randomly choose a position for the shape\n    x_start = np.random.randint(1, n - shape_height - 1)\n    y_start = np.random.randint(1, m - shape_width - 1)\n\n    # Step 4: Create the shape inside the grid\n    for i in range(shape_height):\n        for j in range(shape_width):\n            grid[x_start + i, y_start + j] = shape_color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/23/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/23/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/23/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/23/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/23/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/23/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/23/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/23/images/train_output_2.png"}]}, "index": 23, "seeds": [], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, object detection, noise removal\n\n# description:\n# In the input, you will see a black grid with several colored objects scattered throughout, and some noise pixels (gray) randomly placed. \n# To create the output, fill the pixels of colored objects that are adjacent to noise pixels with teal, and remove the noise pixels.\n\ndef main(input_grid):\n    # Step 1: Identify all objects and noise pixels\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    noise_pixels = detect_objects(input_grid, colors=[Color.GREY], monochromatic=True, allowed_dimensions=[(1, 1)])\n    \n    # Step 2: Create a mask for the output grid\n    output_grid = np.copy(input_grid)\n    \n    # Step 3: For each noise pixel, find its neighbors and fill adjacent colored pixels with teal\n    for noise_pixel in noise_pixels:\n        noise_mask = noise_pixel != Color.BLACK\n        neighbors_mask = object_neighbors(noise_pixel, background=Color.BLACK, connectivity=4)\n\n        # Identify which objects are adjacent to the noise pixel\n        for obj in objects:\n            object_mask = obj != Color.BLACK\n            \n            # If the noise pixel has at least one neighbor that is part of the object, fill that object with teal\n            if np.any(neighbors_mask \u0026 object_mask):\n                output_grid[object_mask] = Color.TEAL\n\n    # Step 4: Remove noise pixels from the output grid\n    output_grid[output_grid == Color.GREY] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly determine number of colored objects and noise pixels\n    num_objects = np.random.randint(2, 6)\n    num_noise = np.random.randint(5, 15)\n\n    # Add colored objects (not grey)\n    for _ in range(num_objects):\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.GREY])\n        obj_width, obj_height = np.random.randint(2, 5), np.random.randint(2, 5)\n        obj_sprite = np.full((obj_width, obj_height), color)\n        x, y = random_free_location_for_sprite(grid, obj_sprite, background=Color.BLACK)\n        blit_sprite(grid, obj_sprite, x, y, background=Color.BLACK)\n\n    # Add random noise pixels (grey)\n    for _ in range(num_noise):\n        x, y = np.random.randint(n), np.random.randint(m)\n        grid[x, y] = Color.GREY\n    \n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/24/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/24/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/24/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/24/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/24/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/24/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/24/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/24/images/train_output_2.png"}]}, "index": 24, "seeds": ["6455b5f5", "1f642eb9", "d4f3cd78", "6f8cd79b"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, fitting, bounding box\n\n# description:\n# In the input you will see several colored objects in a grid where some are overlapping.\n# To make the output, extract all objects and fit them together to form a single tightly-packed shape without rotation. \n# Ensure that the final output grid is the smallest bounding box that contains all the objects.\n\ndef main(input_grid):\n    # 1. Extract connected components (objects) from the input grid\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=False)\n    \n    # 2. Create a new output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # 3. Place each object into the output grid\n    for obj in objects:\n        # Get the bounding box of the current object\n        mask = bounding_box_mask(obj, background=Color.BLACK)\n\n        # Determine the position to fit the object into the output grid\n        # Find the top-left corner of the bounding box\n        y_offset, x_offset = np.where(mask)[0][0], np.where(mask)[1][0]\n        \n        # Determine where to place the object in the output grid\n        # Use the bottom-right corner of the last placed object to avoid overlap\n        placement_x = np.max(np.where(output_grid != Color.BLACK)[0]) if np.any(output_grid != Color.BLACK) else 0\n        placement_y = 0\n\n        # Place the object in the output grid\n        blit_sprite(output_grid, crop(obj, background=Color.BLACK), placement_x, placement_y)\n\n    # 4. Crop the output to the smallest bounding box that contains all non-background pixels\n    return crop(output_grid, background=Color.BLACK)\n\ndef generate_input():\n    # Create a random grid with colored objects\n    grid = np.full((20, 20), Color.BLACK)\n    colors = list(Color.NOT_BLACK)\n\n    # Generate a number of random objects and place them in the grid\n    for _ in range(random.randint(5, 10)):\n        # Randomly create a sprite\n        sprite = random_sprite(random.randint(2, 5), random.randint(2, 5), density=0.5, color_palette=colors)\n\n        # Find a random location to place the sprite\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If no free location, try again\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/25/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/25/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/25/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/25/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/25/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/25/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/25/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/25/images/train_output_2.png"}]}, "index": 25, "seeds": ["e509e548", "8e5a5113", "d2abd087", "681b3aeb"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, orbit, transformation\n\n# description:\n# In the input, you will see a pattern with a specific color in the center and a surrounding color pattern.\n# To create the output, you must identify the central color pattern and reflect the surrounding color pattern across the center point.\n# This reflection should be applied in all directions to create a new pattern. \n\ndef main(input_grid):\n    # Identify the center of the grid\n    center_x, center_y = input_grid.shape[0] // 2, input_grid.shape[1] // 2\n    \n    # Extract the central color (assumed to be a single color)\n    center_color = input_grid[center_x, center_y]\n\n    # Create an output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Get the symmetries of the center color\n    symmetries = [(dx, dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1] if (dx != 0 or dy != 0)]\n\n    # Iterate over the surrounding pixels and apply transformations\n    for x, y in np.ndindex(input_grid.shape):\n        if input_grid[x, y] != center_color:\n            # For each surrounding pixel, get its position in the orbit\n            for dx, dy in symmetries:\n                new_x = center_x + (x - center_x) * dx\n                new_y = center_y + (y - center_y) * dy\n                # Check if the new coordinates are within bounds\n                if 0 \u003c= new_x \u003c output_grid.shape[0] and 0 \u003c= new_y \u003c output_grid.shape[1]:\n                    output_grid[new_x, new_y] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a central color pattern and surrounding color patterns\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Define a center color\n    center_color = np.random.choice(Color.NOT_BLACK)\n    center_x, center_y = n // 2, m // 2\n\n    # Place the center color\n    grid[center_x, center_y] = center_color\n\n    # Generate surrounding colors\n    surrounding_color = np.random.choice(Color.NOT_BLACK)\n    \n    # Fill a surrounding pattern\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx, dy) != (0, 0):  # Skip the center\n                grid[center_x + dx, center_y + dy] = surrounding_color\n\n    # Randomly rotate the grid to add variety\n    grid = np.rot90(grid, np.random.randint(4))\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/26/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/26/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/26/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/26/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/26/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/26/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/26/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/26/images/train_output_2.png"}]}, "index": 26, "seeds": ["f8a8fe49", "eb281b96", "4c5c2cf0", "6fa7a44f"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape detection, boundary coloring\n\n# description:\n# In the input grid, there are enclosed shapes formed by blue pixels surrounded by black pixels. \n# The task is to find these shapes\u0027 boundaries and color them orange in the output grid, while leaving the \n# interior of the shapes unchanged.\n\ndef main(input_grid):\n    # Create a copy of the input grid to store the output\n    output_grid = input_grid.copy()\n\n    # Detect the boundaries of the shapes\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Color the boundaries orange\n    output_grid[boundary_mask] = Color.ORANGE\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a square grid of arbitrary size with black background, size from 10x10 to 20x20\n    n = np.random.randint(10, 20)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Create a few random blue shapes\n    n_objects = np.random.randint(1, 4)  # Generate 1 to 3 shapes\n    for _ in range(n_objects):\n        # Random size for the shape\n        height = np.random.randint(3, 6)\n        width = np.random.randint(3, 6)\n        \n        # Create a blue sprite\n        sprite = random_sprite(height, width, color_palette=[Color.BLUE], connectivity=8)\n\n        # Make sure the sprite is enclosed by black pixels\n        x, y = np.random.randint(1, n-height-1), np.random.randint(1, n-width-1)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/27/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/27/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/27/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/27/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/27/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/27/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/27/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/27/images/train_output_2.png"}]}, "index": 27, "seeds": ["6fa7a44f", "4c5c2cf0", "8e1813be", "eb281b96"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern restoration, bounding box\n\n# description:\n# In the input you will see a grid divided into 9 squares separated by grey lines. \n# The top-left square contains an original pattern, while the other squares may have portions of that pattern or be empty. \n# To create the output, you need to reconstruct the original pattern in each square based on the top-left square while preserving the gray lines.\n\ndef main(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Detect the color of the lines\n    for x, row in enumerate(output_grid):\n        if np.unique(row).size == 1:\n            line_color = row[0]\n            break\n\n    # Get all the squares separated by lines in the grid\n    squares = find_connected_components(grid=output_grid, background=line_color, monochromatic=False, connectivity=4)\n\n    # Get all squares\u0027 bounding box and cropped pattern\n    cropped_squares = []\n    for obj in squares:\n        x, y, width, height = bounding_box(grid=obj, background=line_color)\n        square_pattern = crop(grid=obj, background=line_color)\n        cropped_squares.append({\u0027x\u0027: x, \u0027y\u0027: y, \u0027pattern\u0027: square_pattern})\n\n    # Sort the squares by their position\n    cropped_squares = sorted(cropped_squares, key=lambda k: (k[\u0027y\u0027], k[\u0027x\u0027]))\n\n    # The top-left square contains the original pattern\n    template_pattern = cropped_squares[0][\u0027pattern\u0027]\n    other_patterns = cropped_squares[1:]\n\n    # Fill each empty square with the template pattern\n    for square in other_patterns:\n        x, y = square[\u0027x\u0027], square[\u0027y\u0027]\n        square_pattern = square[\u0027pattern\u0027]\n\n        # Restore the pattern based on template\n        for i, j in np.argwhere(template_pattern != Color.BLACK):\n            if square_pattern[i, j] == Color.BLACK:\n                square_pattern[i, j] = template_pattern[i, j]\n\n        # Place the reconstructed pattern on the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=square_pattern, x=x, y=y)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Create a 3x3 grid of squares separated by grey lines\n    square_len = np.random.choice([5, 7, 9])\n    pattern_len = square_len - 2\n    n, m = square_len * 3 + 2, square_len * 3 + 2  # 3 squares and 2 lines on each dimension\n    grid = np.full((n, m), Color.BLACK)\n\n    # Select line color\n    line_color = Color.GRAY\n    for i in range(square_len, n, square_len + 1):\n        draw_line(grid=grid, x=i, y=0, color=line_color, direction=(0, 1))\n        draw_line(grid=grid, x=0, y=i, color=line_color, direction=(1, 0))\n\n    # Create the pattern in the top-left square\n    template_sprite = random_sprite(n=pattern_len, m=pattern_len, connectivity=8, density=0.5)\n\n    # Fill the top-left square with the original pattern\n    blit_sprite(grid, template_sprite, 1, 1)\n\n    # Fill the other squares with either copies of the pattern or corrupted versions\n    for i in range(1, 3):\n        for j in range(1, 3):\n            if (i == 1 and j == 1):\n                continue  # skip the top-left square\n            # Create a corrupted version of the pattern\n            corrupted_sprite = template_sprite.copy()\n            for x, y in np.argwhere(corrupted_sprite != Color.BLACK):\n                if np.random.rand() \u003c 0.5:  # randomly set some pixels to black\n                    corrupted_sprite[x, y] = Color.BLACK\n            blit_sprite(grid, corrupted_sprite, i * (square_len + 1) + 1, j * (square_len + 1) + 1)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/28/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/28/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/28/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/28/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/28/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/28/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/28/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/28/images/train_output_2.png"}]}, "index": 28, "seeds": ["8e5a5113", "e509e548", "681b3aeb", "b775ac94"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connecting, padding, object detection\n\n# description:\n# In the input, you will see two distinct colored circles on a black background.\n# To create the output, connect the centers of the two circles with a line of a third color (grey).\n# The connection should only occur if there is enough space (defined by a padding) between the objects.\n\ndef main(input_grid):\n    # Copy the input grid as output\n    output_grid = np.copy(input_grid)\n\n    # Detect the objects (circles)\n    circles = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    if len(circles) != 2:\n        raise ValueError(\"The input must contain exactly two objects.\")\n\n    # Get the center positions of the two circles\n    center1 = object_position(circles[0], background=Color.BLACK, anchor=\u0027center\u0027)\n    center2 = object_position(circles[1], background=Color.BLACK, anchor=\u0027center\u0027)\n\n    # Check if there is enough space to connect the centers with padding\n    x_center1, y_center1 = center1\n    x_center2, y_center2 = center2\n\n    # Get the coordinates of the line between the two centers\n    for x in range(min(x_center1, x_center2), max(x_center1, x_center2) + 1):\n        for y in range(min(y_center1, y_center2), max(y_center1, y_center2) + 1):\n            # Check if the current position is between the two circles with a padding\n            if check_between_objects(circles[0], circles[1], x, y, padding=1):\n                output_grid[x, y] = Color.GREY\n    \n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 15, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the circles\n    colors = np.random.choice([color for color in Color.NOT_BLACK], 2, replace=False)\n    color1, color2 = colors\n\n    # Generate two circles\n    radius1 = np.random.randint(2, 4)\n    radius2 = np.random.randint(2, 4)\n\n    # Create the first circle\n    circle1 = np.zeros((radius1 * 2 + 1, radius1 * 2 + 1), dtype=int)\n    for x in range(circle1.shape[0]):\n        for y in range(circle1.shape[1]):\n            if (x - radius1) ** 2 + (y - radius1) ** 2 \u003c= radius1 ** 2:\n                circle1[x, y] = color1\n\n    # Create the second circle\n    circle2 = np.zeros((radius2 * 2 + 1, radius2 * 2 + 1), dtype=int)\n    for x in range(circle2.shape[0]):\n        for y in range(circle2.shape[1]):\n            if (x - radius2) ** 2 + (y - radius2) ** 2 \u003c= radius2 ** 2:\n                circle2[x, y] = color2\n\n    # Place the circles on the grid\n    try:\n        x1, y1 = random_free_location_for_sprite(grid=grid, sprite=circle1, background=Color.BLACK, padding=2, padding_connectivity=8)\n        blit_sprite(grid, circle1, x1, y1)\n\n        x2, y2 = random_free_location_for_sprite(grid=grid, sprite=circle2, background=Color.BLACK, padding=2, padding_connectivity=8)\n        blit_sprite(grid, circle2, x2, y2)\n\n    except ValueError:\n        return generate_input()  # If we fail to place circles, regenerate input\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/29/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/29/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/29/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/29/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/29/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/29/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/29/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/29/images/train_output_2.png"}]}, "index": 29, "seeds": [], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object translation, pixel patterns\n\n# description:\n# In the input you will see a grid with a square shape made up of colored pixels. \n# The task is to slide this square shape to the right by one pixel, while ensuring that \n# the square shape is still contiguous and does not overlap with the background.\n# If it cannot be slid to the right because of the edge of the grid, the shape remains in its original position.\n\ndef main(input_grid):\n    # Find the connected component (the colored square shape)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    \n    if not objects:\n        return input_grid  # If no object found, return the original input grid\n\n    obj = objects[0]\n\n    # Determine the bounding box of the object\n    x, y, width, height = bounding_box(obj)\n\n    # Check if the object can slide right\n    if x + width \u003c input_grid.shape[0]:  # Ensure it stays within bounds\n        # Translate the object to the right by 1 pixel\n        output_grid = translate(obj, 1, 0, background=Color.BLACK)\n    else:\n        output_grid = input_grid.copy()  # If not possible, return original grid\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a 5x5 grid with a black background\n    grid = np.full((5, 5), Color.BLACK)\n\n    # Create a random size for the square shape (1 to 3 pixels)\n    square_size = np.random.randint(1, 4)\n\n    # Randomly choose a color for the square\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly determine the top-left corner of the square\n    # Ensure that the square can fit within the grid\n    x = np.random.randint(0, 5 - square_size + 1)\n    y = np.random.randint(0, 5)\n\n    # Fill the square area with the chosen color\n    grid[x:x + square_size, y:y + square_size] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/30/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/30/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/30/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/30/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/30/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/30/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/30/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/30/images/train_output_2.png"}]}, "index": 30, "seeds": ["bc1d5164", "746b3537", "90c28cc7", "e21d9049"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, filling, color transformation\n\n# description:\n# In the input grid, you will find various shapes made of colored pixels surrounding black pixels (background).\n# The task is to identify the boundaries of each shape and fill the interior of each shape with a new color (blue).\n# The boundary itself should remain unchanged and the outside (background) should still be black.\n\ndef main(input_grid):\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = input_grid.copy()\n\n    # Find the boundaries of the objects in the input grid\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n\n    # Iterate through the grid to fill in the interiors of the shapes\n    for x, y in np.argwhere(output_grid != Color.BLACK):\n        # Check if this pixel is part of the boundary\n        if boundary_mask[x, y]:\n            continue  # Skip boundary pixels\n        # If not, fill the interior with blue\n        output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a size between 10x10 and 20x20\n    n = random.randint(10, 20)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Generate random colored shapes\n    n_objects = random.randint(2, 5)  # Number of shapes to add\n    colors = random.sample(list(Color.NOT_BLACK), n_objects)\n    \n    for color in colors:\n        # Create a random sprite for the object\n        sprite = random_sprite(random.randint(3, 8), random.randint(3, 8), color_palette=[color])\n        \n        # Try to place the sprite in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite)\n            blit_sprite(grid, sprite, x, y)\n        except ValueError:\n            # If no space is found, skip this sprite\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/31/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/31/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/31/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/31/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/31/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/31/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/31/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/31/images/train_output_2.png"}]}, "index": 31, "seeds": ["4c5c2cf0", "6855a6e4", "44f52bb0", "3345333e"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, geometric pattern, filling\n\n# description:\n# In the input you will see a grid with a single colored pixel. \n# To make the output, find the bounding box of the colored pixel and fill it with the same color.\n# Then, draw a diagonal line from the top-left corner of the bounding box to the bottom-right corner.\n\ndef main(input_grid):\n    # Step 1: Find the colored pixel\n    colored_components = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n    assert len(colored_components) == 1, \"There should be exactly one colored pixel.\"\n    \n    colored_pixel = colored_components[0]\n    colored_x, colored_y = object_position(colored_pixel)\n    colored_color = object_colors(colored_pixel)[0]\n\n    # Step 2: Create a mask for the bounding box of the colored pixel\n    bounding_box_mask_result = bounding_box_mask(colored_pixel)\n    min_x, min_y = np.where(bounding_box_mask_result)[0][0], np.where(bounding_box_mask_result)[1][0]\n    max_x, max_y = np.where(bounding_box_mask_result)[0][-1], np.where(bounding_box_mask_result)[1][-1]\n\n    # Step 3: Fill the bounding box with the colored pixel\u0027s color\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[min_x:max_x+1, min_y:max_y+1] = colored_color\n\n    # Step 4: Draw a diagonal line from the top-left corner to the bottom-right corner of the bounding box\n    draw_line(output_grid, min_x, min_y, direction=(1, 1), color=colored_color)\n\n    return output_grid\n\ndef generate_input():\n    # Generate an input grid\n    width, height = np.random.randint(5, 15, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose one color for the colored pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the colored pixel within the grid\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/32/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/32/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/32/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/32/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/32/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/32/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/32/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/32/images/train_output_2.png"}]}, "index": 32, "seeds": ["28e73c20", "3ac3eb23", "ea786f4a", "834ec97d"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color transformation\n\n# description:\n# In the input, you will see a blue square and a green square on a black background.\n# To make the output, change the blue square to red and the green square to orange, \n# while preserving their positions on the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the blue and green squares in the input grid.\n    # 2. Change the color of the blue square to red.\n    # 3. Change the color of the green square to orange.\n    # 4. Return the modified grid.\n\n    # 1. Detect the objects\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)\n    \n    blue_squares = [obj for obj in objects if Color.BLUE in object_colors(obj)]\n    green_squares = [obj for obj in objects if Color.GREEN in object_colors(obj)]\n    \n    assert len(blue_squares) == 1, \"There should be exactly one blue square\"\n    assert len(green_squares) == 1, \"There should be exactly one green square\"\n    \n    blue_square = blue_squares[0]\n    green_square = green_squares[0]\n    \n    # Create an output grid based on the input grid\n    output_grid = input_grid.copy()\n    \n    # 2. Change the blue square to red\n    blue_x, blue_y = object_position(blue_square)\n    output_grid[blue_x, blue_y] = Color.RED\n    \n    # 3. Change the green square to orange\n    green_x, green_y = object_position(green_square)\n    output_grid[green_x, green_y] = Color.ORANGE\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with one blue square and one green square in random positions.\n    width, height = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly place a blue square\n    blue_x, blue_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n    grid[blue_x, blue_y] = Color.BLUE\n    \n    # Randomly place a green square, ensuring it doesn\u0027t overlap with the blue square\n    while True:\n        green_x, green_y = np.random.randint(1, width - 1), np.random.randint(1, height - 1)\n        if (green_x, green_y) != (blue_x, blue_y):\n            break\n    grid[green_x, green_y] = Color.GREEN\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/33/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/33/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/33/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/33/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/33/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/33/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/33/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/33/images/train_output_2.png"}]}, "index": 33, "seeds": ["834ec97d", "508bd3b6", "d4a91cb9", "5168d44c"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, merging, surrounding\n\n# description:\n# In the input, you will see a blue square and several yellow circles on the grid.\n# To make the output, move the blue square to the center of the region occupied by the yellow circles.\n# Then, surround the blue square with green pixels in a 1-pixel border, and make all other pixels black.\n\ndef main(input_grid):\n    # Step 1: Detect the blue square and yellow circles\n    objects = find_connected_components(input_grid, connectivity=4)\n\n    blue_square = [obj for obj in objects if Color.BLUE in object_colors(obj)][0]\n    yellow_circles = [obj for obj in objects if Color.YELLOW in object_colors(obj)]\n\n    # Step 2: Calculate the center of all yellow circles\n    yellow_positions = np.array([object_position(circle) for circle in yellow_circles])\n    center_x = int(np.mean(yellow_positions[:, 0]))\n    center_y = int(np.mean(yellow_positions[:, 1]))\n\n    # Step 3: Move the blue square to the center of the yellow circles\n    blue_x, blue_y = object_position(blue_square)\n    displacement_x = center_x - blue_x\n    displacement_y = center_y - blue_y\n\n    # Translate blue square to the calculated center\n    translated_blue_square = translate(blue_square, displacement_x, displacement_y)\n\n    # Step 4: Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # Step 5: Surround the translated blue square with green pixels\n    sprite_bbox = bounding_box(translated_blue_square)\n    for dx in range(-1, 2):\n        for dy in range(-1, 2):\n            if (dx == 0 and dy == 0) or (sprite_bbox[0] + dx \u003c 0 or sprite_bbox[0] + dx \u003e= output_grid.shape[0] or \n                                          sprite_bbox[1] + dy \u003c 0 or sprite_bbox[1] + dy \u003e= output_grid.shape[1]):\n                continue\n            output_grid[sprite_bbox[0] + dx, sprite_bbox[1] + dy] = Color.GREEN\n\n    # Blit the translated blue square on top of the surrounding green\n    blit_sprite(output_grid, translated_blue_square, x=sprite_bbox[0], y=sprite_bbox[1])\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a grid with random size\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Place a blue square in the grid\n    blue_square = random_sprite(3, 3, color_palette=[Color.BLUE], density=1.0)\n    x, y = random_free_location_for_sprite(grid, blue_square, background=Color.BLACK)\n    blit_sprite(grid, blue_square, x, y)\n\n    # Randomly place several yellow circles on the grid\n    num_circles = np.random.randint(1, 6)\n    yellow_circle = random_sprite(2, 2, color_palette=[Color.YELLOW], density=1.0)\n\n    for _ in range(num_circles):\n        x, y = random_free_location_for_sprite(grid, yellow_circle, background=Color.BLACK)\n        blit_sprite(grid, yellow_circle, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/34/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/34/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/34/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/34/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/34/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/34/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/34/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/34/images/train_output_2.png"}]}, "index": 34, "seeds": ["bc1d5164", "ff28f65a", "3ac3eb23", "31aa019c"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bounding box, translation, color change\n\n# description:\n# In the input, you will see a grid with multiple colored pixels forming a shape.\n# To create the output grid, move the shape upward until it touches the top edge of the grid, while keeping it within the confines of the grid.\n# If any part of the shape exceeds the bounds of the grid, stop moving it. \n# Finally, change the color of the shape to green.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the shape in the input grid.\n    # 2. Calculate the bounding box of the shape to determine its dimensions and position.\n    # 3. Translate the shape upward until it touches the top edge of the grid or exceeds the bounds.\n    # 4. Change the color of the shape to green.\n\n    # 1. Find the connected component, which should be the only shape present\n    objects = find_connected_components(input_grid, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one shape in the grid\"\n    shape = objects[0]\n\n    # 2. Calculate the bounding box mask of the shape\n    bounding_mask = bounding_box_mask(shape)\n\n    # Get the current position of the shape\n    shape_x, shape_y = object_position(shape, background=Color.BLACK, anchor=\u0027upper left\u0027)\n\n    # 3. Translate the shape upward as far as possible without exceeding the grid bounds\n    height = input_grid.shape[1]\n    new_shape_y = shape_y - (shape_y - 0)  # Move upward until it hits the top\n    if new_shape_y \u003c 0:\n        new_shape_y = 0  # Ensure we do not exceed the top edge\n\n    # Create a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Blit the translated shape into the output grid\n    shape_translated = translate(shape, x=0, y=new_shape_y - shape_y, background=Color.BLACK)\n    blit_object(output_grid, shape_translated)\n\n    # 4. Change the color of the shape to green\n    output_grid[shape_translated != Color.BLACK] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Generate an empty grid\n    width, height = np.random.randint(5, 15), np.random.randint(5, 15)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Create a random shape with colors\n    shape_width, shape_height = np.random.randint(1, 4), np.random.randint(1, 4)\n    random_shape = random_sprite(shape_width, shape_height, color_palette=[random.choice(Color.NOT_BLACK)])\n\n    # Choose a random position for the shape, ensuring it fits within the grid\n    x = np.random.randint(0, width - shape_width + 1)\n    y = np.random.randint(0, height - shape_height + 1)\n\n    # Place the shape onto the grid\n    blit_sprite(grid, random_shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/35/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/35/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/35/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/35/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/35/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/35/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/35/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/35/images/train_output_2.png"}]}, "index": 35, "seeds": ["25ff71a9", "834ec97d", "a79310a0", "a3df8b1e"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components, gap filling\n\n# description:\n# In the input you will see two rectangles separated by a gap.\n# To make the output, fill the gap between the two rectangles with a diagonal pattern of colored pixels.\n\ndef main(input_grid):\n    # Copy the input grid as output\n    output_grid = input_grid.copy()\n\n    # Detect the connected components (rectangles)\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    if len(objects) != 2:\n        raise ValueError(\"Input grid must contain exactly two colored rectangles.\")\n\n    # Get the bounding boxes of the two objects\n    obj1_bounds = object_position(objects[0])\n    obj2_bounds = object_position(objects[1])\n\n    # Check the bounding box positions\n    x1, y1 = obj1_bounds\n    x2, y2 = obj2_bounds\n\n    # Fill the gap with a diagonal pattern of colored pixels if the objects are separated\n    for x in range(min(x1, x2), max(x1, x2) + 1):\n        for y in range(min(y1, y2), max(y1, y2) + 1):\n            # Check if the position is a gap between the two objects\n            if check_between_objects(obj1=objects[0], obj2=objects[1], x=x, y=y, padding=0):\n                # Create a diagonal pattern\n                if (x - min(x1, x2)) % 2 == 0:\n                    output_grid[x, y] = Color.TEAL\n                else:\n                    output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the rectangles\n    colors = np.random.choice([color for color in Color.NOT_BLACK if color != Color.BLACK], 2, replace=False)\n    color1, color2 = colors\n\n    # Generate two rectangles\n    n1, m1 = np.random.randint(3, 7, size=2)\n    n2, m2 = np.random.randint(3, 7, size=2)\n\n    rectangle1 = np.full((n1, m1), color1)\n    rectangle2 = np.full((n2, m2), color2)\n\n    # Place the rectangles on the grid with a gap between them\n    x1, y1 = random_free_location_for_sprite(grid=grid, sprite=rectangle1, background=Color.BLACK, padding=2, padding_connectivity=8)\n    blit_sprite(grid, rectangle1, x1, y1, Color.BLACK)\n\n    # Ensure there is a gap before placing the second rectangle\n    gap_width = np.random.randint(2, 5)\n    x2, y2 = x1 + n1 + gap_width, y1  # Place second rectangle to the right of the first with a gap\n    blit_sprite(grid, rectangle2, x2, y2, Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/36/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/36/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/36/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/36/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/36/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/36/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/36/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/36/images/train_output_2.png"}]}, "index": 36, "seeds": ["d06dbe63", "834ec97d", "3ac3eb23", "feca6190"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, boundary extraction, flood fill\n\n# description:\n# The input grid contains a black background with colored regions (colored pixels) that may be disconnected.\n# To produce the output, you need to find the boundaries of these colored regions and fill the inside of these regions with a new color (e.g., yellow).\n# The regions are defined by the connected components of pixels that are not black. \n\ndef main(input_grid):\n    # Create an output grid that starts as a copy of the input grid\n    output_grid = input_grid.copy()\n    \n    # Find all the connected components (colored regions)\n    components = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n    \n    # Iterate over each component to find its boundary and fill the interior\n    for component in components:\n        # Get the boundary of the current component\n        boundary = object_boundary(component, background=Color.BLACK)\n        \n        # Create a mask for the interior of this component\n        interior_mask = object_interior(component)\n        \n        # Fill the interior with yellow, but only if it\u0027s not part of the boundary\n        for x, y in np.argwhere(interior_mask \u0026 ~boundary):\n            output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size between 10x10 and 20x20 with a black background\n    width, height = np.random.randint(10, 21, size=2)\n    grid = np.zeros((width, height), dtype=int)\n    \n    # Randomly create colored regions\n    num_regions = np.random.randint(1, 5)\n    for _ in range(num_regions):\n        # Choose a random color (not black)\n        color = np.random.choice(list(Color.NOT_BLACK))\n        \n        # Randomly choose a size for the region\n        region_width = np.random.randint(2, 5)\n        region_height = np.random.randint(2, 5)\n        \n        # Create a sprite of the chosen size and color\n        sprite = np.full((region_width, region_height), color)\n        \n        # Try to place the sprite in a random free location in the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except ValueError:\n            # If no free location is found, we skip to the next region\n            continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/37/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/37/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/37/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/37/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/37/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/37/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/37/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/37/images/train_output_2.png"}]}, "index": 37, "seeds": ["834ec97d", "3ac3eb23", "8d510a79", "6d58a25d"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern, star shape, collision detection\n\n# description:\n# In the input, you will see a grid with a single colored pixel.\n# To make the output, create a star-shaped pattern from the colored pixel, extending outward in a cross pattern.\n# The star will have arms extending up, down, left, and right. \n# If any of the arms collide with another colored pixel, they should stop growing in that direction.\n\ndef main(input_grid):\n    # Extract the position and color of the single pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # Create the output grid\n    output_grid = input_grid.copy()\n    \n    # Define the directions for the star arms: up, down, left, right\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]  # (dx, dy)\n\n    # Draw each arm of the star\n    for dx, dy in directions:\n        x, y = pixel_x, pixel_y\n        while True:\n            x += dx\n            y += dy\n            \n            # Check for collision with the background color\n            if not (0 \u003c= x \u003c output_grid.shape[0] and 0 \u003c= y \u003c output_grid.shape[1]):\n                break  # Stop if out of bounds\n            \n            if collision(object1=output_grid, object2=np.array([[pixel_color]]), x1=pixel_x, y1=pixel_y, x2=x, y2=y):\n                break  # Stop if colliding with a colored pixel\n            \n            output_grid[x, y] = pixel_color  # Color the current pixel\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid of random size\n    width, height = np.random.randint(5, 20, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose a color for the pixel\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # Randomly place the colored pixel somewhere in the grid\n    x, y = np.random.randint(0, width), np.random.randint(0, height)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/38/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/38/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/38/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/38/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/38/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/38/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/38/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/38/images/train_output_2.png"}]}, "index": 38, "seeds": ["28e73c20", "3ac3eb23", "834ec97d", "746b3537"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# layer stacking, color encoding\n\n# description:\n# In the input, you will see a grid with different colored layers that are stacked on top of each other. Each layer can have different shapes and colors, but only the topmost layer is visible. To produce the output, make a new grid where each visible layer is transformed based on its color: \n# - If the layer is red, replace it with yellow.\n# - If the layer is blue, replace it with green.\n# - If the layer is green, replace it with red.\n# The output grid should show only the visible colors from the stacking, maintaining their positions.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect all layers in the grid\n    # 2. Replace the visible layers according to the color transformation rules\n    # 3. Create a new output grid that shows only the visible layers after transformation\n\n    # 1. Detect all layers\n    layers = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n\n    # Create an output grid initialized with black\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # 2. Process each layer, transforming colors and stacking them\n    for layer in layers:\n        # Identify the unique colors in the layer\n        unique_colors = set(layer.flatten())\n        for color in unique_colors:\n            if color == Color.RED:\n                new_color = Color.YELLOW\n            elif color == Color.BLUE:\n                new_color = Color.GREEN\n            elif color == Color.GREEN:\n                new_color = Color.RED\n            else:\n                continue  # Skip colors that do not need transformation\n\n            # Find the positions of the original color and update them in the output grid\n            output_grid[layer == color] = new_color\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with random layers of colors\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Randomly stack layers of colored shapes\n    num_layers = np.random.randint(3, 6)  # Number of layers\n    for _ in range(num_layers):\n        # Generate a random sprite representing a layer\n        layer = random_sprite([2, 3, 4], [2, 3, 4], connectivity=4, color_palette=[Color.RED, Color.BLUE, Color.GREEN], background=Color.BLACK)\n\n        # Randomly place the layer in the grid\n        x, y = random_free_location_for_sprite(grid, layer, background=Color.BLACK)\n        blit_sprite(grid, layer, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/39/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/39/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/39/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/39/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/39/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/39/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/39/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/39/images/train_output_2.png"}]}, "index": 39, "seeds": ["137eaa0f", "8a004b2b", "6455b5f5", "e509e548"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change, connectivity\n\n# description:\n# In the input you will see a grid with several blue objects and a single yellow object.\n# To create the output grid, you should find the yellow object and connect it to the nearest blue object with a green line.\n# If there are no blue objects nearby, the yellow object should be changed to red.\n\ndef main(input_grid):\n    # Create a copy of the input grid for output\n    output_grid = input_grid.copy()\n    \n    # Detect all blue objects\n    blue_objects = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    \n    # Detect the single yellow object\n    yellow_objects = detect_objects(grid=input_grid, colors=[Color.YELLOW], monochromatic=True, connectivity=4)\n    \n    if len(yellow_objects) == 0:\n        return output_grid # no yellow object found\n    \n    yellow_object = yellow_objects[0]\n    \n    # If no blue objects found, change yellow object to red\n    if len(blue_objects) == 0:\n        yellow_object[yellow_object != Color.BLACK] = Color.RED\n        blit_object(output_grid, yellow_object, background=Color.BLACK)\n        return output_grid\n\n    # Get the position of the yellow object\n    yellow_x, yellow_y, _, _ = bounding_box(yellow_object, background=Color.BLACK)\n\n    # Find the closest blue object\n    closest_blue = None\n    closest_distance = float(\u0027inf\u0027)\n\n    for blue in blue_objects:\n        blue_x, blue_y, _, _ = bounding_box(blue, background=Color.BLACK)\n        distance = np.abs(blue_x - yellow_x) + np.abs(blue_y - yellow_y)\n        \n        if distance \u003c closest_distance:\n            closest_distance = distance\n            closest_blue = blue\n\n    if closest_blue is not None:\n        # Get the bounding box of the closest blue object\n        closest_x, closest_y, _, _ = bounding_box(closest_blue, background=Color.BLACK)\n\n        # Draw a green line connecting the yellow object to the closest blue object\n        for x, y in np.argwhere(output_grid == Color.BLACK):\n            if check_between_objects(yellow_object, closest_blue, x, y, padding=0):\n                output_grid[x, y] = Color.GREEN\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a grid of size n x m\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Place the yellow object\n    yellow_sprite = random_sprite(2, 2, color_palette=[Color.YELLOW])\n    y_x, y_y = random_free_location_for_sprite(grid=grid, sprite=yellow_sprite, padding=1)\n    grid = blit_sprite(grid, yellow_sprite, x=y_x, y=y_y, background=Color.BLACK)\n\n    # Place several blue objects around the yellow one\n    num_blue_objects = np.random.randint(1, 6)\n    for _ in range(num_blue_objects):\n        blue_sprite = random_sprite(np.random.randint(2, 4), np.random.randint(2, 4), color_palette=[Color.BLUE])\n        while True:\n            try:\n                x, y = random_free_location_for_sprite(grid, blue_sprite, padding=1)\n                grid = blit_sprite(grid, blue_sprite, x=x, y=y, background=Color.BLACK)\n                break\n            except ValueError:\n                continue\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/40/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/40/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/40/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/40/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/40/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/40/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/40/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/40/images/train_output_2.png"}]}, "index": 40, "seeds": [], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color separation, object placement, collision detection\n\n# description:\n# In the input, you will see several colored pixels forming a shape, which is surrounded by a black background.\n# To make the output, you need to place a new shape of a different color, directly below the original shape,\n# ensuring that the new shape does not overlap with the original shape. The new shape should be the same size as the original shape.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Find the bounding box of the original shape.\n    # 2. Determine the position for the new shape, which will be directly below the original shape.\n    # 3. Create the new shape with a different color.\n    # 4. Check for collision to ensure the new shape can fit without overlapping the original shape.\n    # 5. Place the new shape on the grid if there is no collision.\n\n    # 1. Find the bounding box of the original shape\n    original_shape = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)[0]\n    x, y, width, height = bounding_box(original_shape)\n\n    # 2. Determine the position for the new shape\n    new_shape_x = x\n    new_shape_y = y + height  # Place directly below the original shape\n\n    # 3. Create the new shape with a different color\n    new_shape_color = Color.BLUE  # Example color for the new shape\n    new_shape = np.full((height, width), new_shape_color)\n\n    # 4. Check for collision to ensure the new shape can fit without overlapping the original shape\n    if collision(object1=input_grid, object2=new_shape, x1=new_shape_x, y1=new_shape_y):\n        raise ValueError(\"Collision detected: Cannot place new shape without overlap.\")\n\n    # 5. Place the new shape on the grid\n    output_grid = input_grid.copy()\n    blit_sprite(output_grid, new_shape, x=new_shape_x, y=new_shape_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random shape on a black grid\n    width = np.random.randint(5, 15)\n    height = np.random.randint(5, 15)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly create a shape with non-black pixels\n    shape_color = np.random.choice(Color.NOT_BLACK)\n    shape_width = np.random.randint(2, 5)\n    shape_height = np.random.randint(2, 5)\n    \n    shape = np.full((shape_height, shape_width), shape_color)\n\n    # Place the shape randomly on the grid\n    x, y = random_free_location_for_sprite(grid, shape, background=Color.BLACK, padding=1)\n    blit_sprite(grid, shape, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/41/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/41/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/41/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/41/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/41/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/41/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/41/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/41/images/train_output_2.png"}]}, "index": 41, "seeds": [], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotation, alignment, overlay\n\n# description:\n# In the input you will see a blue object and a yellow arrow indicating a direction.\n# To make the output, rotate the blue object to align it with the arrow, and overlay the rotated blue object on the grid.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Detect the objects; separate the blue object from the yellow arrow\n    # 2. Determine the angle of the arrow\n    # 3. Rotate the blue object to align with the arrow and overlay it on the grid\n\n    # 1. Object detection and setup\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=True)\n\n    blue_objects = [obj for obj in objects if Color.BLUE in object_colors(obj, background=Color.BLACK)]\n    arrow_objects = [obj for obj in objects if Color.YELLOW in object_colors(obj, background=Color.BLACK)]\n\n    assert len(blue_objects) == 1, \"There should be exactly one blue object\"\n    assert len(arrow_objects) == 1, \"There should be exactly one yellow arrow\"\n\n    blue_object = blue_objects[0]\n    arrow_object = arrow_objects[0]\n\n    # Make the output grid: Start with a black background\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. Determine the angle of the arrow\n    arrow_x, arrow_y = object_position(arrow_object, background=Color.BLACK, anchor=\"center\")\n    # Check the direction in which the arrow points\n    arrow_direction = np.array(np.argwhere(arrow_object == Color.YELLOW))\n    if arrow_direction.size == 0:\n        return output_grid  # Return empty if no direction found\n\n    # Calculate the angle based on the arrow\u0027s position\n    # We can use the y-coordinates to determine the vertical position of the arrow\n    if arrow_direction[0][0] \u003c arrow_object.shape[0] / 2:  # Arrow points up\n        angle = 0\n    elif arrow_direction[0][0] \u003e arrow_object.shape[0] / 2:  # Arrow points down\n        angle = 180\n    else:  # Arrow points right\n        angle = 90\n\n    # 3. Rotate the blue object to align with the arrow\n    rotated_blue_object = np.rot90(blue_object, k=angle // 90)\n\n    # Overlay the rotated blue object on the output grid\n    blit_object(output_grid, rotated_blue_object)\n\n    return output_grid\n\ndef generate_input():\n    # Create a grid with a blue shape and a yellow arrow indicating the direction\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Create a blue object\n    blue_sprite = random_sprite(3, 5, color_palette=[Color.BLUE])\n    x, y = random_free_location_for_sprite(grid, blue_sprite, background=Color.BLACK)\n    blit_sprite(grid, blue_sprite, x, y, background=Color.BLACK)\n\n    # Create a yellow arrow\n    arrow_sprite = np.zeros((3, 3), dtype=object)\n    arrow_sprite[1, 0] = Color.YELLOW  # Arrow base\n    arrow_sprite[0, 1] = Color.YELLOW  # Arrow point\n    arrow_sprite[1, 1] = Color.YELLOW  # Arrow point\n    arrow_sprite[2, 1] = Color.YELLOW  # Arrow point\n    arrow_sprite[1, 2] = Color.YELLOW  # Arrow point\n\n    # Position the arrow pointing in a random direction\n    arrow_x, arrow_y = random_free_location_for_sprite(grid, arrow_sprite, background=Color.BLACK)\n    blit_sprite(grid, arrow_sprite, arrow_x, arrow_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/42/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/42/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/42/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/42/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/42/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/42/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/42/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/42/images/train_output_2.png"}]}, "index": 42, "seeds": ["e8dc4411", "56dc2b01", "57aa92db", "5168d44c"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, object boundaries, coloring\n\n# description:\n# In the input grid, you will see a background of black pixels, and several enclosed regions formed by green pixels.\n# To produce the output, you need to find the boundaries of these enclosed regions and color them blue. \n# Additionally, any interior pixels (the pixels that are not part of the boundary but are within the enclosed regions) should be colored red.\n\ndef main(input_grid):\n    # Create the output grid as a copy of the input grid\n    output_grid = np.copy(input_grid)\n\n    # Identify the boundaries of the green regions\n    boundary_mask = object_boundary(input_grid, background=Color.BLACK)\n    \n    # Color the boundaries blue\n    output_grid[boundary_mask] = Color.BLUE\n\n    # Find the interior pixels (not part of the boundary but within the green regions)\n    interior_mask = object_interior(input_grid)\n    inside_but_not_on_edge = interior_mask \u0026 ~boundary_mask\n\n    # Color the interior pixels red\n    output_grid[inside_but_not_on_edge] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # Generate a square grid with a black background, size from 10x10 to 20x20\n    n = np.random.randint(10, 21)\n    grid = np.full((n, n), Color.BLACK)\n\n    # Generate random green sprites forming enclosed regions\n    n_objects = np.random.randint(2, 5)\n    for _ in range(n_objects):\n        w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n        sprite = random_sprite(w, h, color_palette=[Color.GREEN])\n\n        # Hollow out the interior to create a boundary\n        interior_mask = object_interior(sprite)\n        boundary_mask = object_boundary(sprite)\n        interior_but_not_edges = interior_mask \u0026 ~boundary_mask\n        sprite[interior_but_not_edges] = Color.BLACK  # Make the interior black\n\n        # Try to place the sprite on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n        except ValueError:\n            continue  # Skip if no free location is found\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/43/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/43/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/43/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/43/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/43/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/43/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/43/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/43/images/train_output_2.png"}]}, "index": 43, "seeds": ["264363fd_Kevin", "7f4411dc", "7e0986d6", "0e206a2e"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines, pixel expansion\n\n# description:\n# In the input, you will see a horizontal line of colored pixels on a black background.\n# To make the output, create a square grid and place the input line at the top-left. Each colored pixel shoots a diagonal line outward toward the lower right.\n# The length of the output grid is the product of the number of colored input pixels and the length of the input line.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Determine the size of the output grid based on the input grid dimensions and the number of colored pixels.\n    # 2. Place the input line at the top-left of the output grid.\n    # 3. For each colored pixel, draw diagonal lines extending downward to the right.\n\n    # 1. Count the number of colored pixels in the input grid\n    colored_pixels = np.sum(input_grid != Color.BLACK)\n    input_height, input_width = input_grid.shape\n    output_size = colored_pixels * input_width  # Define output size\n\n    # Create the output grid filled with black color\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # 2. Place the input line at the top-left of the output grid\n    blit_sprite(output_grid, input_grid, x=0, y=0)\n\n    # 3. Draw diagonal lines from each colored pixel in the input line\n    for x in range(input_width):\n        if input_grid[x, 0] != Color.BLACK:  # Only process colored pixels\n            # Start drawing diagonal lines\n            draw_line(output_grid, x, 0, length=None, color=input_grid[x, 0], direction=(1, 1))\n\n    return output_grid\n\ndef generate_input():\n    # Generate a horizontal line of colored pixels\n    width = np.random.randint(3, 8)  # Random width for the line\n    grid = np.full((width, 1), Color.BLACK)  # Start with a black grid\n\n    # Randomly assign colors to the pixels in the line, ensuring at least one color\n    num_colored_pixels = np.random.randint(1, width + 1)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colored_pixels, replace=False)\n    for i in range(num_colored_pixels):\n        grid[np.random.randint(0, width), 0] = colors[i]\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/44/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/44/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/44/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/44/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/44/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/44/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/44/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/44/images/train_output_2.png"}]}, "index": 44, "seeds": ["feca6190", "834ec97d", "3ac3eb23", "8d510a79"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision detection, occlusion, translation\n\n# description:\n# In the input, you will see a colored object (not black) and a rectangular occluder that partially covers it.\n# The output should be the complete object after sliding the occluder away from the object until they just touch.\n\ndef main(input_grid):\n    # Plan:\n    # 1. Identify the occluder and the original object.\n    # 2. Determine the best position to slide the occluder.\n    # 3. Slide the occluder towards the object until they touch without overlapping.\n\n    # Identify the occluder (black rectangle) and the colored object (not black)\n    occluder_mask = (input_grid == Color.BLACK)\n    object_mask = (input_grid != Color.BLACK)\n\n    # Get the shape of the grid\n    height, width = input_grid.shape\n\n    # Initialize output grid with the original object\n    output_grid = np.copy(input_grid)\n\n    # Get coordinates of the object\n    object_coords = np.argwhere(object_mask)\n\n    # Check if the object is present\n    if object_coords.size == 0:\n        return output_grid  # Nothing to process\n\n    # Identify the edges of the occluder\n    occluder_coords = np.argwhere(occluder_mask)\n    occluder_top_left = occluder_coords.min(axis=0)\n    occluder_bottom_right = occluder_coords.max(axis=0)\n\n    # Slide the occluder in four directions\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]  # Down, Up, Right, Left\n    for dx, dy in directions:\n        # Translate the occluder\n        translated_occluder = translate(input_grid[occluder_top_left[0]:occluder_bottom_right[0]+1, \n                                                   occluder_top_left[1]:occluder_bottom_right[1]+1], \n                                         dx, dy, background=Color.BLACK)\n\n        # Check for collisions with the object\n        if collision(object1=object_mask, object2=translated_occluder, background=Color.BLACK):\n            # If they touch, update the output grid\n            blit_sprite(output_grid, translated_occluder, occluder_top_left[0] + dx, occluder_top_left[1] + dy, \n                        background=Color.BLACK)\n            break\n\n    return output_grid\n\n\ndef generate_input():\n    # Plan:\n    # 1. Create a random grid with a colored object.\n    # 2. Place a rectangular occluder over the object.\n\n    # Create a grid of a random size with a black background\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a colored object\n    object_color = np.random.choice(Color.NOT_BLACK)\n    sprite = random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), density=0.5, color_palette=[object_color])\n\n    # Place the colored object randomly onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    # Create a rectangular occluder\n    occluder_width, occluder_height = np.random.randint(2, 5), np.random.randint(2, 5)\n    occluder_x, occluder_y = random.randint(0, n-occluder_height), random.randint(0, m-occluder_width)\n    occluder = np.full((occluder_height, occluder_width), Color.BLACK)\n\n    # Blit the occluder on top of the object\n    blit_sprite(grid, occluder, occluder_x, occluder_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/45/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/45/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/45/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/45/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/45/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/45/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/45/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/45/images/train_output_2.png"}]}, "index": 45, "seeds": ["f9012d9b", "0dfd9992", "caa06a1f", "3345333e"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, pattern placement, color identification\n\n# description:\n# In the input you will see a large colored grid with a smaller colored sprite inside a square border of a different color.\n# To make the output, you should scale the sprite to fit exactly within the border square, filling the border completely.\n# The border will be of a specified color (e.g., red), and the smaller sprite will be of another color (e.g., blue).\n# The output should be only the scaled sprite placed inside the border.\n\ndef main(input_grid):\n    # Detect the border square and the small sprite\n    objects = detect_objects(input_grid, monochromatic=False, connectivity=8)\n    \n    # Extract the objects: one will be the border (indicated by a unique color) and the other the sprite\n    for obj in objects:\n        sprite = crop(obj, background=Color.BLACK)\n        if Color.RED in object_colors(sprite, background=Color.BLACK):\n            border_sprite = sprite\n        else:\n            inner_sprite = sprite\n    \n    # Calculate the scaling factor based on the border size.\n    # The border should have a 1-pixel border around it, so we must account for that\n    scale = (len(border_sprite) - 2) // len(inner_sprite)\n\n    # Scale the small sprite to fit the border\n    scaled_inner_sprite = scale_sprite(inner_sprite, factor=scale)\n\n    # Prepare the output grid which will only contain the scaled sprite\n    output_grid = np.full(border_sprite.shape, Color.BLACK)\n    blit_sprite(output_grid, scaled_inner_sprite, x=1, y=1, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Define the small object size\n    small_object_size = 3\n    scale = np.random.randint(1, 4)  # Scale factor for enlarging the sprite\n    \n    # Create the border square with the specified scale\n    border_size = scale * small_object_size + 2  # accounting for border\n    big_border_square = np.full((border_size, border_size), Color.RED)\n    big_border_square[1:-1, 1:-1] = Color.BLACK  # inner area is black\n\n    # Randomly place the border square in the grid\n    x_border, y_border = random_free_location_for_sprite(grid, big_border_square)\n    grid = blit_sprite(x=x_border, y=y_border, grid=grid, sprite=big_border_square, background=Color.BLACK)\n\n    # Generate the small sprite to fit inside the border\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.RED]\n    random_color = np.random.choice(available_colors)\n\n    # Randomly create the small sprite\n    small_sprite = random_sprite(n=small_object_size, m=small_object_size, color_palette=[random_color], density=0.5)\n\n    # Place the small sprite in the area without the red border\n    x_sprite, y_sprite = random_free_location_for_sprite(grid, small_sprite)\n    grid = blit_sprite(x=x_sprite, y=y_sprite, grid=grid, sprite=small_sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/46/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/46/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/46/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/46/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/46/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/46/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/46/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/46/images/train_output_2.png"}]}, "index": 46, "seeds": ["6fa7a44f", "3ac3eb23", "8e5a5113", "3e980e27"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color matching, grid manipulation\n\n# description:\n# In the input, you will see a grid with a pattern of colored pixels in the center,\n# surrounded by a border of black pixels. The pattern consists of a 3x3 area filled with various colors.\n# To create the output, copy the central pattern and change the color of the pixels to match the color\n# of the top-left pixel of the pattern. The output grid should have an extra border of black pixels around it.\n\ndef main(input_grid):\n    # Step 1: Crop the central 3x3 pattern from the input grid.\n    pattern = input_grid[1:4, 1:4]\n    \n    # Step 2: Determine the color of the top-left pixel of the pattern.\n    color_to_match = pattern[0, 0]\n    \n    # Step 3: Create an output grid with an additional border of black pixels.\n    output_grid = np.full((5, 5), Color.BLACK)\n    \n    # Step 4: Change the color of the pixels in the cropped pattern to match the top-left pixel color.\n    pattern[pattern != Color.BLACK] = color_to_match\n    \n    # Step 5: Blit the modified pattern onto the output grid.\n    blit_sprite(output_grid, pattern, x=1, y=1, background=Color.BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a 5x5 grid filled with black pixels\n    input_grid = np.full((5, 5), Color.BLACK)\n    \n    # Generate a random 3x3 pattern with colors\n    pattern_colors = np.random.choice(list(Color.NOT_BLACK), size=(3, 3))\n    \n    # Place the pattern in the center of the input grid\n    input_grid[1:4, 1:4] = pattern_colors\n    \n    return input_grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/47/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/47/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/47/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/47/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/47/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/47/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/47/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/47/images/train_output_2.png"}]}, "index": 47, "seeds": ["bc1d5164", "46f33fce", "3de23699", "1fad071e"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color alignment, object extraction\n\n# description:\n# In the input grid, you will see several colored objects, each containing a distinct color in one of their corners, and a single pixel of another color in the center of the grid.\n# To make the output grid, you should rotate each object until it aligns such that the corner pixel of the object matches the center pixel\u0027s color, then arrange all these objects so that they cluster around the center.\n\ndef main(input_grid):\n    # Detect the colored objects in the grid. Each object has a unique color in one corner.\n    objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=4)\n    \n    # Create an output grid that will be modified\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Find the center pixel\u0027s color\n    center_color = input_grid[input_grid.shape[0] // 2, input_grid.shape[1] // 2]\n\n    # Process each detected object\n    for obj in objects:\n        # Determine the corner pixel that contains the unique color\n        corner_pixel_pos = np.argwhere(obj != Color.BLACK)[0]\n        corner_color = obj[corner_pixel_pos[0], corner_pixel_pos[1]]\n\n        # Check if the corner color matches the center color\n        if corner_color == center_color:\n            # If colors match, we can place it without rotation\n            x_offset = (output_grid.shape[0] // 2) - corner_pixel_pos[0]\n            y_offset = (output_grid.shape[1] // 2) - corner_pixel_pos[1]\n            blit_sprite(output_grid, obj, x_offset, y_offset, background=Color.BLACK)\n        else:\n            # Rotate the object to find a matching configuration\n            for rotation in range(4):\n                rotated_obj = np.rot90(obj, rotation)\n                new_corner_pos = np.argwhere(rotated_obj != Color.BLACK)[0]\n                new_corner_color = rotated_obj[new_corner_pos[0], new_corner_pos[1]]\n                \n                if new_corner_color == center_color:\n                    # Place the object with the matching corner in the output\n                    x_offset = (output_grid.shape[0] // 2) - new_corner_pos[0]\n                    y_offset = (output_grid.shape[1] // 2) - new_corner_pos[1]\n                    blit_sprite(output_grid, rotated_obj, x_offset, y_offset, background=Color.BLACK)\n                    break\n\n    return output_grid\n\ndef generate_input():\n    # Create a random size grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Create a random center pixel color\n    center_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Place the center pixel in the middle of the grid\n    grid[n // 2, m // 2] = center_color\n\n    # Generate random objects with distinct colors in one of their corners\n    num_objects = np.random.randint(3, 7)\n    for _ in range(num_objects):\n        obj_color = np.random.choice(list(Color.NOT_BLACK))\n        size = np.random.randint(2, 5)\n        obj = np.full((size, size), Color.BLACK)\n        obj[0, 0] = obj_color  # Set a unique color at one corner of the object\n\n        # Place the object in a random position in the grid, making sure it fits\n        x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK, padding=1)\n        blit_sprite(grid, obj, x, y)\n\n    return grid", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/48/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/48/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/48/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/48/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/48/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/48/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/48/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/48/images/train_output_2.png"}]}, "index": 48, "seeds": ["0e206a2e", "aabf363d", "1f642eb9", "137eaa0f"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, color filling\n\n# description:\n# In the input, you will see a grid containing a symmetric pattern of colored pixels that has been partially occluded by a black rectangle.\n# The output should be the missing part of the pattern, which should match the colors of the symmetric pattern.\n\ndef main(input_grid):\n    # Step 1: Identify the occluded area (black rectangle)\n    occlusion_color = Color.BLACK\n    occluded_area = (input_grid == occlusion_color)\n\n    # Step 2: Detect the symmetry of the input grid, excluding the occluded area\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n\n    # Step 3: Fill in the missing part using the symmetry\n    for occluded_x, occluded_y in np.argwhere(occluded_area):\n        # Get the symmetric points\u0027 colors and fill the occluded pixel\n        for symmetric_x, symmetric_y in orbit(input_grid, occluded_x, occluded_y, symmetries):\n            if input_grid[symmetric_x, symmetric_y] != occlusion_color:\n                input_grid[occluded_x, occluded_y] = input_grid[symmetric_x, symmetric_y]\n                break\n\n    # Step 4: Extract the filled region to return as the output sprite\n    filled_in_region = np.full_like(input_grid, occlusion_color)\n    filled_in_region[occluded_area] = input_grid[occluded_area]\n    filled_in_region = crop(filled_in_region, background=occlusion_color)\n\n    return filled_in_region\n\ndef generate_input():\n    # Step 1: Create a random sprite\n    w, h = np.random.randint(3, 6, size=(2))\n    sprite = random_sprite(w, h, color_palette=Color.NOT_BLACK, density=1)\n\n    # Step 2: Create a symmetric pattern by tiling the sprite\n    horizontal_repetitions, vertical_repetitions = np.random.randint(2, 5, size=(2))\n    pattern = np.tile(sprite, (horizontal_repetitions, vertical_repetitions))\n\n    # Step 3: Occlude part of the pattern with a randomly placed black rectangle\n    w_occluder, h_occluder = np.random.randint(2, 5, size=(2))\n    x_occluder = np.random.randint(0, pattern.shape[0] - w_occluder + 1)\n    y_occluder = np.random.randint(0, pattern.shape[1] - h_occluder + 1)\n    black_rectangle_sprite = np.full((w_occluder, h_occluder), Color.BLACK)\n    \n    # Blit the black rectangle onto the pattern to create the occlusion\n    grid_with_occlusion = blit_sprite(pattern, black_rectangle_sprite, x_occluder, y_occluder, background=None)\n\n    return grid_with_occlusion", "images": {"test": {"input": "output/synthetic_examples/barc_heavy_suggest/49/images/test_input.png", "output": "output/synthetic_examples/barc_heavy_suggest/49/images/test_output.png"}, "train": [{"input": "output/synthetic_examples/barc_heavy_suggest/49/images/train_input_0.png", "output": "output/synthetic_examples/barc_heavy_suggest/49/images/train_output_0.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/49/images/train_input_1.png", "output": "output/synthetic_examples/barc_heavy_suggest/49/images/train_output_1.png"}, {"input": "output/synthetic_examples/barc_heavy_suggest/49/images/train_input_2.png", "output": "output/synthetic_examples/barc_heavy_suggest/49/images/train_output_2.png"}]}, "index": 49, "seeds": ["8e5a5113", "6fa7a44f", "8e1813be", "834ec97d"], "source": "barc_heavy_suggest", "source_description": "Examples generated by the Heavy model with functional suggestions", "source_display_name": "BARC Heavy with Suggestions", "total_examples": 50}];
        const sourceInfo = {
            barc_gpt4_desc: {
                name: 'GPT-4',
                description: 'Data generated by GPT4-generated descriptions and GPT4o-mini-generated codes, with 100 seeds from the training dataset.'
            },
            barc_gpt4o_mini_desc: {
                name: 'GPT4o-mini',
                description: 'Data generated by GPT4o-mini generated descriptions and GPT4o-mini generated codes, with 100 seeds from the training dataset.'
            },
            barc_heavy: {
                name: 'Heavy Model',
                description: 'Data generated by GPT4o-generated descriptions and GPT4o-mini-generated codes, with 160 seeds from the training dataset.'
            },
            barc_heavy_suggest: {
                name: 'Heavy Model with Suggestions',
                description: 'Data generated by GPT4o generated descriptions and GPT4o-mini with suggestion functions generated codes, with 160 seeds from the training dataset.'
            }
        };

        let state = {
            currentSource: 'barc_gpt4_desc',
            page: 0,
            loading: false,
            itemsPerPage: 12,
            shuffled: false,
            shuffledExamples: [],
            originalExamples: [], 
            shuffleCount: 0
        };

        // UI Components
        const ui = {
            grid: document.getElementById('examplesGrid'),
            loading: document.getElementById('loadingIndicator'),
            sourceSelect: document.getElementById('sourceSelector'),
            totalCount: document.getElementById('totalCount'),
            currentSource: document.getElementById('currentSource'),
            description: document.getElementById('descriptionText'),
            shuffleButton: document.getElementById('shuffleButton'),
            resetButton: document.getElementById('resetButton')
        };

        // Helper Functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            // Double shuffle for better randomization
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function getFilteredExamples() {
            const filtered = examples.filter(ex => ex.source === state.currentSource);
            if (state.shuffled) {
                return state.shuffledExamples;
            }
            return filtered;
        }

        function handleShuffle() {
            state.shuffled = true;
            state.page = 0;
            state.shuffleCount++;
            ui.grid.innerHTML = '';
            
            if (state.shuffleCount === 1) {
                const filtered = examples.filter(ex => ex.source === state.currentSource);
                state.originalExamples = [...filtered];
            }
            
            state.shuffledExamples = shuffleArray(
                state.shuffleCount === 1 ? state.originalExamples : state.shuffledExamples
            );
            
            // Show reset button (both desktop and mobile)
            ui.resetButton.classList.remove('hidden');
            document.getElementById('mobileResetButton')?.classList.remove('hidden');
            
            // Add spin animation
            [ui.shuffleButton, document.getElementById('mobileShuffleButton')].forEach(button => {
                if (button) {
                    const icon = button.querySelector('i');
                    icon.classList.add('spin-animation');
                    setTimeout(() => icon.classList.remove('spin-animation'), 1000);
                }
            });
            
            loadMoreExamples();
        }

        function handleReset() {
            state.shuffled = false;
            state.page = 0;
            state.shuffleCount = 0;
            state.shuffledExamples = [];
            ui.grid.innerHTML = '';
            
            // Hide reset button (both desktop and mobile)
            ui.resetButton.classList.add('hidden');
            document.getElementById('mobileResetButton')?.classList.add('hidden');
            
            // Add spin animation
            [ui.resetButton, document.getElementById('mobileResetButton')].forEach(button => {
                if (button) {
                    const icon = button.querySelector('i');
                    icon.classList.add('spin-animation');
                    setTimeout(() => icon.classList.remove('spin-animation'), 1000);
                }
            });
            
            loadMoreExamples();
        }

        function updateSourceInfo() {
            const filtered = getFilteredExamples();
            const info = sourceInfo[state.currentSource];
            
            ui.totalCount.textContent = filtered.length;
            ui.currentSource.textContent = info.name;
            ui.description.textContent = info.description;
        }

        function showToast(message, isError = false) {
            // Remove any existing toasts
            const existingToasts = document.querySelectorAll('.copy-toast');
            existingToasts.forEach(toast => toast.remove());
            
            // Create new toast
            const toast = document.createElement('div');
            toast.className = `copy-toast ${isError ? 'error' : ''}`;
            toast.textContent = message;
            
            // Add to DOM
            document.body.appendChild(toast);
            
            // Remove after animation completes
            toast.addEventListener('animationend', () => toast.remove());
        }

        function copyToClipboard(text, button) {
            // Check if we can use the modern clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showCopySuccess(button);
                    })
                    .catch(() => {
                        fallbackCopyToClipboard(text, button);
                    });
            } else {
                fallbackCopyToClipboard(text, button);
            }
        }

        function fallbackCopyToClipboard(text, button) {
            // Create temporary textarea
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            
            try {
                textArea.select();
                document.execCommand('copy');
                showCopySuccess(button);
            } catch (err) {
                showToast('Failed to copy', true);
            } finally {
                textArea.remove();
            }
        }

        function showCopySuccess(button) {
            showToast('Copied to clipboard');
            button.classList.add('copied');
            const icon = button.querySelector('i');
            icon.classList.remove('fa-copy');
            icon.classList.add('fa-check');
            
            setTimeout(() => {
                button.classList.remove('copied');
                icon.classList.remove('fa-check');
                icon.classList.add('fa-copy');
            }, 1500);
        }

        function createExampleCard(example) {
            const codeHtml = example.code ? example.code.replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';
            const rawCode = example.code ? example.code.replace(/`/g, '\\`').replace(/\${/g, '\\${') : '';
            
            return `
                <div class="card-container" id="card-${example.index}">
                    <div class="card-flipper">
                        <div class="card-front">
                            <div class="example-card">
                                <div class="card-header">
                                    <span class="text-lg font-medium text-slate-400">
                                        Example ${example.index + 1}
                                    </span>
                                    <div class="seeds-dropdown">
                                        <button class="button-base" onclick="toggleSeeds(${example.index}, event)">
                                            <i class="fas fa-seedling"></i>
                                        </button>
                                        <div class="seeds-content" id="seeds-${example.index}">
                                            ${example.seeds.map(seed => `
                                            <a href="#" class="seed-link" onclick="handleSeedFilter(event, ${example.index})">
                                                ${seed}
                                            </a>
                                            `).join('')}
                                        </div>
                                    </div>
                                    <button class="button-base" onclick="toggleCode(${example.index})">
                                        <i class="fas fa-code"></i>
                                        <span>View Code</span>
                                    </button>
                                </div>
                                
                                <div class="image-grid">
                                    ${example.images.train.map((train, i) => `
                                        <div class="image-container">
                                            <div class="image-pair">
                                                <div class="image-wrapper">
                                                    <img data-src="${train.input}" 
                                                        alt="Train Input ${i+1}" 
                                                        class="w-full rounded-lg">
                                                    <p class="image-caption">Train Input ${i+1}</p>
                                                </div>
                                                <div class="image-wrapper">
                                                    <img data-src="${train.output}" 
                                                        alt="Train Output ${i+1}" 
                                                        class="w-full rounded-lg">
                                                    <p class="image-caption">Train Output ${i+1}</p>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                    
                                    <div class="image-container">
                                        <div class="image-pair">
                                            <div class="image-wrapper">
                                                <img data-src="${example.images.test.input}" 
                                                    alt="Test Input"
                                                    class="w-full rounded-lg">
                                                <p class="image-caption">Test Input</p>
                                            </div>
                                            <div class="image-wrapper">
                                                <img data-src="${example.images.test.output}" 
                                                    alt="Test Output"
                                                    class="w-full rounded-lg">
                                                <p class="image-caption">Test Output</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-back">
                            <div class="card-header">
                                <!-- Change the onclick to use a data attribute instead -->
                                <button class="button-base copy-button" data-code="${rawCode}">
                                    <i class="fas fa-copy"></i>
                                    <span>Copy</span>
                                </button>
                                <button class="button-base" onclick="toggleCode(${example.index})">
                                    <i class="fas fa-image"></i>
                                    <span>View Example</span>
                                </button>
                            </div>
                            <div class="code-content">
                                <pre><code class="language-python">${codeHtml}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function initializeCopyButtons() {
            // Remove any existing listeners first
            document.querySelectorAll('.copy-button').forEach(button => {
                button.removeEventListener('click', handleCopyClick);
            });
            
            // Add fresh listeners
            document.querySelectorAll('.copy-button').forEach(button => {
                button.addEventListener('click', handleCopyClick);
            });
        }

        function handleCopyClick(event) {
            const button = event.currentTarget;
            const code = button.getAttribute('data-code');
            if (code) {
                copyToClipboard(code, button);
            }
        }

        function toggleCode(index) {
            const cardContainer = document.querySelector(`#card-${index}`);
            if (!cardContainer) return;
            
            const flipper = cardContainer.querySelector('.card-flipper');
            if (flipper) {
                flipper.classList.toggle('flipped');
            }
        }

        // Data Loading
        async function loadMoreExamples() {
            if (state.loading) return;
            
            state.loading = true;
            ui.loading.classList.remove('hidden');
            
            try {
                const filtered = getFilteredExamples();
                const start = state.page * state.itemsPerPage;
                const end = start + state.itemsPerPage;
                const pageExamples = filtered.slice(start, end);
                
                if (pageExamples.length > 0) {
                    const fragment = document.createDocumentFragment();
                    pageExamples.forEach(example => {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = createExampleCard(example);
                        fragment.appendChild(tempDiv.firstElementChild);
                    });
                    ui.grid.appendChild(fragment);
                    state.page++;
                    
                    // Initialize copy buttons after adding new content
                    initializeCopyButtons();
                    
                    // Initialize lazy loading for new images
                    requestAnimationFrame(() => {
                        lazyLoadImages();
                    });
                }
            } catch (error) {
                console.error('Error loading examples:', error);
            } finally {
                state.loading = false;
                ui.loading.classList.add('hidden');
            }
        }

        const debouncedResize = debounce(() => {
            initializeCopyButtons();
        }, 250);

        window.addEventListener('resize', debouncedResize);

        // Event Handlers
        function handleSourceChange(event) {
            state.currentSource = event.target.value;
            state.page = 0;
            state.shuffled = false;
            state.shuffleCount = 0;
            state.shuffledExamples = [];
            ui.grid.innerHTML = '';
            
            // Sync both selectors
            document.getElementById('sourceSelector').value = event.target.value;
            document.getElementById('mobileSourceSelector').value = event.target.value;
            
            // Reset UI
            ui.shuffleButton.classList.remove('shuffle-active');
            ui.resetButton.classList.add('hidden');
            
            updateSourceInfo();
            loadMoreExamples();
        }

        function handleScroll() {            
            const threshold = 1000;
            const bottomDistance = document.documentElement.scrollHeight - (window.scrollY + window.innerHeight);
            
            if (bottomDistance < threshold) {
                loadMoreExamples();
            }
            
            // Trigger lazy loading check on scroll
            lazyLoadImages();
        }

        // Initialize
        function initializeViewport() {
            const viewportStyle = document.createElement('meta');
            viewportStyle.name = 'viewport';
            viewportStyle.content = 'width=device-width, initial-scale=1.0';
            document.head.appendChild(viewportStyle);
        }

        function initializeIntersectionObserver() {
            const options = {
                root: null,
                rootMargin: '100px',
                threshold: 0.1
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, options);

            document.querySelectorAll('.example-card').forEach(card => {
                observer.observe(card);
            });
        }

        function toggleInfo() {
            const infoPanel = document.querySelector('.info-panel-wrapper');
            const mobileInfoPanel = document.getElementById('mobileInfoPanel');
            const infoToggle = document.getElementById('infoToggle');
            
            if (window.innerWidth <= 768) {
                // Mobile: toggle mobile info panel
                mobileInfoPanel.classList.toggle('open');
                document.body.classList.toggle('info-open');
            } else {
                // Desktop: toggle desktop info panel
                infoPanel.classList.toggle('open');
            }
        }

        function initializeInfoPanels() {
            const mobileInfoContent = document.getElementById('mobileInfoContent');
            const desktopInfoContent = document.getElementById('infoDisplay').innerHTML;
            mobileInfoContent.innerHTML = desktopInfoContent;
            
            // Add click handlers
            document.getElementById('infoToggle').addEventListener('click', toggleInfo);
            document.getElementById('mobileInfoToggle').addEventListener('click', toggleInfo);
        }

        function initializePage() {
            // Set up scrollbar
            const scrollbar = document.querySelector('.custom-scrollbar');
            const thumb = document.querySelector('.scrollbar-thumb');
            const track = document.querySelector('.scrollbar-track');
            let isDragging = false;
            let startY;
            let scrollStartY;

            function updateThumbSize() {
                const viewportHeight = window.innerHeight;
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const scrollbarHeight = track.offsetHeight;
                
                // Calculate thumb height based on viewport/document ratio
                const thumbHeight = Math.max(
                    (viewportHeight / documentHeight) * scrollbarHeight,
                    40 // Minimum thumb height
                );
                
                thumb.style.height = `${thumbHeight}px`;
            }

            function flipCard(index) {
                const cardContainer = document.getElementById(`card-${index}`);
                const flipper = cardContainer.querySelector('.card-flipper');
                flipper.classList.toggle('flipped');
            }

            // Handle clicking outside the card
            document.addEventListener('click', function(event) {
                const cardContainers = document.querySelectorAll('.card-container');
                cardContainers.forEach(container => {
                    const flipper = container.querySelector('.card-flipper');
                    const isFlipped = flipper.classList.contains('flipped');
                    
                    if (isFlipped && !container.contains(event.target)) {
                        flipper.classList.remove('flipped');
                    }
                });
            });

            // Stop propagation on card clicks to prevent the outside click handler from firing
            document.querySelectorAll('.card-container').forEach(container => {
                container.addEventListener('click', function(event) {
                    event.stopPropagation();
                });
            });

            function updateThumbPosition() {
                if (isDragging) return;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const scrollbarHeight = track.offsetHeight;
                const maxScroll = documentHeight - viewportHeight;
                const scrolled = window.scrollY;
                
                if (maxScroll <= 0) {
                    thumb.style.display = 'none';
                    return;
                }
                
                thumb.style.display = 'block';
                const scrollRatio = scrolled / maxScroll;
                const thumbTravel = scrollbarHeight - thumb.offsetHeight;
                const thumbPosition = thumbTravel * scrollRatio;
                
                thumb.style.transform = `translateY(${thumbPosition}px)`;
            }

            // Handle thumb drag
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                thumb.classList.add('dragging');
                startY = e.clientY - thumb.getBoundingClientRect().top;
                scrollStartY = window.scrollY;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const trackRect = track.getBoundingClientRect();
                const y = e.clientY - trackRect.top - startY;
                const scrollbarHeight = track.offsetHeight;
                const thumbHeight = thumb.offsetHeight;
                const maxY = scrollbarHeight - thumbHeight;
                
                const boundedY = Math.max(0, Math.min(y, maxY));
                const scrollRatio = boundedY / maxY;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const maxScroll = documentHeight - viewportHeight;
                
                window.scrollTo(0, maxScroll * scrollRatio);
                thumb.style.transform = `translateY(${boundedY}px)`;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                thumb.classList.remove('dragging');
            });

            // Track click to jump to position
            track.addEventListener('click', (e) => {
                if (e.target === thumb) return;
                
                const trackRect = track.getBoundingClientRect();
                const clickY = e.clientY - trackRect.top;
                const scrollbarHeight = track.offsetHeight;
                const thumbHeight = thumb.offsetHeight;
                const maxY = scrollbarHeight - thumbHeight;
                
                const boundedY = Math.max(0, Math.min(clickY - thumbHeight / 2, maxY));
                const scrollRatio = boundedY / maxY;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const maxScroll = documentHeight - viewportHeight;
                
                window.scrollTo({
                    top: maxScroll * scrollRatio,
                    behavior: 'smooth'
                });
            });

            // Update on scroll
            window.addEventListener('scroll', updateThumbPosition, { passive: true });

            // Update on resize
            window.addEventListener('resize', () => {
                updateThumbSize();
                updateThumbPosition();
            });

            // Set up intersection observer
            initializeIntersectionObserver();

            // Set up initial state and UI
            updateSourceInfo();
            loadMoreExamples();

            // Add event listeners
            window.addEventListener('scroll', handleScroll, { passive: true });
            ui.sourceSelect.addEventListener('change', handleSourceChange);
            ui.shuffleButton.addEventListener('click', handleShuffle);
            ui.resetButton.addEventListener('click', handleReset);

            // Initialize scrollbar
            updateThumbSize();
            updateThumbPosition();

            // Add keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === 's' && !e.ctrlKey && !e.metaKey) {
                    handleShuffle();
                } else if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
                    if (!state.shuffled) return;
                    handleReset();
                }
                switch(e.key) {
                    case 'ArrowLeft':
                        const prevOption = ui.sourceSelect.selectedIndex - 1;
                        if (prevOption >= 0) {
                            ui.sourceSelect.selectedIndex = prevOption;
                            handleSourceChange({ target: ui.sourceSelect });
                        }
                        break;
                    case 'ArrowRight':
                        const nextOption = ui.sourceSelect.selectedIndex + 1;
                        if (nextOption < ui.sourceSelect.options.length) {
                            ui.sourceSelect.selectedIndex = nextOption;
                            handleSourceChange({ target: ui.sourceSelect });
                        }
                        break;
                }
            });

            if (window.matchMedia('(max-width: 768px)').matches) {
                const mobileSourceSelector = document.getElementById('mobileSourceSelector');
                if (mobileSourceSelector) {
                    mobileSourceSelector.value = state.currentSource;
                }
            }

            document.querySelectorAll('pre code').forEach((block) => {
                Prism.highlightElement(block);
            });

        }

        // Add performance optimizations
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Optimize scroll handler
        const debouncedScroll = debounce(handleScroll, 16);
        window.addEventListener('scroll', debouncedScroll, { passive: true });
        let globalImageObserver;

        // Image loading optimization
        function lazyLoadImages() {
            // Create observer if it doesn't exist
            if (!globalImageObserver) {
                globalImageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            if (img.dataset.src) {
                                img.src = img.dataset.src;
                                img.removeAttribute('data-src');
                                observer.unobserve(img);
                            }
                        }
                    });
                }, {
                    root: null,
                    rootMargin: '50px 0px',
                    threshold: 0.1
                });
            }

            // Get all unloaded images
            const imageElements = document.querySelectorAll('img[data-src]');
            imageElements.forEach(img => {
                globalImageObserver.observe(img);
            });
        }

        // Add mobile touch handling
        let touchStartY = 0;
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].pageY;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            const touchY = e.touches[0].pageY;
            const difference = touchStartY - touchY;
            
            if (difference > 0) { // Scrolling up
                const nearBottom = window.innerHeight + window.pageYOffset >= 
                    document.documentElement.scrollHeight - 1000;
                if (nearBottom) {
                    loadMoreExamples();
                }
            }
        }, { passive: true });

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Page error:', e.error);
            ui.loading.classList.add('hidden');
            state.loading = false;
        });

        function initializeCodeHighlighting() {
            // Re-run Prism highlighting when new code is added
            document.querySelectorAll('pre code').forEach((block) => {
                Prism.highlightElement(block);
            });
        }

        function toggleSeeds(index, event) {
            event.stopPropagation();
            const dropdown = document.getElementById(`seeds-${index}`);
            dropdown.classList.toggle('show');
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            const dropdowns = document.getElementsByClassName('seeds-content');
            Array.from(dropdowns).forEach(dropdown => {
                if (dropdown.classList.contains('show')) {
                dropdown.classList.remove('show');
                }
            });
        });

        // Prevent dropdown from closing when clicking inside it
        document.querySelectorAll('.seeds-content').forEach(content => {
            content.addEventListener('click', function(event) {
                event.stopPropagation();
            });
        });

        // Handle URL parameters in seeds.html
        function handleSeedFilter(event, index) {
            event.preventDefault();
            
            // Get all seeds from this dropdown
            const dropdown = document.getElementById(`seeds-${index}`);
            const seedLinks = dropdown.querySelectorAll('.seed-link');
            const seeds = Array.from(seedLinks).map(link => link.textContent.trim());
            // Create URL with all seeds
            const queryParams = new URLSearchParams();
            seeds.forEach(seed => queryParams.append('seeds', seed));
            
            // Redirect to seeds.html with all seeds in URL
            window.location.href = `seeds.html?${queryParams.toString()}`;
        }

        // Initialize everything when the DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            initializePage()
            initializeInfoPanels();

            // Update click outside handling
            document.addEventListener('click', (e) => {
                const infoPanel = document.querySelector('.info-panel-wrapper');
                const mobileInfoPanel = document.getElementById('mobileInfoPanel');
                const infoToggle = document.getElementById('infoToggle');
                const mobileInfoToggle = document.getElementById('mobileInfoToggle');
                
                if (!infoPanel.contains(e.target) && !infoToggle?.contains(e.target)) {
                    infoPanel.classList.remove('open');
                }
                
                if (!mobileInfoPanel.contains(e.target) && !mobileInfoToggle?.contains(e.target)) {
                    mobileInfoPanel.classList.remove('open');
                    document.body.classList.remove('info-open');
                }
            });
        });
        
    </script>
</body>
</html>