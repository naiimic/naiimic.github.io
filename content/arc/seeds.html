<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ARC Seeds</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <link rel="shortcut icon" href="https://naiimic.github.io/favicons/videogame-favicon.ico">
	<link rel="apple-touch-icon" href="https://naiimic.github.io/favicons/videogame-apple-touch-icon.png">
	<link rel="icon" type="image/png" href="https://naiimic.github.io/favicons/videogame-favicon-16x16.png" sizes="16x16">
	<link rel="icon" type="image/png" href="https://naiimic.github.io/favicons/videogame-favicon-32x32.png" sizes="32x32">
    
    
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <style>
        /* Base Styles */
        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            font-family: 'Space Grotesk', sans-serif;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Hide Scrollbar */
        ::-webkit-scrollbar { display: none; }
        * { -ms-overflow-style: none; scrollbar-width: none; }

        /* Navigation Styles */
        .nav-glass {
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 2px solid rgba(99, 102, 241, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .nav-group {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        @media (max-width: 768px) {
            
            .nav-group {
                width: 100%;
                justify-content: center;
            }
            
            .nav-group:last-child {
                flex-direction: row;
                gap: 0.5rem;
            }

            #mobileInfoContent {
                height: calc(70vh - 60px);
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                padding: 0 0.5rem 80px 0.5rem;
            }

            #mobileInfoContent {
                transition: none;
                transform: none;
            }

            .info-panel-mobile {
                touch-action: none;
            }
        }

        @media (max-width: 768px) {
            /* Hide desktop controls */
            /* .nav-group:last-child {
                display: none !important;
            } */

            .nav-group .flex.items-center.gap-2 {
                display: none !important;
            }

            /* Keep the Example link visible */
            .nav-group a[href="examples.html"] {
                display: flex !important;
            }

            .nav-group a[href="arc.html"] {
                display: flex !important;
            }
            
            /* Bottom navigation/controls */
            .mobile-model-select {
                position: fixed;
                bottom: 0;  /* Changed from 1rem to 0 */
                left: 0;
                right: 0;
                background: rgba(15, 23, 42, 0.98);
                backdrop-filter: blur(10px);
                padding: 0.75rem;
                z-index: 49;
                border-top: 1px solid rgba(99, 102, 241, 0.2);
            }

            .mobile-model-select select {
                width: 100%;
                padding: 0.75rem;
                background: rgba(30, 41, 59, 0.8);
                border: 1px solid rgba(99, 102, 241, 0.2);
                border-radius: 0.5rem;
                color: white;
                font-size: 0.875rem;
            }

            /* Floating action buttons - adjust position to be above model selector */
            .mobile-fab-container {
                position: fixed;
                bottom: 15px;
                right: 1rem;
                display: flex;
                flex-direction: column;
                gap: 0.75rem;
                z-index: 51;
            }

            .mobile-fab {
                width: 48px;
                height: 48px;
                border-radius: 50%;
                background: rgba(99, 102, 241, 0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                border: none;
                color: white;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);
                transition: all 0.3s ease;
            }

            .mobile-fab:active {
                transform: scale(0.95);
                background: rgba(99, 102, 241, 1);
            }
            
            .mobile-fab.hidden {
                display: none;
            }

            /* Add padding to main content to prevent content from being hidden */
            main {
                padding-bottom: calc(60px + 1rem) !important; /* Height of model selector + some padding */
            }
        }

        .logo-gradient {
            background: linear-gradient(45deg, #6366f1, #ec4899);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }

        /* Card Styles */
        .example-card {
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            overflow: hidden;
            min-height: 100%;
        }

        .example-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 32px rgba(99, 102, 241, 0.15);
        }

        /* Grid Layout */
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 2rem;
            padding: 1rem;
        }

        /* Source Card Styles */
        .source-card {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            transition: all 0.3s ease;
        }

        .source-card.active {
            border-color: #6366f1;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.2);
        }

        /* Button Styles */
        .gradient-btn {
            height: 40px;
            min-width: 100px;
            padding: 0 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            font-weight: 500;
            letter-spacing: 0.025em;
            border-radius: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
            position: relative;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap;
        }

        .card-header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            z-index: 1;
            background: rgba(24, 19, 60, 0.5);
            backdrop-filter: blur(0px);
            height: 70px;
        }

        .card-container {
            width: 100%;
            margin-bottom: 2rem;
            perspective: 1000px;
        }

        .card-flipper {
            width: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            position: relative;
        }

        .card-flipper.flipped {
            transform: rotateY(180deg);
        }

        /* Card Faces */
        .card-front {
            width: 100%;
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            backface-visibility: hidden;
        }

        .card-back {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotateY(180deg);
            background: rgba(30, 41, 59, 0.5);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 1rem;
            backface-visibility: hidden;
            overflow: hidden; /* Contain the absolute positioned content */
        }

        .card-front {
            position: relative;
        }

        .card-back {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            transform: rotateY(180deg);
        }

        .code-content {
            position: absolute;
            top: 80px; /* Height of header */
            left: 0;
            right: 0;
            bottom: 0;
            padding: 0 1.5rem 1.5rem;
            overflow: hidden; /* Hide container overflow */
        }

        .code-content pre code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.75rem !important;
            line-height: 1.4 !important;
        }

        .code-content code {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace !important;
            font-size: 0.75rem !important;
            line-height: 1.4 !important;
        }

        .code-content pre {
            height: 100%;
            margin: 0;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.3) !important;
            border-radius: 0.5rem;
            overflow-y: auto; /* Only scroll the pre element */
            font-size: 0.75rem !important;
        }

        .button-base {
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            color: white;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1rem;
            white-space: nowrap;
        }

        .button-base:hover {
            background: rgba(99, 102, 241, 0.3);
        }

        .copy-toast {
            position: fixed;
            top: 2rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(34, 197, 94, 0.9);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            animation: fade 1.5s forwards;
        }
        
        .bottom-sheet-handle {
            width: 40px;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            margin: 0 auto 16px;
            flex-shrink: 0;
        }

        .bottom-sheet-handle {
            pointer-events: none;
        }

        @keyframes fade {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            15% { opacity: 1; transform: translate(-50%, 0); }
            85% { opacity: 1; transform: translate(-50%, 0); }
            100% { opacity: 0; transform: translate(-50%, -20px); }
        }

        @keyframes toast {
            0% { 
                opacity: 0;
                transform: translate(-50%, -1rem);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            80% {
                opacity: 1;
                transform: translate(-50%, 0);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -1rem);
            }
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        .copy-tooltip {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            pointer-events: none;
            animation: fadeOut 1.5s forwards;
            white-space: nowrap;
        }

        /* Image Grid */
        .image-grid {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 0 1.5rem 1.5rem;
            margin-top: 80px; /* Match the space where code starts in back card */
        }

        .image-container {
            background: rgba(30, 41, 59, 0.3);
            padding: 1rem;
            border-radius: 0.75rem;
        }

        .image-pair {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .image-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: white;
            border-radius: 0.75rem;
            overflow: hidden; /* Ensure image respects container's border radius */
            padding: 0.25rem;
        }

        .image-wrapper img {
            width: 100%;
            height: auto;
            object-fit: contain;
            border-radius: 0.5rem;
            display: block; /* Remove any potential spacing */
        }

        .image-caption {
            margin-top: 0.5rem;
            font-size: 0.875rem;
            color: #94a3b8;
            text-align: center;
        }

        pre {
            margin: 0;
            padding: 1rem;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 0.5rem;
            overflow-x: auto;
        }

        .gradient-btn:focus {
            outline: none;
        }

        .gradient-btn:not(.active):hover {
            background: linear-gradient(45deg, rgba(236, 72, 153, 0.1), rgba(99, 102, 241, 0.1));
            border: 1px solid rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .gradient-btn i,
        .gradient-btn span {
            color: inherit;
            position: relative;
        }

        .gradient-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Loading Animation */
        .loading-dots {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            padding: 2rem;
        }

        .loading-dot {
            width: 0.5rem;
            height: 0.5rem;
            background: linear-gradient(45deg, #6366f1, #ec4899);
            border-radius: 50%;
            animation: pulse 1s infinite ease-in-out;
        }

        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            .examples-grid {
                grid-template-columns: 1fr;
                gap: 1rem;
            }

            .source-card {
                padding: 1rem;
            }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spin-animation {
            animation: spin 1s linear;
        }

        .gradient-btn.shuffle-active {
            background: linear-gradient(45deg, rgba(236, 72, 153, 0.2), rgba(99, 102, 241, 0.2));
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .custom-scrollbar {
            position: fixed;
            right: 8px;
            top: 120px; /* Positioned below the nav bar */
            height: calc(100vh - 120px); /* Adjust height to account for nav */
            width: 12px;
            z-index: 50; /* Ensure it's below the nav which has z-index: 50 */
            pointer-events: none;
        }

        .scrollbar-track {
            position: absolute;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 100%;
            height: 70vh;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            pointer-events: all;
        }

        .scrollbar-thumb {
            position: absolute;
            width: 100%;
            border-radius: 6px;
            min-height: 40px;
            max-height: 15vh; 
            background: rgba(99, 102, 241, 0.3);
            cursor: pointer;
            transition: background 0.2s;
        }

        .scrollbar-thumb:hover,
        .scrollbar-thumb:active {
            background: rgba(99, 102, 241, 0.5);
        }

        .scrollbar-thumb.dragging {
            background: rgba(99, 102, 241, 0.6);
            cursor: grabbing;
        }

        @media (max-width: 768px) {
            .custom-scrollbar {
                display: none;
            }
        }

        #filterIndicator {
            display: flex;
            align-items: center;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
        }

        #filterIndicator button:hover {
            transform: scale(1.1);
        }

        .gradient-btn:disabled {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
            pointer-events: none;
        }

        .mobile-fab:disabled {
            opacity: 0.5 !important;
            cursor: not-allowed !important;
            pointer-events: none;
        }

        .info-toggle {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            z-index: 40;
            padding: 0.75rem;
            border-radius: 0.75rem;
            background: rgba(30, 41, 59, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(99, 102, 241, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
            color: #f8fafc;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-toggle:hover {
            background: rgba(30, 41, 59, 0.98);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.3);
        }

        /* Info Panel */
        .info-panel-wrapper {
            position: fixed;
            bottom: 6rem;
            left: 2rem;
            z-index: 30;
            width: 32rem;
            max-width: calc(100vw - 4rem);
            transform: translateX(calc(-100% - 2rem));
            transition: all 0.3s ease;
            opacity: 0;
            visibility: hidden;
        }

        .info-panel-wrapper.open {
            transform: translateX(0);
            opacity: 1;
            visibility: visible;
        }

        .info-panel {
            background: rgba(30, 41, 59, 0.98);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(99, 102, 241, 0.2);
            border-radius: 1rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            padding: 1.5rem;
            margin-top: 1rem;
            max-height: calc(100vh - 15rem);
            overflow-y: auto;
        }

        .info-section {
            font-size: 0.95rem;
            line-height: 1.6;
        }

        /* Mobile Info Panel */
        .info-panel-mobile {
            position: fixed;
            left: 0;
            right: 0;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(10px);
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
            padding: 1rem;
            z-index: 52;
            display: flex;
            flex-direction: column;
        }

        .info-panel-mobile {
            height: 90vh; /* Fixed height */
            bottom: 0px;
            transform: translateY(100%);
            transition: transform 0.3s ease-out;
        }

        .info-panel-mobile.open {
            transform: translateY(0);
            height: 90vh; /* Maintain fixed height when open */
        }

        #mobileInfoContent {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            padding: 0 0.5rem;
            padding-bottom: 80px;
        }

        #mobileInfoToggle {
            position: fixed;
            left: 1rem;
            bottom: 15px;
            z-index: 60;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            z-index: 60;
        }

        /* Hide desktop controls on mobile */
        @media (max-width: 768px) {
            .info-toggle {
                display: none !important;
            }
        }

        @media (min-width: 769px) {
            /* Container width */
            .container {
                max-width: 80% !important;
            }

            /* Text scaling */
            .text-2xl {
                font-size: 1.2rem !important; /* 80% of 1.5rem */
            }
            
            .text-3xl {
                font-size: 1.6rem !important; /* 80% of 2rem */
            }

            /* Button and input scaling */
            .gradient-btn {
                height: 32px !important; /* 80% of 40px */
                min-width: 80px !important; /* 80% of 100px */
                padding: 0 1rem !important; /* 80% of 1.25rem */
                font-size: 0.9rem !important;
            }

            /* Examples grid scaling */
            .examples-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)) !important; /* 80% of 350px */
                gap: 1.6rem !important; /* 80% of 2rem */
                padding: 0.8rem !important; /* 80% of 1rem */
            }

            /* Card scaling */
            .example-card {
                font-size: 0.9rem !important;
            }

            .card-header {
                height: 56px !important; /* 80% of 70px */
                padding: 0.8rem 1.2rem !important; /* 80% of padding */
            }

            /* Code content scaling */
            .code-content {
                top: 56px !important; /* 80% of header height */
            }

            .code-content pre code {
                font-size: 0.6rem !important; /* 80% of 0.75rem */
            }

            /* Image grid scaling */
            .image-grid {
                gap: 0.8rem !important; /* 80% of 1rem */
                padding: 0 1.2rem 1.2rem !important; /* 80% of padding */
                margin-top: 56px !important; /* 80% of 70px */
            }

            .image-container {
                padding: 0.8rem !important; /* 80% of 1rem */
            }

            .image-pair {
                gap: 0.8rem !important; /* 80% of 1rem */
            }

            /* Source overview cards */
            .source-card {
                padding: 1.2rem !important; /* 80% of 1.5rem */
            }

            /* Button base */
            .button-base {
                padding: 0.4rem 0.8rem !important; /* 80% of padding */
                font-size: 0.9rem !important;
                gap: 0.4rem !important;
            }

            /* Info panel scaling */
            .info-panel-wrapper {
                width: 25.6rem !important; /* 80% of 32rem */
                bottom: 1.6rem !important; /* 80% of 2rem */
            }

            .info-toggle {
                padding: 0.6rem !important;
                border-radius: 0.6rem !important;
                bottom: 1.6rem !important;
                left: 1.6rem !important;
            }

            /* Stats overview */
            .text-xl {
                font-size: 1.2rem !important; /* 80% of 1.5rem */
            }

            .text-2xl {
                font-size: 1.4rem !important; /* 80% of 1.75rem */
            }

            /* Filter indicator */
            #filterIndicator {
                height: 32px !important; /* 80% of 40px */
                font-size: 0.9rem !important;
                padding: 0 0.8rem !important;
            }

            /* Grid gaps */
            .gap-6 {
                gap: 1.2rem !important; /* 80% of 1.5rem */
            }

            .gap-4 {
                gap: 0.8rem !important; /* 80% of 1rem */
            }

            /* Spacing */
            .mb-8 {
                margin-bottom: 1.6rem !important; /* 80% of 2rem */
            }

            .p-6 {
                padding: 1.2rem !important; /* 80% of 1.5rem */
            }

            /* Image wrapper */
            .image-wrapper {
                padding: 0.2rem !important; /* 80% of 0.25rem */
            }

            /* Image caption */
            .image-caption {
                font-size: 0.7rem !important; /* 80% of 0.875rem */
                margin-top: 0.4rem !important;
            }

            /* Custom scrollbar */
            .custom-scrollbar {
                width: 10px !important; /* 80% of 12px */
                top: 96px !important; /* 80% of 120px */
            }

            .scrollbar-thumb {
                min-height: 32px !important; /* 80% of 40px */
            }
        }
    </style>
</head>
<body class="antialiased">
    <!-- Navigation -->
    <nav class="nav-glass sticky top-0 z-50">
        <div class="container mx-auto px-6">
            <div class="flex flex-col gap-4 py-3">
                <!-- Top Row - Title -->
                <div class="flex justify-center">
                    <h1 class="text-2xl md:text-3xl font-bold logo-gradient">ARC Seed Tasks</h1>
                </div>
                
                <!-- Bottom Row - Controls -->
                <div class="flex justify-between items-center">
                    <div class="nav-group">
                        <a href="examples.html" class="gradient-btn px-4 py-2 rounded-lg">
                            <i class="fas fa-lightbulb mr-2"></i>
                            <span>Synthetic Examples</span>
                        </a>
                        <div class="flex items-center gap-2">
                            <button id="shuffleButton" class="gradient-btn px-4 py-2 rounded-lg">
                                <i class="fas fa-random mr-2"></i>
                                <span>Shuffle</span>
                            </button>
                            <button id="resetButton" class="gradient-btn px-3 py-2 rounded-lg hidden">
                                <i class="fas fa-rotate"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container mx-auto px-4 py-8">
        <!-- Source Overview -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
            <div id="sourceStats" class="source-card p-6">
                <h2 class="text-xl font-bold text-slate-200 mb-4">Overview</h2>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <p class="text-slate-400">Total Examples</p>
                        <p class="text-2xl font-bold logo-gradient" id="totalCount">0</p>
                    </div>
                    <div>
                        <p class="text-slate-400">Current Source</p>
                        <p class="text-2xl font-bold logo-gradient" id="currentSource">All</p>
                    </div>
                </div>
            </div>
            <div id="sourceDescription" class="source-card p-6">
                <h2 class="text-xl font-bold text-slate-200 mb-4">Source Description</h2>
                <p class="text-slate-400" id="descriptionText">
                    Viewing all examples from different sources.
                </p>
            </div>
        </div>

        <!-- Examples Grid -->
        <div id="examplesGrid" class="examples-grid">
            <!-- Examples will be inserted here -->
        </div>

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="loading-dots hidden">
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
            <div class="loading-dot"></div>
        </div>

        <button id="infoToggle" class="info-toggle">
            <i class="fas fa-info-circle"></i>
            <span>Info</span>
        </button>

        <div class="info-panel-wrapper">
            <div id="infoDisplay" class="info-panel">
                <h3 class="text-xl font-bold mb-4 logo-gradient">About the ARC Challenge</h3>
                
                <div class="info-section">
                    <p class="text-slate-300 mb-4">
                        The Abstraction and Reasoning Corpus (ARC) is a dataset that measures general fluid intelligence in AI systems. It consists of tasks where the AI must infer a pattern from a few examples and apply it to new situations.
                    </p>
                    
                    <p class="text-slate-300 mb-4">
                        Each task contains:
                    </p>
                    <ul class="list-disc list-inside text-slate-300 mb-4 space-y-2">
                        <li>Training examples showing input-output pairs that demonstrate the pattern</li>
                        <li>A test input where the AI must predict the correct output</li>
                        <li>The ground truth test output for evaluation</li>
                    </ul>
                    
                    <p class="text-slate-300 mb-4">
                        This page showcases different transduction models attempting to solve the ARC validation set. For each task, models generate multiple candidate solutions, which are ranked based on various strategies including test-time fine-tuning and reranking approaches.
                    </p>
        
                    <p class="text-slate-300 mb-4">
                        The visualization allows you to:
                    </p>
                    <ul class="list-disc list-inside text-slate-300 mb-4 space-y-2">
                        <li>Compare different model variants and their performance</li>
                        <li>View training examples and test cases</li>
                        <li>Examine candidate solutions generated by the models</li>
                        <li>Track success rates and solution rankings</li>
                    </ul>
        
                    <div class="mt-6 p-4 bg-slate-800/50 rounded-lg">
                        <p class="text-slate-300">
                            For implementation details about the models and evaluation process, visit:
                            <a href="https://github.com/xu3kev/BARC/blob/master/seeds/common.py" 
                               class="text-indigo-400 hover:text-indigo-300 underline break-all" 
                               target="_blank">
                                github.com/xu3kev/BARC/blob/master/seeds/common.py
                            </a>
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div class="md:hidden">
            <button class="mobile-fab" id="mobileInfoToggle">
                <i class="fas fa-info-circle"></i>
            </button>
        </div>
        
        <div class="mobile-fab-container md:hidden">
            <button class="mobile-fab" id="mobileShuffleButton" onclick="handleShuffle()">
                <i class="fas fa-random"></i>
            </button>
            <button class="mobile-fab hidden" id="mobileResetButton" onclick="handleReset()">
                <i class="fas fa-rotate"></i>
            </button>
        </div>
    </main>

    <div class="custom-scrollbar">
        <div class="scrollbar-track">
            <div class="scrollbar-thumb">
                <div class="scrollbar-thumb-inner"></div>
            </div>
        </div>
    </div>

    <div id="mobileInfoPanel" class="info-panel-mobile md:hidden">
        <div class="bottom-sheet-handle"></div>
        <div id="mobileInfoContent">
            <!-- Info content will be copied here for mobile -->
        </div>
    </div>

    <script>
        // Data and State Management
        const examples = [{"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# repeating patterns, colors as indicators, scaling\n\n# description:\n# In the input you will see a nxm sprite with black background. \n# Construct an output grid with n^2 x m^2 black pixels. Divide the output grid into subgrids, \n# and look at the corresponding pixel in the nxm input grid. If the corresponding pixel is not black, \n# then copy the nxm input grid into the subgrid. Else, the subgrid does not change. \n\ndef transform(input_grid):\n    # creates an empty 9x9 output grid \n    output_grid = np.zeros((input_grid.shape[0]**2,input_grid.shape[1]**2),dtype=int)\n\n    input_sprite = input_grid\n\n    # Go through the input grid. If an input grid pixel is not black, \n    # then copy the input grid to the corresponding location on the output grid\n    for n in range(input_grid.shape[0]):\n      for m in range(input_grid.shape[1]):\n        if input_grid[n,m] != Color.BLACK:\n            blit_sprite(output_grid, input_sprite, n*input_grid.shape[0], m*input_grid.shape[1])\n    \n    return output_grid\n\ndef generate_input():\n  n,m = random.randint(3, 6), random.randint(3, 6)\n  random_color = random.choice(list(Color.NOT_BLACK))\n  return random_sprite(n, m, color_palette=[random_color])", "images": {"test": {"input": "output/seeds/seed_examples/0/images/test_input.png", "output": "output/seeds/seed_examples/0/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/0/images/train_input_0.png", "output": "output/seeds/seed_examples/0/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/0/images/train_input_1.png", "output": "output/seeds/seed_examples/0/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/0/images/train_input_2.png", "output": "output/seeds/seed_examples/0/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/0/images/train_input_3.png", "output": "output/seeds/seed_examples/0/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/0/images/train_input_4.png", "output": "output/seeds/seed_examples/0/images/train_output_4.png"}]}, "index": 0, "seed": "007bbfb7", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology\n\n# description:\n# The input grid is a square grid with black and green pixels. The input grid should have regions that are enclosed by the green pixels. \n# To produce the output, you need to find the enclosed regions in the input grid, and then color them yellow. \n                \ndef transform(input_grid):\n    # Create initial output grid template based on input grid.\n    output_grid = input_grid.copy()\n\n    # Find enclosed regions\n    interior_mask = object_interior(input_grid)\n    boundary_mask = object_boundary(input_grid)\n    inside_but_not_on_edge = interior_mask \u0026 ~boundary_mask\n\n    # Color enclosed regions\n    for x, y in np.argwhere(inside_but_not_on_edge):\n        if output_grid[x, y] == Color.BLACK:\n            output_grid[x, y] = Color.YELLOW\n\n    return output_grid\n\n\ndef generate_input():\n    # Generate a square grid of arbitrary size with black background, size from 5x5 to 20x20\n    n = random.randint(10, 20)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Generate some random green sprites, and then hollow out the interior\n    n_objects = random.randint(1, 3)\n    for _ in range(n_objects):\n        n, m = random.randint(4, 10), random.randint(4, 10)\n        sprite = random_sprite(n, m, color_palette=[Color.GREEN], connectivity=8)\n        interior_mask = object_interior(sprite)\n        boundary_mask = object_boundary(sprite)\n        interior_but_not_edges = interior_mask \u0026 ~boundary_mask\n        sprite[interior_but_not_edges] = Color.BLACK\n\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, border_size=1, padding=1)\n        except:\n            continue\n\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/1/images/test_input.png", "output": "output/seeds/seed_examples/1/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/1/images/train_input_0.png", "output": "output/seeds/seed_examples/1/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/1/images/train_input_1.png", "output": "output/seeds/seed_examples/1/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/1/images/train_input_2.png", "output": "output/seeds/seed_examples/1/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/1/images/train_input_3.png", "output": "output/seeds/seed_examples/1/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/1/images/train_input_4.png", "output": "output/seeds/seed_examples/1/images/train_output_4.png"}]}, "index": 1, "seed": "00d62c1b", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, symmetry detection\n\n# description:\n# In the input you will see a grid consisting of a blue sprite that is repeatedly translated vertically, forming a stack of the same sprite.\n# To make the output, expand the input to have height 9, and continue to repeatedly translate the sprite vertically. Change color to red.\n \ndef transform(input_grid):\n    # Plan:\n    # 1. Find the repeated translation, which is a symmetry\n    # 2. Extend the pattern by copying the sprite and its symmetric copies\n    # 3. Change the color from blue to red\n    \n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[], background=Color.BLACK)\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # make the output (the height is now 9)\n    output_grid = np.full((input_grid.shape[0], 9), Color.BLACK)\n    \n    # Copy all of the input pixels to the output, INCLUDING their symmetric copies (i.e. their orbit)\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Compute the orbit into the output grid\n        for x2, y2 in orbit(output_grid, x, y, symmetries):\n            output_grid[x2, y2] = input_grid[x, y]\n    \n    # Color change: blue -\u003e red\n    output_grid[output_grid == Color.BLUE] = Color.RED\n\n    return output_grid\n\n\ndef generate_input():\n    # grid is always 3x6\n    grid = np.zeros((3, 6),dtype = int)\n\n    # The input is always blue\n    color = Color.BLUE\n\n    # Creates a random smaller sprite, where the height (period) is chosen randomly\n    height = random.randint(2, 7)\n    sprite = random_sprite(3, height, symmetry=\"not_symmetric\", color_palette=[color], density=0.4, connectivity=8)\n\n    # place the smaller pattern, tiling it so that it is repeated vertically\n    # tile \"infinitely\" (x100)\n    vertically_repeated = np.tile(sprite, (1, 100))\n    # crop to the size of the grid\n    vertically_repeated = vertically_repeated[:, :grid.shape[1]]\n    # copy to the grid\n    grid[:,:] = vertically_repeated\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/2/images/test_input.png", "output": "output/seeds/seed_examples/2/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/2/images/train_input_0.png", "output": "output/seeds/seed_examples/2/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/2/images/train_input_1.png", "output": "output/seeds/seed_examples/2/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/2/images/train_input_2.png", "output": "output/seeds/seed_examples/2/images/train_output_2.png"}]}, "index": 2, "seed": "017c7c7b", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, pixel manipulation\n\n# description:\n# In the input you will see a set of objects, each consisting of a horizontal top/bottom and diagonal left/right edges (but that structure is not important)\n# To make the output shift right each pixel in the object *except* when there are no other pixels down and to the right\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # find the connected components, which are monochromatic objects\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    output_grid = np.zeros_like(input_grid)\n\n    for obj in objects:\n        transformed_object = np.zeros_like(obj)\n\n        for x in range(obj.shape[0]):\n            for y in range(obj.shape[1]):\n                if obj[x, y] != Color.BLACK:\n                    # check that there are other colored pixels down and to the right\n                    down_and_to_the_right = obj[x+1:, y+1:]\n                    if np.any(down_and_to_the_right != Color.BLACK):\n                        transformed_object[x+1, y] = obj[x, y]\n                    else:\n                        transformed_object[x, y] = obj[x, y]\n\n        blit_object(output_grid, transformed_object, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    n, m = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    n_objects = np.random.randint(1, 3)\n\n    for _ in range(n_objects):\n        color = random.choice(Color.NOT_BLACK)\n\n        bar_width = np.random.randint(3, n//2)\n        side_height = np.random.randint(3, m - bar_width)\n\n        width, height = bar_width + side_height, side_height\n        obj = np.zeros((width, height), dtype=int)\n\n        # make the horizontal top edge\n        obj[:bar_width+1, 0] = color\n        # make the horizontal bottom edge\n        obj[-bar_width:, -1] = color\n        # make the diagonal left edge\n        for i in range(side_height):\n            obj[i, i] = color\n        # make the diagonal right edge\n        for i in range(side_height-1):\n            obj[bar_width+i+1, i] = color\n\n        # place the object randomly on the grid, assuming we can find a spot\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, background=Color.BLACK, padding=2, padding_connectivity=8, border_size=2)\n        except:\n            continue\n\n        blit_sprite(grid, obj, x=x, y=y, background=Color.BLACK)\n\n    # Make sure that we actually generated something\n    if np.all(grid == Color.BLACK):\n        return generate_input()\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/3/images/test_input.png", "output": "output/seeds/seed_examples/3/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/3/images/train_input_0.png", "output": "output/seeds/seed_examples/3/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/3/images/train_input_1.png", "output": "output/seeds/seed_examples/3/images/train_output_1.png"}]}, "index": 3, "seed": "025d127b", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sprites, color change, collision detection, repetition, overlap\n\n# description:\n# In the input you will see a 3x3 object with a few other objects around it.\n# For each of the other sprites around the central 3x3 object:\n# 1. Slide the central sprite so it completely overlaps the other sprite (slide it as much as you can to do so)\n# 2. Change the color of the central sprite to match the color of the other sprite\n# 3. Repeat the slide (by the same displacement vector) indefinitely until it falls off the canvas\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # find the objects, which are monochromatic connected components\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n\n    # find the central object, which is the biggest\n    central_object = max(objects, key=lambda obj: np.sum(obj != Color.BLACK))\n\n    # find the other objects\n    other_objects = [obj for obj in objects if not np.array_equal(obj, central_object)]\n\n    output_grid = np.copy(input_grid)\n\n    for other_object in other_objects:\n        # find the biggest displacement vector that will make the central object completely overlap the other object\n        biggest_displacement_vector = (0,0)\n        displacement_vectors = [ (i, j) for i in range(-10, 10) for j in range(-10, 10) ]\n        for displacement_vector in displacement_vectors:\n            # translate the central object by the displacement vector\n            translated_central_object = translate(central_object, displacement_vector[0], displacement_vector[1], background=Color.BLACK)\n\n            # check if the translated object completely overlaps the other object\n            translated_mask, other_mask = translated_central_object != Color.BLACK, other_object != Color.BLACK\n            overlaps = np.all(translated_mask \u0026 other_mask == other_mask)\n\n            if overlaps:\n                # but is it the biggest?\n                if biggest_displacement_vector[0] ** 2 + biggest_displacement_vector[1] ** 2 \u003c displacement_vector[0] ** 2 + displacement_vector[1] ** 2:\n                    biggest_displacement_vector = displacement_vector\n\n        displacement_vector = biggest_displacement_vector\n\n        # color change\n        color_of_other_object = np.unique(other_object[other_object != Color.BLACK])[0]\n        central_object[central_object != Color.BLACK] = color_of_other_object\n\n        # repeat the displacement indefinitely until it falls off the canvas\n        for i in range(1, 10):\n            displaced_central_object = translate(central_object, displacement_vector[0] * i, displacement_vector[1] * i, background=Color.BLACK)\n            blit_object(output_grid, displaced_central_object, background=Color.BLACK)\n            \n    return output_grid\n\n\n\ndef generate_input() -\u003e np.ndarray:\n    # make a black grid first as background\n    n, m = 21, 21\n    grid = np.zeros((n, m), dtype=int)\n\n    # make a 3x3 object\n    central_color = np.random.choice(Color.NOT_BLACK)\n    central_sprite = random_sprite(3, 3, color_palette=[central_color])\n\n    # place the central object near the center\n    x, y = np.random.randint(int(0.3*n), int(0.7*n)), np.random.randint(int(0.3*m), int(0.7*m))\n    blit_sprite(grid, central_sprite, x, y, background=Color.BLACK)\n\n    # possible displacement vectors can range in any of the eight different directions (cardinal directions and in between them)\n    # they should be close to just a little more than the length of the central object, however\n    eight_cardinal_directions = [(0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1)]\n    # pick a random subset of them, between 1-4\n    displacement_vectors = random.sample(eight_cardinal_directions, k=np.random.randint(1, 5))\n\n    for vector in displacement_vectors:\n        vector_length = np.random.randint(4, 5)\n        vector = (vector[0] * vector_length, vector[1] * vector_length)\n\n        # make a random object by recoloring the central object, translating by the vector,\n        # and then randomly removing parts of it by flipping random pixels to black\n        other_sprite = np.copy(central_sprite)\n        other_sprite[other_sprite != Color.BLACK] = np.random.choice(Color.NOT_BLACK)\n\n        # flip some random pixels to black:\n        # first find the foreground (nonblack) pixels,\n        # then randomly sample a subset of them to color black\n        nonblack_pixels = np.argwhere(other_sprite != Color.BLACK)\n        num_nonblack = len(nonblack_pixels)\n        num_to_flip = np.random.randint(1, num_nonblack-3)\n        random_subset_of_nonblack_pixels = random.sample(list(nonblack_pixels), k=num_to_flip)\n\n        # color black\n        for pixel in random_subset_of_nonblack_pixels:\n            other_sprite[pixel[0], pixel[1]] = Color.BLACK        \n\n        # place the new object near the center, but offset by the vector\n        blit_sprite(grid, other_sprite, x + vector[0], y + vector[1], background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/4/images/test_input.png", "output": "output/seeds/seed_examples/4/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/4/images/train_input_0.png", "output": "output/seeds/seed_examples/4/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/4/images/train_input_1.png", "output": "output/seeds/seed_examples/4/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/4/images/train_input_2.png", "output": "output/seeds/seed_examples/4/images/train_output_2.png"}]}, "index": 4, "seed": "045e512c", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "import numpy as np\nfrom typing import *\nfrom common import *\n\n# concepts:\n# boolean logical operations, bitmasks with separator\n\n# description:\n# In the input you will see two blue bitmasks separated by a grey vertical bar\n# To make the output, color teal the red that are set in both bitmasks (logical AND)\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the grey vertical bar. Vertical means constant X\n    for x_bar in range(input_grid.shape[0]):\n        if np.all(input_grid[x_bar, :] == Color.GREY):\n            break\n\n    left_mask = input_grid[:x_bar, :]\n    right_mask = input_grid[x_bar+1:, :]\n\n    output_grid = np.zeros_like(left_mask)\n    output_grid[(left_mask == Color.BLUE) \u0026 (right_mask == Color.BLUE)] = Color.RED\n    \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # create a pair of equally sized maroon bitmasks\n    width, height = np.random.randint(2, 10), np.random.randint(2, 10)\n\n    grid1 = np.zeros((width, height), dtype=int)\n    grid2 = np.zeros((width, height), dtype=int)\n\n    for x in range(width):\n        for y in range(height):\n            grid1[x, y] = np.random.choice([Color.BLUE, Color.BLACK])\n            grid2[x, y] = np.random.choice([Color.BLUE, Color.BLACK])\n    \n    # create a blue vertical bar\n    bar = np.zeros((1, height), dtype=int)\n    bar[0, :] = Color.GREY\n\n    grid = np.concatenate((grid1, bar, grid2), axis=0)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/5/images/test_input.png", "output": "output/seeds/seed_examples/5/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/5/images/train_input_0.png", "output": "output/seeds/seed_examples/5/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/5/images/train_input_1.png", "output": "output/seeds/seed_examples/5/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/5/images/train_input_2.png", "output": "output/seeds/seed_examples/5/images/train_output_2.png"}]}, "index": 5, "seed": "0520fde7", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines, repetition\n\n# description:\n# In the input you will see a 7x7 grid, with three diagonal lines that stretch from one end of the canvas to the other\n# Each line is a different color, and the colors are not black\n# The output should be the result of repeating every diagonal line on multiples of 3 offset from the original, which gives an interlacing pattern filling the output canvas\n\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros((7, 7), dtype=int)\n\n    # Loop over the input looking for any of the three diagonals\n    # If we find one, we will fill the output with the same color in the same pattern\n    for i in range(output_grid.shape[0]):\n        for j in range(output_grid.shape[1]):\n            c = input_grid[i][j]\n            if c != Color.BLACK:\n                # Fill the output with the same color in the same pattern\n                # Loop by multiples of 3 to create the pattern\n                # Loop way beyond the canvas (double the canvas size) to make sure we cover everything\n                for distance in range(0, output_grid.shape[0]*2, 3):\n                    draw_diagonal(output_grid, i-distance, j, c)\n                    draw_diagonal(output_grid, i+distance, j, c)\n    \n    return output_grid\n\ndef draw_diagonal(grid, x, y, c):\n    # create diagonal line that stretches from one side of the canvas to the other\n    # to do this, draw infinite rays pointing in opposite directions\n    draw_line(grid, x, y, length=None, color=c, direction=(1, -1))\n    draw_line(grid, x, y, length=None, color=c, direction=(-1, 1))\n\ndef generate_input() -\u003e np.ndarray:\n\n    # create a 7x7 grid of black (0)\n    grid = np.zeros((7, 7), dtype=int)\n    # pick 3 random distinct colors\n    c1, c2, c3 = np.random.choice(Color.NOT_BLACK, 3, replace=False)\n\n    # put down the three diagonal lines\n    draw_diagonal(grid, np.random.choice(range(7)), np.random.choice(range(7)), c1)\n    draw_diagonal(grid, np.random.choice(range(7)), np.random.choice(range(7)), c2)\n    draw_diagonal(grid, np.random.choice(range(7)), np.random.choice(range(7)), c3)\n\n    # make sure that the output is completely filled up with the pattern meaning it doesn\u0027t contain any black pixels\n    if np.any(main(grid) == Color.BLACK):\n        return generate_input()\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/6/images/test_input.png", "output": "output/seeds/seed_examples/6/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/6/images/train_input_0.png", "output": "output/seeds/seed_examples/6/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/6/images/train_input_1.png", "output": "output/seeds/seed_examples/6/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/6/images/train_input_2.png", "output": "output/seeds/seed_examples/6/images/train_output_2.png"}]}, "index": 6, "seed": "05269061", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision detection, sliding objects\n\n# description:\n# In the input you will see a teal 2x2 square and a red object (the red object might be irregular in its shape)\n# Slide the red object in any of the four directions until it just touches the teal square\n\ndef transform(input_grid):\n\n    # get just the teal object\n    teal_object = np.zeros_like(input_grid)\n    teal_object[input_grid == Color.TEAL] = Color.TEAL\n\n    # get just the red object\n    red_object = np.zeros_like(input_grid)\n    red_object[input_grid == Color.RED] = Color.RED\n\n    # the output grid starts with just the teal object, because we still need to figure out where the red object will be by sliding it\n    output_grid = np.copy(teal_object)\n    \n    # consider sliding in the 4 cardinal directions, and consider sliding as far as possible\n    possible_displacements = [ (slide_distance*dx, slide_distance*dy)\n                               for slide_distance in range(max(input_grid.shape))\n                               for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)] ]\n    for x, y in possible_displacements:\n        # check if the objects are touching after sliding\n        translated_red_object = translate(red_object, x, y, background=Color.BLACK)\n        if contact(object1=teal_object, object2=translated_red_object):\n            # put the red object where it belongs\n            blit_object(output_grid, translated_red_object, background=Color.BLACK)\n            return output_grid\n            \n    assert 0, \"No valid slide found\"\n\ndef generate_input():\n    # make a black grid first as background, roughly 5 x 5 to 10x10 works\n    n, m = random.randint(5, 20), random.randint(5, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    # make a 2x2 teal square, put it somewhere random on the grid\n    square_sprite = np.full((2, 2), Color.TEAL)\n    x, y = random_free_location_for_sprite(grid, square_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, square_sprite, x, y, background=Color.BLACK)\n\n    # make a random sprite of [3,4] x [3,4] with a random symmetry type and the color red\n    sprite = random_sprite([3,4], [3,4], symmetry=\"not_symmetric\", color_palette=[Color.RED])\n\n    # put the sprite somewhere random on the grid\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, sprite, x, y, background=Color.BLACK)    \n\n    # check that we could slide the object either vertically or horizontally in order to touch the red square\n    # this will be true if there is a row or column that has both red and blue\n    for x in range(n):\n        if Color.TEAL in grid[x, :] and Color.RED in grid[x, :]:\n            return grid\n    for y in range(m):\n        if Color.TEAL in grid[:, y] and Color.RED in grid[:, y]:\n            return grid\n    \n    # if not, try again\n    return generate_input()", "images": {"test": {"input": "output/seeds/seed_examples/7/images/test_input.png", "output": "output/seeds/seed_examples/7/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/7/images/train_input_0.png", "output": "output/seeds/seed_examples/7/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/7/images/train_input_1.png", "output": "output/seeds/seed_examples/7/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/7/images/train_input_2.png", "output": "output/seeds/seed_examples/7/images/train_output_2.png"}]}, "index": 7, "seed": "05f2a901", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rectangular cells, flood fill, connecting same color\n\n# description:\n# In the input you will see horizontal and vertical bars that divide the grid into rectangular cells\n# To make the output, find any pair of rectangular cells that are in the same row and column and have the same color, then color all the rectangular cells between them with that color\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n\n    # find the color of the horizontal and vertical bars that divide the rectangular cells\n    # this is the color of any line that extends all the way horizontally or vertically\n    jail_color = None\n    for i in range(input_grid.shape[0]):\n        for j in range(input_grid.shape[1]):\n            color = input_grid[i][j]\n            if np.all(input_grid[i, :] == color) or np.all(input_grid[:, j] == color):\n                jail_color = color\n                break\n    \n    assert jail_color is not None, \"No jail color found\"\n\n    output_grid = input_grid.copy()\n\n    # color all the cells between the same color pixels\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == jail_color or color == Color.BLACK:\n                continue\n\n            # check if there is a cell with the same color in the same X value\n            for y2 in range(y+1, input_grid.shape[1]):\n                if input_grid[x][y2] == color:\n                    for y3 in range(y+1, y2):\n                        if input_grid[x][y3] == Color.BLACK:\n                            output_grid[x][y3] = color\n                    break\n\n            # check if there is a cell with the same color in the same Y value\n            for x2 in range(x+1, input_grid.shape[0]):\n                if input_grid[x2][y] == color:\n                    for x3 in range(x+1, x2):\n                        if input_grid[x3][y] == Color.BLACK:\n                            output_grid[x3][y] = color\n                    break\n                \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n\n    grid_size = 32\n    cell_size = 2\n\n    # First create the array of rectangular cells, each of which is separated by horizontal and vertical bars dividing cells\n\n    # pick a non-black color for the divider\n    divider_color = random.choice(Color.NOT_BLACK)\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n    r_offset_x, r_offset_y = np.random.randint(0, cell_size), np.random.randint(0, cell_size)\n\n    # make horizontal bars with cell_size gaps, but +1 because we need to include the divider, which is one pixel wide\n    for x in range(r_offset_x, grid_size, cell_size+1):\n        grid[x, :] = divider_color\n    # make vertical bars with cell_size gaps\n    for y in range(r_offset_y, grid_size, cell_size+1):\n        grid[:, y] = divider_color\n\n    # Second we will color some of the cells with a random color\n\n    # random number of cells to color\n    number_to_color = np.random.randint(1, 4)\n    for _ in range(number_to_color):\n        # pick what we\u0027re going to color the inside of the cell, which needs to be a different color from the divider\n        other_color = np.random.choice([c for c in Color.ALL_COLORS if c != divider_color and c != Color.BLACK])\n\n        # get all coords of black cells\n        black_coords = np.argwhere(grid == Color.BLACK)\n        # pick a random black cell\n        x, y = random.choice(black_coords)\n        flood_fill(grid, x, y, other_color)\n\n        # sometimes skip coloring the other side of the divider\n        if random.random() \u003c= 0.2:\n            continue \n\n        # flip a coin to decide if horizontal or vertical\n        h_or_v = random.random() \u003c 0.5\n        if h_or_v:\n            # horizontal\n            # get all the black cells in the same row\n            black_coords = np.argwhere(grid[x, :] == Color.BLACK)\n            # pick a random black cell\n            other_y = random.choice(black_coords)\n            flood_fill(grid, x, other_y, other_color)\n        else:\n            # vertical\n            # get all the black cells in the same column\n            black_coords = np.argwhere(grid[:, y] == Color.BLACK)\n            # pick a random black cell\n            other_x = random.choice(black_coords)\n            flood_fill(grid, other_x, y, other_color)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/8/images/test_input.png", "output": "output/seeds/seed_examples/8/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/8/images/train_input_0.png", "output": "output/seeds/seed_examples/8/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/8/images/train_input_1.png", "output": "output/seeds/seed_examples/8/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/8/images/train_input_2.png", "output": "output/seeds/seed_examples/8/images/train_output_2.png"}]}, "index": 8, "seed": "06df4c85", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sorting, color change, size\n\n# description:\n# In the input you will see a row of exactly 4 grey bars of different heights, each starting at the bottom of the canvas, and each separated by 1 pixel (so they are two pixels apart)\n# Color the tallest one blue, the second tallest one red, the third tallest one green, and the shortest one yellow.\n\ndef transform(input_grid):\n\n    # extract the bars, each of which is a connected component\n    bars = find_connected_components(input_grid, background=Color.BLACK)\n\n    # sort the bars by height\n    bars = list(sorted(bars, key=lambda bar: np.sum(bar != Color.BLACK), reverse=True))\n\n    # color the bars\n    output_grid = input_grid.copy()\n\n    biggest_bar = bars[0]\n    biggest_bar_mask = biggest_bar != Color.BLACK\n    output_grid[biggest_bar_mask] = Color.BLUE\n\n    second_biggest_bar = bars[1]\n    second_biggest_bar_mask = second_biggest_bar != Color.BLACK\n    output_grid[second_biggest_bar_mask] = Color.RED\n\n    third_biggest_bar = bars[2]\n    third_biggest_bar_mask = third_biggest_bar != Color.BLACK\n    output_grid[third_biggest_bar_mask] = Color.GREEN\n\n    smallest_bar = bars[3]\n    smallest_bar_mask = smallest_bar != Color.BLACK\n    output_grid[smallest_bar_mask] = Color.YELLOW\n\n    return output_grid\n\n\n\ndef generate_input():\n    # make a black 9x9 grid\n    n, m = 9, 9\n    grid = np.zeros((9, 9), dtype=int)\n\n    # pick 4 distinct heights (can\u0027t reuse the same height)\n    heights = random.sample(range(1, 9), 4)\n\n    # draw the bars\n    # space them by 2 so that there is a black pixel in between each pair\n    for i, height in enumerate(heights):\n        grid[1+i*2, -height:] = Color.GREY\n        \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/9/images/test_input.png", "output": "output/seeds/seed_examples/9/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/9/images/train_input_0.png", "output": "output/seeds/seed_examples/9/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/9/images/train_input_1.png", "output": "output/seeds/seed_examples/9/images/train_output_1.png"}]}, "index": 9, "seed": "08ed6ac7", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rectangular cells, color guide\n\n# description:\n# In the input you will see grey horizontal and vertical bars that divide the grid into nine 3x3 rectangular regions, each of which contains 4-5 colored pixels\n# To make the output, find the region that has exactly 4 colored pixels, and use its colors as a guide to fill in all the other cells\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n\n    # First identify \n\n    # Trick for decomposing inputs divided into rectangular regions by horizontal/vertical bars:\n    # Treat the bar color as the background, and break the input up into connected components with that background color\n\n    # The divider color is the color of the horizontal and vertical bars\n    divider_colors = [ input_grid[x,y] for x in range(input_grid.shape[0]) for y in range(input_grid.shape[1])\n                     if np.all(input_grid[x,:] == input_grid[x,0]) or np.all(input_grid[:,y] == input_grid[0,y]) ]\n    assert len(set(divider_colors)) == 1, \"There should be exactly one divider color\"\n    divider_color = divider_colors[0] # background=divider_color\n\n    # Find multicolored regions, which are divided by divider_color, so we treat that as background, because it separates objects\n    # Within each region there can be multiple colors\n    regions = find_connected_components(input_grid, background=divider_color, monochromatic=False)\n    # Tag the regions with their location within the 2D grid of (divided) regions\n    # First get the bounding-box locations...\n    locations = []\n    for region in regions:\n        x, y, w, h = bounding_box(region, background=divider_color)\n        locations.append((x, y, region))\n    # ...then re-index them so that (x, y) is the coordinate within the grid of rectangular regions\n    grid_of_regions = []\n    for x, y, region in locations:\n        num_left_of_region = len({other_x for other_x, other_y, other_region in locations if other_x \u003c x})\n        num_above_region = len({other_y for other_x, other_y, other_region in locations if other_y \u003c y})\n        grid_of_regions.append((num_left_of_region, num_above_region, region))\n\n    # Find the region with exactly 4 colors\n    special_region = None\n    for region in regions:\n        not_divider_and_not_black = (region != divider_color) \u0026 (region != Color.BLACK)\n        if np.sum(not_divider_and_not_black) == 4:\n            assert special_region is None, \"More than one special region found\"\n            special_region = region\n    \n    # Convert to a sprite\n    special_sprite = crop(special_region, background=divider_color)\n    \n    # Create the output grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Put the dividers back in\n    output_grid[input_grid == divider_color] = divider_color\n\n    # Fill in the cells with the special colors\n    for x, y, region in grid_of_regions:\n        output_grid[region != divider_color] = special_sprite[x, y]\n\n    return output_grid\n\n\n\ndef generate_input() -\u003e np.ndarray:\n    \n    divider_color = Color.GRAY\n\n    # make the dividers, which comprise horizontal/vertical bars creating 3x3 cells, with 3 cells in each direction\n    cell_size = 3\n    n_cells = 3\n    divider_size = 1 # the divider is a single pixel\n    n_dividers = n_cells - 1\n    distance_between_cells = cell_size + divider_size\n    m = cell_size*n_cells + divider_size*n_dividers\n    grid = np.full((m, m), Color.BLACK)\n    for i in range(n_dividers):\n        # horizontal dividers\n        grid[cell_size + i*(cell_size + divider_size), :] = divider_color\n        # vertical dividers\n        grid[:, cell_size + i*(cell_size + divider_size)] = divider_color\n    \n    # pick one of the cells to have exactly 4 colors (the others will have 5)\n    special_cell_x, special_cell_y = np.random.randint(3), np.random.randint(3)\n\n    for x in range(3):\n        for y in range(3):\n            if x == special_cell_x and y == special_cell_y:\n                n_colors = 4\n            else:\n                n_colors = 5\n\n            # extract view of the cell\n            # each of the cells is 3x3, but there is a divider in between them, so they are actually 4x4 apart\n            cell = grid[x*distance_between_cells : x*distance_between_cells + cell_size,\n                        y*distance_between_cells : y*distance_between_cells + cell_size]\n\n            # color the cell by picking random positions and random colors until we have enough colored pixels\n            while np.sum(cell!=Color.BLACK) \u003c n_colors:\n                # pick a random spot to color\n                cell_x, cell_y = np.random.randint(cell_size), np.random.randint(cell_size)\n                cell[cell_x, cell_y] = random.choice([color for color in Color.ALL_COLORS if color != Color.BLACK and color != divider_color])\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/10/images/test_input.png", "output": "output/seeds/seed_examples/10/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/10/images/train_input_0.png", "output": "output/seeds/seed_examples/10/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/10/images/train_input_1.png", "output": "output/seeds/seed_examples/10/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/10/images/train_input_2.png", "output": "output/seeds/seed_examples/10/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/10/images/train_input_3.png", "output": "output/seeds/seed_examples/10/images/train_output_3.png"}]}, "index": 10, "seed": "09629e4f", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation, growing\n\n# description:\n# In the input you will see some number of colored crosses, each of which is 3 pixels tall, 3 pixels wide, and has a single pixel in the center of the cross that is a different color.\n# Make the output by growing the cross by 1 pixel north/south/east/west, and growing the center pixel by 2 pixels along each of the 4 diagonals.\n\ndef transform(input_grid):\n\n    # extract the 3x3 crosses\n    crosses = find_connected_components(input_grid, background=Color.BLACK, monochromatic=False)\n\n    output_grid = input_grid.copy()\n\n    for cross in crosses:\n        # find the center\n        x, y, w, h = bounding_box(cross)\n        center_x, center_y = x + w//2, y + h//2\n\n        # extract the relevant colors\n        center_color = cross[center_x, center_y]\n        cross_color = cross[cross != Color.BLACK][0]\n\n        # grow the cross\n        for output_x in range(x-1, x+w+1):\n            for output_y in range(y-1, y+h+1):\n                # skip if out of bounds\n                if output_x \u003c 0 or output_y \u003c 0 or output_x \u003e= input_grid.shape[0] or output_y \u003e= input_grid.shape[1]:\n                    continue\n                \n                # grow the cross north/south/east/west\n                if output_x == center_x or output_y == center_y:\n                    output_grid[output_x, output_y] = cross_color\n                \n                # grow the center diagonally\n                if (output_x - center_x) == (output_y - center_y) or (output_x - center_x) == (center_y - output_y):\n                    output_grid[output_x, output_y] = center_color\n\n    return output_grid\n\n\n\ndef generate_input():\n    input_grid = np.zeros((20, 20), dtype=int)\n\n    # create 2 crosses\n    for cross_number in range(2):\n        # create a separate sprite\n        cross = np.zeros((3, 3), dtype=int)\n        cross_color, center_color = random.sample(list(Color.NOT_BLACK), 2)\n        cross[1, :] = cross_color\n        cross[:, 1] = cross_color\n        cross[1, 1] = center_color\n\n        # find a free place on the grid\n        x, y = random_free_location_for_sprite(input_grid, cross)\n\n        # blit the cross to the canvas\n        blit_sprite(input_grid, cross, x, y)\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/11/images/test_input.png", "output": "output/seeds/seed_examples/11/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/11/images/train_input_0.png", "output": "output/seeds/seed_examples/11/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/11/images/train_input_1.png", "output": "output/seeds/seed_examples/11/images/train_output_1.png"}]}, "index": 11, "seed": "0962bcdd", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# repetition, horizontal/vertical bars\n\n# description:\n# In the input you will see a pair of colored pixels\n# Make each pixel into a horizontal/vertical bar by connecting it to the other side of the canvas\n# Then, repeat the bars indefinitely in the same direction: either downward (for horizontal bars) or rightward (for vertical bars)\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # find the individual coloured pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # there should be exactly two colored pixels\n    assert len(colored_pixels) == 2\n\n    # find the two pixels\n    pixel1, pixel2 = colored_pixels\n    x1, y1 = pixel1\n    x2, y2 = pixel2\n    color1, color2 = input_grid[x1, y1], input_grid[x2, y2]\n\n    # make the horizontal/vertical bars\n    output_grid = np.copy(input_grid)\n\n    # check if they should be horizontal (constant y) or vertical (constant x)\n    # if they are on the top or bottom, they should be vertical\n    if y1 == 0 or y1 == input_grid.shape[1] - 1 or y2 == 0 or y2 == input_grid.shape[1] - 1:\n        # vertical bars: constant x\n        output_grid[x1, :] = color1\n        output_grid[x2, :] = color2\n\n        # repeat the vertical bars indefinitely\n        # first, figure out how far apart they are.\n        dx = abs(x2 - x1)\n        # next, each repetition needs to be separated by twice that amount, because we have two lines\n        dx = 2 * dx\n        # finally, repeat the vertical bars indefinitely, using the same colors and using a list slice to repeat the bars\n        output_grid[x1::dx, :] = color1\n        output_grid[x2::dx, :] = color2\n    else:\n        # horizontal bars: constant y\n        output_grid[:, y1] = color1\n        output_grid[:, y2] = color2\n\n        # repeat the horizontal bars indefinitely\n        # first, figure out how far apart they are.\n        dy = abs(y2 - y1)\n        # next, each repetition needs to be separated by twice that amount, because we have two lines\n        dy = 2 * dy\n        # finally, repeat the horizontal bars indefinitely, using the same colors and using a list slice to repeat the bars\n        output_grid[:, y1::dy] = color1\n        output_grid[:, y2::dy] = color2\n\n    return output_grid\n\n\n\ndef generate_input() -\u003e np.ndarray:\n    # make a grid that is narrow and tall. This is for horizontal lines, and we will flip a coin at the end to transpose everything to make things vertical\n    n = np.random.randint(5, 10)\n    m = np.random.randint(n+1, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # place two colored pixels. They should be on the left/right edges, so that they give rise to horizontal bars\n    x1, y1, color1 = random.choice([0,n-1]), np.random.randint(m//2), random.choice(Color.NOT_BLACK)\n    x2, y2, color2 = random.choice([0,n-1]), np.random.randint(y1+2, m), random.choice(Color.NOT_BLACK)\n\n    grid[x1, y1] = color1\n    grid[x2, y2] = color2\n\n    # decide to either do vertical or horizontal\n    vertical = np.random.choice([True, False])\n    if vertical: \n        # transpose the grid\n        grid = grid.T\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/12/images/test_input.png", "output": "output/seeds/seed_examples/12/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/12/images/train_input_0.png", "output": "output/seeds/seed_examples/12/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/12/images/train_input_1.png", "output": "output/seeds/seed_examples/12/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/12/images/train_input_2.png", "output": "output/seeds/seed_examples/12/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/12/images/train_input_3.png", "output": "output/seeds/seed_examples/12/images/train_output_3.png"}]}, "index": 12, "seed": "0a938d79", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rectangular cells, color guide\n\n# description:\n# In the input you will see a pretty big grid divided into four axis-aligned quadrants (but there might be different sizes), each of which is separated by at least 1 row/column of black. All the quadrants contain random pixels, and all quadrants except for one have the same color\n# To make the output, find the quadrant with a different color, and copy only that quadrant to the output, producing a smaller grid\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # break the input up into quadrants\n    # remember they are different sizes, but they are all separated by at least 2 rows/columns of black\n    # we do this by computing the x, y coordinates of separators\n    for i in range(input_grid.shape[0]):\n        if np.all(input_grid[i, :] == Color.BLACK):\n            x_separator = i\n            break\n    for i in range(input_grid.shape[1]):\n        if np.all(input_grid[:, i] == Color.BLACK):\n            y_separator = i\n            break\n    \n    quadrants = [ input_grid[:x_separator, :y_separator],\n                  input_grid[:x_separator, y_separator:],\n                  input_grid[x_separator:, :y_separator],\n                  input_grid[x_separator:, y_separator:] ]\n    \n    # check that each of them is monochromatic (only one color that isn\u0027t black)\n    colors = [ np.unique(quadrant[quadrant != Color.BLACK]) for quadrant in quadrants ]\n    for color in colors:\n        assert len(color) == 1, \"Quadrant has more than one color\"\n\n    for color, quadrant in zip(colors, quadrants):\n        color_frequency = sum(other_color == color for other_color in colors)\n        if color_frequency == 1:\n            output_grid = quadrant\n\n            # we have to crop the output grid to remove any extraneous black rows/columns\n            output_grid = crop(output_grid, background=Color.BLACK)\n\n            break\n\n    return output_grid\n\n\n\ndef generate_input() -\u003e np.ndarray:\n    \n    # pick a pair of colors, one of which is going to fill 3 quadrants, and the other will fill 1\n    popular_color, unique_color = random.sample(Color.NOT_BLACK, 2)\n\n    # make a grid\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # pick a random size for the first quadrant (all other quadrant sizes follow from this)\n    x_size, y_size = np.random.randint(6, n-6), np.random.randint(6, m-6)\n\n    quadrants = [ grid[:x_size, :y_size],\n                  grid[:x_size, y_size:],\n                  grid[x_size:, :y_size],\n                  grid[x_size:, y_size:] ]\n    unique_quadrant = random.choice(quadrants)\n    for quadrant in quadrants:\n        target_color = popular_color if quadrant is not unique_quadrant else unique_color\n        # fill a random 70% of the quadrant with the target color\n        for i in range(quadrant.shape[0]):\n            for j in range(quadrant.shape[1]):\n                if random.random() \u003c 0.7:\n                    quadrant[i, j] = target_color\n        \n    # add black separators\n    separator_width, separator_height = np.random.randint(2, 4), np.random.randint(2, 4)\n    grid[x_size:x_size+separator_width, :] = Color.BLACK\n    grid[:, y_size:y_size+separator_height] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/13/images/test_input.png", "output": "output/seeds/seed_examples/13/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/13/images/train_input_0.png", "output": "output/seeds/seed_examples/13/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/13/images/train_input_1.png", "output": "output/seeds/seed_examples/13/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/13/images/train_input_2.png", "output": "output/seeds/seed_examples/13/images/train_output_2.png"}]}, "index": 13, "seed": "0b148d64", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel manipulation\n\n# description:\n# In the input you will see a medium sized grid width individual colored pixels, some of which are red or blue (those ones are special)\n# To make the output:\n# 1. For each red pixel, add yellow pixels in its immediate diagonals (northeast, northwest, southeast, southwest)\n# 2. For each blue pixel, add orange pixels in its immediate neighbors (up, down, left, right)\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            color = input_grid[x][y]\n            if color == Color.RED:\n                # put yellow pixels in the diagonals\n                for dx in [-1, 1]:\n                    for dy in [-1, 1]:\n                        if 0 \u003c= x+dx \u003c input_grid.shape[0] and 0 \u003c= y+dy \u003c input_grid.shape[1]:\n                            output_grid[x+dx, y+dy] = Color.YELLOW\n            elif color == Color.BLUE:\n                # put orange pixels in the neighbors\n                for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                    if 0 \u003c= x+dx \u003c input_grid.shape[0] and 0 \u003c= y+dy \u003c input_grid.shape[1]:\n                        output_grid[x+dx, y+dy] = Color.ORANGE\n\n    return output_grid\n\n\n\ndef generate_input() -\u003e np.ndarray:\n    n, m = np.random.randint(5, 20), np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    num_red, num_blue, num_other = np.random.randint(1, 5), np.random.randint(1, 5), np.random.randint(1, 5)\n\n    for _ in range(num_red):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.RED\n    \n    for _ in range(num_blue):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLUE\n    \n    for _ in range(num_other):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = np.random.choice([ color for color in Color.NOT_BLACK if color not in [Color.RED, Color.BLUE] ])\n\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/14/images/test_input.png", "output": "output/seeds/seed_examples/14/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/14/images/train_input_0.png", "output": "output/seeds/seed_examples/14/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/14/images/train_input_1.png", "output": "output/seeds/seed_examples/14/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/14/images/train_input_2.png", "output": "output/seeds/seed_examples/14/images/train_output_2.png"}]}, "index": 14, "seed": "0ca9ddb6", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color mapping\n\n# description:\n# The input is a grid where each column is of the same color. \n# To make the output, change each color according to the following mapping:\n# green -\u003e yellow, blue -\u003e gray, red -\u003e pink, teal -\u003e maroon, yellow -\u003e green, gray -\u003e blue, pink -\u003e red, maroon -\u003e teal\n\ndef transform(input_grid):\n    # Initialize output grid\n    output_grid = input_grid.copy()\n\n    # Performs color mapping\n    output_grid = np.vectorize(lambda color: color_map.get(color, color))(output_grid)\n\n    return output_grid\n    \n# Constructing the color map\ncolor_map = {Color.GREEN : Color.YELLOW, \n             Color.BLUE : Color.GRAY, \n             Color.RED : Color.PINK,\n             Color.TEAL : Color.MAROON,\n             Color.YELLOW : Color.GREEN, \n             Color.GRAY : Color.BLUE, \n             Color.PINK : Color.RED,\n             Color.MAROON : Color.TEAL             \n            }\n\n\ndef generate_input():\n    grid = np.full((3, 3), Color.BLACK)\n    for x in range(grid.shape[0]):\n        grid[x, :] = random.choice(list(color_map.keys()))\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/15/images/test_input.png", "output": "output/seeds/seed_examples/15/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/15/images/train_input_0.png", "output": "output/seeds/seed_examples/15/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/15/images/train_input_1.png", "output": "output/seeds/seed_examples/15/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/15/images/train_input_2.png", "output": "output/seeds/seed_examples/15/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/15/images/train_input_3.png", "output": "output/seeds/seed_examples/15/images/train_output_3.png"}]}, "index": 15, "seed": "0d3d703e", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# occlusion, translational symmetry\n\n# description:\n# In the input you will see a translationally symmetric pattern randomly occluded by black pixels.\n# To make the output, remove the occluding black pixels to reveal the translationally symmetric pattern.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the translational symmetries\n    # 2. Reconstruct the sprite by ignoring the black pixels and exploiting the symmetry\n\n    w, h = input_grid.shape\n\n    # Identify the translational symmetries. Note that there is no background color for this problem.\n    translations = detect_translational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=None)\n    assert len(translations) \u003e 0, \"No translational symmetry found\"\n\n    # Reconstruct the occluded black pixels by replacing them with colors found in the orbit of the symmetries\n    output_grid = np.copy(input_grid)\n    for x in range(w):\n        for y in range(h):\n            if output_grid[x, y] == Color.BLACK:\n                # Use the translational symmetry to fill in the occluded pixels\n                # to do this we compute the ORBIT of the current pixel under the translations\n                # and take the most common non-black color in the orbit\n\n                # Compute the orbit into the output\n                orbit_pixels = orbit(output_grid, x, y, translations)\n                orbit_colors = {input_grid[transformed_x, transformed_y]\n                                for transformed_x, transformed_y in orbit_pixels}\n                \n                # occluded by black, so whatever color it is, black doesn\u0027t count\n                orbit_colors = orbit_colors - {Color.BLACK}\n\n                # Copy the color\n                assert len(orbit_colors) == 1, \"Ambiguity: multiple colors in the orbit\"\n                output_grid[x, y] = orbit_colors.pop()\n    \n    return output_grid\n\ndef generate_input():\n    # Make a random large canvas\n    grid = np.full((np.random.randint(15, 30), np.random.randint(15, 30)), Color.BLACK)\n\n    # Make the basic sprite\n    w, h = random.randint(3, 8), random.randint(3, 8)\n    sprite = random_sprite(w, h, density=1, color_palette=Color.NOT_BLACK)\n\n    # Place the sprite in the upper left corner of the canvas, then compute the orbit under the symmetry group\n    blit_sprite(grid, sprite, x=0, y=0)\n    symmetries = [TranslationalSymmetry(w, 0), TranslationalSymmetry(0, h)]\n    for x, y in np.argwhere(sprite != Color.BLACK):\n        for x2, y2 in orbit(grid, x, y, symmetries):\n            grid[x2, y2] = sprite[x, y]\n    # You could have also done this:\n    # for x in range(0, grid.shape[0], w):\n    #     for y in range(0, grid.shape[1], h):\n    #         blit_sprite(grid, sprite, x, y)\n    \n    # Create random occluders\n    n_occluders = random.randint(1, 5)\n    for _ in range(n_occluders):\n        x, y = random.randint(0, grid.shape[0]), random.randint(0, grid.shape[1])\n        w, h = random.randint(3, 7), random.randint(3, 7)\n        grid[x:x+w+1, y:y+h+1] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/16/images/test_input.png", "output": "output/seeds/seed_examples/16/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/16/images/train_input_0.png", "output": "output/seeds/seed_examples/16/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/16/images/train_input_1.png", "output": "output/seeds/seed_examples/16/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/16/images/train_input_2.png", "output": "output/seeds/seed_examples/16/images/train_output_2.png"}]}, "index": 16, "seed": "0dfd9992", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetries, objects\n\n# description:\n# In the input you will see one or two medium-sized multicolor objects, and some multicolor pixels sprinkled around in one or two clusters\n# To make the output, take each of the medium-sized object and move it so that it perfectly covers some of the pixels sprinkled around, matching colors wherever they overlap.\n# You can rotate and flip the objects in order to make them fit the pixels, but they have to match colors wherever they overlap.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Break the input into 1-2 big object(s) and a mask containing the remaining pixels\n    # 2. For each object, create rotations and flips of it\n    # 3. For each object, find the best way to place one of its rotations/flips so that it covers the most number of the pixels (remember the pixel has to match object color)\n\n    # Extract the objects from the input and categorize them into objects and pixels\n    # Objects can be multicolored\n    connected_components = find_connected_components(input_grid, monochromatic=False)\n    objects = [ cc for cc in connected_components if np.count_nonzero(cc != Color.BLACK) \u003e 4 ]\n    pixels = [ cc for cc in connected_components if np.count_nonzero(cc != Color.BLACK) \u003c= 4 ]\n\n    # Make the pixel mask, which shows where the pixels are. These guide the placement of objects.\n    pixel_mask = np.full(input_grid.shape, Color.BLACK)\n    for pixel_object in pixels:\n        blit_object(pixel_mask, pixel_object, background=Color.BLACK)\n    \n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    \n    # For each object, find the best way to place it so that it covers the most number of the pixels\n    for obj in objects:\n        # The object can be rotated and flipped to match the pixels\n        # First, convert it to a sprite before transforming, because these operations are independent of position\n        sprite = crop(obj)\n        sprite_variations = [sprite, np.rot90(sprite), np.rot90(sprite, 2), np.rot90(sprite, 3), np.flipud(sprite), np.fliplr(sprite), np.flipud(np.rot90(sprite)), np.fliplr(np.rot90(sprite))]\n\n        # We are going to optimize the position and variation, so we need to keep track of the best placement so far\n        best_output, best_pixels_covered = None, 0\n        for x, y, sprite_variation in [(x, y, variant) for x in range(input_grid.shape[0]) for y in range(input_grid.shape[1]) for variant in sprite_variations]:\n            test_grid = np.copy(output_grid)\n            blit_sprite(test_grid, sprite_variation, x, y, background=Color.BLACK)\n            # Check if there was any color mismatch: A colored pixel in the mask which is different from what we just made\n            # If there is a mismatch, we can\u0027t place the object here\n            if np.any((pixel_mask != Color.BLACK) \u0026 (test_grid != Color.BLACK) \u0026 (pixel_mask != test_grid)):\n                continue\n            num_covered_pixels = np.count_nonzero((pixel_mask != Color.BLACK) \u0026 (test_grid != Color.BLACK))\n            if num_covered_pixels \u003e best_pixels_covered:\n                best_output, best_pixels_covered = test_grid, num_covered_pixels\n        output_grid = best_output\n\n    return output_grid\n\n\ndef generate_input():\n    # to make the input, we make random objects\n    # we need to make sure that the objects can match with the \"sprinkled\" pixels, so we make the pixels by placing some objects and then removing some parts of them\n\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_objects = np.random.randint(1, 3)\n    sprites = [ random_sprite(np.random.randint(3, 6), np.random.randint(3, 6), color_palette=Color.NOT_BLACK, density=0.5)\n                for _ in range(num_objects) ]\n    sprite_variations = [ [sprite, np.rot90(sprite), np.rot90(sprite, 2), np.rot90(sprite, 3), np.flipud(sprite), np.fliplr(sprite), np.flipud(np.rot90(sprite)), np.fliplr(np.rot90(sprite))]\n                          for sprite in sprites ]\n    # Pick a variation for each sprite\n    sprite_variations = [ random.choice(variations) for variations in sprite_variations ]\n    \n    # Remove parts of the sprite to create the \"sprinkled\" pixels\n    # We remove enough of the sprite so that there are only 3 pixels remaining\n    # We do this to the variation, which is what is going to be put on the canvas to be matched with\n    occluded_sprites = []\n    for sprite in sprite_variations:\n        occluded_sprite = np.copy(sprite)\n        could_be_removed = np.argwhere(occluded_sprite != Color.BLACK)\n        np.random.shuffle(could_be_removed)\n        for i in range(len(could_be_removed) - 3):\n            x, y = could_be_removed[i]\n            occluded_sprite[x, y] = Color.BLACK\n\n        occluded_sprites.append(occluded_sprite)\n\n    # place everything on the canvas but make sure that nothing overlaps, so they all have their own free location with a little bit of padding\n    for sprite in sprites + occluded_sprites:\n        x, y = random_free_location_for_sprite(grid, sprite, padding=2, border_size=2)\n        blit_sprite(grid, sprite, x, y)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/17/images/test_input.png", "output": "output/seeds/seed_examples/17/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/17/images/train_input_0.png", "output": "output/seeds/seed_examples/17/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/17/images/train_input_1.png", "output": "output/seeds/seed_examples/17/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/17/images/train_input_2.png", "output": "output/seeds/seed_examples/17/images/train_output_2.png"}]}, "index": 17, "seed": "0e206a2e", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# Coloring diagonal pixels, repetition\n\n# description:\n# Given an input grid of arbitrary size, with some small number of colored pixels on it.\n# To produce the output, replicate the input grid 4 times, 2 on the top and 2 on the bottom. \n# Color all the diagonal pixels adjacent to a colored pixel teal if the diagonal pixels are black. \n\ndef transform(input_grid):\n   # Replicate input grid 4 times to initialize output grid\n   output_grid = np.zeros((2*input_grid.shape[0], 2* input_grid.shape[1]),dtype=int)\n   for i in range(2):\n      for j in range(2):\n         blit_sprite(output_grid, input_grid, i*input_grid.shape[0], j*input_grid.shape[1])\n  \n   # Create diagonal directions\n   diagonal_dx_dy = [(1,1),(-1,1),(1,-1),(-1,-1)]\n\n   # Color diagonal pixels \n   for y in range(output_grid.shape[1]):\n      for x in range(output_grid.shape[0]):\n         if output_grid[x,y] != Color.BLACK and output_grid[x,y] != Color.TEAL:\n            for dx,dy in diagonal_dx_dy:\n               # Color diagonal pixel teal if it is black\n               if x+dx \u003e= 0 and x+dx \u003c output_grid.shape[0] and y+dy \u003e= 0 and y+dy \u003c output_grid.shape[1] and output_grid[x+dx,y+dy] == Color.BLACK:\n                  output_grid[x+dx,y+dy] = Color.TEAL\n  \n   return output_grid\n\ndef generate_input():\n    # Have 1 to 4 number of colored pixels in the initial square\n    n_colored_pixels = random.randint(1,4)\n    \n    # Random pixel color that is not black or teal. \n    pixel_color = random.choice(list(Color.NOT_BLACK))\n    while pixel_color == Color.TEAL:\n        pixel_color = random.choice(list(Color.NOT_BLACK))\n\n    # Random size of input grid\n    n,m= random.randint(2,10), random.randint(2,10)\n\n    # Initialize grid\n    grid = np.zeros((n,m),dtype=int)\n  \n    # Create a dummy sprite with one pixel. \n    sprite = np.array([pixel_color]).reshape(1,1)\n    \n    # Randomly place n_colored_pixels pixels on the grid\n    for i in range(n_colored_pixels):\n      x,y = random_free_location_for_sprite(grid,sprite)\n      blit_sprite(grid, sprite, x,y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/18/images/test_input.png", "output": "output/seeds/seed_examples/18/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/18/images/train_input_0.png", "output": "output/seeds/seed_examples/18/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/18/images/train_input_1.png", "output": "output/seeds/seed_examples/18/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/18/images/train_input_2.png", "output": "output/seeds/seed_examples/18/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/18/images/train_input_3.png", "output": "output/seeds/seed_examples/18/images/train_output_3.png"}]}, "index": 18, "seed": "10fcaaa3", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, occlusion\n\n# description:\n# In the input you will see an object that is almost rotationally symmetric, except that some of it has been removed (covered in black pixels)\n# To make the output fill in the missing parts of the object to make it rotationally symmetric\n\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the center of rotation\n    # 2. Rotate each colored pixel (4 times, rotating around the center of rotation) and fill in any missing pixels\n    output_grid = input_grid.copy()\n\n    # Find the rotational symmetry\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK])\n\n    # Find the colored pixels\n    colored_pixels = np.argwhere(input_grid != Color.BLACK)\n\n    # Do the rotations and fill in the missing colors\n    for x, y in colored_pixels:\n        # Get the color, which is going to be copied to the rotated positions\n        color = input_grid[x, y]\n        \n        # Loop over all rotations, going 90 degrees each time (so four times)\n        for i in range(1, 4):\n            # Calculate rotated coordinate\n            rotated_x, rotated_y = sym.apply(x, y, iters=i)\n\n            # Fill in the missing pixel\n            if output_grid[rotated_x, rotated_y] == Color.BLACK:\n                output_grid[rotated_x, rotated_y] = color\n            else:\n                assert output_grid[rotated_x, rotated_y] == color, \"The object is not rotationally symmetric\"\n\n    return output_grid\n\n\ndef generate_input():\n    # Initialize 10x10 grid\n    grid = np.zeros((10, 10), dtype=int)\n\n    # Create 5x5 sprite\n    sprite = random_sprite(\n        5, 5, density=0.3, symmetry=\"radial\", color_palette=list(Color.NOT_BLACK)\n    )\n\n    # Randomly remove pixels from sprite\n    for i in range(sprite.shape[0]):\n        for j in range(sprite.shape[1]):\n            if random.random() \u003c 0.2:\n                sprite[i, j] = Color.BLACK\n\n    # Place sprite randomly onto the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/19/images/test_input.png", "output": "output/seeds/seed_examples/19/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/19/images/train_input_0.png", "output": "output/seeds/seed_examples/19/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/19/images/train_input_1.png", "output": "output/seeds/seed_examples/19/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/19/images/train_input_2.png", "output": "output/seeds/seed_examples/19/images/train_output_2.png"}]}, "index": 19, "seed": "11852cab", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# horizontal/vertical bars, counting\n\n# description:\n# In the input, you will see horizontal and vertical bars, dividing the input into a grid of rectangular regions, on a non-black background.\n# To make the output produce a monochromatic image whose width is the number of background-colored regions going left-to-right, and whose height is the number of regions going top-to-bottom.\n# The output should have the same background.\n\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the color of the background and the bars\n    # 2. Count the number of regions going left-to-right\n    # 3. Count the number of regions going top-to-bottom\n\n    # Find bar color and background color\n    for x in range(input_grid.shape[0]):\n        bar_slice = input_grid[x, :]\n        if np.all(bar_slice == bar_slice[0]):\n            bar_color = bar_slice[0]\n            break\n\n    # background is whatever color isn\u0027t the bar color\n    background = [ color for color in input_grid.flatten() if color != bar_color ][0]\n\n    # Count the number of regions going left-to-right\n    n_horizontal = 1\n    for x in range(input_grid.shape[0]):\n        if input_grid[x, 0] == bar_color:\n            n_horizontal += 1\n    \n    # Count the number of regions going top-to-bottom\n    n_vertical = 1\n    for y in range(input_grid.shape[1]):\n        if input_grid[0, y] == bar_color:\n            n_vertical += 1\n    \n    # Create output grid\n    output_grid = np.full((n_horizontal, n_vertical), background)\n\n    return output_grid\n\n\ndef generate_input():\n    # Picking background and line colors\n    background_color, bar_color = random.sample(list(Color.NOT_BLACK), k=2)\n\n    # Creating the background grid\n    n = random.randint(11, 21)\n    grid = np.full((n, n), background_color)\n\n    # Create sprites for the bars. We will place them randomly later.\n    vertical_line_sprite = np.full((1, n), bar_color)\n    horizontal_line_sprite = np.full((n, 1), bar_color)\n\n    # Picking how many lines to have in each dimension\n    line_n, line_m = random.randint(1, n // 3), random.randint(1, n // 3)\n\n    # Create separate grids for horizontal and vertical lines, and then merge them later\n    # This is because horizontal/vertical are allowed to intersect, but horizontals can\u0027t touch each other (and verticals can\u0027t touch each other)\n    # So we need to do collision detection / free location separately for each type of line\n    vertical_line_grid = grid.copy()\n    horizontal_line_grid = grid.copy()\n\n    # Verticals\n    for i in range(line_n):\n        x, y = random_free_location_for_sprite(\n            vertical_line_grid,\n            vertical_line_sprite,\n            background=background_color,\n            padding=1\n        )\n        blit_sprite(vertical_line_grid, vertical_line_sprite, x, y)\n\n    # Horizontals\n    for i in range(line_m):\n        x, y = random_free_location_for_sprite(horizontal_line_grid, horizontal_line_sprite, background=background_color, padding=1)\n        blit_sprite(horizontal_line_grid, horizontal_line_sprite, x, y)\n\n    # Combine the two line grids\n    blit_object(grid, vertical_line_grid, background=background_color)\n    blit_object(grid, horizontal_line_grid, background=background_color)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/20/images/test_input.png", "output": "output/seeds/seed_examples/20/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/20/images/train_input_0.png", "output": "output/seeds/seed_examples/20/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/20/images/train_input_1.png", "output": "output/seeds/seed_examples/20/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/20/images/train_input_2.png", "output": "output/seeds/seed_examples/20/images/train_output_2.png"}]}, "index": 20, "seed": "1190e5a7", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, alignment by color\n\n# description:\n# In the input you will see some objects scattered around on a black grid. Each object has a single grey pixel, but everything else is a single other color.\n# To make the output, place each object into the output grid such that the grey pixel is in the center of the output.\n# Equivalently, move the objects to line up all their grey pixels so they overlap.\n# The output grid should be the smallest possible size that contains all the objects (after they have been placed correctly), which for all the inputs here is 3x3.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract the objects from the input, convert them into sprites by cropping them\n    # 2. Make a big output grid\n    # 3. Place each sprite into the output grid such that the grey pixel is in the center of the output\n    # 4. Make the output as small as you can to contain all the objects\n\n    # Extract the objects from the input. It is not monochromatic because the grey pixel is different, and they can be connected on the diagonals (connectivity=8)\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n\n    # Convert the objects into sprites by cropping them\n    sprites = [crop(obj, background=Color.BLACK) for obj in objects]\n\n    # Make a big output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Place each sprite into the output grid such that the grey pixel is in the center of the output\n    for sprite in sprites:\n        # Find the grey pixel\n        grey_pixel_x, grey_pixel_y = np.argwhere(sprite == Color.GREY)[0]\n\n        # Find the center of the output. We want the grey pixel to end up here.\n        center_x, center_y = output_grid.shape[0] // 2, output_grid.shape[1] // 2\n\n        # Calculate the offset to ensure the grey pixel ends up in the center of the output\n        x, y = center_x - grey_pixel_x, center_y - grey_pixel_y\n        \n        # Place the sprite into the output grid\n        blit_sprite(output_grid, sprite, x, y, background=Color.BLACK)\n\n    # Make the output as small as you can to contain all the objects\n    output_grid = crop(output_grid)\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a series of 3x3 objects, each of which has a great pixel at the center, and none of which overlap except for the grey pixels\n    sprites = []\n\n    # To make sure there is no overlap, we keep track of what pixels are already occupied\n    occupied = np.full((3, 3), False)\n\n    n_objects = np.random.randint(2, 4)\n    for _ in range(n_objects):\n        sprite = np.full((3, 3), Color.BLACK)\n        sprite[1, 1] = Color.GREY\n        other_color = random.choice([c for c in Color.NOT_BLACK if c != Color.GREY])\n\n        # Randomly pick a subset of valid pixels to color\n        # To be valid it has to be unoccupied and not grey (it will be black)\n        valid_pixels = np.argwhere(~occupied \u0026 (sprite == Color.BLACK))\n        if len(valid_pixels) == 0:\n            break\n\n        n_pixels = np.random.randint(1, len(valid_pixels) + 1)\n        pixels = valid_pixels[np.random.choice(len(valid_pixels), n_pixels, replace=False)]\n        for x, y in pixels:\n            sprite[x, y] = other_color\n            occupied[x, y] = True\n        \n        sprites.append(sprite)\n\n    # Place the sprites randomly on a medium sized canvas but make sure they don\u0027t touch each other\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((n, m), Color.BLACK)\n    for sprite in sprites:\n        x, y = random_free_location_for_sprite(grid, sprite, padding=2, padding_connectivity=8)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/21/images/test_input.png", "output": "output/seeds/seed_examples/21/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/21/images/train_input_0.png", "output": "output/seeds/seed_examples/21/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/21/images/train_input_1.png", "output": "output/seeds/seed_examples/21/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/21/images/train_input_2.png", "output": "output/seeds/seed_examples/21/images/train_output_2.png"}]}, "index": 21, "seed": "137eaa0f", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# decomposition, color change\n\n# description:\n# In the input you will see grey-colored regions on a medium sized black canvas. These regions are comprised of 2x2 squares and 1x3/3x1 rectangles, but this might be hard to see because regions might be touching.\n# To make the output, decompose the input into 2x2 squares and 1x3/3x1 rectangles, and color them as follows:\n# 1. Color teal the 2x2 squares\n# 2. Color red the 1x3/3x1 rectangles\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n\n    # Decompose the grid into non-overlapping grey regions\n    # We need a custom predicate because otherwise the regions are also allowed to include background pixels, and we want it all grey\n    decomposition = detect_objects(input_grid, background=Color.BLACK, colors=[Color.GREY],\n                                   allowed_dimensions=[(2, 2), (3, 1), (1, 3)], # 2x2 squares and 1x3/3x1 rectangles\n                                   predicate=lambda sprite: np.all(sprite == Color.GREY))\n\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    for obj in decomposition:\n        x, y, w, h = bounding_box(obj, background=Color.BLACK)\n        sprite = crop(obj, background=Color.BLACK)\n\n        # Color change based on dimensions: 2x2 -\u003e teal, 1x3/3x1 -\u003e red        \n        if w == 2 and h == 2:\n            sprite[sprite == Color.GREY] = Color.TEAL\n        elif (w == 3 and h == 1) or (w == 1 and h == 3):\n            sprite[sprite == Color.GREY] = Color.RED\n        else:\n            assert 0, \"Invalid object found\"\n        \n        # Copy the sprite back into the output grid\n        blit_sprite(output_grid, sprite, x, y, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    n_objects = np.random.randint(4, 8)\n\n    for _ in range(n_objects):\n        # Make a gray rectangle sprite\n        color = Color.GREY\n        w, h = random.choice([(2, 2), (3, 1), (1, 3)])\n        sprite = np.full((w, h), color)\n\n        # place it randomly on the grid, assuming we can find a spot\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        except:\n            continue\n\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/22/images/test_input.png", "output": "output/seeds/seed_examples/22/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/22/images/train_input_0.png", "output": "output/seeds/seed_examples/22/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/22/images/train_input_1.png", "output": "output/seeds/seed_examples/22/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/22/images/train_input_2.png", "output": "output/seeds/seed_examples/22/images/train_output_2.png"}]}, "index": 22, "seed": "150deff5", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# vertical lines, growing\n\n# description:\n# In the input you will see individual pixels sprinkled on a black background that are either red, green, or blue\n# Turn each red pixel into a vertical bar, and each green or blue pixel into a horizontal bar\n\ndef transform(input_grid):\n\n    # extract the pixels of each color\n    red_pixels = (input_grid == Color.RED)\n    green_pixels = (input_grid == Color.GREEN)\n    blue_pixels = (input_grid == Color.BLUE)\n\n    # prepare a blank output grid, because we don\u0027t need to reuse anything from the input (we\u0027re not drawing on top of the input)\n    output_grid = np.zeros_like(input_grid)\n\n    # turn red pixels into vertical bars\n    red_locations = np.argwhere(red_pixels)\n    for x, y in red_locations:\n        # vertical means the same X value\n        output_grid[x, :] = Color.RED\n    \n    # turn green and blue pixels into horizontal bars\n    green_locations = np.argwhere(green_pixels)\n    blue_locations = np.argwhere(blue_pixels)\n    for x, y in green_locations:\n        # horizontal means the same Y value\n        output_grid[:, y] = Color.GREEN\n    for x, y in blue_locations:\n        # horizontal means the same Y value\n        output_grid[:, y] = Color.BLUE\n    \n    return output_grid\n\n\n\ndef generate_input():\n    # make a black grid, of a random size\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # sprinkle some red, green, and blue pixels\n    num_red, num_green, num_blue = np.random.randint(1, 5), np.random.randint(1, 5), np.random.randint(1, 5)\n    for _ in range(num_red):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.RED\n    for _ in range(num_green):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.GREEN\n    for _ in range(num_blue):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        grid[x, y] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/23/images/test_input.png", "output": "output/seeds/seed_examples/23/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/23/images/train_input_0.png", "output": "output/seeds/seed_examples/23/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/23/images/train_input_1.png", "output": "output/seeds/seed_examples/23/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/23/images/train_input_2.png", "output": "output/seeds/seed_examples/23/images/train_output_2.png"}]}, "index": 23, "seed": "178fcbfb", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision detection, sliding objects, horizontal/vertical bars\n\n# description:\n# In the input you will see horizontal/vertical bars and individual coloured pixels sprinkled on a black background\n# Move each colored pixel to the bar that has the same colour until the pixel touches the bar.\n# If a colored pixel doesn\u0027t have a corresponding bar, it should be deleted.\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.zeros_like(input_grid)\n\n    # each object is either a bar or pixel, all uniform color\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # separate the bars from the pixels\n    bars, pixels = [], []\n    for obj in objects:\n        w, h = crop(obj).shape\n        if w == input_grid.shape[0] or h == input_grid.shape[1]:\n            bars.append(obj)\n        else:\n            pixels.append(obj)\n    \n    # copy the bars to the output grid\n    for bar in bars:\n        blit_object(output_grid, bar, background=Color.BLACK)\n    \n    # slide each pixel until it just barely touches the bar with the matching color\n    for pixel in pixels:\n        color = np.unique(pixel)[1]\n        matching_bars = [bar for bar in bars if np.unique(bar)[1] == color]\n\n        # if there is no matching bar, delete the pixel\n        if len(matching_bars) == 0:\n            continue\n\n        # consider sliding in the 4 cardinal directions, and consider sliding as far as possible\n        possible_displacements = [ (slide_distance*dx, slide_distance*dy)\n                                   for slide_distance in range(max(input_grid.shape))\n                                   for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)] ]\n        for dx, dy in possible_displacements:\n            new_pixel = translate(pixel, dx, dy, background=Color.BLACK)\n            if contact(object1=matching_bars[0], object2=new_pixel):\n                blit_object(output_grid, new_pixel, background=Color.BLACK)\n                break\n    \n    return output_grid\n\n\n\ndef generate_input() -\u003e np.ndarray:\n\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    \n    # separately generate canvas for bars and pixels, so that we can put the bars on top of the pixels\n    just_the_bars = np.zeros((n, m), dtype=int)\n    just_the_pixels = np.zeros((n, m), dtype=int)\n\n    n_bars = np.random.randint(1, 5)\n\n    # make sure that every bar has a different color\n    bar_colors = random.sample(Color.NOT_BLACK, n_bars)\n\n    horizontal_or_vertical = np.random.choice([\"horizontal\", \"vertical\"])\n    for bar in range(n_bars):\n        color = bar_colors[bar]\n\n        if horizontal_or_vertical == \"horizontal\":\n            x = np.random.randint(0, n)\n            just_the_bars[x, :] = color\n        else:\n            y = np.random.randint(0, m)\n            just_the_bars[:, y] = color\n\n        n_pixels = np.random.randint(1, 5)\n        for _ in range(n_pixels):\n            x, y = np.random.randint(0, n), np.random.randint(0, m)\n            just_the_pixels[x, y] = color\n\n    # sample a few pixels that aren\u0027t the same color as any of the bars\n    not_a_bar_color = set(Color.NOT_BLACK) - set(bar_colors)\n    n_distracter_pixels = np.random.randint(1, 5)\n    for _ in range(n_distracter_pixels):\n        x, y = np.random.randint(0, n), np.random.randint(0, m)\n        just_the_pixels[x, y] = np.random.choice(list(not_a_bar_color))\n\n    # put the bars on top of the pixels by copying them on top\n    grid = just_the_pixels.copy()\n    blit_object(grid, just_the_bars, background=Color.BLACK)\n    # Equivalent to:\n    # grid[just_the_bars != Color.BLACK] = just_the_bars[just_the_bars != Color.BLACK]\n    \n\n    return grid\n\n\n        \n\n\n\n\n\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/24/images/test_input.png", "output": "output/seeds/seed_examples/24/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/24/images/train_input_0.png", "output": "output/seeds/seed_examples/24/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/24/images/train_input_1.png", "output": "output/seeds/seed_examples/24/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/24/images/train_input_2.png", "output": "output/seeds/seed_examples/24/images/train_output_2.png"}]}, "index": 24, "seed": "1a07d186", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "import numpy as np\nfrom typing import *\nfrom common import *\n\n# concepts:\n# boolean logical operations, bitmasks with separator\n\n# description:\n# In the input you will see two maroon bitmasks separated by a blue vertical bar\n# To make the output, color teal the pixels that are not set in either bitmasks (logical NOR)\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Find the blue vertical bar. Vertical means constant X\n    for x_bar in range(input_grid.shape[0]):\n        if np.all(input_grid[x_bar, :] == Color.BLUE):\n            break\n\n    left_mask = input_grid[:x_bar, :]\n    right_mask = input_grid[x_bar+1:, :]\n\n    output_grid = np.zeros_like(left_mask)\n    output_grid[(left_mask != Color.MAROON) \u0026 (right_mask != Color.MAROON)] = Color.TEAL\n    \n    return output_grid\n\n\ndef generate_input() -\u003e np.ndarray:\n    # create a pair of equally sized maroon bitmasks\n    width, height = np.random.randint(2, 10), np.random.randint(2, 10)\n\n    grid1 = np.zeros((width, height), dtype=int)\n    grid2 = np.zeros((width, height), dtype=int)\n\n    for x in range(width):\n        for y in range(height):\n            grid1[x, y] = np.random.choice([Color.MAROON, Color.BLACK])\n            grid2[x, y] = np.random.choice([Color.MAROON, Color.BLACK])\n    \n    # create a blue vertical bar\n    bar = np.zeros((1, height), dtype=int)\n    bar[0, :] = Color.BLUE\n\n    grid = np.concatenate((grid1, bar, grid2), axis=0)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/25/images/test_input.png", "output": "output/seeds/seed_examples/25/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/25/images/train_input_0.png", "output": "output/seeds/seed_examples/25/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/25/images/train_input_1.png", "output": "output/seeds/seed_examples/25/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/25/images/train_input_2.png", "output": "output/seeds/seed_examples/25/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/25/images/train_input_3.png", "output": "output/seeds/seed_examples/25/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/25/images/train_input_4.png", "output": "output/seeds/seed_examples/25/images/train_output_4.png"}]}, "index": 25, "seed": "1b2d62fb", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry\n\n# description:\n# In the input you will see an image containing blue pixels that is almost rotationally symmetric, except that it is missing the section either north, south, east, or west that would make it rotationally symmetric\n# Color red all the pixels that would need to be colored in order to make the image rotationally symmetric (when rotating clockwise)\n\ndef transform(input_grid):\n\n    # The goal is to make the object rotationally symmetric, *not* to make the whole grid rotationally symmetric\n    # We have to extract the object from the grid and then rotate it to construct the missing section\n    blue_sprite = crop(input_grid)\n    rotated_blue_sprite = np.rot90(blue_sprite)\n    \n    # We need to find the optimal location for placing the rotated sprite\n    # This will make the resulting object radially symmetric\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            \n            test_grid = np.copy(input_grid)\n            blit_sprite(test_grid, rotated_blue_sprite, x, y, background=Color.BLACK)\n            test_blue_sprite = crop(test_grid)\n\n            # Check if the resulting object is radially symmetric\n            if np.array_equal(test_blue_sprite, np.rot90(test_blue_sprite)):\n                # Save what the input would look like if it were perfectly symmetric\n                perfectly_symmetric_grid = test_grid\n                break\n\n    # The missing section is the part of the input grid that would have been blue if it were perfectly symmetric\n    missing_pixels = np.where((input_grid == Color.BLACK) \u0026 (perfectly_symmetric_grid == Color.BLUE))\n\n    # Color the missing section red\n    output_grid = np.copy(input_grid)\n    output_grid[missing_pixels] = Color.RED\n\n    return output_grid\n\ndef transform(input_grid):\n    # This also works, and uses the library function `detect_rotational_symmetry``\n    \n    # Plan:\n    # 1. Detect the (x,y) point that the object is rotated around\n    # 2. Rotate each blue colored pixel around that point. If the rotated pixel is not colored, color it red.\n\n    output_grid = np.copy(input_grid)\n\n    # Find the symmetry\n    sym = detect_rotational_symmetry(input_grid, ignore_colors=[Color.BLACK], background=Color.BLACK)\n    \n    # Rotate the blues and color red as needed\n    blues = np.argwhere(input_grid == Color.BLUE)\n    for x, y in blues:\n        rotated_x, rotated_y = sym.apply(x, y, iters=1)        \n\n        if input_grid[rotated_x, rotated_y] == Color.BLACK:\n            output_grid[rotated_x, rotated_y] = Color.RED\n    \n    return output_grid\n\ndef generate_input():\n    # make a black medium large grid\n    n, m = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # make a blue radially symmetric sprite and put it at a random free location\n    sprite_size = np.random.randint(8, min(n, m))\n    sprite = random_sprite(sprite_size, sprite_size, symmetry=\u0027radial\u0027, color_palette=[Color.BLUE], density=0.2)\n    x, y = random_free_location_for_sprite(grid, sprite)\n\n    # remove a random section of the sprite to make it not radially symmetric\n    remove_length = np.random.randint(1, sprite_size//4)\n    quadrant = np.random.choice([\u0027north\u0027, \u0027south\u0027, \u0027east\u0027, \u0027west\u0027])\n    if quadrant == \u0027north\u0027:\n        sprite[sprite_size//2 - remove_length : sprite_size//2 + remove_length, : sprite_size//2] = Color.BLACK\n    elif quadrant == \u0027south\u0027:\n        sprite[sprite_size//2 - remove_length : sprite_size//2 + remove_length, sprite_size//2 :] = Color.BLACK\n    elif quadrant == \u0027east\u0027:\n        sprite[: sprite_size//2, sprite_size//2 - remove_length : sprite_size//2 + remove_length] = Color.BLACK\n    elif quadrant == \u0027west\u0027:\n        sprite[sprite_size//2 :, sprite_size//2 - remove_length : sprite_size//2 + remove_length] = Color.BLACK\n\n    blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/26/images/test_input.png", "output": "output/seeds/seed_examples/26/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/26/images/train_input_0.png", "output": "output/seeds/seed_examples/26/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/26/images/train_input_1.png", "output": "output/seeds/seed_examples/26/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/26/images/train_input_2.png", "output": "output/seeds/seed_examples/26/images/train_output_2.png"}]}, "index": 26, "seed": "1b60fb0c", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation\n\n# description:\n# In the input you will see a grid with two colored pixels.\n# To make the output, you should draw a pattern from the two pixels.\n# step 1: draw a horizontal line outward from the two pixels in their respective colours.\n# step 2: draw a border around the canvas whose top half is colored to match the top pixel and whose bottom half matches the bottom pixel.\n\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input and determine which pixel is top in which is bottom\n    # 2. Draw horizontal lines\n    # 3. Draw border, colored appropriately\n\n    # 1. Input parsing\n    # Detect the two pixels, sorting by Y coordinate so top one is first, bottom one is second\n    background = Color.BLACK\n    pixels = find_connected_components(input_grid, monochromatic=True, background=background)\n    pixels.sort(key=lambda obj: object_position(obj, background=background)[1])\n\n    # 2. Draw a horizontal lines outward pixels\n    output_grid = np.full_like(input_grid, background)\n    for pixel in pixels:\n        x, y = object_position(pixel, background=background)\n        color = object_colors(pixel, background=background)[0]\n        draw_line(output_grid, x=0, y=y, direction=(1, 0), color=color)\n    \n    # 3. Make a border colored appropriately\n    top_color = object_colors(pixels[0], background=background)[0]\n    bottom_color = object_colors(pixels[1], background=background)[0]\n    draw_line(output_grid, x=0, y=0, direction=(1, 0), color=top_color)\n    draw_line(output_grid, x=0, y=0, direction=(0, 1), color=top_color)\n    draw_line(output_grid, x=0, y=output_grid.shape[1] - 1, direction=(1, 0), color=bottom_color)\n    draw_line(output_grid, x=output_grid.shape[0] - 1, y=0, direction=(0, 1), color=bottom_color)\n    # Everything below the midline is bottom color, everything above is top color\n    # Recolor to enforce this\n    width, height = output_grid.shape\n    top = output_grid[:, :height//2]\n    top[top!=background] = top_color\n    bottom = output_grid[:, height//2:]\n    bottom[bottom!=background] = bottom_color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the grid, ensure the grid has an even height so that we can split it evenly between top and bottom\n    width, height = np.random.randint(10, 20, size=2)\n    while (height % 2 == 1):\n        width, height = np.random.randint(10, 20, size=2)\n    background = Color.BLACK\n    grid = np.full((width, height), background)\n\n    # Randomly choose two colors\n    colors = np.random.choice(Color.NOT_BLACK, size=2, replace=False)\n\n    # Randomly place the pixels so that one of them is the in the bottom half and the other in the top half\n    x1, x2 = np.random.choice(range(width), size=2, replace=False)\n    y1, y2 = np.random.randint(2, height//2-1), np.random.randint(height//2 + 1, height-2)\n    grid[x1, y1] = colors[0]\n    grid[x2, y2] = colors[1]\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/27/images/test_input.png", "output": "output/seeds/seed_examples/27/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/27/images/train_input_0.png", "output": "output/seeds/seed_examples/27/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/27/images/train_input_1.png", "output": "output/seeds/seed_examples/27/images/train_output_1.png"}]}, "index": 27, "seed": "1bfc4729", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alignment, objects\n\n# description:\n# In the input you will see a red, blue, and yellow shape. Each are the same shape (but different color). They occur left to right in the input grid on a black background, but at different vertical heights.\n# The output is the same as the input, but with the vertical heights of the red and yellow shapes adjusted to match the height of the blue shape.\n\ndef transform(input_grid):\n    # find the blue shape, red shape, and yellow shape\n    blue_coords = np.where(input_grid == Color.BLUE)\n    red_coords = np.where(input_grid == Color.RED)\n    yellow_coords = np.where(input_grid == Color.YELLOW)\n\n    # set the vertical height of the red and yellow shape to match\n    red_coords = (red_coords[0], blue_coords[1])\n    yellow_coords = (yellow_coords[0], blue_coords[1])\n\n    # make output grid with the colored shapes at their new locations\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    output_grid[blue_coords] = Color.BLUE\n    output_grid[red_coords] = Color.RED\n    output_grid[yellow_coords] = Color.YELLOW\n\n    return output_grid\n\n\ndef generate_input():\n\n    # All three shapes are the same shape, but different colors, so we generate one sprite and color it three ways\n    # We put each sprite in a different grid, and concatenate the grids to make the input grid\n\n    # make a random sprite of size (1-4)x(1-4)\n    w = np.random.randint(1, 5)\n    h = np.random.randint(1, 5)\n    sprite = random_sprite(w, h)\n\n    # Figure out the height of the output grid\n    # This has to be the same across all three colors, because we concatenate them along the x axis\n    grid_height = np.random.randint(h+1, 16)\n\n    # for each color,\n    # put a colored form of the shape in a random spot in a new grid\n    subgrids = []\n    for color in [Color.BLUE, Color.RED, Color.YELLOW]:\n        # make a grid to put the shape in\n        # the grid should be wide enough to fit the shape, which has width w\n        grid_width = np.random.randint(w, 30//3)\n        subgrid = np.full((grid_width, grid_height), Color.BLACK, dtype=int)\n\n        # make the shape that color\n        colored_sprite = np.copy(sprite)\n        colored_sprite[sprite != Color.BLACK] = color\n\n        # put the shape in a random spot in its grid\n        x, y = random_free_location_for_sprite(subgrid, colored_sprite)\n        blit_sprite(subgrid, colored_sprite, x, y)\n        subgrids.append(subgrid)\n\n    # now concatenate the subgrids along the x axis to make the input grid\n    grid = np.concatenate(subgrids, axis=0)\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/28/images/test_input.png", "output": "output/seeds/seed_examples/28/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/28/images/train_input_0.png", "output": "output/seeds/seed_examples/28/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/28/images/train_input_1.png", "output": "output/seeds/seed_examples/28/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/28/images/train_input_2.png", "output": "output/seeds/seed_examples/28/images/train_output_2.png"}]}, "index": 28, "seed": "1caeab9d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cropping\n\n# description:\n# In the input you will see a single colored shape, around 4x6 in size, floating in a 12x12 grid of black.\n# To make the output, crop the background out of the image - so the output grid has the same dimensions as the shape.\n\ndef transform(input_grid):\n    return crop(input_grid, background=Color.BLACK)\n\ndef generate_input():\n    # create a roughly 12x12 input grid\n    n = np.random.randint(10, 15)\n    m = np.random.randint(10, 15)\n    grid = np.full((n, m), Color.BLACK, dtype=int)\n\n    # create a small random sprite with shape (2-7)x(2-7)\n    w = np.random.randint(2, 8)\n    h = np.random.randint(2, 8)\n    sprite = random_sprite(w, h, color_palette=[np.random.choice(Color.NOT_BLACK)])\n\n    # blit the spite onto a random location on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x, y)\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/29/images/test_input.png", "output": "output/seeds/seed_examples/29/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/29/images/train_input_0.png", "output": "output/seeds/seed_examples/29/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/29/images/train_input_1.png", "output": "output/seeds/seed_examples/29/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/29/images/train_input_2.png", "output": "output/seeds/seed_examples/29/images/train_output_2.png"}]}, "index": 29, "seed": "1cf80156", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern reconstruction\n\n# description:\n# In the input you will see 9 squares seperated by 4 lines. The top-left square contains the original pattern.\n# Each square contains either a small portion of pattern or remains empty.\n# To make the output, you should detect the pattern on the top-left square and fill each square \n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)  \n\n    # Detect the color of the lines\n    for x, row in enumerate(output_grid):\n        # Find the line\n        all_equal = np.unique(row).size == 1\n        if all_equal:\n            line_color = row[0]\n            break\n    \n    # Get all the squares seperated by lines in the grid\n    squares = find_connected_components(grid=output_grid, background=line_color, monochromatic=False, connectivity=4)\n\n    # Get all squares\u0027 bounding box and cropped pattern\n    cropped_squares  = []\n    for obj in squares:\n        x, y, width, height = bounding_box(grid=obj, background=line_color)\n        square = crop(grid=obj, background=line_color)\n        cropped_squares.append({\u0027x\u0027: x, \u0027y\u0027: y, \u0027len\u0027: width, \u0027pattern\u0027: square})\n\n    # Sort the squares by their position\n    cropped_squares = sorted(cropped_squares, key=lambda x: (x[\u0027x\u0027], x[\u0027y\u0027]))\n\n    # The top-left square contains the original pattern\n    template_pattern = cropped_squares[0][\u0027pattern\u0027]\n    other_patterns = cropped_squares[1:]\n\n    # Fill the missing pattern compared to template square with line color\n    for square in other_patterns:\n        x, y = square[\u0027x\u0027], square[\u0027y\u0027]\n        square_pattern = square[\u0027pattern\u0027]\n\n        # Fill the missing pattern compared to template square with line color\n        for i, j in np.argwhere(template_pattern != Color.BLACK):\n            if template_pattern[i, j] != square_pattern[i, j]:\n                square_pattern[i, j] = line_color\n\n        # Place the reconstructed pattern on the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=square_pattern, x=x, y=y)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the base cofiguration of the grid seperated by chessboard lines\n    # Randomly select the size of the squares, create a 3x3 grid of squares\n    square_len = np.random.choice([5, 7, 9])\n    pattern_len = square_len - 2\n    square_num = 3\n\n    # Size of the grid is grid length plus line length\n    n, m = square_len * square_num + square_num - 1, square_len * square_num + square_num - 1\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select two colors for the lines and the pattern\n    colors = Color.NOT_BLACK.copy()\n    line_color = random.choice(colors)  \n    colors.remove(line_color)\n    pattern_color = random.choice(colors) \n\n    # Fill specific rows and columns with the line color\n    for i in range(square_len, n, square_len + 1):\n        draw_line(grid=grid, x=i, y=0, color=line_color, direction=(0, 1))\n        draw_line(grid=grid, x=0, y=i, color=line_color, direction=(1, 0))\n\n    # Create the pattern in the top-left square with the pattern color\n    template_sprite = random_sprite(n=pattern_len, m=pattern_len, color_palette=[pattern_color], connectivity=8, density=0.5)\n\n    # Fill the top-left square with the original pattern\n    # Fill the other regions with corrupted versions that have pixels randomly set to black\n    for i in range(0, n, square_len + 1):\n        for j in range(0, m, square_len + 1):\n            # are we the top-left region?\n            if i == 0 and j == 0:\n                blit_sprite(grid, template_sprite, i + 1, j + 1)\n                continue\n\n            # otherwise: Create a corrupted version of the pattern; randomly set some pixels to black\n            corrupted_sprite = template_sprite.copy()\n            for x, y in np.argwhere(corrupted_sprite != Color.BLACK):\n                if random.choice([0, 1]) == 0:\n                    corrupted_sprite[x, y] = Color.BLACK\n            # Place the sprite on the grid, remain a black border around the sprite\n            blit_sprite(grid, corrupted_sprite, i + 1, j + 1)  \n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/30/images/test_input.png", "output": "output/seeds/seed_examples/30/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/30/images/train_input_0.png", "output": "output/seeds/seed_examples/30/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/30/images/train_input_1.png", "output": "output/seeds/seed_examples/30/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/30/images/train_input_2.png", "output": "output/seeds/seed_examples/30/images/train_output_2.png"}]}, "index": 30, "seed": "1e32b0e9", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alignment, copy to object border\n\n# description:\n# In the input you will see a teal object on a black background, and several colored pixels on the border of canvas.\n# To make the output grid, you should copy the colored pixels horizontally/vertically so that they are just barely overlapping/colliding with the teal object.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the teal object\n    # 2. Detect the colored pixels on the border\n    # 3. Slide the colored pixels in the 4 cardinal directions until we find how to make them overlapping with the teal object\n\n    output_grid = np.copy(input_grid)\n\n    # Detects the rectangle in the input grid that is TEAL\n    teal_objects = detect_objects(grid=input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=4)\n    \n    # There should only be one rectangle of the color TEAL has been detected in the grid.\n    assert len(teal_objects) == 1\n    teal_object = teal_objects[0]\n\n    # colored pixels are NOT black and NOT TEAL.\n    colors_except_teal = [c for c in Color.NOT_BLACK if c != Color.TEAL]\n    \n    # Detects all other colored pixels in the grid \n    pixels = detect_objects(grid=input_grid,\n                            # Exclude teal from the search\n                            colors=colors_except_teal, \n                            # only consider single pixels\n                            allowed_dimensions=[(1,1)], \n                            monochromatic=True, connectivity=4)\n\n    # Copy the colored pixels to the teal object by moving them either vertically or horizontally.\n    for pixel in pixels:\n        # consider translating the pixel in the 4 cardinal directions, and consider translating as far as possible\n        possible_displacements = [ (slide_distance*dx, slide_distance*dy)\n                                   # We could slide as far as the maximum grid extent\n                                   for slide_distance in range(max(input_grid.shape))\n                                   # (dx, dy) ranges over 4 cardinal directions\n                                   for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)] ]\n        for dx, dy in possible_displacements:\n            # check if the objects are colliding/overlapping after translating\n            translated_pixel = translate(pixel, dx, dy, background=Color.BLACK)\n            if collision(object1=teal_object, object2=translated_pixel):\n                # put the red object where it belongs\n                blit_object(output_grid, translated_pixel, background=Color.BLACK)\n                break\n    \n    return output_grid\n\n\ndef generate_input():\n    # Initialize a 10x10 grid representing a black background.\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Randomly determine the width and height of the TEAL rectangle between 2 and 5.\n    width, height = np.random.randint(2, 6), np.random.randint(2, 6)\n    teal_sprite = np.full((width, height), Color.TEAL)\n\n    # Find a free location for this sprite and blit it to the grid\n    x, y = random_free_location_for_sprite(grid, teal_sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, teal_sprite, x, y, background=Color.BLACK)\n\n    # list to hold the available positions, which are all on the border of the canvas\n    border_locations = [ (0, y) for y in range(n) ] + [ (m-1, y) for y in range(n) ] + [ (x, 0) for x in range(1, m-1) ] + [ (x, n-1) for x in range(1, m-1) ]\n    \n    # Put a random number of colored pixels on the border of the canvas\n    for _ in range(np.random.randint(3, 8)):\n        # Pick a random location on the border\n        x, y = random.choice(border_locations)\n        # Pick a random color that is not black or teal\n        color = random.choice([c for c in Color.NOT_BLACK if c != Color.TEAL])\n\n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/31/images/test_input.png", "output": "output/seeds/seed_examples/31/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/31/images/train_input_0.png", "output": "output/seeds/seed_examples/31/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/31/images/train_input_1.png", "output": "output/seeds/seed_examples/31/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/31/images/train_input_2.png", "output": "output/seeds/seed_examples/31/images/train_output_2.png"}]}, "index": 31, "seed": "1f642eb9", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting\n\n# description:\n# In the input you will see multiple 2x2 blue squares, multiple 2x2 red squares, and some red or blue dots sprinkled about.\n# To make the output, fill a 1x5 grid with blue pixels from left to right for each 2x2 blue square in the input (counting the number of blue 2x2 squares).\n\ndef transform(input_grid):\n    # make a counter to count the number of blue squares\n    blue_square_count = 0\n\n    # scan the grid for blue squares and count them up\n    for x in range(input_grid.shape[0]-1):\n        for y in range(input_grid.shape[1]-1):\n            if input_grid[x,y] == input_grid[x+1,y] == input_grid[x,y+1] == input_grid[x+1,y+1] == Color.BLUE:\n                blue_square_count += 1\n    \n    # make a 1x5 output grid\n    output_grid = np.zeros((5,1), dtype=int)\n\n    # add the number of blue squares to the array from left to right with each pixel representing one blue block\n    output_grid[:blue_square_count, :] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # make 9x9 black background grid first\n    n = m = 9\n    grid = np.zeros((n,m), dtype=int)\n\n    # make a random number of blue square sprites and place them at random places on the grid but don\u0027t have them touch\n    blue_square = np.full((2,2), Color.BLUE, dtype=int)\n    for _ in range(np.random.randint(2,6)):\n        x, y = random_free_location_for_sprite(grid, blue_square)\n        if not contact(object1=grid, object2=blue_square, x2=x, y2=y): # only place new squares that won\u0027t touch old ones\n          blit_sprite(grid, blue_square, x, y)\n    \n    # make a random number of red square sprites and place them at random places on the grid but don\u0027t have them touch\n    red_square = np.full((2,2), Color.RED, dtype=int)\n    for _ in range(np.random.randint(2,6)):\n        x, y = random_free_location_for_sprite(grid, red_square)\n        if not contact(object1=grid, object2=red_square, x2=x, y2=y): # only place new squares that won\u0027t touch old ones\n          blit_sprite(grid, red_square, x, y)\n        \n    # make a random number of blue pixel sprites and place them at random places on the grid\n    blue_pixel = random_sprite(1, 1, density=1, color_palette=[Color.BLUE])\n    for _ in range(np.random.randint(4)):\n        x, y = random_free_location_for_sprite(grid, blue_pixel)\n        blit_sprite(grid, blue_pixel, x, y)\n\n    # make a random number of red pixel sprites and place them at random places on the grid\n    red_pixel = random_sprite(1, 1, density=1, color_palette=[Color.RED])\n    for _ in range(np.random.randint(4)):\n        x, y = random_free_location_for_sprite(grid, red_pixel)\n        blit_sprite(grid, red_pixel, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/32/images/test_input.png", "output": "output/seeds/seed_examples/32/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/32/images/train_input_0.png", "output": "output/seeds/seed_examples/32/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/32/images/train_input_1.png", "output": "output/seeds/seed_examples/32/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/32/images/train_input_2.png", "output": "output/seeds/seed_examples/32/images/train_output_2.png"}]}, "index": 32, "seed": "1fad071e", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# proximity, color change, horizontal/vertical bars\n\n# description:\n# In the input you will see a pair of lines on the edge of the canvas that are either horizontal or vertical, and also green pixels randomly placed in between the lines\n# Change the color of each green pixel to match the color of the line it is closest to\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # find the two lines by removing the green pixels\n    lines = np.copy(input_grid)\n    lines[input_grid == Color.GREEN] = Color.BLACK\n\n    # lines now contains only the lines, which are going to be used to assign color to the green pixels\n    output_grid = np.copy(input_grid)\n\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] == Color.GREEN:\n                # find the closest point on the lines\n                closest_x, closest_y = min([(i, j) for i in range(input_grid.shape[0]) for j in range(input_grid.shape[1]) if lines[i, j] != Color.BLACK],\n                                           key=lambda p: abs(p[0] - x) + abs(p[1] - y))\n                color_of_closest_line = lines[closest_x, closest_y]\n                output_grid[x, y] = color_of_closest_line\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # make a black grid first as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # sprinkle green pixels randomly\n    for green_index in range(random.randint(5, 20)):\n        x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n        grid[x, y] = Color.GREEN\n\n    # decide on a pair of colors for the horizontal/vertical lines\n    line_colors = random.sample([color for color in Color.ALL_COLORS if color != Color.GREEN and color != Color.BLACK], 2)\n\n    # flip a coin to decide whether it is horizontal or vertical\n    is_horizontal = random.choice([True, False])\n    if is_horizontal:\n        grid[:, 0] = line_colors[0]\n        grid[:, -1] = line_colors[1]\n    else:\n        grid[0, :] = line_colors[0]\n        grid[-1, :] = line_colors[1]\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/33/images/test_input.png", "output": "output/seeds/seed_examples/33/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/33/images/train_input_0.png", "output": "output/seeds/seed_examples/33/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/33/images/train_input_1.png", "output": "output/seeds/seed_examples/33/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/33/images/train_input_2.png", "output": "output/seeds/seed_examples/33/images/train_output_2.png"}]}, "index": 33, "seed": "2204b7a8", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# holes, objects, distracters, topology, puzzle piece\n\n# description:\n# In the input you will see multiple grey rectangular objects, each with a black hole inside of it. There are also monochromatic objects somewhere exactly the same shape as each hole, and random other distracter objects (distracters all the same color). \n# To make the output, check to see if each non-distracter object perfectly fits inside the black hole inside of a gray object, like it is a puzzle piece. If it does, place it inside the black hole. If it doesn\u0027t, leave it where it is.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input into objects, sprites, and black holes inside the grey objects\n    # 2. Identify color of distracter objects.\n    # 3. Turn each object into a sprite\n    # 4. Check if each sprite can be moved into a black hole, and if so, move it there\n    \n    # Parse, separating greys from other objects\n    grey_input = input_grid.copy()\n    grey_input[input_grid != Color.GREY] = Color.BLACK\n    grey_objects = find_connected_components(grey_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # extracting a mask for the black region is tricky, because black is also the color of the background\n    # get the black region inside the object by getting the interior mask, then just the black pixels\n    interior_black_regions = [ object_interior(obj, background=Color.BLACK) \u0026 (obj == Color.BLACK)\n                               for obj in grey_objects ]\n\n    not_grey_input = input_grid.copy()\n    not_grey_input[input_grid == Color.GREY] = Color.BLACK\n    not_grey_objects = find_connected_components(not_grey_input, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Get the sprites\n    not_grey_sprites = [ crop(obj, background=Color.BLACK) for obj in not_grey_objects ]\n\n    # Get the color of the distracter objects\n    # This is the most common color of the non-grey objects\n    color_of_each_object = [ np.unique(obj[obj!=Color.BLACK])[0] for obj in not_grey_objects ]\n    distracter_color = max(set(color_of_each_object), key=color_of_each_object.count)\n    \n    # Check if each sprite perfectly fits in a black hole/black interior region\n    # do this by checking if it has the same shape as a black interior region\n    # if it does, place it there\n    output_grid = np.copy(input_grid)\n    for sprite, obj, color in zip(not_grey_sprites, not_grey_objects, color_of_each_object):\n        # Try to find a perfect fit (if it is not the distracter color)\n        if color == distracter_color:\n            continue\n        \n        for interior_obj_mask in interior_black_regions:\n            # check the sprite masks are the same, meaning that they have the same shape\n            # to convert a sprite to a mask you check if it is not background (black)\n            sprite_mask = sprite != Color.BLACK\n            # to convert an object to a spright you crop it\n            interior_sprite_mask = crop(interior_obj_mask, background=Color.BLACK)\n            perfect_fit = np.array_equal(sprite_mask, interior_sprite_mask)\n\n            if perfect_fit:\n                # remove the object from its original location\n                object_mask = obj != Color.BLACK\n                output_grid[object_mask] = Color.BLACK\n\n                # place the sprite in the black hole by blitting it\n                interior_x, interior_y, interior_width, interior_height = bounding_box(interior_obj_mask)\n                blit_sprite(output_grid, sprite, interior_x, interior_y, background=Color.BLACK)\n                break\n\n    return output_grid            \n    \n    \n\n\ndef generate_input():\n    n, m = np.random.randint(10, 25, size=2)\n    input_grid = np.full((n, m), Color.BLACK)\n\n    distracter_color = np.random.choice(Color.NOT_BLACK)\n\n    n_grey_objects = np.random.randint(1, 3)\n    for k in range(n_grey_objects):\n        grey_width, grey_height = np.random.randint(5, 8, size=2)\n        grey_sprite = np.full((grey_width, grey_height), Color.GREY)\n\n        # make a black hole in the grey object\n        # the black hole should be a sprite whole primary color is black, and whose background color is grey\n        # it should be smaller than the grey object\n        hole_width, hole_height = np.random.randint(1, grey_width-2), np.random.randint(1, grey_height-2)\n        hole_sprite = random_sprite(hole_width, hole_height, color_palette=[Color.BLACK], background=Color.GREY, symmetry=\"not_symmetric\")\n        hole_x, hole_y = random_free_location_for_sprite(grey_sprite, hole_sprite, border_size=1, background=Color.GREY)\n        blit_sprite(grey_sprite, hole_sprite, hole_x, hole_y, background=Color.GREY)\n\n        # place the grey object in the input grid\n        x, y = random_free_location_for_sprite(input_grid, grey_sprite, padding=1, border_size=1)\n        blit_sprite(input_grid, grey_sprite, x, y, background=Color.BLACK)\n\n        # each hole has a corresponding colored object somewhere on the grid waiting for it with the same shape as the whole\n        # this is going to have the perfect fit, so it needs to have the same mask as the hole but a different color (but not the special colors of gray or the distracter)\n        color = np.random.choice([c for c in Color.NOT_BLACK if c != Color.GREY and c != distracter_color])\n        object_sprite = np.full((hole_width, hole_height), Color.BLACK)\n        object_sprite[hole_sprite == Color.BLACK] = color\n\n        # place the object sprite in the input grid\n        x, y = random_free_location_for_sprite(input_grid, object_sprite, padding=1, border_size=1)\n        blit_sprite(input_grid, object_sprite, x, y, background=Color.BLACK)\n\n    # place small distracter objects\n    n_distracter_objects = np.random.randint(5, 10)\n    for k in range(n_distracter_objects):\n        distracter_width, distracter_height = np.random.randint(1, 3, size=2)\n        distracter_sprite = random_sprite(distracter_width, distracter_height, color_palette=[distracter_color], background=Color.BLACK)\n        x, y = random_free_location_for_sprite(input_grid, distracter_sprite, padding=1)\n        blit_sprite(input_grid, distracter_sprite, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/34/images/test_input.png", "output": "output/seeds/seed_examples/34/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/34/images/train_input_0.png", "output": "output/seeds/seed_examples/34/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/34/images/train_input_1.png", "output": "output/seeds/seed_examples/34/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/34/images/train_input_2.png", "output": "output/seeds/seed_examples/34/images/train_output_2.png"}]}, "index": 34, "seed": "228f6490", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, intersection\n\n# description:\n# In the input, you will see a grid with a single orange pixel and a single teal pixel.\n# To make the output, draw an orange vertical line and an orange horizontal line that intersect at the orange pixel, and draw a teal vertical line and a teal horizontal line that intersect at the teal pixel. The lines should go from edge to edge of the grid.\n# Lastly, draw a red pixel where the teal and orange lines intersect.\n\ndef transform(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # get the index of the orange pixel\n    orange = np.where(input_grid == Color.ORANGE)\n    x, y = orange[0][0], orange[1][0]\n\n    # get the index of the teal pixel\n    teal = np.where(input_grid == Color.TEAL)\n    x2, y2 = teal[0][0], teal[1][0]\n\n    # draw lines from one edge of the grid through the orange and teal pixels and across to the other edge of the grid:\n    # draw orange vertical line\n    output_grid[x, :] = Color.ORANGE # Can also use draw_line(output_grid, x, 0, length=None, color=Color.ORANGE, direction=(0, 1))\n    # draw orange horizontal line\n    output_grid[:, y] = Color.ORANGE # Can also use draw_line(output_grid, 0, y, length=None, color=Color.ORANGE, direction=(1, 0))\n    # draw teal vertical line\n    output_grid[x2, :] = Color.TEAL # Can also use draw_line(output_grid, x2, 0, length=None, color=Color.TEAL, direction=(0, 1))\n    # draw teal horizontal line\n    output_grid[:, y2] = Color.TEAL # Can also use draw_line(output_grid, 0, y2, length=None, color=Color.TEAL, direction=(1, 0))\n    \n\n    # draw both intersection points\n    output_grid[x, y2] = Color.RED\n    output_grid[x2, y] = Color.RED\n\n    return output_grid\n\ndef generate_input():\n    # make a 9x9 black grid for the background\n    n = m = 9\n    grid = np.zeros((n,m), dtype=int)\n\n    # put an orange pixel at a random point on the grid\n    x, y = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x,y] = Color.ORANGE\n\n    # put a teal pixel at a random point on the grid but not in the same row or column as the orange pixel\n    x2, y2 = np.random.randint(0, n), np.random.randint(0, m)\n    while x2 == x or y2 == y:\n        x2, y2 = np.random.randint(0, n), np.random.randint(0, m)\n    grid[x2,y2] = Color.TEAL\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/35/images/test_input.png", "output": "output/seeds/seed_examples/35/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/35/images/train_input_0.png", "output": "output/seeds/seed_examples/35/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/35/images/train_input_1.png", "output": "output/seeds/seed_examples/35/images/train_output_1.png"}]}, "index": 35, "seed": "23581191", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connectivity\n\n# description:\n# In the input image you will see several teal pixels and two 2x2 red squares on the black background.\n# If the 2x2 red squares are connected by a path of teal pixels, then output a 1x1 teal grid, otherwise, output a 1x1 black grid. \n\ndef transform(input_grid):\n    # make output grid\n    output_grid = np.zeros((1,1), dtype=int)\n\n    # get just the red squares\n    red_squares = np.zeros_like(input_grid)\n    red_squares[input_grid == Color.RED] = Color.RED\n\n    # get all components that are connected, regardless of color\n    connected_components = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n\n    # check each connected component to see if it contains both red squares\n    for connected_component in connected_components:\n        # if it contains both red squares, output teal grid\n        if np.all(connected_component[red_squares == Color.RED] == Color.RED):         \n            output_grid[:,:] = Color.TEAL\n            return output_grid\n\n    # if none of the connected components contain both red squares, output black grid\n    output_grid[:,:] = Color.BLACK\n    return output_grid\n\n\ndef generate_input():\n    # make a black grid first as background\n    n, m = np.random.randint(5, 10), np.random.randint(5, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # make a 2x2 red square sprite\n    red_square_sprite = np.full((2,2), Color.RED, dtype=int)\n\n    # place a red square sprite at two random places on the grid\n    x1, y1 = random_free_location_for_sprite(grid, red_square_sprite, padding=1)\n    blit_sprite(grid, red_square_sprite, x1, y1)\n    x2, y2 = random_free_location_for_sprite(grid, red_square_sprite, padding=1)\n    blit_sprite(grid, red_square_sprite, x2, y2)\n\n    # check that the red squares do not touch\n    # if they do, then try again\n    if contact(object1=red_square_sprite, object2=red_square_sprite, x1=x1, y1=y1, x2=x2, y2=y2):\n        return generate_input()\n\n    # sprinkle teal pixels over the black parts of the grid so they cover roughly a third of it\n    for _ in range(n * m // 3):\n        x, y = random.randint(0, n - 1), random.randint(0, m - 1)\n        # do not sprinkle teal pixels on top of red ones\n        if grid[x, y] != Color.RED:\n            grid[x, y] = Color.TEAL\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/36/images/test_input.png", "output": "output/seeds/seed_examples/36/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/36/images/train_input_0.png", "output": "output/seeds/seed_examples/36/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/36/images/train_input_1.png", "output": "output/seeds/seed_examples/36/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/36/images/train_input_2.png", "output": "output/seeds/seed_examples/36/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/36/images/train_input_3.png", "output": "output/seeds/seed_examples/36/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/36/images/train_input_4.png", "output": "output/seeds/seed_examples/36/images/train_output_4.png"}, {"input": "output/seeds/seed_examples/36/images/train_input_5.png", "output": "output/seeds/seed_examples/36/images/train_output_5.png"}]}, "index": 36, "seed": "239be575", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, growing, pixel manipulation\n\n# description:\n# In the input you will see a small multicolor object, and a few big rectangles. Each rectangle has a few colored pixels sprinkled inside it. The background is NOT black.\n# To make the output:\n# 1. Remove the small object from the input\n# 2. Place copies of the small object centered on top of the colored pixels sprinkled inside the rectangles\n# 3. The small object has pointy things sticking out of it. Extend each pointy thing outward until it hits the edge of the rectangle\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Figure out the background color. Replace it with black (we\u0027ll swap it back later)\n    # 2. Find the small object and delete it\n    # 3. Identify the pointy things sticking out of the small sprite, and what their displacement vectors are\n    # 4. For each rectangle, find the colored pixels inside it, put copies and extend the pointy things\n\n    # For these inputs, background color is the most common color\n    background_color = np.argmax(np.bincount(input_grid.flatten()))\n    # Replace the background color with black\n    input_grid[input_grid == background_color] = Color.BLACK\n\n    # 2. Find the small object and delete it\n    objects = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    smallest_object = min(objects, key=lambda x: np.count_nonzero(x))\n    input_grid[smallest_object != Color.BLACK] = Color.BLACK    \n\n    # Crop the object to get its sprite, and then decide if something is pointing:\n    # Pointy means a pixel on the edge with its other edge-neighbors black\n    sprite = crop(smallest_object)\n    pointy_positions = get_points(sprite)    \n    \n    # 4. For each rectangle, find the colored pixels inside it, put copies and extend the pointy things\n    output_grid = np.copy(input_grid)\n    rectangles = find_connected_components(input_grid, monochromatic=False, connectivity=8)\n    for rectangle in rectangles:\n        # Figure out the most common color of the rectangle (apart from black, which is the background)\n        main_rectangle_color = max(Color.NOT_BLACK, key=lambda x: np.count_nonzero(rectangle == x))\n        colored_pixels = np.where((rectangle != Color.BLACK) \u0026 (rectangle != main_rectangle_color))\n        for x, y in zip(*colored_pixels):\n            # Place a copy of the sprite centered on the colored pixel. If any of the sprite goes out of bounds, crop it to the legal region (inside the rectangle)\n            blit_sprite(output_grid, sprite, x - sprite.shape[0]//2, y - sprite.shape[1]//2, background=Color.BLACK)\n            # bounds check accomplished by overwriting with black\n            output_grid[input_grid == Color.BLACK] = Color.BLACK\n\n            \n            for point_x, point_y in pointy_positions:                \n                # Extend the pointy things\n                # Get the direction and color of the pointy thing, relative to the sprite\n                dx, dy = np.sign([point_x - sprite.shape[0]//2, point_y - sprite.shape[1]//2])\n                dx, dy = int(dx), int(dy)\n                color = sprite[point_x, point_y]\n                draw_line(output_grid, x + dx, y + dy, length=None, direction=(dx, dy), color=color, stop_at_color=[Color.BLACK])\n\n\n    # Swap the background color back\n    output_grid[output_grid == Color.BLACK] = background_color\n\n    return output_grid\n\ndef get_points(sprite):\n    \"\"\"\n    Returns the positions of the pointy things sticking out of the sprite.\n    Something is pointy if it is on the edge the sprite, and both of its neighboring edge pixels are black\n    \"\"\"\n    edge_indices = get_edge_indices(sprite)\n    next_neighbor, previous_neighbor = edge_indices[1:] + edge_indices[:1], edge_indices[-1:] + edge_indices[:-1]\n    pointy_positions = [ (x, y) for (x, y), (next_x, next_y), (prev_x, prev_y) in zip(edge_indices, next_neighbor, previous_neighbor)\n                         if sprite[x, y] != Color.BLACK and sprite[next_x, next_y] == Color.BLACK and sprite[prev_x, prev_y] == Color.BLACK ]\n    return pointy_positions\n\ndef get_edge_indices(sprite):\n    \"\"\"Returns a list of all the (i,j) locations of the edge pixels\"\"\"\n    edge_indices = [ (x, 0) for x in range(sprite.shape[0]) ]\n    edge_indices.extend([ (sprite.shape[0]-1, y) for y in range(1, sprite.shape[1]) ])\n    edge_indices.extend([ (x, sprite.shape[1]-1) for x in range(sprite.shape[0]-2, -1, -1) ])\n    edge_indices.extend([ (0, y) for y in range(sprite.shape[1]-2, 0, -1) ])\n    return edge_indices\n\ndef generate_input():\n    background_color = random.choice(Color.NOT_BLACK)\n    rectangle_color = random.choice([color for color in Color.NOT_BLACK if color != background_color])\n    marker_color = random.choice([color for color in Color.NOT_BLACK if color != background_color and color != rectangle_color])\n\n    # Make the sprite, and then add pointy things to it\n    w, h = random.choice([2, 3]), random.choice([2,3])\n    sprite = random_sprite(w, h, symmetry=\"not_symmetric\",\n                            color_palette=[color for color in Color.NOT_BLACK if color not in [background_color, rectangle_color, marker_color]])\n    # put a ring of black pixels around the sprite and then color some of them to be pointing\n    sprite = np.pad(sprite, 1, constant_values=Color.BLACK)\n    w, h = sprite.shape\n    possible_pointy_positions = [ (w//2, 0), (w-1, h//2), (w//2, h-1), (0, h//2) ]\n    pointy_positions = random.sample(possible_pointy_positions, np.random.randint(1, 4))\n    for x, y in pointy_positions:\n        sprite[x, y] = random.choice([color for color in Color.NOT_BLACK if color not in [background_color, rectangle_color, marker_color]])\n    sprite = crop(sprite)\n    \n    # Make the grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), Color.BLACK)\n    \n    # Make the rectangles\n    n_rectangles = random.choice([1, 2])\n    for _ in range(n_rectangles):\n        w, h = np.random.randint(n//3, 2*n//3), np.random.randint(m//3, 2*m//3)\n        rectangle_sprite = np.full((w, h), rectangle_color)\n        # sprinkle some colored pixels\n        for _ in range(random.choice([1, 2, 3])):\n            x, y = np.random.randint(1, w-1), np.random.randint(1, h-1)\n            rectangle_sprite[x, y] = marker_color\n        x, y = random_free_location_for_sprite(grid, rectangle_sprite, padding=1, padding_connectivity=8)\n        blit_sprite(grid, rectangle_sprite, x, y)\n\n    # Place the sprite in the grid\n    x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n    blit_sprite(grid, sprite, x, y)\n\n    # Change the background\n    grid[grid == Color.BLACK] = background_color\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/37/images/test_input.png", "output": "output/seeds/seed_examples/37/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/37/images/train_input_0.png", "output": "output/seeds/seed_examples/37/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/37/images/train_input_1.png", "output": "output/seeds/seed_examples/37/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/37/images/train_input_2.png", "output": "output/seeds/seed_examples/37/images/train_output_2.png"}]}, "index": 37, "seed": "264363fd", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n\n# concepts:\n# patterns, horizontal bars\n\n# description:\n# In the input you will see a colored pattern in a 3x3 grid.\n# For each row of the input, if that row is a single color, color that row in the output grey. Otherwise, output black.\n\ndef transform(input_grid):\n    # get input grid shape\n    n, m = input_grid.shape\n\n    # get output grid ready\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # look at each row of the input grid\n    for y in range(m):\n        # check if each pixel in the row is the same color\n        base_color = input_grid[0][y]\n        all_same_color = True\n        for color in input_grid[1:, y]:\n            if color != base_color:\n                all_same_color = False\n\n        # if they are all the same color, change the output row to grey\n        if all_same_color:\n            for x in range(n):\n                output_grid[x][y] = Color.GREY\n\n    return output_grid\n\ndef generate_input():\n    # create a 3x3 array of randomly chosen, non-black, colors\n    grid = np.random.choice(Color.NOT_BLACK, size=(3, 3))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/38/images/test_input.png", "output": "output/seeds/seed_examples/38/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/38/images/train_input_0.png", "output": "output/seeds/seed_examples/38/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/38/images/train_input_1.png", "output": "output/seeds/seed_examples/38/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/38/images/train_input_2.png", "output": "output/seeds/seed_examples/38/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/38/images/train_input_3.png", "output": "output/seeds/seed_examples/38/images/train_output_3.png"}]}, "index": 38, "seed": "25d8a9c8", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n\n# concepts:\n# sliding objects\n\n# description:\n# In the input you will see a 3x3 grid with a contiguous shape on it.\n# Slide the shape down by one pixel.\n\ndef transform(input_grid):\n    # find the connected component, which is a monochromatic object\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    obj = objects[0]\n\n    # translate the object down by one pixel\n    output_grid = translate(obj, 0, 1, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # first create blank grid\n    grid = np.zeros((3, 3), dtype=int)\n\n    # while the grid is empty\n    while grid.sum() == 0:\n\n        # generate a random up to 3x3 sprite\n        n = random.randint(1, 3)\n        m = random.randint(1, 2)\n        random_sprite_to_add = random_sprite(n, m, symmetry=\u0027not_symmetric\u0027, color_palette=[random.choice(Color.NOT_BLACK)])\n\n        # choose a random location on the grid, ensuring the bottom row is empty\n        x = random.randint(0, 2)\n        y = random.randint(0, 2 - m)\n\n        # place the sprite onto the grid\n        blit_sprite(grid, random_sprite_to_add, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/39/images/test_input.png", "output": "output/seeds/seed_examples/39/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/39/images/train_input_0.png", "output": "output/seeds/seed_examples/39/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/39/images/train_input_1.png", "output": "output/seeds/seed_examples/39/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/39/images/train_input_2.png", "output": "output/seeds/seed_examples/39/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/39/images/train_input_3.png", "output": "output/seeds/seed_examples/39/images/train_output_3.png"}]}, "index": 39, "seed": "25ff71a9", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern, repetition, spiral\n\n# description:\n# In the input you will see an empty black grid.\n# To make the output, you should draw a spiral pattern of green pixels starting from the top left corner and going to the right.\n\ndef transform(input_grid):\n    # get the grid size\n    width, height = input_grid.shape\n\n    # start from the top left corner of the grid\n    x, y = 0, 0\n    output_grid = input_grid.copy()\n    output_grid[x, y] = Color.GREEN\n\n    # we define our initial direction as going to the right, which is (1, 0)\n    direction = (1, 0)\n\n    # we also make a helper function to turn the direction clockwise\n    def turn_clockwise(direction):\n        if direction[0] == 0:\n            return -direction[1], 0\n        return 0, direction[0]\n\n    # continue spiralling until we cannot anymore\n    while True:\n        # First, check if we hit the border, if so, we turn clockwise\n        if x + direction[0] \u003e= width or y + direction[1] \u003e= height or x + direction[0] \u003c 0 or y + direction[1] \u003c 0:\n            direction = turn_clockwise(direction)\n            continue\n\n        # Then, check if the square after the current one is green, if so,\n        # we are already spiralling, so stop here\n        if output_grid[x + direction[0], y + direction[1]] == Color.GREEN:\n            break\n\n        # Last, check if the square after the current one is green, if so, we turn clockwise\n        # We do this to draw the spiral pattern\n        if (0 \u003c= x + 2 * direction[0] \u003c width and 0 \u003c= y + 2 * direction[1] \u003c height \n            and output_grid[x + 2 * direction[0], y + 2 * direction[1]] == Color.GREEN):\n            direction = turn_clockwise(direction)\n            continue\n        \n        # then we move to the next square and color it green\n        x += direction[0]\n        y += direction[1]\n        output_grid[x, y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # first create a randomly sized grid, somewhere between 5x5 and 20x20\n    length = random.randint(5, 20)\n    grid = np.full((length, length), Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/40/images/test_input.png", "output": "output/seeds/seed_examples/40/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/40/images/train_input_0.png", "output": "output/seeds/seed_examples/40/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/40/images/train_input_1.png", "output": "output/seeds/seed_examples/40/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/40/images/train_input_2.png", "output": "output/seeds/seed_examples/40/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/40/images/train_input_3.png", "output": "output/seeds/seed_examples/40/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/40/images/train_input_4.png", "output": "output/seeds/seed_examples/40/images/train_output_4.png"}]}, "index": 40, "seed": "28e73c20", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, dividers, filling\n\n# description:\n# In the input you will see grey horizontal and vertical bars that divide rectangular regions. Each rectangular region is black with some colored pixels added.\n# To make the output, fill the rectangular region with the most colored pixels. Fill it with is color. Fill the other rectangular regions with black.   \n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)  \n\n    # Get all the rectangular regions seperated by horizontal and vertical dividers\n    # The dividers are colored grey, but more generally their color is just whatever color stretches all the way horizontally or vertically\n    for x in range(input_grid.shape[0]):\n        if np.all(input_grid[x, :] == input_grid[x, 0]):\n            divider_color = input_grid[x, 0]\n            break\n    # For this problem you could also do: divider_color = Color.GRAY\n    regions = find_connected_components(grid=output_grid, background=divider_color, monochromatic=False, connectivity=4)\n\n    # Find the region with the most colored pixels inside of it\n    num_colored_pixels = [ np.sum((region != divider_color) \u0026 (region != Color.BLACK)) for region in regions ]\n    max_colored_pixels = max(num_colored_pixels)\n\n    # Fill the region with the most colored pixels with its color\n    # Fill the other regions with black\n    for region_obj in regions:\n        # Figure out if it is one of the max colored regions to determine what the target color is that we are going to fill with\n        num_colored_pixels_in_this_region = np.sum((region_obj != divider_color) \u0026 (region_obj != Color.BLACK))\n        if num_colored_pixels_in_this_region == max_colored_pixels:\n            colors = [ color for color in object_colors(region_obj, background=divider_color) if color != Color.BLACK ]\n            assert len(colors) == 1, \"Each region should have only one color\"\n            target_color = colors[0]\n        else:\n            target_color = Color.BLACK\n\n        # Fill the region with the target color\n        output_grid[region_obj != divider_color] = target_color\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Define the base cofiguration of the grid seperated by chessboard lines\n    # Randomly select the size of the squares, create a 3x3 grid of squares\n    region_len = np.random.choice([4, 5, 7])\n    interior_len = region_len - 2\n    region_num = 3\n\n    # Size of the grid is grid length plus line length\n    n, m = region_len * region_num + region_num - 1, region_len * region_num + region_num - 1\n    grid = np.zeros((n, m), dtype=int)\n\n    # Select two distinct colors for the lines and the pattern\n    divider_color, interior_color = np.random.choice(Color.NOT_BLACK, 2, replace=False) \n\n    # Fill rows and columns with the divider color\n    for i in range(region_len, n, region_len + 1):\n        draw_line(grid=grid, x=i, y=0, color=divider_color, direction=(0, 1))\n        draw_line(grid=grid, x=0, y=i, color=divider_color, direction=(1, 0))\n\n    # Add different density of pixels to each square\n    for x in range(0, n, region_len + 1):\n        for y in range(0, m, region_len + 1):\n            # Randomly select the density of the square\n            square_background = np.zeros((interior_len, interior_len), dtype=int)\n            density = np.random.randint(1, interior_len * interior_len) / (interior_len * interior_len)\n\n            # Randomly scatter the color in the square\n            square_background = randomly_scatter_points(square_background, color=interior_color, density=density)\n            blit_sprite(grid, square_background, x, y)\n        \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/41/images/test_input.png", "output": "output/seeds/seed_examples/41/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/41/images/train_input_0.png", "output": "output/seeds/seed_examples/41/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/41/images/train_input_1.png", "output": "output/seeds/seed_examples/41/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/41/images/train_input_2.png", "output": "output/seeds/seed_examples/41/images/train_output_2.png"}]}, "index": 41, "seed": "29623171", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, magnetism\n\n# description:\n# In the input you will individual pixels are the sides of a grid. Each pixel is in a matching pair, which is a different color, but on the opposite side of the grid.\n# To make the output, make each pixel copy its color toward its matching pair until they meet in the middle. Turn the middle point grey.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the pixels\n    # 2. Associate each pixel with its matching pair\n    # 3. Make them attract/march toward each other until they meet in the middle, leaving a trail of their own color\n\n    # 1. Find the location of the pixels\n    pixel_objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK)\n    assert len(pixel_objects) % 2 == 0, \"There should be an even number of pixels\"\n\n    # we\u0027re going to draw on top of the input grid\n    output_grid = input_grid.copy()\n\n    for obj in pixel_objects:\n        # 2. Associate each pixel with its matching pair\n        # Find the matching position, which is either the opposite x or the opposite y\n        x, y = object_position(obj, background=Color.BLACK, anchor=\u0027center\u0027)\n        if x in [0, input_grid.shape[0] - 1]:\n            opposite_x = input_grid.shape[0] - 1 - x\n            opposite_y = y\n        else:\n            opposite_x = x\n            opposite_y = input_grid.shape[1] - 1 - y\n\n        # get the unit vector pointing from one to the other\n        dx, dy = np.sign([opposite_x - x, opposite_y - y], dtype=int)\n\n        color = input_grid[x, y]\n        other_color = input_grid[opposite_x, opposite_y]\n\n        # 3. Make them attract/march toward each other until they meet in the middle (grey when they touch), leaving a trail of their own color\n        while (x, y) != (opposite_x, opposite_y):\n            # Draw a trail of color\n            if output_grid[x, y] == Color.BLACK:\n                output_grid[x, y] = color\n            if output_grid[opposite_x, opposite_y] == Color.BLACK:\n                output_grid[opposite_x, opposite_y] = other_color\n            x += dx\n            y += dy\n            opposite_x -= dx\n            opposite_y -= dy\n\n            # Make sure we haven\u0027t fallen out of bounds\n            if not (0 \u003c= x \u003c input_grid.shape[0] and 0 \u003c= y \u003c input_grid.shape[1] and 0 \u003c= opposite_x \u003c input_grid.shape[0] and 0 \u003c= opposite_y \u003c input_grid.shape[1]):\n                break\n        # when they meet, turn the middle point grey\n        output_grid[x, y] = Color.GREY\n    \n    return output_grid\n        \n\n\n\ndef generate_input():\n    # We are going to generate a grid with pairs that go top-bottom, but then randomly rotate to get the other orientations\n\n    # Generate the grid with random size, but odd height so that there is a unique middle point\n    width, height = np.random.randint(5, 25), np.random.randint(10, 30)\n    # Makes sure it\u0027s odd\n    if height%2 != 1:\n        return generate_input()\n        \n    grid = np.full((width, height), Color.BLACK)\n    \n    n_pairs = np.random.randint(3, 6+1)\n    for pair_index in range(n_pairs):\n        # Pick a random top-bottom position for the first pixel, which has to be on the border but not in the corners\n        top_bottom_locations = [ (x, 0) for x in range(1, width-1) ] + [ (x, height-1) for x in range(1, width-1) ]\n        x, y = random.choice(top_bottom_locations)\n        color = random.choice([ color for color in Color.NOT_BLACK if color != Color.GREY ])\n        # Make sure it is not already occupied\n        if grid[x, y] != Color.BLACK: continue\n        grid[x, y] = color\n\n        # Find the opposite position\n        if x in [0, width - 1]:\n            opposite_x = width - 1 - x\n            opposite_y = y\n        else:\n            opposite_x = x\n            opposite_y = height - 1 - y\n        other_color = random.choice([ other_color for other_color in Color.NOT_BLACK if other_color != color and other_color != Color.GREY ])\n        grid[opposite_x, opposite_y] = other_color\n\n    # random rotation\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/42/images/test_input.png", "output": "output/seeds/seed_examples/42/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/42/images/train_input_0.png", "output": "output/seeds/seed_examples/42/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/42/images/train_input_1.png", "output": "output/seeds/seed_examples/42/images/train_output_1.png"}]}, "index": 42, "seed": "29c11459", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# mirror symmetry, non-black background, indicator pixels\n\n# description:\n# In the input you will see an object with some red pixels attached to it on one side.\n# To make the output, mirror the object to cover the red pixels. Then change the background to green.\n \ndef transform(input_grid):\n    # Plan:\n    # 1. Find the main object and the red pixels\n    # 2. Calculate the axis over which to mirror depending on which side the red pixels are on\n    # 3. Do the mirroring\n    # 4. Change background to green\n    \n    # 1. Input parsing\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, connectivity=8, background=background, monochromatic=True)\n    assert len(objects) == 2, \"There should be exactly two objects\"\n\n    # Find the main object\n    main_object = next(obj for obj in objects if Color.RED not in object_colors(obj, background=background))\n    # Find the red pixels\n    red_pixels = next(obj for obj in objects if Color.RED in object_colors(obj, background=background))\n\n    # 2. Axis calculation\n\n    # Figure out what side of the object the red pixels are on\n    x1, y1 = object_position(main_object, anchor=\"upper left\")\n    x2, y2 = object_position(main_object, anchor=\"lower right\")\n    # on the right?\n    if collision(object1=translate(main_object, x=1, y=0), object2=red_pixels):\n        # the +/- 0.5 is to clobber the red pixels, otherwise we\u0027d reflect over them and leave them be, which would also be a reasonable thing to do\n        symmetry = MirrorSymmetry(mirror_x=x2+0.5, mirror_y=None)\n    # on the left?\n    elif collision(object1=translate(main_object, x=-1, y=0), object2=red_pixels):\n        symmetry = MirrorSymmetry(mirror_x=x1-0.5, mirror_y=None)\n    # on the top?\n    elif collision(object1=translate(main_object, x=0, y=-1), object2=red_pixels):\n        symmetry = MirrorSymmetry(mirror_x=None, mirror_y=y1-0.5)\n    # on the bottom?\n    elif collision(object1=translate(main_object, x=0, y=1), object2=red_pixels):\n        symmetry = MirrorSymmetry(mirror_x=None, mirror_y=y2+0.5)\n    else:\n        assert False, \"Red pixels are not on any side of the main object\"\n    \n    # 3. Mirror the main object\n    output_grid = np.full_like(input_grid, background)\n    blit_object(output_grid, main_object)\n    for x, y in np.argwhere(main_object != background):\n        for x2, y2 in orbit(output_grid, x, y, symmetries=[symmetry]):\n            if 0 \u003c= x2 \u003c output_grid.shape[0] and 0 \u003c= y2 \u003c output_grid.shape[1]:\n                output_grid[x2, y2] = main_object[x, y]\n    \n    # 4. Change the background to green\n    output_grid[output_grid == background] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # Make an empty black grid of random size, and then put a non-red object somewhere. Put some red pixels on one side.\n    background = Color.BLACK\n    grid = np.full((random.randint(10, 25), random.randint(10, 25)), background)\n\n    object_color = random.choice([ color for color in Color.NOT_BLACK if color != Color.RED ])\n    sprite = random_sprite(random.randint(3, 6), random.randint(3, 6), color_palette=[object_color])\n\n    # Put red on the right side. We will randomly rotate at the end to get a variety of orientations.\n    # But make sure that there are some pixels on the right side.\n    assert np.any(sprite[-1, :] == object_color), \"The object must have some pixels on the right side\"\n    for x, y in np.argwhere(sprite == object_color):\n        if x == sprite.shape[0]-1:\n            sprite[x, y] = Color.RED\n\n    # placed randomly but a little bit far away from the border\n    x, y = random_free_location_for_sprite(grid, sprite, border_size=6)\n    blit_sprite(grid, sprite, x, y)\n\n    # randomly rotate\n    grid = np.rot90(grid, random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/43/images/test_input.png", "output": "output/seeds/seed_examples/43/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/43/images/train_input_0.png", "output": "output/seeds/seed_examples/43/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/43/images/train_input_1.png", "output": "output/seeds/seed_examples/43/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/43/images/train_input_2.png", "output": "output/seeds/seed_examples/43/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/43/images/train_input_3.png", "output": "output/seeds/seed_examples/43/images/train_output_3.png"}]}, "index": 43, "seed": "2bcee788", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, objects, non-black background\n\n# description:\n# In the input you will see a non-black background with a colored rectangle and some colored pixels sprinkled randomly.\n# To make the output, draw a horizontal or vertical line connecting each colored pixel to the rectangle (whenever possible: the rectangle and pixel have to be lined up). Color the line the same as the pixel.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the background color\n    # 2. Extract objects, separating the pixels from the rectangle\n    # 3. For each pixel, draw a line to the rectangle\n\n    # The background is the most common color\n    background = np.bincount(input_grid.flatten()).argmax()\n\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=background)\n    # The rectangle is the largest object\n    rectangle_object = max(objects, key=lambda obj: np.sum(obj != background))\n    # The pixels are the rest\n    pixel_objects = [obj for obj in objects if obj is not rectangle_object]\n\n    for pixel_object in pixel_objects:\n        for x, y in np.argwhere(pixel_object != background):\n            pixel_color = pixel_object[x, y]\n\n            # Check if the pixel is on a horizontal or vertical line with the rectangle\n            # Do this by trying to move the pixel up/down/left/right by different amounts until there is contact\n            # After finding contact, double check that going one step further would lead to overlap (collision) to avoid glancing contact\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]: # up, right, down, left\n                for distance in range(max(input_grid.shape)):\n                    translated_pixel = translate(pixel_object, distance * dx, distance * dy, background=background)\n                    if contact(object1=translated_pixel, object2=rectangle_object, background=background) and \\\n                        collision(object1=translate(pixel_object, (distance + 1) * dx, (distance + 1) * dy, background=background), object2=rectangle_object, background=background):\n                        # Draw the line\n                        end_x, end_y = x + distance * dx, y + distance * dy\n                        draw_line(input_grid, x, y, end_x=end_x, end_y=end_y, color=pixel_color)\n                        break\n    \n    return input_grid\n                \n\n\ndef generate_input():\n    # Plan:\n    # 1. Pick different colors for the background, rectangle, and pixels\n    # 2. Randomly place the rectangle\n    # 3. Randomly place the pixels\n    # 4. Check that at least one pixel will make a line to the rectangle\n\n    background_color, rectangle_color, pixel_color = np.random.choice(Color.NOT_BLACK, size=3, replace=False)\n    width, height = np.random.randint(7, 20, size=2)\n\n    input_grid = np.full((width, height), fill_value=background_color)\n\n    rectangle_width, rectangle_height = np.random.randint(2, width//2), np.random.randint(2, height//2)\n    rectangle_sprite = random_sprite(rectangle_width, rectangle_height, color_palette=[rectangle_color], density=1)\n    rectangle_x, rectangle_y = random_free_location_for_sprite(input_grid, rectangle_sprite, background=background_color, padding=1, border_size=1)\n    blit_sprite(input_grid, rectangle_sprite, x=rectangle_x, y=rectangle_y, background=background_color)\n\n    n_pixels = np.random.randint(2, 8)\n    for _ in range(n_pixels):\n        pixel_sprite = random_sprite(1, 1, color_palette=[pixel_color], density=1)\n        pixel_x, pixel_y = random_free_location_for_sprite(input_grid, pixel_sprite, background=background_color, padding=1, border_size=1)\n        blit_sprite(input_grid, pixel_sprite, x=pixel_x, y=pixel_y, background=background_color)\n    \n    # Check that at least one pixel shares an X or Y coordinate with the rectangle\n    rectangle_coordinates = np.argwhere(input_grid == rectangle_color)\n    pixel_coordinates = np.argwhere(input_grid == pixel_color)\n    rectangle_xs, rectangle_ys = set(rectangle_coordinates[:, 0]), set(rectangle_coordinates[:, 1])\n    pixel_xs, pixel_ys = set(pixel_coordinates[:, 0]), set(pixel_coordinates[:, 1])\n    if not (rectangle_xs \u0026 pixel_xs) and not (rectangle_ys \u0026 pixel_ys):\n        return generate_input()\n    \n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/44/images/test_input.png", "output": "output/seeds/seed_examples/44/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/44/images/train_input_0.png", "output": "output/seeds/seed_examples/44/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/44/images/train_input_1.png", "output": "output/seeds/seed_examples/44/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/44/images/train_input_2.png", "output": "output/seeds/seed_examples/44/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/44/images/train_input_3.png", "output": "output/seeds/seed_examples/44/images/train_output_3.png"}]}, "index": 44, "seed": "2c608aff", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\nimport time\n\n# concepts:\n# path finding\n\n\n# description:\n# In the input you will see teal pixels and a short green line and a short red line.\n# Find a path starting from the green line and ending at the red line and color that path green, with the following constraints:\n# You can\u0027t go through a teal pixel; you can only change direction when you hit a teal pixel; you have to start in the direction of the green line.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the start and end points of the pathfinding problem\n    # 2. Define the state space, initial state(s), successor function, and goal test\n    # 3. Run bfs to find the shortest path from start to end\n    # 4. Color the path green\n\n    # 1. Parse the input, based on color\n    # There is the start object, end object, and barriers object\n    background = Color.BLACK\n    start_object = input_grid.copy()\n    start_object[start_object != Color.GREEN] = background\n    end_object = input_grid.copy()\n    end_object[end_object != Color.RED] = background\n    barriers_object = input_grid.copy()\n    barriers_object[barriers_object != Color.TEAL] = background\n\n    # Determine the orientation of the start object\n    x_coordinates = {x for x, y in np.argwhere(start_object == Color.GREEN)}\n    y_coordinates = {y for x, y in np.argwhere(start_object == Color.GREEN)}\n    # vertical line?\n    if len(x_coordinates) == 1:\n        possible_orientations = [(0, 1), (0, -1)]\n    # horizontal line?\n    elif len(y_coordinates) == 1:\n        possible_orientations = [(1, 0), (-1, 0)]\n    else:\n        assert False, \"Start object is not horizontal/vertical\"\n    \n    # 2. Define the state space, initial state(s), successor function, and goal test\n    # A state is a tuple of (x, y, orientation)\n    # orientation is a tuple of (dx, dy)\n        \n    # Initially we begin at a point on the line, along the orientation of the line\n    initial_states = [(x, y, orientation)\n                      for x, y in np.argwhere(start_object == Color.GREEN)\n                      for orientation in possible_orientations]\n    \n\n    def successors(state):\n        x, y, orientation = state\n        dx, dy = orientation\n\n        if not (0 \u003c= x + dx \u003c input_grid.shape[0] and 0 \u003c= y + dy \u003c input_grid.shape[1]):\n            return\n\n        if barriers_object[x + dx, y + dy] == background:\n            yield (x + dx, y + dy, orientation)\n        if barriers_object[x + dx, y + dy] != background:\n            # right angle turns\n            new_orientations = [(dy, dx), (-dy, -dx)]\n            for new_orientation in new_orientations:\n                yield (x, y, new_orientation)\n    \n    def is_goal(state):\n        x, y, (dx, dy) = state\n        if not (0 \u003c= x + dx \u003c end_object.shape[0] and 0 \u003c= y + dy \u003c end_object.shape[1]):\n            return False\n        return end_object[x + dx, y + dy] == Color.RED\n    \n    # 3. Run bfs to find the shortest path from start to end\n    queue = list(initial_states)\n    visited = set(initial_states)\n    parent = {}\n    while queue:\n        state = queue.pop(0)        \n        if is_goal(state):\n            break        \n        for successor in successors(state):\n            if successor not in visited:\n                visited.add(successor)\n                parent[successor] = state\n                queue.append(successor)\n\n    assert is_goal(state), \"No path found\"\n    \n    path = []\n    while state in parent:\n        path.append(state)\n        state = parent[state]\n\n    # 4. Color the path green\n    # draw on top of the input grid\n    output_grid = input_grid.copy()\n    for x, y, _ in path:\n        output_grid[x, y] = Color.GREEN\n\n    return output_grid\n\ndef generate_input():\n    # We want to first generate a successful path and add some noise teal pixels.\n    # Finally, we will remove the intermediate pixels in the path.\n    # Because the problem never uses the color 42, we will draw the path in that color, but finally erase it before returning the grid.\n\n    # Initialize grid\n    n = random.randint(14, 20)\n    grid = np.zeros((n, n), dtype=int)\n\n    # Generate start sprite, making it vertical (1x2 dimensions). We will rotate the final grid randomly to get a variety of orientations.\n    start_sprite = random_sprite(1, 2, density=1, color_palette=[Color.GREEN])\n\n    # Draw start sprite\n    start_x, start_y = random_free_location_for_sprite(grid, start_sprite, border_size=4)\n    blit_sprite(grid, start_sprite, start_x, start_y)\n\n    # Make a random path from the start to the end, leaving color 42 along the path, and leaving teal pixels at each turn\n    x,y = start_x, start_y-1\n    orientation = (0, -1)\n    target_length = random.randint(10, 20)\n    for _ in range(target_length):\n        # Draw the path\n        grid[x, y] = 42        \n\n        if random.random() \u003c 0.2:\n            # right angle turn\n            dx, dy = orientation\n            new_orientation = random.choice([(dy, dx), (-dy, -dx)])\n            grid[x+dx, y+dy] = Color.TEAL\n            orientation = new_orientation\n        \n        dx, dy = orientation\n        x += dx\n        y += dy\n\n        if x \u003c 0 or x \u003e= n or y \u003c 0 or y \u003e= n: return generate_input()\n    \n    # Color the ending red\n    grid[x, y] = Color.RED\n    grid[x-dx, y-dy] = Color.RED\n\n    # randomly sprinkle teal in unoccupied locations\n    for x, y in np.argwhere(grid == Color.BLACK):\n        if random.random() \u003c 0.3:\n            grid[x, y] = Color.TEAL\n\n    # Replace the path with black\n    grid[grid == 42] = Color.BLACK\n\n    # Randomly rotate\n    grid = np.rot90(grid, k=random.randint(0, 3))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/45/images/test_input.png", "output": "output/seeds/seed_examples/45/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/45/images/train_input_0.png", "output": "output/seeds/seed_examples/45/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/45/images/train_input_1.png", "output": "output/seeds/seed_examples/45/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/45/images/train_input_2.png", "output": "output/seeds/seed_examples/45/images/train_output_2.png"}]}, "index": 45, "seed": "2dd70a9a", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, symmetry detection, reflection\n\n# description:\n# In the input, you will see a sprite repeated horizontally, and some of those repetitions might be reflected top/down/right/left.\n# To make the output, just extract the repeated sprite.\n\ndef transform(input_grid):\n    # Find the period, remembering that we need to consider reflections\n    for period in range(1, input_grid.shape[0]):\n        # Extract the sprite and all of its repeated translated versions\n        sprite = input_grid[:period]\n        repetitions = [ input_grid[i*period:(i+1)*period] for i in range(input_grid.shape[0]//period) ]\n\n        # Check that every repetition matches the sprite, or a reflection of the sprite\n        valid = True\n        for rep in repetitions:\n            reflections = [rep, np.flip(rep, 0), np.flip(rep, 1)]\n            if not any([np.array_equal(sprite, r) for r in reflections]):\n                valid = False\n\n        if valid:\n            return sprite\n        \n    assert False, \"No valid period found\"\n\ndef generate_input():\n    # Create the sprite to be duplicated; pick a trio of random colors\n    n = random.randint(2,7)\n    sprite = random_sprite(n, n, color_palette=random.sample(list(Color.NOT_BLACK),3))\n    \n    # Duplicate the sprite 3 times horizontally\n    grid = np.zeros((3*n, n),dtype=int)\n    for i in range(3):\n        blit_sprite(grid, sprite, x=i*n, y=0)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/46/images/test_input.png", "output": "output/seeds/seed_examples/46/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/46/images/train_input_0.png", "output": "output/seeds/seed_examples/46/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/46/images/train_input_1.png", "output": "output/seeds/seed_examples/46/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/46/images/train_input_2.png", "output": "output/seeds/seed_examples/46/images/train_output_2.png"}]}, "index": 46, "seed": "2dee498d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, uniqueness, surrounding\n\n# description:\n# In the input, you will see a grid with a black background and colored pixels sprinkled on it. Exactly one color occurs only one time.\n# To make the output, find the cell whose color is unique (color occurs only one time), and surround that cell with red pixels. Make all the other pixels black.\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Create a blank new canvas (so that the non-unique colors don\u0027t get copied)\n    # 2. Find the unique cell\n    # 3. Surround the unique cell with red pixels\n\n    output_grid = np.zeros_like(input_grid)\n\n    # 2. Find the unique cell\n    unique_color = None\n    for color in Color.NOT_BLACK:\n        if np.count_nonzero(input_grid == color) == 1:\n            unique_color = color\n            break\n    \n    # 3. Surround the unique cell with red pixels\n    # First get the coordinates of the unique cell\n    x, y, width, height = bounding_box(input_grid == unique_color)\n    # Copy red over the region around the unique cell (but this will accidentally delete the unique cell, so be copied back)\n    for i in range(x-1, x+2):\n        for j in range(y-1, y+2):\n            if 0 \u003c= i \u003c len(input_grid) and 0 \u003c= j \u003c len(input_grid[0]):\n                output_grid[i, j] = Color.RED\n    # Copy the unique cell back\n    output_grid[x, y] = unique_color\n\n    return output_grid\n\n\n    \n\n\n\ndef generate_input() -\u003e np.ndarray:\n    \n    # make a 10x10 black grid first as background\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # randomly select a unique color from Color.NOT_BLACK\n    unique_color = random.choice(Color.NOT_BLACK)\n\n    # randomly choose a non-border cell for the unique color\n    non_border_cells = [ (i, j) for i in range(1, n-1) for j in range(1, m-1) ]\n    unique_cell = random.choice(non_border_cells)\n    grid[unique_cell] = unique_color\n\n    # remove the unique color from the list\n    remaining_colors = [ color for color in Color.NOT_BLACK if color != unique_color ]\n\n    for remaining_color in remaining_colors:\n        # Pick a random frequency but make sure that this colour is not unique (does not have frequency 1)\n        frequency_of_this_color = random.choice([0, 2, 3, 4, 5, 6])\n\n        for _ in range(frequency_of_this_color):\n            # randomly choose an unoccupied cell for the remaining color\n            empty_cells = [ (i, j) for i in range(n) for j in range(m) if grid[i][j] == Color.BLACK ]\n            x, y = random.choice(empty_cells)\n            grid[x, y] = remaining_color\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/47/images/test_input.png", "output": "output/seeds/seed_examples/47/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/47/images/train_input_0.png", "output": "output/seeds/seed_examples/47/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/47/images/train_input_1.png", "output": "output/seeds/seed_examples/47/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/47/images/train_input_2.png", "output": "output/seeds/seed_examples/47/images/train_output_2.png"}]}, "index": 47, "seed": "31aa019c", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, occlusion\n\n# description:\n# In the input you will see a left-right symmetric monochromatic object occluded by a colored rectangle\n# To make the output, remove the colored rectangle and fill in the missing parts of the object to make it left-right symmetric\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract and separate the rectangle from the symmetric object\n    # 2. Find the left-right symmetry\n    # 3. Fill in the missing parts of the object\n\n    background_color = Color.BLACK\n\n    # Each object has a different color, so we can look at connected components by color\n    objects = detect_objects(input_grid, monochromatic=True, connectivity=8, background=background_color)\n    sprites = [ crop(obj, background=Color.BLACK) for obj in objects ]\n    # Find the rectangle\n    for obj, sprite in zip(objects, sprites):\n        # the rectangle will be completely filled, so we can check if its total area is the whole rectangular region\n        if sprite.shape[0] * sprite.shape[1] == np.sum(sprite != Color.BLACK):\n            rectangle = obj\n            break\n\n    # Find the color of the rectangle, because it is the occluder\n    rectangle_color = object_colors(rectangle, background=background_color)[0]\n    \n    # Delete the rectangle\n    rectangle_mask = rectangle != Color.BLACK\n    output_grid = input_grid.copy()\n    output_grid[rectangle_mask] = Color.BLACK\n\n    # Find the symmetry\n    # The occluder is rectangle_color, so we ignore it. In contrast, Color.BLACK is places where the object *actually* isn\u0027t located, so we can\u0027t ignore that.\n    mirrors = detect_mirror_symmetry(input_grid, ignore_colors=[rectangle_color], background=Color.BLACK)\n\n    # Mirror each colored pixel\n    for x, y in np.argwhere(output_grid != Color.BLACK):\n        for mirror in mirrors:\n            source_color = output_grid[x,y]\n            destination = mirror.apply(x, y)\n            output_grid[destination] = source_color\n\n    return output_grid\n\n\ndef generate_input():\n    # Create a medium sized grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    object_color, rectangle_color = random.sample(list(Color.NOT_BLACK), 2)\n\n    sprite = random_sprite(np.random.randint(5, n-2), np.random.randint(5, m-2), density=0.5, symmetry=\"horizontal\", color_palette=[object_color])\n    rectangle = np.full((np.random.randint(2, 5), np.random.randint(2, 5)), rectangle_color)\n\n    sprite_x, sprite_y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=sprite_x, y=sprite_y)\n\n    # Find a random place for the rectangle that is NOT free (because the rectangle occludes the sprite)\n    while True:\n        rectangle_x, rectangle_y = np.random.randint(0, n-rectangle.shape[0]), np.random.randint(0, m-rectangle.shape[1])\n        if collision(object1=grid, object2=rectangle, x2=rectangle_x, y2=rectangle_y, background=Color.BLACK):\n            # Equivalently, could have done:\n            # collision(object1=sprite, object2=rectangle, x1=sprite_x, y1=sprite_y, x2=rectangle_x, y2=rectangle_y)\n            break\n    blit_sprite(grid, rectangle, x=rectangle_x, y=rectangle_y, background=Color.BLACK)\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/48/images/test_input.png", "output": "output/seeds/seed_examples/48/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/48/images/train_input_0.png", "output": "output/seeds/seed_examples/48/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/48/images/train_input_1.png", "output": "output/seeds/seed_examples/48/images/train_output_1.png"}]}, "index": 48, "seed": "3345333e", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bitmasks with separator, boolean logical operations\n\n# description:\n# Compute the XOR operation of where the two grids are red, turning the output green in those locations.\n# In the input, you should see two 6x5 red patterns on top and bottom separated a horizontal yellow line in the middle of the grid.\n# To make the output, you have to overlap the two patterns. If the overlapping cells are the same color, then the corresponding cell is colored black; otherwise, \n# if the overlapping cells are not the same color, then the corresponding cell is colored green\n\ndef transform(input_grid):\n\n    width, height = input_grid.shape\n   \n    # Find the yellow horizontal line/bar\n    for y_bar in range(height):\n        if np.all(input_grid[:, y_bar] == Color.YELLOW):\n            break\n    \n    # extract left and right patterns\n    left_pattern = input_grid[:, :y_bar]\n    right_pattern = input_grid[:, y_bar+1:] \n\n    output_grid = np.zeros_like(left_pattern)\n\n    # applying the XOR pattern, which is where they are different\n    output_grid[(left_pattern!=right_pattern)] = Color.GREEN\n    output_grid[(left_pattern==right_pattern)] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n  \n    # Define the grid size\n    width = 5  \n    height = 13 # 6 top + 1 yellow line + 6 bottom\n\n    # Initialize an empty grid\n    input_grid = np.full((width, height), Color.BLACK)\n\n    # Randomly assign red or black to the top and bottom patterns\n    for x in range(width):\n        for y in range(height):\n            input_grid[x, y] = np.random.choice([Color.BLACK, Color.RED])\n\n    # Set the yellow vertical line\n    input_grid[:, int(height//2)] = Color.YELLOW\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/49/images/test_input.png", "output": "output/seeds/seed_examples/49/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/49/images/train_input_0.png", "output": "output/seeds/seed_examples/49/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/49/images/train_input_1.png", "output": "output/seeds/seed_examples/49/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/49/images/train_input_2.png", "output": "output/seeds/seed_examples/49/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/49/images/train_input_3.png", "output": "output/seeds/seed_examples/49/images/train_output_3.png"}]}, "index": 49, "seed": "3428a4f5", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color, falling\n\n# description:\n# In the input, you should see a gray baseline at the bottom. For each gray baseline pixel, there may or may not be gray pixels above it. If there are gray pixels above it, you can see a blue pixel above the gray pixels.\n# To make the output, make the blue pixels fall downward, falling through the gray baseline until they hit the bottom.\n\ndef transform(input_grid):\n    output_grid = np.copy(input_grid)\n\n    width, height = output_grid.shape\n\n    # Find the color of the bottom baseline\n    baseline = output_grid[:, -1]\n    baseline_colors = np.unique(baseline)\n    assert len(baseline_colors) == 1\n    baseline_color = baseline_colors[0]\n\n    # Find the color of the background, which is the most common color\n    background_color = np.argmax(np.bincount(output_grid.flatten()))\n\n    # Now make all the other colors fall down\n    for x in range(width):\n      for y in range(height):\n          if output_grid[x, y] != background_color and output_grid[x, y] != baseline_color:\n              # Make it fall to the bottom\n              # Do this by finding the background/baseline spot below it which is closest to the bottom\n              possible_y_values = [ possible_y for possible_y in range(y+1, height)\n                                   if output_grid[x, possible_y] == background_color or output_grid[x, possible_y] == baseline_color]\n              if len(possible_y_values) \u003e 0:\n                  closest_to_bottom_y = max(possible_y_values)\n                  output_grid[x, closest_to_bottom_y] = output_grid[x, y]\n                  output_grid[x, y] = background_color                  \n  \n    return output_grid\n\n\ndef generate_input():\n    width, height = 5, 5\n    input_grid = np.zeros((width,height), dtype= int)\n\n    # make the bottom pixels gray\n    input_grid[:, height-1] = Color.GRAY\n\n    # randomly select 1 or 2 squares\n    num_blue_squares = random.choice([1, 2])\n\n    # randomly pick where to put them\n    blue_x_positions = random.sample(range(width), num_blue_squares)\n\n    # put the blue squares above new gray squares\n    for pos in blue_x_positions:\n        # grey is directly above the bottom (directly above height-1)\n        input_grid[pos, height-2] = Color.GREY\n        # and blue is directly above that\n        input_grid[pos, height-3] = Color.BLUE\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/50/images/test_input.png", "output": "output/seeds/seed_examples/50/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/50/images/train_input_0.png", "output": "output/seeds/seed_examples/50/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/50/images/train_input_1.png", "output": "output/seeds/seed_examples/50/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/50/images/train_input_2.png", "output": "output/seeds/seed_examples/50/images/train_output_2.png"}]}, "index": 50, "seed": "3618c87e", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel pattern generation, falling downward\n\n# description:\n# In the input you will see a grid with several colored pixels at the top.\n# To make the output, you should draw a pattern downward from each pixel:\n# Color the diagonal corners, and then color downward with a vertical period of 2 from those corners and from the original pixel, making the pattern fall downward.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the pixels and make the output\n    # 2. Grow the pixel pattern downward from each pixel\n\n    # Extract the pixels\n    pixels = find_connected_components(input_grid, monochromatic=True, background=Color.BLACK)\n\n    # Create output grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    width, height = input_grid.shape\n\n    # 2. Grow the pixel pattern downward from each pixel\n    for pixel in pixels:\n        pixel_x, pixel_y = object_position(pixel, background=Color.BLACK)\n        pixel_color = object_colors(pixel)[0]\n\n        # We do the diagonal corners *and* also the original pixel, so one of the offsets is 0,0\n        for offset_x, offset_y in [(0, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]:\n            x, y = offset_x + pixel_x, offset_y + pixel_y\n\n            # Fall downward (w/ period 2)\n            while 0 \u003c= x \u003c width and 0 \u003c= y \u003c height:\n                output_grid[x, y] = pixel_color\n                # Vertical period of 2\n                y += 2\n            \n    return output_grid\n\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 20, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose the number of pattern\n    num_pixels = np.random.randint(1, 4)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_pixels, replace=False)\n\n    # Randomly place one pixel on the top row of the grid, each two pixels has at least two pixels padding\n    for i in range(num_pixels):\n        pixel_sprite = np.full((1,1), colors[i])\n        # Find a free spot but just in the top row\n        top_y = 0\n        top_row = grid[:, top_y:top_y+1]        \n        try:\n            x, _ = random_free_location_for_sprite(top_row, pixel_sprite, padding=2, padding_connectivity=4)\n        except:\n            # No more space\n            break\n        blit_sprite(grid, pixel_sprite, x, top_y)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/51/images/test_input.png", "output": "output/seeds/seed_examples/51/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/51/images/train_input_0.png", "output": "output/seeds/seed_examples/51/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/51/images/train_input_1.png", "output": "output/seeds/seed_examples/51/images/train_output_1.png"}]}, "index": 51, "seed": "3ac3eb23", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# punching holes, geometric pattern\n\n# description:\n# In the input you will see a grid with some rectangles. Each rectangle is three pixels along its short side, and is monochromatic.\n# To make the output, you should draw black pixels along the middle of each rectangle with a period of 2 starting one pixel in.\n# Effectively punching holes in the middle of each rectangle, skipping alternating pixels.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract the rectangles from the input grid\n    # 2. Canonicalize the rectangles: ensure that they are horizontal (remember to rotate back otherwise)\n    # 3. Draw black pixels inside each rectangle (horizontally, skipping every other pixel)\n    # 4. Rotate the rectangle back if it was not originally horizontal\n\n    # 1. Extract the rectangles from the input grid\n    rectangle_objects = find_connected_components(input_grid, monochromatic=True)\n\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    for rectangle_object in rectangle_objects:\n        # 2. Canonicalize the rectangle sprite\n        original_x, original_y, width, height = bounding_box(rectangle_object, background=Color.BLACK)\n        # crop to convert object to sprite\n        rectangle_sprite = crop(rectangle_object, background=Color.BLACK)\n\n        # Flip it to be horizontal if it isn\u0027t already\n        is_horizontal = width \u003e height\n        if not is_horizontal:\n            rectangle_sprite = np.rot90(rectangle_sprite)\n            width, height = height, width\n\n        # 3. Punch holes through the middle of the rectangle\n        # The inner row is y=height//2\n        for x in range(1, width, 2):\n            rectangle_sprite[x, height//2] = Color.BLACK\n        \n        # 4. Rotate back if it was originally vertical, and then draw it to the output grid\n        if not is_horizontal:\n            rectangle_sprite = np.rot90(rectangle_sprite, k=-1)\n        \n        # draw it back in its original location\n        blit_sprite(output_grid, rectangle_sprite, original_x, original_y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(10, 30), np.random.randint(10, 20)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose the number of rectangles on the grid\n    num_rectangles = np.random.randint(1, 4)\n    # Randomly choose colors for the rectangles\n    colors = np.random.choice(Color.NOT_BLACK, num_rectangles, replace=False)\n\n    for color in colors:\n        # Randomly choose the width of the rectangle, should not be too short and should be odd\n        w, h = np.random.randint(2, 6) * 2 + 1, 3\n        rectangle_sprite = np.full((w, h), color)\n\n        # randomly flipped to create different orientations\n        if np.random.rand() \u003c 0.5:\n            rectangle_sprite = np.rot90(rectangle_sprite)\n\n        # Randomly choose the position of the rectangle\n        try:\n            x, y = random_free_location_for_sprite(grid, rectangle_sprite, padding=1, padding_connectivity=8)\n        except:\n            # If there is no free location for the rectangle, retry\n            return generate_input()\n        blit_sprite(grid, rectangle_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/52/images/test_input.png", "output": "output/seeds/seed_examples/52/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/52/images/train_input_0.png", "output": "output/seeds/seed_examples/52/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/52/images/train_input_1.png", "output": "output/seeds/seed_examples/52/images/train_output_1.png"}]}, "index": 52, "seed": "3bdb4ada", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# growing, color change\n\n# description:\n# In the input you will see square(s) with a single pixel border around them in a different color.\n# To make the output, swap the color between the square and the border, \n# and then put rectangles on the edges of the border whose width is the same as the length of the inner square, \n# and whose color is the same as the border in the input image.\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Get the output grid with the same size as the input grid.\n    output_grid = np.copy(input_grid)\n\n    # Detect the square pattern in the input grid.\n    entire_square = find_connected_components(grid=input_grid, connectivity=4, monochromatic=False)\n    for each_square in entire_square:\n        # Detect the inner and outer squares in the pattern.\n        object_square = find_connected_components(grid=each_square, connectivity=4, monochromatic=True)\n\n        # Split the square pattern into inner and outer squares.\n        split_objects = []\n        for obj in object_square:\n            x, y, width, height = bounding_box(grid=obj)\n            shape = crop(grid=obj)\n            color = obj[x, y]\n            split_objects.append({\u0027x\u0027: x, \u0027y\u0027: y, \u0027len\u0027: width, \u0027color\u0027: color, \u0027shape\u0027: shape})\n\n        # Get the outer and inner square by comparing their size.\n        if split_objects[0][\u0027len\u0027] \u003e split_objects[1][\u0027len\u0027]:\n            outer_square = split_objects[0]\n            inner_square = split_objects[1]\n        else:\n            outer_square = split_objects[1]\n            inner_square = split_objects[0]\n        \n        # Swap the color between the inner and outer squares.\n        outer_square_pattern, inner_square_pattern = outer_square[\u0027shape\u0027], inner_square[\u0027shape\u0027]\n        outer_square_pattern[outer_square_pattern == outer_square[\u0027color\u0027]] = inner_square[\u0027color\u0027]\n        inner_square_pattern[inner_square_pattern == inner_square[\u0027color\u0027]] = outer_square[\u0027color\u0027]\n\n        # Draw the inner and outer squares after swaping on the output grid.\n        output_grid = blit_sprite(grid=output_grid, sprite=outer_square_pattern, x=outer_square[\u0027x\u0027], y=outer_square[\u0027y\u0027])\n        output_grid = blit_sprite(grid=output_grid, sprite=inner_square_pattern, x=inner_square[\u0027x\u0027], y=inner_square[\u0027y\u0027])\n\n        # Draw the rectangle as growing from outer square, the width is the same as the length of the inner square.\n        # The rectangle is the same color as the original outer square.\n        rectangle_width, rectangle_height = outer_square[\u0027len\u0027], inner_square[\u0027len\u0027]  \n        \n        # Create the rectangle pattern for the edges of the outer square.\n        rectangle_up_down = np.full((rectangle_width, rectangle_height), outer_square[\u0027color\u0027])\n        rectangle_left_right = np.full((rectangle_height, rectangle_width), outer_square[\u0027color\u0027])\n\n        # Draw the rectangle on the four edges of the outer square.\n        output_grid = blit_sprite(grid=output_grid, sprite=rectangle_up_down, x=outer_square[\u0027x\u0027], y=outer_square[\u0027y\u0027] - inner_square[\u0027len\u0027])\n        output_grid = blit_sprite(grid=output_grid, sprite=rectangle_up_down, x=outer_square[\u0027x\u0027], y=outer_square[\u0027y\u0027] + outer_square[\u0027len\u0027])\n        output_grid = blit_sprite(grid=output_grid, sprite=rectangle_left_right, x=outer_square[\u0027x\u0027] - inner_square[\u0027len\u0027], y=outer_square[\u0027y\u0027])\n        output_grid = blit_sprite(grid=output_grid, sprite=rectangle_left_right, x=outer_square[\u0027x\u0027] + outer_square[\u0027len\u0027], y=outer_square[\u0027y\u0027])\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_len = random.randint(24, 30)\n    n, m = grid_len, grid_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select the number of square pattern.\n    num_square = random.randint(1, 2)\n\n    # Ensure there is enough space for the square pattern to grow.\n    max_square_len = grid_len // (num_square * 3)\n\n    # Choose two colors for inner and outer square, and one color represents the boundary.\n    # The boundary is used for leave enough space for the square pattern in output to grow.\n    available_color = Color.NOT_BLACK.copy()\n    two_colors = random.sample(available_color, k=2)\n    available_color.remove(two_colors[0])\n    available_color.remove(two_colors[1])\n    boundary_color = available_color[0]\n\n    for _ in range(num_square):\n        # Randomly select the size of the square pattern.\n        # The outer square is the inner square with a single pixel border around it.\n        outer_square_len = random.randint(3, max_square_len)\n        inner_square_len = outer_square_len - 2\n\n        # The square will grow inner_square_len in four directions\n        border_len = outer_square_len + inner_square_len * 2\n        \n        # Create the inner square, outer square, and border.\n        outer_square = random_sprite(n=outer_square_len, m=outer_square_len, color_palette=[two_colors[1]], density=1.0)\n        inner_square = random_sprite(n=inner_square_len, m=inner_square_len, color_palette=[two_colors[0]], density=1.0)\n        border = random_sprite(n=border_len, m=border_len, color_palette=[boundary_color], density=1.0)\n        \n        # Get a random free location for the pattern\n        posx, posy = random_free_location_for_sprite(grid=grid, sprite=border)\n\n        # Draw the square pattern on the grid\n        grid = blit_sprite(grid=grid, sprite=border, x=posx, y=posy)\n        grid = blit_sprite(grid=grid, sprite=outer_square, x=posx + inner_square_len, y=posy + inner_square_len)\n        grid = blit_sprite(grid=grid, sprite=inner_square, x=posx + inner_square_len + 1, y=posy + inner_square_len + 1)\n    \n    # Remove the boundary color from the grid\n    grid = np.where(grid == boundary_color, Color.BLACK, grid)\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/53/images/test_input.png", "output": "output/seeds/seed_examples/53/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/53/images/train_input_0.png", "output": "output/seeds/seed_examples/53/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/53/images/train_input_1.png", "output": "output/seeds/seed_examples/53/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/53/images/train_input_2.png", "output": "output/seeds/seed_examples/53/images/train_output_2.png"}]}, "index": 53, "seed": "3befdf3e", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, color matching\n\n# description:\n# In the input you will see a grid with a central pattern with four differently-colored pixels at the corners.\n# To make the output, you should extract the central pattern (removing the differently-colored corners), \n# and change the color of the central pattern to match the corner pixels.\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Extract the central pattern by the four corner squares\n    output_grid = np.copy(input_grid)\n\n    # Crop the pattern out\n    output_grid = crop(grid=output_grid)\n\n    # Get the color of the corner squares\n    corner_color = output_grid[0, 0]\n\n    # Change the color of the central pattern to match the corner squares\n    output_grid[output_grid != Color.BLACK] = corner_color\n\n    # Remove the one pixel border around the central pattern\n    output_grid = output_grid[1:-1, 1:-1]\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Random generate the size of the pattern \n    n, m = random.randint(3, 10), random.randint(3, 10)\n\n    # Get the color of the pattern and the corner squares\n    available_colors = random.sample(Color.NOT_BLACK, 2)\n    pattern_color, corner_color = available_colors[0], available_colors[1]\n    \n    # Generate a random pattern\n    pattern = random_sprite(n, m, color_palette=[pattern_color], density=0.4)\n\n    # Ensure there is space for the four corner squares\n    enlarged_pattern = np.zeros((n + 2, m + 2), dtype=int)\n\n    # Set four pixels in each corner to the corner color\n    enlarged_pattern[0, 0] = corner_color\n    enlarged_pattern[0, m + 1] = corner_color\n    enlarged_pattern[n + 1, 0] = corner_color\n    enlarged_pattern[n + 1, m + 1] = corner_color\n\n    # Place the pattern in the center of the corner pixels\n    enlarged_pattern = blit_sprite(grid=enlarged_pattern, sprite=pattern, x=1, y=1)\n    \n    # Create the grid and place the pattern in it\n    grid_width, grid_height = random.randint(n + 2, 2 * n + 2), random.randint(m + 2, 2 * m + 2)\n    grid = np.zeros((grid_width, grid_height), dtype=int)\n\n    # Randomly place the pattern in the grid\n    pos_x, pos_y = random.randint(0, grid_width - (n + 2)), random.randint(0, grid_height - (m + 2))\n    grid = blit_sprite(grid=grid, sprite=enlarged_pattern, x=pos_x, y=pos_y)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/54/images/test_input.png", "output": "output/seeds/seed_examples/54/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/54/images/train_input_0.png", "output": "output/seeds/seed_examples/54/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/54/images/train_input_1.png", "output": "output/seeds/seed_examples/54/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/54/images/train_input_2.png", "output": "output/seeds/seed_examples/54/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/54/images/train_input_3.png", "output": "output/seeds/seed_examples/54/images/train_output_3.png"}]}, "index": 54, "seed": "3de23699", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern recognition, rotation, color correspondence, pattern reconstruction\n\n# description:\n# In the input you will see one or two color pattern with a red or green pixel as an indicator\n# and a set of red and green pixels. \n# To make the output, you should reconstruct the pattern with the red and green pixels \n# indicates the pattern\u0027s position. If the indicator is red, the pattern should be flipped by x-axis before reconstructing.\n\ndef transform(input_grid):\n    # Detect the continuous object in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n    pixels = []\n    original_pattern = []\n\n    # Find out the original pattern and the pixel indicator for reconstruction\n    for obj in objects:\n        cropped_obj = crop(grid=obj, background=Color.BLACK)\n        if cropped_obj.shape == (1,1):\n            pixels.append(obj)\n        else:\n            original_pattern.append(cropped_obj)\n    output_grid = input_grid.copy()\n\n    for pattern in original_pattern:\n        # If the indicator color is red, flip the pattern by x-axis\n        if np.any(pattern == Color.RED):\n            indicator_color = Color.RED\n            pattern = np.flipud(pattern)\n        else:\n            indicator_color = Color.GREEN\n        \n        # Find the relative position of the indicator pixel in the pattern\n        rela_x, rela_y = np.where(pattern == indicator_color)\n        rela_x, rela_y = rela_x[0], rela_y[0]\n\n        for pixel in pixels:\n            color_pixel = Color.RED if np.any(pixel == Color.RED) else Color.GREEN\n\n            # Find the position of the indicator pixel in the input grid\n            if color_pixel == indicator_color:\n                x, y = np.where(pixel == color_pixel)\n                x, y = x[0], y[0]\n                x -= rela_x\n                y -= rela_y\n\n                # Place the pattern in correct position using the indicator pixel, finish the reconstruction\n                output_grid = blit_sprite(x=x, y=y, grid=output_grid, sprite=pattern, background=Color.BLACK)\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = 13, 13\n    grid = np.zeros((n, m), dtype=int)\n\n    # The indicator color is red or green, the pattern color is blue, yellow or teal\n    number_object = np.random.randint(1, 3)\n    indicator_color = [Color.RED, Color.GREEN]\n    available_color = [Color.BLUE, Color.YELLOW, Color.TEAL]\n\n    # mask color: dummy color used to indicate where we aren\u0027t allowed to put something\n    # these mask color pixel wil be occupied in the output, when that\u0027s computed\n    # after making the input, we scrub the mask color (change it to black)\n    mask_color = mask_color\n\n    # Randomly shuffle the indicator color and available color\n    random.shuffle(indicator_color)\n    random.shuffle(available_color)\n\n\n    # There are 1 or 2 object pattern need to be reconstructed\n    for i in range(number_object):\n        # Generate the object pattern need to be reconstructed, use mask_color to represent the object pattern\n        object_pattern = random_sprite(n=3, m=3, color_palette=[mask_color], density=0.5, symmetry=\"not_symmetric\")\n\n        # There are 1 or 2 object pattern need to be reconstructed\n        num_sample = np.random.randint(1, 3)\n\n        # Place the indicator in the object pattern\n        position_x, position_y = np.random.randint(0, 3), np.random.randint(0, 3)\n        while object_pattern[position_x, position_y] != mask_color:\n            position_x, position_y = np.random.randint(0, 3), np.random.randint(0, 3)\n\n        # Randomly place the object pattern in the grid\n        for _ in range(num_sample):\n            object_pattern[position_x, position_y] = indicator_color[i]\n            x, y = random_free_location_for_sprite(grid=grid, sprite=object_pattern, padding=1, padding_connectivity=8)\n            grid = blit_sprite(x=x, y=y, grid=grid, sprite=object_pattern, background=Color.BLACK)\n        \n        # Replace the gray color with the available color as the original pattern for reconstruction\n        showed_pattern = object_pattern.copy()\n        showed_pattern[showed_pattern == mask_color] = available_color[i]\n\n        # If the indicator color is red, flip the pattern by x-axis\n        if indicator_color[i] == Color.RED:\n            showed_pattern = np.flipud(showed_pattern)\n        \n        # Place the original pattern in the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=showed_pattern, padding=1, padding_connectivity=8)\n        grid = blit_sprite(x=x, y=y, grid=grid, sprite=showed_pattern, background=Color.BLACK)\n    \n    grid[grid == mask_color] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/55/images/test_input.png", "output": "output/seeds/seed_examples/55/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/55/images/train_input_0.png", "output": "output/seeds/seed_examples/55/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/55/images/train_input_1.png", "output": "output/seeds/seed_examples/55/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/55/images/train_input_2.png", "output": "output/seeds/seed_examples/55/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/55/images/train_input_3.png", "output": "output/seeds/seed_examples/55/images/train_output_3.png"}]}, "index": 55, "seed": "3e980e27", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rectangle detection\n\n# description:\n# In the input you will see a grid with random pixels on it (mostly blue pixels).\n# To make the output, you should find the largest rectangular area (of height/width \u003e= 2, i.e. not a line) of black cells and turn it into pink.\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    # Plan:\n    # 1. Enumerate all rectangular regions\n    # 2. For each region, filter it out if it isn\u0027t all black\n    # 3. Find the biggest region remaining by area\n    # 4. Turn the biggest region into pink\n\n    # 1. Enumerate all rectangular regions\n    regions = { (x, y, w, h) for x in range(len(input_grid)) for y in range(len(input_grid[0])) for w in range(2, len(input_grid) - x + 1) for h in range(2, len(input_grid[0]) - y + 1) }\n\n    # 2. For each region, filter it out if it isn\u0027t all black\n    regions = { (x, y, w, h) for x, y, w, h in regions if np.all(input_grid[x:x+w, y:y+h] == Color.BLACK) }\n\n    # 3. Find the biggest region remaining by area\n    largest_region = max(regions, key=lambda region: region[2] * region[3])\n    x, y, w, h = largest_region\n\n    # 4. Turn the biggest region into pink\n    output_grid = np.copy(input_grid)\n    output_grid[x:x+w, y:y+h] = Color.PINK\n    \n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(20, 30), np.random.randint(3, 5)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Random largest_rec_height scatter density of blue color pixels on the grid.\n    randomly_scatter_points(grid, color=Color.BLUE, density=0.6)\n    \n    # Define random size for the pink rectangle, the rectangle should not be a line or point\n    rectangle_width = max(2, random.randint(int(0.25 * n), int(0.45 * n)))\n    rectangle_height = max(2, random.randint(int(0.5 * m), int(0.75 * m)))\n\n    # The pink rectangle region are represented by color black\n    rectangle = np.full((rectangle_width, rectangle_height), Color.BLACK)\n    \n    # Place the pink sprite at a random position in the grid\n    x, y = random.randint(0, n - rectangle_width + 1), random.randint(0, m - rectangle_height + 1)\n    blit_sprite(grid=grid, sprite=rectangle, x=x, y=y, background=Color.BLUE)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/56/images/test_input.png", "output": "output/seeds/seed_examples/56/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/56/images/train_input_0.png", "output": "output/seeds/seed_examples/56/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/56/images/train_input_1.png", "output": "output/seeds/seed_examples/56/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/56/images/train_input_2.png", "output": "output/seeds/seed_examples/56/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/56/images/train_input_3.png", "output": "output/seeds/seed_examples/56/images/train_output_3.png"}]}, "index": 56, "seed": "3eda0437", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# boundary detection, object extraction\n\n# description:\n# In the input you will see several teal pixels and two vertical parallel gray lines with four teal pixels indicates the boundary of the output grid.\n# To make the output grid, you should extract the part of grid that is bounded by the two vertical parallel gray lines and four teal pixels in each corner.\n\ndef transform(input_grid):\n    # Detect the vertical parallel gray lines.\n    vertical_lines = detect_objects(grid=input_grid, colors=[Color.GRAY], monochromatic=True, connectivity=4)\n    pos_list = []\n    for vertical_line in vertical_lines:\n        pos_x, pos_y, length_v, height_v = bounding_box(grid=vertical_line)\n        pos_list.append({\u0027x\u0027: pos_x, \u0027y\u0027: pos_y, \u0027length\u0027: length_v, \u0027height\u0027: height_v})\n    \n    # Get the left upper position and width, length of the extract part.\n    pos_list.sort(key=lambda pos: pos[\u0027x\u0027])\n    x1, y1 = pos_list[0][\u0027x\u0027], pos_list[0][\u0027y\u0027]\n    x2, y2 = pos_list[1][\u0027x\u0027], pos_list[1][\u0027y\u0027] + pos_list[1][\u0027height\u0027] - 1\n\n    # Grow the bounding box 1 pixel up and one pixel down.\n    y1 = y1 - 1\n    y2 = y2 + 1\n\n    # Extract the bounded part of the grid.\n    output_grid = input_grid[x1:x2 + 1, y1:y2 + 1]\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(9, 15), np.random.randint(9, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random teal pixels on the grid.    \n    randomly_scatter_points(grid, color=Color.TEAL, density=0.2)\n\n    # Randomly get the width, length and position of the extract part.\n    width, length = np.random.randint(4, n - 1), np.random.randint(4, m - 1)\n    x, y = np.random.randint(0, n - width), np.random.randint(0, m - length)\n\n    # Draw two vertical parallel gray lines with four teal pixels in each corner to indicate the boundary of the extract part.\n    draw_line(grid=grid, x=x, y=y, color=Color.GRAY, direction=(0, 1), length=length)\n    draw_line(grid=grid, x=x + width, y=y, color=Color.GRAY, direction=(0, 1), length=length)\n\n    grid[x, y] = Color.TEAL\n    grid[x, y + length] = Color.TEAL\n    grid[x + width, y] = Color.TEAL\n    grid[x + width, y + length] = Color.TEAL\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/57/images/test_input.png", "output": "output/seeds/seed_examples/57/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/57/images/train_input_0.png", "output": "output/seeds/seed_examples/57/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/57/images/train_input_1.png", "output": "output/seeds/seed_examples/57/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/57/images/train_input_2.png", "output": "output/seeds/seed_examples/57/images/train_output_2.png"}]}, "index": 57, "seed": "3f7978a0", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, magnetism, color change\n\n# description:\n# In the input you will see a grey rectangle and colored pixels scattered around it.\n# To make the output, move each colored pixel toward the grey rectangle until it touches, then turn its color to gray. If multiple colored pixels collide, they stack.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the objects; separate the gray rectangle from the other pixels\n    # 2. Move each colored pixel toward the gray rectangle until it touches\n    # 3. Change its color once it touches\n\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)\n\n    grey_objects = [ obj for obj in objects if Color.GREY in object_colors(obj, background=Color.BLACK) ]\n    other_objects = [ obj for obj in objects if Color.GREY not in object_colors(obj, background=Color.BLACK) ]\n\n    assert len(grey_objects) == 1, \"There should be exactly one grey object\"\n    \n    grey_object = grey_objects[0]\n\n    # Make the output grid: Start with the gray object, then add the colored pixels one-by-one\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    blit_object(output_grid, grey_object)\n\n    # Move the colored objects and change their color once they hit grey\n    for colored_object in other_objects:\n        # First calculate what direction we have to move in order to contact the grey object\n        # Consider all displacements, starting with the smallest translations first\n        possible_displacements = [ (i*dx, i*dy) for i in range(0, 30) for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)] ]\n\n        # Only keep the displacements that cause a contact between the colored object and the grey object\n        valid_displacements = [ displacement for displacement in possible_displacements\n                                if contact(object1=translate(colored_object, *displacement), object2=grey_object) ]\n        assert valid_displacements, \"There should be at least one valid displacement\"\n\n        # Pick the smallest valid displacement\n        displacement = min(valid_displacements, key=lambda displacement: sum(abs(x) for x in displacement))\n\n        # Extract the direction from the displacement\n        direction = np.sign(displacement, dtype=int)\n\n        # Now move the colored object in that direction until there is a collision with something else\n        if not all( delta == 0 for delta in direction ):\n            while not collision(object1=translate(colored_object, *direction), object2=output_grid):\n                colored_object = translate(colored_object, *direction)\n        \n        # Finally change the color of the colored object to grey anne draw it onto the outlet\n        colored_object[colored_object != Color.BLACK] = Color.GREY\n        blit_object(output_grid, colored_object)\n    \n    return output_grid\n\ndef generate_input():\n    # Make a grid with a grey horizontal rectangle stretching all the way through the middle, and some scattered points around it\n    # Then randomly rotate to get a variety of orientations\n\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    rectangle_y1 = np.random.randint(0, height//2)\n    rectangle_y2 = np.random.randint(height//2, height)\n    grid[:, rectangle_y1:rectangle_y2] = Color.GREY\n\n    # scatter some colored pixels around the grey rectangle\n    for _ in range(np.random.randint(5, 10)):\n        random_color = random.choice([color for color in Color.NOT_BLACK if color != Color.GREY])\n        pixel_sprite = np.full((1,1), random_color)\n        x, y = random_free_location_for_sprite(grid, pixel_sprite, background=Color.BLACK)\n        blit_sprite(grid, pixel_sprite, x, y, background=Color.BLACK)\n    \n    # random rotation\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/58/images/test_input.png", "output": "output/seeds/seed_examples/58/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/58/images/train_input_0.png", "output": "output/seeds/seed_examples/58/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/58/images/train_input_1.png", "output": "output/seeds/seed_examples/58/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/58/images/train_input_2.png", "output": "output/seeds/seed_examples/58/images/train_output_2.png"}]}, "index": 58, "seed": "4093f84a", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# non-black background, occlusion\n\n# description:\n# In the input you will see a non-black background (teal background) and the outlines of 5x5 blue rectangles\n# To make the output, draw pink horizontal/vertical bars at the center of each rectangle. The bars should be underneath the rectangles, and they should reach the edges of the canvas.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the background color; check that it is teal\n    # 2. Find the rectangles\n    # 3. Draw the pink bars\n    # 4. Ensure the rectangles are on top of the bars by drawing the rectangles last\n\n    # The background is the most common color\n    background = np.bincount(input_grid.flatten()).argmax()\n    assert background == Color.TEAL\n\n    # Extract the objects, which are the outlines of rectangles\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=background)\n\n    # Each object gets pink bars at its center, but these are going to be drawn over the object, which we have to undo later by redrawing the objects\n    for obj in objects:\n        center_x, center_y = object_position(obj, anchor=\u0027center\u0027, background=background)\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            draw_line(input_grid, center_x, center_y, direction=(dx, dy), color=Color.PINK)\n    \n    # Redraw the objects\n    for obj in objects:\n        blit_object(input_grid, obj, background=background)\n    \n    return input_grid\n\ndef generate_input():\n    background_color, rectangle_color = Color.TEAL, Color.BLUE\n    width, height = np.random.randint(7, 20, size=2)\n    input_grid = np.full((width, height), fill_value=background_color)\n\n    n_rectangles = np.random.randint(1, 3)\n    for _ in range(n_rectangles):\n        # Create a rectangle and then hollow it out by filling its inside with the background color\n        rectangle_sprite = np.full((5, 5), rectangle_color)\n        rectangle_sprite[1:-1, 1:-1] = background_color\n        # Place the rectangle randomly, taking care though that it does not touch or overlap any other rectangles\n        x, y = random_free_location_for_sprite(input_grid, rectangle_sprite, background=background_color, padding=1, border_size=1)\n        blit_sprite(input_grid, rectangle_sprite, x, y, background=background_color)\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/59/images/test_input.png", "output": "output/seeds/seed_examples/59/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/59/images/train_input_0.png", "output": "output/seeds/seed_examples/59/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/59/images/train_input_1.png", "output": "output/seeds/seed_examples/59/images/train_output_1.png"}]}, "index": 59, "seed": "41e4d17e", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# surrounding\n\n# description:\n# surround every gray pixel with blue pixels\n\ndef transform(input_grid):\n    output_grid = np.zeros_like(input_grid)\n\n    for i in range(len(input_grid)):\n        for j in range(len(input_grid[i])):\n            if input_grid[i, j] == Color.GRAY:\n                # if the current pixel is gray, then we need to surround it with blue\n                output_grid[max(0, i-1):min(len(input_grid), i+2), max(0, j-1):min(len(input_grid[i]), j+2)] = Color.BLUE\n\n    # but we need to keep the gray center: so copy over all the gray pixels\n    output_grid[input_grid == Color.GRAY] = Color.GRAY\n            \n    return output_grid\n\n\n# create a 9x9 grid of black (0) and then sparsely populate it with gray\ndef generate_input():\n    # create a 9x9 grid of black (0)\n    grid = np.zeros((9, 9), dtype=int)\n    # sparsely populate it with gray\n    for x in range(9):\n        for y in range(9):\n            if np.random.random() \u003c 0.05:\n                grid[x, y] = Color.GRAY\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/60/images/test_input.png", "output": "output/seeds/seed_examples/60/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/60/images/train_input_0.png", "output": "output/seeds/seed_examples/60/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/60/images/train_input_1.png", "output": "output/seeds/seed_examples/60/images/train_output_1.png"}]}, "index": 60, "seed": "4258a5f9", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cups, filling\n\n# description:\n# In the input you will see several blue \"cups\", meaning an almost-enclosed shape with a small opening at the top, and empty space (black pixels) inside, as well as a single colored pixel inside.\n# To make the output grid, you should fill the interior of each cup with the same color as the colored pixel inside it. \n# Also, put a single layer of colored pixels above the cup with the same color as what\u0027s inside.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect all the blue cups\n    # 2. For each cup, find the mask of what is inside of it\n    # 3. Find the color of the single pixel inside the cup\n    # 4. Fill the cup with the color\n    # 5. Put a single layer of colored pixels above the cup with the same color as what\u0027s inside\n    \n    # Detect all the blue cups\n    blue_cups = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n\n    output_grid = input_grid.copy()\n\n    # For each cup object...\n    for obj in blue_cups:\n        # Extract what\u0027s inside the cup (as its own object), which is everything in the bounding box that is not the object itself\n        cup_x, cup_y, cup_width, cup_height = bounding_box(obj)\n        inside_cup_mask = np.zeros_like(input_grid, dtype=bool)\n        inside_cup_mask[cup_x:cup_x+cup_width, cup_y:cup_y+cup_height] = True\n        inside_cup_mask = inside_cup_mask \u0026 (obj != Color.BLUE)\n        object_inside_cup = np.where(inside_cup_mask, input_grid, Color.BLACK)        \n\n        # Find the color of the single pixel inside the cup\n        colors = object_colors(object_inside_cup, background=Color.BLACK)\n        assert len(colors) == 1, \"There should be exactly one color inside the cup\"\n        color = colors[0]\n\n        # Fill the cup with the color\n        output_grid[inside_cup_mask] = color\n\n        # Put a single layer of colored pixels above the cup with the same color as what\u0027s inside\n        top_y = cup_y - 1\n        output_grid[cup_x:cup_x+cup_width, top_y] = color\n\n    return output_grid\n\ndef generate_input():\n    # Generate the grid with random size\n    width = np.random.randint(8, 30)\n    height = np.random.randint(8, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    n_cups = np.random.randint(1, 2+1)\n\n    for cup_index in range(n_cups):\n        # Pick a random width/height for this cup\n        cup_width = np.random.randint(4, 8)\n        cup_height = np.random.randint(3, 8)\n\n        # Make a sprite, which is just going to be a blue outline of a rectangle with a hole at the top\n        sprite = np.full((cup_width, cup_height), Color.BLACK)\n        sprite[0, :] = Color.BLUE\n        sprite[-1, :] = Color.BLUE\n        sprite[:, 0] = Color.BLUE\n        sprite[:, -1] = Color.BLUE\n\n        # Make the hole centered at the top (variable size)\n        hole_left_x = np.random.randint(1, cup_width//2)\n        hole_right_x = cup_width - hole_left_x - 1\n        hole_y = 0\n        sprite[hole_left_x:hole_right_x+1, hole_y] = Color.BLACK\n\n        # Put another color inside the cup\n        color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.BLUE])\n        x, y = np.random.randint(1, cup_width-1), np.random.randint(1, cup_height-1)\n        sprite[x, y] = color\n\n        # Find a random free location for it\n        free_x, free_y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n        blit_sprite(grid, sprite, free_x, free_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/61/images/test_input.png", "output": "output/seeds/seed_examples/61/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/61/images/train_input_0.png", "output": "output/seeds/seed_examples/61/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/61/images/train_input_1.png", "output": "output/seeds/seed_examples/61/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/61/images/train_input_2.png", "output": "output/seeds/seed_examples/61/images/train_output_2.png"}]}, "index": 61, "seed": "444801d8", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, topology\n\n# description:\n# The input is a black 12x12 grid containing a few grey squares. Each square has a \"hole\" in it, a contiguous black region of pixels.\n# To create the output, fill in the hole of each grey object with red if the hole is a square. Otherwise, leave the hole as is.\n\ndef transform(input_grid):\n    # get the grey squares\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # create an output grid to store the result\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # for each grey square, fill in the hole if it is a square\n    for obj in objects:\n        # to check if the grey object contains a square hole, we can check if the bounding box of the hole is a square.\n        # To do so, first crop the object, then find the black hole inside\n        sprite = crop(obj, background=Color.BLACK)\n        hole_mask = (sprite == Color.BLACK) \u0026 (object_interior(sprite, background=Color.BLACK))\n\n        # check if the mask is square\n        def is_square(thing):\n            \"\"\"thing can be a mask or a sprite or an object\"\"\"\n            thing = crop(thing)\n            return np.sum(thing != Color.BLACK) == thing.shape[0] * thing.shape[1] and thing.shape[0] == thing.shape[1]\n        \n        if is_square(hole_mask):\n            sprite[hole_mask] = Color.RED\n\n        # get location of object so we can blit the possibly edited sprite back into the grid\n        x, y = object_position(obj, background=Color.BLACK)\n        blit_sprite(output_grid, sprite, x, y)\n\n    return output_grid\n\n\ndef generate_input():\n    # create a 12x12 black grid\n    grid = np.full((12, 12), Color.BLACK)\n\n    # add 2-3 grey squares.\n    # For each grey square, add a hole in the middle.\n    # 50% chance the hole is a square, otherwise it\u0027s a random contiguous object.\n    # The hole should not overlap with the border of the square.\n\n    num_grey_squares = np.random.randint(2, 4)\n\n    for _ in range(num_grey_squares):\n        # create grey square, and try to find a location for it\n        length = np.random.randint(4, 6)\n        grey_square = np.full((length, length), Color.GREY)\n        try:\n            x, y = random_free_location_for_sprite(grid, grey_square, padding=1)\n        except ValueError:\n            # we were unable to find a space for a square; try over from scratch\n            return generate_input()\n\n        # # add a hole in the middle.\n        # # 50% chance the hole is a square, otherwise it\u0027s a random contiguous object.\n        # # The hole should not overlap with the border of the square.\n        has_square_hole = np.random.choice([True, False])\n        if has_square_hole:\n            hole_size = np.random.randint(1, length - 1)\n            hole_x, hole_y = np.random.randint(1, length - hole_size), np.random.randint(1, length - hole_size)\n            grey_square[hole_x:hole_x + hole_size, hole_y:hole_y + hole_size] = Color.BLACK\n        else:\n            hole_obj = random_sprite(length-2, length-2, color_palette=[Color.BLACK], background=Color.GREY)\n            grey_square[1:-1, 1:-1] = hole_obj\n\n        grid = blit_sprite(grid, grey_square, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/62/images/test_input.png", "output": "output/seeds/seed_examples/62/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/62/images/train_input_0.png", "output": "output/seeds/seed_examples/62/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/62/images/train_input_1.png", "output": "output/seeds/seed_examples/62/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/62/images/train_input_2.png", "output": "output/seeds/seed_examples/62/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/62/images/train_input_3.png", "output": "output/seeds/seed_examples/62/images/train_output_3.png"}]}, "index": 62, "seed": "44d8ac46", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, boolean indicator\n\n# description:\n# In the input you will see a 3x3 grid with red pixels scattered randomly.\n# To make the output grid, you should recognize if the input grid has mirror symmetry along the x-axis.\n# If the input grid has mirror symmetry along the x-axis, output a 1x1 grid with a blue pixel.\n# Otherwise, output a 1x1 grid with an orange pixel.\n\ndef transform(input_grid):\n    # Check if the input grid has mirror symmetry along the middle x-axis.\n    width, height = input_grid.shape\n    middle_x = width // 2\n    \n    # If the input grid has mirror symmetry along the middle x-axis, output a blue pixel.\n    # Otherwise, output an orange pixel.\n    if np.all(input_grid[0: middle_x] == input_grid[middle_x + 1:][::-1]):\n        output_grid = np.full((1,1), Color.BLUE)\n    else:\n        output_grid = np.full((1,1), Color.ORANGE)\n    \n    return output_grid\n\ndef generate_input():\n    width, height = 3, 3\n    grid = np.zeros((width, height), dtype=int)\n    \n    # Randomly generate a 3x3 grid with symmetric pattern or not.\n    has_y_axis_symmetry = np.random.choice([True, False])\n    symmetry_type = \"horizontal\" if has_y_axis_symmetry else \"not_symmetric\"\n    density = random.choice([0.3, 0.4, 0.5, 0.6])\n    grid = random_sprite(n=3, m=3, density=density, color_palette=[Color.RED], symmetry=symmetry_type)\n    \n    # If the pattern is not symmetric, scatter some black pixels on the grid to make it not symmetric.\n    if not has_y_axis_symmetry:\n        # Randomly 40% colored pixels on the grid\n        target_density = 0.4\n        target_number_of_pixels = int(target_density * height * width)\n        for i in range(target_number_of_pixels):\n            x = np.random.randint(0, width)\n            y = np.random.randint(0, height)\n            grid[x, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/63/images/test_input.png", "output": "output/seeds/seed_examples/63/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/63/images/train_input_0.png", "output": "output/seeds/seed_examples/63/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/63/images/train_input_1.png", "output": "output/seeds/seed_examples/63/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/63/images/train_input_2.png", "output": "output/seeds/seed_examples/63/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/63/images/train_input_3.png", "output": "output/seeds/seed_examples/63/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/63/images/train_input_4.png", "output": "output/seeds/seed_examples/63/images/train_output_4.png"}, {"input": "output/seeds/seed_examples/63/images/train_input_5.png", "output": "output/seeds/seed_examples/63/images/train_output_5.png"}]}, "index": 63, "seed": "44f52bb0", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, resizing\n\n# description:\n# In the input, you will see a grid with a row of colored blocks on the bottom and the right. \n# There is also a square in the top left that is not touching the other colors.\n# To make the output:\n# 1. count the number of colors that aren\u0027t black\n# 2. enlarge every pixel in the input by a factor of the number of colors\n# 3. add diagonal red lines coming out of the corners of the square in the top left portion of the grid\n\ndef transform(input_grid):\n    # count the number of colors that aren\u0027t black\n    num_colors = len(set(input_grid.flatten())) - 1\n\n    # magnify the pixels in input grid onto the output grid\n    output_grid = np.repeat(np.repeat(input_grid, num_colors, axis=0), num_colors, axis=1)\n\n    # find the square in the output grid\n    objects = find_connected_components(output_grid, connectivity=8, monochromatic=False)\n    for obj in objects:\n        # the square is the only object not in the bottom right corner\n        if obj[-1,-1] == Color.BLACK:\n            square = obj\n            break\n    \n    # find the bounding box of the square\n    x, y, w, h = bounding_box(square)\n\n    # draw the diagonal red lines\n    draw_line(output_grid, x - 1, y - 1, length=None, color=Color.RED, direction=(-1,-1), stop_at_color=Color.NOT_BLACK)\n    draw_line(output_grid, x + w, y + h, length=None, color=Color.RED, direction=(1,1), stop_at_color=Color.NOT_BLACK)\n    draw_line(output_grid, x - 1, y + h, length=None, color=Color.RED, direction=(-1,1), stop_at_color=Color.NOT_BLACK)\n    draw_line(output_grid, x + w, y - 1, length=None, color=Color.RED, direction=(1,-1), stop_at_color=Color.NOT_BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # make a 5x5 black grid for the background\n    n = m = 5\n    grid = np.zeros((n,m), dtype=int)\n\n    # pick the colors for the bottom and right of the grid\n    colors = list(Color.NOT_BLACK)\n\n    # construct a random sequence of colors for the bottom and right of the grid\n    # don\u0027t repeat a color in the sequence\n    sequence = []\n    while len(sequence) \u003c 5:\n        # select a color\n        color = np.random.choice(colors)\n        # remove the color from the array of remaining colors\n        colors = np.delete(colors, np.where(colors == color))\n        length = np.random.randint(1, 6 - len(sequence))\n        sequence.extend([color] * length)\n\n    # put the same sequence on the bottom and right of the grid\n    grid[-1, :] = sequence\n    grid[:, -1] = sequence\n\n    # pick the color of the square\n    square_color = np.random.choice(list(Color.NOT_BLACK))\n    \n    # make the square\n    square_sprite = random_sprite(2, 2, density=1, color_palette=[square_color])\n\n    # put the square on the grid so it doesn\u0027t touch the bottom or right\n    x, y = random_free_location_for_sprite(grid, square_sprite, padding=1)\n    blit_sprite(grid, square_sprite, x, y)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/64/images/test_input.png", "output": "output/seeds/seed_examples/64/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/64/images/train_input_0.png", "output": "output/seeds/seed_examples/64/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/64/images/train_input_1.png", "output": "output/seeds/seed_examples/64/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/64/images/train_input_2.png", "output": "output/seeds/seed_examples/64/images/train_output_2.png"}]}, "index": 64, "seed": "469497ad", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling\n\n# description:\n# In the input you will see a grid with different colors of pixels scattered on the grid\n# To make the output grid, you should first only scale the pixels by 2 times,\n# then scale in whole grid 2 times.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect all the colored pixels\n    # 2. Rescale each such sprite\n    # 3. Blit the rescaled sprite onto the output grid, taking care to anchor it correctly\n    # 4. Rescale the output grid (2x)\n\n    # Detect all the colored pixels in the input grid\n    pixel_objects = detect_objects(grid=input_grid, colors=Color.NOT_BLACK,\n                            # These are single pixels, so they are 1x1\n                            allowed_dimensions=[(1, 1)],\n                            monochromatic=True, connectivity=4)\n\n    # Initialize the output grid with the same size as the input grid\n    output_grid = np.copy(input_grid)\n\n    scale_factor = 2\n    for obj in pixel_objects:\n        # Get the position of each colored pixel, and crop it to produce a sprite\n        x, y = object_position(obj, background=Color.BLACK, anchor=\"upper left\")\n        single_pixel_sprite = crop(obj, background=Color.BLACK)\n\n        # Scale the sprite by `scale_factor` times\n        scaled_sprite = scale_sprite(single_pixel_sprite, scale_factor)\n\n        # The coordinate of the scaled pattern (anchored at the upper left)\n        new_x, new_y = x - scale_factor + 1, y - scale_factor + 1\n\n        # Put the scaled pattern on the output grid\n        output_grid = blit_sprite(grid=output_grid, x=new_x, y=new_y, sprite=scaled_sprite, background=Color.BLACK)\n    \n    # Scale the whole grid by scale_factor times\n    output_grid = scale_sprite(output_grid, scale_factor)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_size = 10\n    grid = np.zeros((grid_size, grid_size), dtype=int)\n\n    # randomly scatter the pixels on the grid with only every scaling_factor coordinates\n    # Leave enough space for scaling\n    density = 0.4\n    scaling_factor = 2\n    colors = Color.NOT_BLACK\n    for x in range(1, grid_size, scaling_factor):\n        for y in range(1, grid_size, scaling_factor):\n            # Randomly scatter the pixels on the grid\n            if np.random.rand() \u003c density:\n                grid[x, y] = np.random.choice(colors)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/65/images/test_input.png", "output": "output/seeds/seed_examples/65/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/65/images/train_input_0.png", "output": "output/seeds/seed_examples/65/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/65/images/train_input_1.png", "output": "output/seeds/seed_examples/65/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/65/images/train_input_2.png", "output": "output/seeds/seed_examples/65/images/train_output_2.png"}]}, "index": 65, "seed": "46f33fce", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object extraction, contact, cropping\n\n# description:\n# In the input you will see several objects with same color placed in a 10x10 grid, only one of \n# them contact a gray pixel.\n# To make the output grid, you should select the object contact the gray pixel, crop it, and then output it.\n\ndef transform(input_grid):\n    # Get the color of the pattern\n    pattern_color = [color for color in np.unique(input_grid) if color != Color.BLACK and color != Color.GRAY][0]\n\n    # Detect all the patterns with pattern color in the input grid\n    pattern_list = detect_objects(grid=input_grid, colors=[pattern_color], connectivity=8, monochromatic=True)\n\n    # Detect the indicator gray pixel\n    gray_pixel = detect_objects(grid=input_grid, colors=[Color.GRAY], connectivity=8, monochromatic=True)[0]\n\n    # Find out which pattern has contact the gray pixel\n    for pattern in pattern_list:\n        cropped_pattern = crop(grid=pattern)\n        # Check if the gray pixel contact the pattern\n        if contact(object1=pattern, object2=gray_pixel, connectivity=4):\n            # Crop the pattern and output it\n            output_grid = cropped_pattern\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Generate a 10x10 grid with several objects with same color placed in it\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # Select a color for the objects and the number of objects.\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.GRAY]\n    obj_color = random.choice(available_colors)\n    num_sprite = np.random.randint(2,4)\n\n    # Place the objects in the grid.\n    for i in range(num_sprite):\n        # Create a 3x3 object with the selected color and random pattern.\n        sprite = random_sprite(n=3, m=3, color_palette=[obj_color], density=0.4)\n        # Place the object in the grid.\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8, border_size=1)\n        except:\n            continue\n        # Add a gray pixel to contact one of the object.\n        if i == 0:\n            grid[x + 1, y - 1] = Color.GRAY\n            # Make sure the grey pixel contact the object.\n            grid[x + 1, y] = obj_color\n        # Place the object in the grid.\n        grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n            \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/66/images/test_input.png", "output": "output/seeds/seed_examples/66/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/66/images/train_input_0.png", "output": "output/seeds/seed_examples/66/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/66/images/train_input_1.png", "output": "output/seeds/seed_examples/66/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/66/images/train_input_2.png", "output": "output/seeds/seed_examples/66/images/train_output_2.png"}]}, "index": 66, "seed": "48d8fb45", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, reflection\n\n# description:\n# In the input you will see a small monochromatic pattern with reflectional symmetry (horizontal and vertical), as well as another monochromatic object in one of its quadrants.\n# To make the output, reflect the other object across the axes of reflectional symmetry of the small pattern.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the pair of objects and divide them by whether or not they are already symmetric\n    # 2. Reflect the non-symmetric object across the axes of symmetry of the symmetric object\n\n    # 1. Object detection and setup\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK)\n    assert len(objects) == 2\n\n    # Find the object that is symmetric\n    symmetric_object = None\n    for obj in objects:\n        # Detect all symmetry\n        # There is no occlusion so and don\u0027t ignore any colors\n        # But we know the background is black\n        symmetries = detect_mirror_symmetry(obj, ignore_colors=[], background=Color.BLACK)\n\n        # actually finds three symmetries: horizontal, vertical, and diagonal mirroring\n        if len(symmetries) \u003e= 2:\n            symmetric_object = obj\n            break\n    assert symmetric_object is not None, \"There should be a symmetric object\"\n\n    # Find the object that is not symmetric\n    non_symmetric_object = next(obj for obj in objects if obj is not symmetric_object)\n\n    # 2. Reflect the non-symmetric object across the axes of symmetry of the symmetric object\n    output_grid = input_grid.copy()\n\n    for x, y in np.argwhere(non_symmetric_object != Color.BLACK):\n        original_color = non_symmetric_object[x, y]\n        for transformed_x, transformed_y in orbit(output_grid, x, y, symmetries=symmetries):\n            output_grid[transformed_x, transformed_y] = original_color\n    \n    return output_grid\n        \n\n\n\ndef generate_input():\n    \n    grid = np.full((random.choice(range(15, 30+1)), random.choice(range(15, 30+1))), Color.BLACK)\n\n    # We are going to generate a grid with a symmetric pattern and a non-symmetric object in one of its quadrants\n    \n    # Generate the symmetric pattern\n    symmetric_sprite = random_sprite(range(3, 6), range(3, 6),\n                                     color_palette=[random.choice(Color.NOT_BLACK)], connectivity=8, \n                                     symmetry=\"mirror\")    \n\n    # Generate the non-symmetric object\n    non_symmetric_sprite = random_sprite(range(7,10), range(7,10),\n                                         color_palette=[random.choice(Color.NOT_BLACK)], connectivity=8, \n                                         symmetry=\"not_symmetric\")\n    \n    # Randomly place the small symmetric object with enough padding so that the non symmetric one can go in one of its quadrants\n    x_symmetric, y_symmetric = random_free_location_for_sprite(grid, symmetric_sprite, border_size=max(non_symmetric_sprite.shape))\n    blit_sprite(grid, symmetric_sprite, x_symmetric, y_symmetric)\n\n    # Put the other sprite in the lower right quadrant, and then randomly rotate at the end to get a variety of possible placements\n    x_non_symmetric = x_symmetric + symmetric_sprite.shape[0] + 1\n    y_non_symmetric = y_symmetric + symmetric_sprite.shape[1] + 1\n    blit_sprite(grid, non_symmetric_sprite, x_non_symmetric, y_non_symmetric)\n\n    # random rotation\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/67/images/test_input.png", "output": "output/seeds/seed_examples/67/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/67/images/train_input_0.png", "output": "output/seeds/seed_examples/67/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/67/images/train_input_1.png", "output": "output/seeds/seed_examples/67/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/67/images/train_input_2.png", "output": "output/seeds/seed_examples/67/images/train_output_2.png"}]}, "index": 67, "seed": "4c5c2cf0", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bouncing\n\n# description:\n# In the input you will see a short diagonal teal line pointing at a red rectangle on a black background.\n# To make the output, shoot outward from the teal line, but change the color to green. Reflect off the red rectangle.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the objects\n    # 2. Determine the orientation of the teal line, and its endpoints\n    # 3. Shoot a green line outward until it hits the red rectangle\n    # 4. Reflect the green line off the red rectangle, continuing in green\n\n    teal_line = detect_objects(input_grid, colors=[Color.TEAL], monochromatic=True, connectivity=8)\n    assert len(teal_line) == 1, \"There should be exactly one teal line\"\n    teal_line = list(teal_line)[0]\n    red_rectangle = detect_objects(input_grid, colors=[Color.RED], monochromatic=True, connectivity=8)\n    assert len(red_rectangle) == 1, \"There should be exactly one red rectangle\"\n    red_rectangle = list(red_rectangle)[0]\n\n    output_grid = input_grid.copy()\n\n    # To get the orientation of a line, find the endpoints and compare their x and y coordinates\n    x1, y1 = max( (x, y) for x, y in np.argwhere(teal_line == Color.TEAL) )\n    x2, y2 = min( (x, y) for x, y in np.argwhere(teal_line == Color.TEAL) )\n    direction12 = (int(np.sign(x2 - x1)), int(np.sign(y2 - y1)))\n    direction21 = (-direction12[0], -direction12[1])\n\n    # Try both (direction, x2, y2) and (-direction, x1, y1) as starting points\n    for (dx,dy), start_x, start_y in [ (direction12, x2, y2), (direction21, x1, y1) ]:\n        start_x += dx\n        start_y += dy\n        # Loop, shooting lines off of red things, until we run out of the canvas\n        while 0 \u003c= start_x \u003c input_grid.shape[0] and 0 \u003c= start_y \u003c input_grid.shape[1]:\n            stop_x, stop_y = draw_line(output_grid, start_x, start_y, direction=(dx,dy), color=Color.GREEN, stop_at_color=[Color.RED])\n\n            # reflection geometry depends on if we hit the red rectangle on our left/right/up/down\n            # did we hit the red rectangle on our right? \n            if stop_x+1 \u003c output_grid.shape[0] and output_grid[stop_x+1, stop_y] != Color.BLACK:\n                dx = -dx\n            # did we hit the red rectangle on our left?\n            elif stop_x-1 \u003e= 0 and output_grid[stop_x-1, stop_y] != Color.BLACK:\n                dx = -dx\n            # did we hit the red rectangle on our bottom?\n            elif stop_y+1 \u003c output_grid.shape[1] and output_grid[stop_x, stop_y+1] != Color.BLACK:\n                dy = -dy\n            # did we hit the red rectangle on our top?\n            elif stop_y-1 \u003e= 0 and output_grid[stop_x, stop_y-1] != Color.BLACK:\n                dy = -dy\n            else:\n                # didn\u0027t do any reflections, so stop\n                break\n\n            start_x, start_y = stop_x + dx, stop_y + dy\n    \n    return output_grid\n\n\ndef generate_input():\n    # Make a grid with a red rectangle on the bottom and a teal diagonal line at the top pointing at it\n    # Then randomly rotate to get a variety of orientations\n\n    width, height = np.random.randint(10, 25), np.random.randint(8, 10)\n    grid = np.full((width, height), Color.BLACK)\n\n    red_height = np.random.randint(2, 5)\n    grid[:, -red_height:] = Color.RED\n\n    # Make a diagonal line, which always begins at the top\n    line_x = np.random.randint(0, width//2)\n    # always begins at the top\n    line_y = 0\n\n    draw_line(grid, line_x, line_y, direction=(1, 1), color=Color.TEAL, length=2)\n\n    # randomly rotate to get a variety of orientations\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/68/images/test_input.png", "output": "output/seeds/seed_examples/68/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/68/images/train_input_0.png", "output": "output/seeds/seed_examples/68/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/68/images/train_input_1.png", "output": "output/seeds/seed_examples/68/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/68/images/train_input_2.png", "output": "output/seeds/seed_examples/68/images/train_output_2.png"}]}, "index": 68, "seed": "508bd3b6", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# collision, translation\n\n# description:\n# In the input you will see a red object overlaid on a track of green dots.\n# To make the output, move the red object one green dot to the right (if the track is horizontal) or one green dot down (if the track is vertical).\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the objects\n    # 2. Determine the orientation of the track of green dots\n    # 3. Move in the appropriate direction until it perfectly fits over the next green dot, meaning there are no collisions\n\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=True)\n\n    red_objects = [ obj for obj in objects if Color.RED in object_colors(obj, background=Color.BLACK) ]\n    green_objects = [ obj for obj in objects if Color.GREEN in object_colors(obj, background=Color.BLACK) ]\n\n    assert len(red_objects) == 1, \"There should be exactly one red object\"\n    assert len(green_objects) \u003e= 1, \"There should be at least one green object\"\n\n    red_object = red_objects[0]\n\n    # Determine the orientation of the track of green dots by comparing the positions of two dots\n    x1,y1 = min( object_position(obj, anchor=\"center\") for obj in green_objects )\n    x2,y2 = max( object_position(obj, anchor=\"center\") for obj in green_objects )\n    if x1 == x2:\n        # vertical track\n        dx, dy = 0, 1\n    elif y1 == y2:\n        # horizontal track\n        dx, dy = 1, 0\n    \n    # Make the output grid: Start with all the greens, then put the red in the right spot by moving it one-by-one\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    for green_object in green_objects:\n        blit_object(output_grid, green_object)\n\n    for distance in range(1, 100):\n        translated_red_object = translate(red_object, dx*distance, dy*distance)\n        if not collision(object1=translated_red_object, object2=output_grid):\n            blit_object(output_grid, translated_red_object)\n            break\n\n    return output_grid\n\ndef generate_input():\n    # Make a grid with a red rectangle on the bottom and a teal diagonal line at the top pointing at it\n    # Then randomly rotate to get a variety of orientations\n\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), Color.BLACK)\n\n    # the red object will be a rectangle with a hole in the middle that the green dot fits into\n    # for the hole to fit perfectly in the middle, it needs to be of odd dimension\n    rectangle_width, rectangle_height = random.choice([3, 5]), random.choice([3, 5])\n    red_rectangle = np.full((rectangle_width, rectangle_height), Color.RED)\n\n    # randomly place the red rectangle at least 5 pixels away from the edge\n    x, y = random_free_location_for_sprite(grid, red_rectangle, background=Color.BLACK, border_size=5)\n    blit_sprite(grid, red_rectangle, x, y, background=Color.BLACK)\n\n    # Create a row of green dots, starting with the center of the rectangle\n    center_x, center_y = object_position(grid, anchor=\"center\", background=Color.BLACK)\n    grid[center_x, center_y] = Color.GREEN\n\n    # create a horizontal row of green dots\n    for i in range(-10, 10):\n        dx = rectangle_width\n        if 0 \u003c= center_x + i*dx \u003c width:\n            grid[center_x + i*dx, center_y] = Color.GREEN\n    \n    # randomly flip/rotate\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/69/images/test_input.png", "output": "output/seeds/seed_examples/69/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/69/images/train_input_0.png", "output": "output/seeds/seed_examples/69/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/69/images/train_input_1.png", "output": "output/seeds/seed_examples/69/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/69/images/train_input_2.png", "output": "output/seeds/seed_examples/69/images/train_output_2.png"}]}, "index": 69, "seed": "5168d44c", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# gravity, falling\n\n# description:\n# In the input you will see various monochromatic objects\n# To make the output, make each object drop a single yellow pixel below it, centered with the middle of the object\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the objects\n    # 2. Drop yellow pixels which land in the final row of the grid, centered with the middle of the object\n\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)\n\n    output_grid = input_grid.copy()\n\n    for obj in objects:\n        x, y = object_position(obj, background=Color.BLACK, anchor=\u0027center\u0027)\n        bottom_y = output_grid.shape[1] - 1\n        output_grid[x, bottom_y] = Color.YELLOW\n    \n    return output_grid\n\n\ndef generate_input():\n    width, height = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.full((width, height), Color.BLACK)\n    \n    n_objects = np.random.randint(1, 5)\n    for _ in range(n_objects):\n        # Make a random sprite with odd width, so that there will be a unique horizontally center pixel \n        widths = [3, 5, 7]\n        heights = [1,2,3,4]\n        sprite = random_sprite(widths, heights, color_palette=[random.choice(Color.NOT_BLACK)])\n        # Find a place for it, but put some padding along the borders so that it\u0027s not at the bottom\n        x, y = random_free_location_for_sprite(grid, sprite, padding=2, border_size=2)\n        # Put it down\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/70/images/test_input.png", "output": "output/seeds/seed_examples/70/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/70/images/train_input_0.png", "output": "output/seeds/seed_examples/70/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/70/images/train_input_1.png", "output": "output/seeds/seed_examples/70/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/70/images/train_input_2.png", "output": "output/seeds/seed_examples/70/images/train_output_2.png"}]}, "index": 70, "seed": "54d82841", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# attraction, magnetism, translation5\n\n# description:\n# In the input you will see a green object and a red bar\n# To make the output, move the green object to touch the red bar. Finally put a teal bar on the other side of the green object.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the objects; separate the green thing from the red bar\n    # 2. Move the green object to touch the red bar\n    # 3. Add a teal bar on the other side of the green object\n\n    # 1. Object detection and setup\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=True)\n\n    red_objects = [ obj for obj in objects if Color.RED in object_colors(obj, background=Color.BLACK) ]\n    green_objects = [ obj for obj in objects if Color.GREEN in object_colors(obj, background=Color.BLACK) ]\n\n    assert len(red_objects) == 1, \"There should be exactly one red object\"\n    assert len(green_objects) == 1, \"There should be exactly one green object\"\n    \n    red_object = red_objects[0]\n    green_object = green_objects[0]\n\n    # Make the output grid: Start with the red object, then add the green object and the teal bar\n    output_grid = np.full_like(input_grid, Color.BLACK)\n    blit_object(output_grid, red_object)\n\n    # 2. Move the green object to touch the red bar\n    # First calculate what direction we have to move in order to contact the grey object\n    # Consider all displacements, starting with the smallest translations first\n    possible_displacements = [ (i*dx, i*dy) for i in range(0, 30) for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)] ]\n\n    # Only keep the displacements that cause a contact between the colored object and the grey object\n    valid_displacements = [ displacement for displacement in possible_displacements\n                            if contact(object1=translate(green_object, *displacement), object2=red_object) ]\n    assert valid_displacements, \"There should be at least one valid displacement\"\n\n    # Pick the smallest valid displacement\n    displacement = min(valid_displacements, key=lambda displacement: sum(abs(x) for x in displacement))\n\n    # Extract the direction from the displacement\n    direction = np.sign(displacement, dtype=int)\n\n    # Translate and draw on the canvas\n    green_object = translate(green_object, *displacement)\n    blit_object(output_grid, green_object)\n\n    # 3. Add a teal bar on the other side of the green object\n    # It should be the same shape as the red bar, but teal\n    # To place it correctly, it needs to be on the other side so we go in the opposite direction that the green object moved\n    teal_object = red_object.copy()\n    teal_object[teal_object != Color.BLACK] = Color.TEAL\n    opposite_direction = -direction\n    # Move the teal object until it doesn\u0027t collide with anything\n    while collision(object1=teal_object, object2=output_grid):\n        teal_object = translate(teal_object, *opposite_direction)\n    # Draw the teal object on the canvas\n    blit_object(output_grid, teal_object)\n    \n    return output_grid\n\ndef generate_input():\n    # Make a long skinny grid with a green thing and a red vertical bar\n    # Then randomly rotate to get a variety of orientations\n\n    width, height = np.random.randint(10, 25), np.random.randint(3, 8)\n    grid = np.full((width, height), Color.BLACK)\n\n    bar_x = np.random.randint(0, width)\n    grid[bar_x, :] = Color.RED\n\n    green_sprite = random_sprite(3, height, color_palette=[Color.GREEN])\n    x, y = random_free_location_for_sprite(grid, green_sprite, background=Color.BLACK, padding=1)\n    blit_sprite(grid, green_sprite, x, y, background=Color.BLACK)\n\n    # random rotation\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/71/images/test_input.png", "output": "output/seeds/seed_examples/71/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/71/images/train_input_0.png", "output": "output/seeds/seed_examples/71/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/71/images/train_input_1.png", "output": "output/seeds/seed_examples/71/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/71/images/train_input_2.png", "output": "output/seeds/seed_examples/71/images/train_output_2.png"}]}, "index": 71, "seed": "56dc2b01", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, puzzle pieces, indicator pixels\n\n# description:\n# In the input you will see objects with exactly 2 colors, each with one pixel/rectangle of a different color as an indicator. The indicator color is the same across objects.\n# To make the output, one of those objects is a template shape that you are going to translate/recolor/rescale to match indicators with each other object.\n# Place the rescaled template on top of the other shape so that the indicators are at the same position, and change color to match what you are placing on top of.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input into template object and other objects, and determine the indicator color\n    # 2. For each other object, rescale+recolor the template to match indicators\n\n    # 1. Parse the input\n\n    # Extract all the objects from the input grid\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, background=background, connectivity=8, monochromatic=False)\n\n    # The indicator pixel\u0027s color appears in all the objects\n    possible_indicator_colors = [ color for color in Color.ALL_COLORS\n                                 if all( color in object_colors(obj, background=background) for obj in objects)]\n    assert len(possible_indicator_colors) == 1, \"There should be exactly one indicator color\"\n    indicator_color = possible_indicator_colors[0]\n\n    # Find the template object, which is the biggest object after you scale the indicator down to have size 1x1\n    object_sizes = [ np.sum(obj != background) for obj in objects]\n    indicator_sizes = [ np.sum(obj == indicator_color) for obj in objects]\n    rescaled_sizes = [size // indicator_size for size, indicator_size in zip(object_sizes, indicator_sizes)]\n    template_index = np.argmax(rescaled_sizes)\n    template_object = objects[template_index]\n    other_objects = [obj for i, obj in enumerate(objects) if i != template_index]\n\n    template_sprite = crop(template_object, background=background)\n\n    # 2. For each other object, rescale+recolor the template to match indicators\n    # Determine the scaling factor by the ratio of the size of the indicator pixel region\n    # Determine the color according to the non-indicator color of the object\n    # Determine the position so that indicator pixels are overlaid\n\n    # To produce the output we draw on top of the input\n    output_grid = input_grid.copy()\n\n    for other_object in other_objects:\n\n        # Find the new shape\u0027s color\n        new_color = [ color for color in object_colors(other_object, background=background) if color != indicator_color][0]\n\n        # find the new scale, which is the ratio of the size of the indicator pixel in the original shape to the size of the indicator pixel in the new shape\n        new_scale = crop(other_object == indicator_color).shape[0] // crop(template_object == indicator_color).shape[0]\n\n        # Scale the original template to the same scale...\n        template_sprite_scaled = scale_sprite(template_sprite, new_scale)\n        # ...and change its color to the new shape\u0027s color\n        template_sprite_scaled[(template_sprite_scaled != background) \u0026 (template_sprite_scaled != indicator_color)] = new_color\n\n        # Overlay the indicator pixels from the scaled/recolored template sprite with the indicator pixels from the other object\n        x = np.min(np.argwhere(other_object == indicator_color)[:,0]) - np.min(np.argwhere(template_sprite_scaled == indicator_color)[:,0])\n        y = np.min(np.argwhere(other_object == indicator_color)[:,1]) - np.min(np.argwhere(template_sprite_scaled == indicator_color)[:,1])\n        blit_sprite(output_grid, template_sprite_scaled, x=x, y=y)\n        \n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    background = Color.BLACK\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), background)\n\n    # Randomly select the color of objects and indicator, which should all be distinct\n    n_objects = np.random.randint(2, 4)\n    colors = np.random.choice(Color.NOT_BLACK, n_objects + 1, replace=False)\n    indicator_color, template_color, other_colors = colors[0], colors[1], colors[2:]\n\n    # Ensure the shapes after completion do not overlap by having a canvas that shows what things will look like after producing the output\n    output_grid = grid.copy()    \n\n    # Generate the original shape\n    w, h = np.random.randint(3, 5), np.random.randint(3, 5)\n    template_sprite = random_sprite(w, h, color_palette=[template_color], connectivity=4)\n\n    # Randomly turn one pixel into the indicator pixel\n    indicator_pixel = random.choice(np.argwhere(template_sprite == template_color))\n    template_sprite[indicator_pixel[0], indicator_pixel[1]] = indicator_color\n\n    # Place the template on the grid, and on the predicted output\n    x, y = random_free_location_for_sprite(grid=output_grid, sprite=template_sprite)\n    blit_sprite(grid, sprite=template_sprite, x=x, y=y)\n    blit_sprite(output_grid, sprite=template_sprite, x=x, y=y)\n\n    # Check which pixels are neighbors of the indicator pixel, which will be included in the other objects\n    neighbor_mask = (template_sprite == template_color) \u0026 object_neighbors(template_sprite == indicator_color, connectivity=8)\n    \n    # Place the other objects\n    for other_color in other_colors:\n        # there is the completed other object which will be in the output, and the uncompleted other object which will be in the input\n        complete_other_object = template_sprite.copy()\n        complete_other_object[complete_other_object == template_color] = other_color\n\n        # Make the incomplete object, which just has the indicator pixel plus one of its neighbors\n        incomplete_other_object = template_sprite.copy()\n        incomplete_other_object[incomplete_other_object == template_color] = background        \n        neighbor_x, neighbor_y = random.choice(np.argwhere(neighbor_mask))\n        incomplete_other_object[neighbor_x, neighbor_y] = other_color\n\n        # Rescale both\n        scale = np.random.randint(1, 4)\n        complete_other_object = scale_sprite(complete_other_object, scale)\n        incomplete_other_object = scale_sprite(incomplete_other_object, scale)\n\n        # Place the complete object on the predicted output\n        x, y = random_free_location_for_sprite(output_grid, complete_other_object, padding=1, padding_connectivity=8)\n        blit_sprite(output_grid, complete_other_object, x=x, y=y)\n\n        # place the incomplete object such that its indicators overlap at the same location\n        x -= np.min(np.argwhere(complete_other_object == indicator_color)[:,0]) - np.min(np.argwhere(incomplete_other_object == indicator_color)[:,0])\n        y -= np.min(np.argwhere(complete_other_object == indicator_color)[:,1]) - np.min(np.argwhere(incomplete_other_object == indicator_color)[:,1])\n        blit_sprite(grid, incomplete_other_object, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/72/images/test_input.png", "output": "output/seeds/seed_examples/72/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/72/images/train_input_0.png", "output": "output/seeds/seed_examples/72/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/72/images/train_input_1.png", "output": "output/seeds/seed_examples/72/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/72/images/train_input_2.png", "output": "output/seeds/seed_examples/72/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/72/images/train_input_3.png", "output": "output/seeds/seed_examples/72/images/train_output_3.png"}]}, "index": 72, "seed": "57aa92db", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# repeating pattern, connecting colors\n\n# description:\n# In the input grid, you will see an all black grid with three dots of the same color in a perfect 45 degree diagonal, but equally spaced apart from each other.\n# To create the output grid, connect the outer two of the three dots with a square border shape. The square border contains the two dots as corners, and is centered on the third center dot. Then make another square border that is the same distance (number of background cells) from the existing border as the existing border is from the center dot. Repeat making square borders of the same distance outwards until the grid is filled.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. get the dots\n    # 2. get the center dot, and the two outer dots\n    # 3. calculate the distance from the center dot of the outer dots.\n    # 4. make a helper function for drawing a square of a certain distance from the center dot\n    # 5. repeat making squares of multiples of that distance until no new cells are filled in on the grid.\n\n    # get a list of locations\n    pixel_xs, pixel_ys = np.where(input_grid != Color.BLACK)\n    pixel_locations = list(zip(list(pixel_xs), list(pixel_ys)))\n    assert len(pixel_locations) == 3\n    \n    # sort by x coordinate\n    pixel0, pixel1, pixel2 = sorted(pixel_locations, key=lambda l: l[0])\n    color = input_grid[pixel0[0], pixel0[1]]\n    width = pixel1[0] - pixel0[0]\n\n    def in_bounds(grid, x, y):\n        return 0 \u003c= x \u003c grid.shape[0] and 0 \u003c= y \u003c grid.shape[1]\n\n    def draw_square_border(grid, x, y, w, h, color):\n        # x, y is the top left corner\n        for dx in range(w+1):\n            # top border\n            if in_bounds(grid, x+dx, y):\n                grid[x+dx, y] = color\n            # bottom border\n            if in_bounds(grid, x+dx, y+h):\n                grid[x+dx, y+h] = color\n        for dy in range(h+1):\n            # left border\n            if in_bounds(grid, x, y+dy):\n                grid[x, y+dy] = color\n            # right border\n            if in_bounds(grid, x+w, y+dy):\n                grid[x+w, y+dy] = color\n\n    output_grid = input_grid.copy()\n    i = 1\n    while True:\n        top_left_x = pixel1[0] - width * i\n        top_left_y = pixel1[1] - width * i\n        w = 2 * (width * i)\n        old_grid = output_grid.copy()\n        draw_square_border(output_grid, top_left_x, top_left_y, w, w, color)\n        if not np.any(old_grid != output_grid):\n            break\n        i += 1\n\n    return output_grid\n\ndef generate_input():\n    # 1. make a 28x28 black grid\n    # 2. choose a distance from the center between 1 and 10\n    # 3. make the three initial dots on a grid\n    # 4. blit onto a random spot on the black grid\n    input_grid = np.full((28,28), Color.BLACK)\n    distance = np.random.randint(2, 11)\n    color = np.random.choice(Color.NOT_BLACK)\n    center_x = np.random.randint(distance, 28 - distance)\n    center_y = np.random.randint(distance, 28 - distance)\n    input_grid[center_x, center_y] = color\n    input_grid[center_x - distance, center_y - distance] = color\n    input_grid[center_x + distance, center_y + distance] = color\n    # randomly rotate the input grid sometimes\n    if np.random.rand() \u003c 0.55:\n        input_grid = np.rot90(input_grid)\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/73/images/test_input.png", "output": "output/seeds/seed_examples/73/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/73/images/train_input_0.png", "output": "output/seeds/seed_examples/73/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/73/images/train_input_1.png", "output": "output/seeds/seed_examples/73/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/73/images/train_input_2.png", "output": "output/seeds/seed_examples/73/images/train_output_2.png"}]}, "index": 73, "seed": "5c2c9af4", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern extraction, pixel expanding\n\n# description:\n# In the input you will see four lines of different colors intersecting and forming a rectangle.\n# Few pixels of one specific line\u0027s color are scattered in the grid.\n# To make the output, you should cropped out the rectangle and extend the scatterd pixels to \n# the specific line which has same color as the scattered pixels.\n\ndef transform(input_grid: np.ndarray) -\u003e np.ndarray:\n    output_grid = np.copy(input_grid)\n    \n    # Identify two vertical and two horizontal lines\n    horizontal_lines = np.where(np.all(output_grid != Color.BLACK, axis=1))[0]\n    vertical_lines = np.where(np.all(output_grid != Color.BLACK, axis=0))[0]\n    \n    # Find out the color of the scattered pixels\n    mask = np.ones(output_grid.shape, dtype=bool)\n    mask[horizontal_lines, :] = False\n    mask[:, vertical_lines] = False\n    color = output_grid[mask \u0026 (output_grid != Color.BLACK)][0]\n    \n    # Crop the grid by the rectangle formed by the four lines\n    output_grid = output_grid[horizontal_lines[0] : horizontal_lines[1] + 1, vertical_lines[0] : vertical_lines[1] + 1]\n    \n    # Extend the scattered pixels to the line that has same color as the scattered pixels\n    for x in range(len(output_grid)):\n        for y in range(len(output_grid[0])):\n            # did we find a scattered pixel? (of color `color`)\n            if output_grid[x, y] == color:\n                # draw a line to the matching color line, which is going to be either left/right/top/bottom\n                # so we need to examine four cases for each location that the matching color line might be\n\n                # Left: x=0 indicates this is the left line\n                if output_grid[0, y] == color:\n                    draw_line(output_grid, x, y, end_x = 0, end_y = y, color = color)\n                # Right: x=len(output_grid) - 1 indicates this is the right line\n                if output_grid[len(output_grid) - 1, y] == color:\n                    draw_line(output_grid, x, y, end_x = len(output_grid) - 1, end_y = y, color = color)\n                # Top: y=0 indicates this is the top line\n                if output_grid[x, 0] == color:\n                    draw_line(output_grid, x, y, end_x = x, end_y = 0, color = color)\n                # Bottom: y=len(output_grid[0]) - 1 indicates this is the bottom line\n                if output_grid[x, len(output_grid[0]) - 1] == color:\n                    draw_line(output_grid, x, y, end_x = x, end_y = len(output_grid[0]) - 1, color = color)\n\n    return output_grid\n\ndef generate_input() -\u003e np.ndarray:\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly get the position of two horizontal and two vertical lines\n    # The lines form a rectangle\n    horizontal_lines_pos = [np.random.randint(1, n // 2), np.random.randint(n // 2 + 1, n - 1)]\n    vertical_lines_pos = [np.random.randint(1, m // 2), np.random.randint(m // 2 + 1, m - 1)]\n    \n    # Generate four different colors for four lines\n    line_colors = np.random.choice(Color.NOT_BLACK, 4, replace=False)\n\n    # Randomly choose a color from line and create several scattered pixels of that color\n    scattered_pixel_color = random.choice(line_colors)\n    randomly_scatter_points(grid, color=scattered_pixel_color, density=0.2)\n    \n    # Randomly determine order for placing colored lines\n    lines_pos = [(horizontal_lines_pos[0], 0), (horizontal_lines_pos[1], 0), (0, vertical_lines_pos[0]), (0, vertical_lines_pos[1])]\n    random.shuffle(lines_pos)\n\n    # Draw four lines on the grid\n    for i in range(len(lines_pos)):\n        line_x, line_y = lines_pos[i]\n\n        # Draw horizontal line\n        if line_y == 0:\n            draw_line(grid = grid, x = line_x, y = 0, end_x = line_x, end_y = m, color = line_colors[i])\n        \n        # Draw vertical line\n        if line_x == 0:\n            draw_line(grid = grid, x = 0, y = line_y, end_x = n, end_y = line_y, color = line_colors[i])\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/74/images/test_input.png", "output": "output/seeds/seed_examples/74/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/74/images/train_input_0.png", "output": "output/seeds/seed_examples/74/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/74/images/train_input_1.png", "output": "output/seeds/seed_examples/74/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/74/images/train_input_2.png", "output": "output/seeds/seed_examples/74/images/train_output_2.png"}]}, "index": 74, "seed": "5daaa586", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines\n\n# description:\n# In the input you will see one colored pixel on a black background.\n# To make the output, make two diagonal lines that are the same color as the colored pixel and intersect at the location of the colored pixel.\n\ndef transform(input_grid):\n    # make output grid\n    output_grid = np.copy(input_grid)\n\n    # get the index of the colored pixel\n    x, y, width, height = bounding_box(input_grid != Color.BLACK)\n    \n    # get color from colored pixel\n    color = input_grid[x,y]\n\n    # draw diagonals\n    # first diagonal\n    draw_line(output_grid, x, y, length=None, color=color, direction=(1, -1))\n    draw_line(output_grid, x, y, length=None, color=color, direction=(-1, 1))\n    # second diagonal\n    draw_line(output_grid, x, y, length=None, color=color, direction=(-1, -1))\n    draw_line(output_grid, x, y, length=None, color=color, direction=(1, 1))\n\n    return output_grid\n\n    \n\n\n\ndef generate_input():\n    # make a square black grid for the background first\n    n = m = np.random.randint(5, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # put a randomly colored pixel at a random point on the grid\n    color = random.choice(list(Color.NOT_BLACK))\n    x, y = np.random.randint(0, n-1), np.random.randint(0, m-1)\n    grid[x,y] = color\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/75/images/test_input.png", "output": "output/seeds/seed_examples/75/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/75/images/train_input_0.png", "output": "output/seeds/seed_examples/75/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/75/images/train_input_1.png", "output": "output/seeds/seed_examples/75/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/75/images/train_input_2.png", "output": "output/seeds/seed_examples/75/images/train_output_2.png"}]}, "index": 75, "seed": "623ea044", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling\n\n# description:\n# The input consists of a black grid. The grid is divided with red lines into black rectangles of different sizes.\n# To produce the output grid, fill in the smallest black rectangles with teal, and fillin in the largest black rectangles with blue.\n\ndef transform(input_grid):\n    # to get the black rectangles, find connected components with red as background\n    objects = find_connected_components(input_grid, background=Color.RED, connectivity=4, monochromatic=True)\n\n    # get object areas\n    object_areas = [np.sum(obj == Color.BLACK) for obj in objects]\n\n    # find the smallest and largest areas\n    smallest_area = min(object_areas)\n    largest_area = max(object_areas)\n\n    # fill in the smallest rectangles with teal, and the largest rectangles with blue\n    new_objects = []\n    for obj in objects:\n        area = np.sum(obj == Color.BLACK)\n        if area == smallest_area:\n            obj[obj == Color.BLACK] = Color.TEAL\n        elif area == largest_area:\n            obj[obj == Color.BLACK] = Color.BLUE\n        new_objects.append(obj)\n\n    # create an output grid to store the result\n    output_grid = np.full(input_grid.shape, Color.RED)\n\n    # blit the objects back into the grid\n    for obj in new_objects:\n        blit_object(output_grid, obj, background=Color.RED)\n\n    return output_grid\n\n\ndef generate_input():\n    # create a grid of size 10-20x10-20\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    grid = np.full((n, m), Color.BLACK)\n\n    num_lines = np.random.randint(3, 15)\n\n    for i in range(num_lines):\n        # add a red line to divide the grid somewhere\n        x, y = np.random.randint(2, n-1), np.random.randint(2, m-1)\n        # make sure we\u0027re not neighboring a red line already\n        if Color.RED in [grid[x, y+1], grid[x, y-1], grid[x+1, y], grid[x-1, y]]:\n            continue\n\n        horizontal = np.random.choice([True, False])\n        if horizontal:\n            draw_line(grid, x, y, direction=(1, 0), color=Color.RED, stop_at_color=[Color.RED])\n            draw_line(grid, x-1, y, direction=(-1, 0), color=Color.RED, stop_at_color=[Color.RED])\n        else:\n            draw_line(grid, x, y, direction=(0, 1), color=Color.RED, stop_at_color=[Color.RED])\n            draw_line(grid, x, y-1, direction=(0, -1), color=Color.RED, stop_at_color=[Color.RED])\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/76/images/test_input.png", "output": "output/seeds/seed_examples/76/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/76/images/train_input_0.png", "output": "output/seeds/seed_examples/76/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/76/images/train_input_1.png", "output": "output/seeds/seed_examples/76/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/76/images/train_input_2.png", "output": "output/seeds/seed_examples/76/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/76/images/train_input_3.png", "output": "output/seeds/seed_examples/76/images/train_output_3.png"}]}, "index": 76, "seed": "6455b5f5", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# puzzle pieces,\n\n# description:\n# In the input you will see two monochromatic objects -- \"puzzle pieces\"\n# To make the output, fit the pieces together so that they form a single tightly-packed rectangular object. The pieces can be translated, but not rotated.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the pieces\n    # 2. Consider different ways of placing them together\n    # 3. Pick the way which makes them the most tightly packed, meaning that there is as little empty pixels remaining as possible\n\n    # 1. Extract puzzle pieces\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=True)\n    assert len(objects) == 2, \"There should be exactly 2 objects\"\n    sprites = [ crop(obj, background=Color.BLACK) for obj in objects ]\n    \n    width = max(sprite.shape[0] for sprite in sprites) + min(sprite.shape[0] for sprite in sprites)\n    height = max(sprite.shape[1] for sprite in sprites) + min(sprite.shape[1] for sprite in sprites)\n    output_grid = np.full((width, height), Color.BLACK)\n\n    # 2. Try to fit the pieces together\n    possible_placements = [ (x1, x2, y1, y2)\n                           for x1 in range(width - sprites[0].shape[0] + 1)\n                           for x2 in range(width - sprites[1].shape[0] + 1)\n                           for y1 in range(height - sprites[0].shape[1] + 1)\n                           for y2 in range(height - sprites[1].shape[1] + 1) \n                           if not collision(object1=sprites[0], object2=sprites[1], x1=x1, x2=x2, y1=y1, y2=y2) ]\n    \n    def score_placement(x1, x2, y1, y2):\n        # We are trying to make the puzzle pieces fit together perfectly\n        # Therefore, there shouldn\u0027t be very many unfilled (black) pixels remaining after we place the pieces\n        # So we are minimizing the number of black pixels\n        # Equivalently maximizing the negative number of black pixels\n        test_canvas = np.full_like(output_grid, Color.BLACK)\n        blit_sprite(test_canvas, sprites[0], x1, y1)\n        blit_sprite(test_canvas, sprites[1], x2, y2)\n        test_canvas = crop(test_canvas, background=Color.BLACK)\n        return -np.sum(test_canvas == Color.BLACK)\n    \n    # pick the best one\n    x1, x2, y1, y2 = max(possible_placements, key=lambda placement: score_placement(*placement))\n    blit_sprite(output_grid, sprites[0], x1, y1)\n    blit_sprite(output_grid, sprites[1], x2, y2)\n\n    return crop(output_grid, background=Color.BLACK)\n\ndef generate_input():\n    # Create a 2-color object and then break it up into 2 pieces\n    two_color = random_sprite([2,3,4], [2,3,4], density=1, color_palette=Color.NOT_BLACK, background=Color.BLACK)\n    if len(object_colors(two_color, background=Color.BLACK)) != 2:\n        return generate_input()\n    \n    # break it up into 2 pieces\n    pieces = find_connected_components(two_color, connectivity=8, background=Color.BLACK, monochromatic=True)\n    if len(pieces) != 2:\n        return generate_input()\n    \n    # convert them to sprites and then randomly place them on a big canvas\n    sprites = [ crop(piece, background=Color.BLACK) for piece in pieces ]\n    width, height = np.random.randint(10, 20), np.random.randint(10, 20)\n    grid = np.full((width, height), Color.BLACK)\n    for sprite in sprites:\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n        blit_sprite(grid, sprite, x, y, background=Color.BLACK)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/77/images/test_input.png", "output": "output/seeds/seed_examples/77/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/77/images/train_input_0.png", "output": "output/seeds/seed_examples/77/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/77/images/train_input_1.png", "output": "output/seeds/seed_examples/77/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/77/images/train_input_2.png", "output": "output/seeds/seed_examples/77/images/train_output_2.png"}]}, "index": 77, "seed": "681b3aeb", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, mirror\n\n# description:\n# In the input you will see two objects on each outer side of two red frames.\n# To make the output, you need to mirror the two objects by flipping them over the symmetry of the red frames, making them inside the red frames. Each object flips over the frame closest to it.\n\ndef transform(input_grid):\n    # Extract the framework\n    frame_color = Color.RED\n    object_color = Color.GRAY \n    background = Color.BLACK\n\n    # Create an empty grid\n    n, m = input_grid.shape\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # parse the input\n    objects = find_connected_components(grid=input_grid, connectivity=8, monochromatic=True, background=background)\n    frames = [ obj for obj in objects if frame_color in object_colors(obj, background=background) ]\n    mirrored_objects = [ obj for obj in objects if object_color in object_colors(obj, background=background) ]\n\n    # determine if we are doing horizontal or vertical mirroring\n    # if all the objects have the same X coordinate, we are doing vertical mirroring\n    # if all the objects have the same Y coordinate, we are doing horizontal mirroring\n    x_positions = [ object_position(obj, background=background, anchor=\"center\")[0] for obj in objects ]\n    y_positions = [ object_position(obj, background=background, anchor=\"center\")[1] for obj in objects ]\n    if all(x == x_positions[0] for x in x_positions): orientation = \"vertical\"\n    elif all(y == y_positions[0] for y in y_positions): orientation = \"horizontal\"\n    else: raise ValueError(f\"The objects are not aligned in a single axis\")\n\n    # Flip each other object over its closest frame\n    for mirrored_object in mirrored_objects:\n        # Find the closest frame\n        def distance_between_objects(obj1, obj2):\n            x1, y1 = object_position(obj1, background=background, anchor=\"center\")\n            x2, y2 = object_position(obj2, background=background, anchor=\"center\")\n            return (x1 - x2)**2 + (y1 - y2)**2        \n        closest_frame = min(frames, key=lambda frame: distance_between_objects(frame, mirrored_object))\n\n        # Build a symmetry object for flipping over the closest frame\n        frame_x, frame_y = object_position(closest_frame, background=background, anchor=\"center\")\n        this_x, this_y = object_position(mirrored_object, background=background, anchor=\"center\")\n        # Make it one pixel past the middle of frame\n        frame_y += 0.5 if this_y \u003e frame_y else -0.5\n        frame_x += 0.5 if this_x \u003e frame_x else -0.5\n        symmetry = MirrorSymmetry(mirror_x=frame_x if orientation == \"horizontal\" else None,\n                                  mirror_y=frame_y if orientation == \"vertical\" else None)\n        \n        # Flip the object over the symmetry\n        for x, y in np.argwhere(mirrored_object != background):\n            x2, y2 = symmetry.apply(x, y)\n            output_grid[x2, y2] = mirrored_object[x, y]\n        \n        # Draw the frame\n        output_grid = blit_object(output_grid, closest_frame)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 2D background\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Get a framework for pattern\n    frame_length = np.random.randint(5, 10)\n    frame_width = 2\n    frame_color = Color.RED\n\n    # Draw a half of the framework\n    frame_sprite = np.zeros((frame_length, frame_width), dtype=int)\n    # horizontal bar and two vertical pixels\n    frame_sprite[:, 0] = frame_color\n    frame_sprite[0, 1] = frame_color\n    frame_sprite[-1, 1] = frame_color\n\n    # Select the interval for two half frameworks that form one entire framework\n    frame_interval = np.random.randint(4, 6)\n    \n    # Calculate the sizes of two things that we are going to mirror within framwork\n    pattern_color = Color.GRAY\n    pattern_length = frame_length - 2\n    pattern_width = frame_interval // 2\n    pattern_width_with_padding = frame_interval // 2 + 1\n\n    # Generate two patterns out the framwork\n    pattern_1 = random_sprite(n=pattern_length, m=pattern_width, color_palette=[pattern_color])\n    pattern_2 = random_sprite(n=pattern_length, m=pattern_width, color_palette=[pattern_color])\n\n    # place the pattern in the frame\n    whole_frame = np.zeros((frame_length, frame_width * 2 + frame_interval + pattern_width_with_padding * 2), dtype=int)\n    # Place the upper half of the frame\n    whole_frame = blit_sprite(whole_frame, frame_sprite, x=0, y=pattern_width_with_padding)\n    # Place the upper pattern\n    whole_frame = blit_sprite(whole_frame, pattern_1, x=1, y=0)\n    # Place the lower pattern\n    whole_frame = blit_sprite(whole_frame, pattern_2, x=1, y=frame_width * 2 + frame_interval + pattern_width_with_padding + 1)\n    # Place the lower half of the frame\n    whole_frame = blit_sprite(whole_frame, np.fliplr(frame_sprite), x=0, y=frame_width + frame_interval + pattern_width_with_padding)\n\n    # place the frame in the background\n    x, y = random_free_location_for_sprite(grid=grid, sprite=whole_frame)\n    grid = blit_sprite(grid=grid, sprite=whole_frame, x=x, y=y)\n\n    # Randomly rotate the grid so that we get both vertical and horizontal arrangements\n    if np.random.rand() \u003c 0.5:\n        grid = np.rot90(grid)\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/78/images/test_input.png", "output": "output/seeds/seed_examples/78/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/78/images/train_input_0.png", "output": "output/seeds/seed_examples/78/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/78/images/train_input_1.png", "output": "output/seeds/seed_examples/78/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/78/images/train_input_2.png", "output": "output/seeds/seed_examples/78/images/train_output_2.png"}]}, "index": 78, "seed": "6855a6e4", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# puzzle pieces, contact\n\n# description:\n# In the input you will see blue puzzles pieces lying beneath a red shape with holes on its underside.\n# To make the output, move the gray puzzle pieces upward so that they fit into the holes on the underside. They need to fully plug the holes.\n# Finally change the grey puzzle pieces to be blue.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the puzzle pieces and red thing\n    # 2. Extract the sprites of each puzzle piece\n    # 3. Try moving the puzzle pieces (but not so much that they collide with the red thing). You can translate but not rotate. Plug as much of the holes in the red thing as possible.\n    # 4. Change the color of the puzzle pieces to blue (just change everything that\u0027s grey to blue)\n\n    # 1. Separate puzzle pieces from the red object\n    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=8)\n    assert len(red_objects) == 1, \"There should be exactly one fully red object\"\n    red_object = red_objects[0]\n    \n    puzzle_pieces = detect_objects(grid=input_grid, colors=[Color.GREY], monochromatic=True, connectivity=4)\n\n    # 2. Extract sprites by cropping\n    sprites = [ crop(piece, background=Color.BLACK) for piece in puzzle_pieces ]\n\n    # Output begins with just the red and then we add stuff to it\n    output_grid = red_object.copy()\n\n    # 3. Try moving the puzzle pieces, plugging as much of the red object is possible\n    sprites_to_move = list(sprites)\n    while sprites_to_move:\n        possible_solutions = [ (x, y, sprite) for sprite in sprites_to_move \n                              for x in range(output_grid.shape[0] - sprite.shape[0] + 1)\n                              for y in range(output_grid.shape[1] - sprite.shape[1] + 1) ]\n        def score_solution(x, y, sprite):\n            # The score is -inf if it collides with the red object\n            # Otherwise it is the number of black pixels that are plugged by the sprite\n\n            # Make a canvas by trying putting down the sprite\n            test_canvas = np.full_like(output_grid, Color.BLACK)\n            blit_sprite(test_canvas, sprite, x, y)\n\n            # Check for collision\n            if collision(object1=test_canvas, object2=output_grid):\n                return float(\"-inf\")\n            \n            # Count the number of black pixels that are plugged by the sprite, only counting those within the bounding box of the red object\n            red_object_mask = red_object != Color.BLACK\n            test_object_mask = test_canvas != Color.BLACK\n            plugged_pixels = test_object_mask \u0026 ~red_object_mask \u0026 bounding_box_mask(red_object)\n            \n            return np.sum(plugged_pixels)\n        \n        best_x, best_y, best_sprite = max(possible_solutions, key=lambda solution: score_solution(*solution))\n\n        # Blit the sprite into the output grid\n        blit_sprite(output_grid, best_sprite, best_x, best_y)\n\n        # Remove the sprite from the list of sprites to move\n        sprites_to_move = [ sprite for sprite in sprites_to_move if sprite is not best_sprite ]\n\n    # 4. grey-\u003eblue\n    output_grid[output_grid == Color.GREY] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Create a red rectangle and then chisel out some holes on the underside for some random sprites\n\n    rectangle_width, rectangle_height = np.random.randint(15, 30), np.random.randint(5, 10)\n    red_rectangle = np.full((rectangle_width, rectangle_height), Color.RED)\n\n    # make the full grid such that it is wide enough for the rectangle but taller so that there is space for stuff underneath it\n    width = rectangle_width\n    height = np.random.randint(rectangle_height+5, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # put the red rectangle in the grid\n    blit_sprite(grid, red_rectangle, 0, 0)\n\n    # make the holes, each of which comes from a different puzzle piece (sprite)\n    n_holes = np.random.randint(2, 4)\n    for _ in range(n_holes):\n        puzzle_piece = random_sprite([1,2,3,4], [1,2,3,4], connectivity=4, color_palette=[Color.GREY], background=Color.BLACK)\n\n        # find a possible place to chisel out a hole, which has to be a spot which would currently collide with the red rectangle\n        possible_hole_locations = [ (x, y)\n                                   for x in range(rectangle_width - puzzle_piece.shape[0] + 1)\n                                   for y in range(rectangle_height - puzzle_piece.shape[1], rectangle_height) \n                                   if collision(object1=grid, object2=puzzle_piece, x2=x, y2=y) ]\n        x, y = random.choice(possible_hole_locations)\n\n        # chisel out the hole, which is everywhere 5the puzzle piece is grey\n        for dx, dy in np.argwhere(puzzle_piece == Color.GREY):\n            grid[x + dx, y + dy] = Color.BLACK\n\n        # find a place to put the puzzle piece in the bottom of the grid\n        possible_puzzle_locations = [ (x, height - puzzle_piece.shape[1]) for x in range(width - puzzle_piece.shape[0] + 1) \n                                     if not contact(object1=grid, object2=puzzle_piece, x2=x, y2=height - puzzle_piece.shape[1]) ]\n        x, y = random.choice(possible_puzzle_locations)\n        blit_sprite(grid, puzzle_piece, x, y)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/79/images/test_input.png", "output": "output/seeds/seed_examples/79/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/79/images/train_input_0.png", "output": "output/seeds/seed_examples/79/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/79/images/train_input_1.png", "output": "output/seeds/seed_examples/79/images/train_output_1.png"}]}, "index": 79, "seed": "6a1e5592", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# puzzle pieces, rotation, rescaling\n\n# description:\n# In the input you will see a non-black background, a small multicolored object, and fragments of that object rescaled and rotated scattered around.\n# To make the output, isolate the small multicolored object and then rescale/rotate/translate to cover the fragments as much as possible, matching color whenever the fragment has that color.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the object, separating the small multicolored puzzle piece from its fragments\n    # 2. Rescale/rotate/translate the small object\n    # 3. Find the transformation covering as much of the fragments as possible, matching colors whenever they overlap\n    # 4. Copy the resulting transformation to the output grid; delete the fragments from the input\n    # 5. Repeat until all the fragments are gone\n\n    # 1. object detection\n    # because the background is not black, set it to be the most common color\n    background = max(Color.NOT_BLACK, key=lambda color: np.sum(input_grid == color))\n    # detect the objects and figure out which is the template puzzle piece, which is going to be the one with the largest variety of colors\n    objects = find_connected_components(input_grid, connectivity=8, background=background, monochromatic=False)\n    template_object = max(objects, key=lambda obj: len(object_colors(obj, background=background)))\n    template_sprite = crop(template_object, background=background)\n\n    output_grid = np.full_like(input_grid, background)\n\n    # 2. rescale/rotate/translate the small object to cover as much of the fragments as possible, matching colors whenever they overlap\n    rescaled_and_rotated = [ np.rot90(scale_sprite(template_sprite, scale), k=rot)\n                            for scale in [1, 2, 3, 4]\n                            for rot in range(4) ]\n    # A placement solution is a tuple of (x, y, sprite) where x, y is the top-left corner of the rotated/scaled sprite\n    possible_solutions = [ (x, y, sprite)\n                          for sprite in rescaled_and_rotated\n                          for x in range(output_grid.shape[0] - sprite.shape[0])\n                          for y in range(output_grid.shape[1] - sprite.shape[1]) ]\n    \n    # Keep on looping until we are out of things to copy to the output\n    while np.any(input_grid != background):\n\n        def score_solution(x, y, sprite):\n            # The score is -inf if the placement violates non-background colors\n            # Otherwise it is the number of pixels that match in color between the sprite and the input\n            test_canvas = np.full_like(input_grid, background)\n            blit_sprite(test_canvas, sprite, x, y)\n\n            if np.any( (test_canvas != background) \u0026 (input_grid != background) \u0026 (test_canvas != input_grid) ):\n                return float(\"-inf\")\n            \n            return np.sum( (test_canvas == input_grid) \u0026 (input_grid != background) )\n        \n        # Remove -inf solutions, and zero solutions\n        possible_solutions = [ solution for solution in possible_solutions if score_solution(*solution) \u003e 0 ]\n        \n        best_x, best_y, best_sprite = max(possible_solutions, key=lambda solution: score_solution(*solution))\n\n        # 4. Copy the resulting transformation to the output grid; delete the fragments from the input\n        # Copy output\n        blit_sprite(output_grid, best_sprite, best_x, best_y)\n        # Delete from input\n        for dx, dy in np.argwhere(best_sprite != background):\n            input_grid[best_x + dx, best_y + dy] = background\n        \n        # 5. Repeat until all the fragments are gone\n    \n    return output_grid\n\n\ndef generate_input():\n    # Create a template puzzle piece, and then put down some randomly transformed+occluded versions of it on a non-black background\n\n    background = random.choice(Color.NOT_BLACK)\n    width, height = np.random.randint(10, 30), np.random.randint(10, 30)\n    grid = np.full((width, height), background)\n\n    template_puzzle_piece = random_sprite([2,3,4], [2,3,4], connectivity=8, color_palette=Color.NOT_BLACK, background=background)\n    x, y = random_free_location_for_sprite(grid, template_puzzle_piece, background=background)\n    blit_sprite(grid, template_puzzle_piece, x, y, background=background)\n\n    n_fragments = np.random.randint(1, 3)\n    for _ in range(n_fragments):\n        fragment = template_puzzle_piece.copy()\n        # randomly occlude w/ background squares\n        fragment[np.random.rand(*fragment.shape) \u003c 0.3] = background\n        # randomly rotate and scale\n        fragment = np.rot90(fragment, k=np.random.randint(0, 4))\n        fragment = scale_sprite(fragment, np.random.randint(1, 3+1))\n        x, y = random_free_location_for_sprite(grid, fragment, background=background, padding=2, border_size=2)\n        blit_sprite(grid, fragment, x, y, background=background)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/80/images/test_input.png", "output": "output/seeds/seed_examples/80/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/80/images/train_input_0.png", "output": "output/seeds/seed_examples/80/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/80/images/train_input_1.png", "output": "output/seeds/seed_examples/80/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/80/images/train_input_2.png", "output": "output/seeds/seed_examples/80/images/train_output_2.png"}]}, "index": 80, "seed": "6aa20dc0", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, scaling\n\n# description:\n# In the input you will see a 3x3 object and a red square n times larger than the 3x3 object.\n# To make the output, you should scale the 3x3 object to the size of the red square and place it in the red square.\n# Return just the red square (with the rescaled object put into it)\n\ndef transform(input_grid):\n    # Detect the red frame sqaure and the 3x3 pattern square\n    objects = detect_objects(input_grid, monochromatic=True, connectivity=8)\n    \n    # Extract the object, seperate them into the red frame square and the 3x3 pattern square\n    for obj in objects:\n        sprite = crop(obj, background=Color.BLACK)\n        if Color.RED in object_colors(sprite, background=Color.BLACK):\n            outer_sprite = sprite\n        else:\n            inner_sprite = sprite\n    \n    # Calculate the scaling factor.\n    # You need to subtract 2 because the red frame square has 1 pixel border on each side, and there are 2 sides\n    scale = (len(outer_sprite) - 2) // len(inner_sprite)\n\n    # Scale the small thing\n    scaled_inner_sprite = scale_sprite(inner_sprite, factor=scale)\n\n    # Put them all down on a new output grid\n    output_grid = np.full(outer_sprite.shape, Color.BLACK)\n    blit_sprite(output_grid, outer_sprite, x=0, y=0, background=Color.BLACK)\n    blit_sprite(output_grid, scaled_inner_sprite, x=1, y=1, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Initialize the grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.zeros((n, m), dtype=int)    \n\n    # Set the pattern size and scaling range\n    small_object_size = 3\n    availabe_scales = range(1, 5)\n    scale = np.random.choice(availabe_scales)\n\n    # Generate the red square frame scale times larger than the pattern square and randomly place it\n    big_red_rectangle = np.full((scale * small_object_size + 2, scale * small_object_size + 2), Color.RED)\n    big_red_rectangle[1:-1, 1:-1] = Color.BLACK\n    x_square, y_square = random_free_location_for_sprite(grid, big_red_rectangle)\n    grid = blit_sprite(x=x_square, y=y_square, grid=grid, sprite=big_red_rectangle, background=Color.BLACK)\n\n    # Generate the random pattern square with pattern_size\n    availabe_color = [c for c in Color.NOT_BLACK if c != Color.RED]\n    random_color = np.random.choice(availabe_color)\n\n    # Randomly place the pattern square in the area without the red square\n    sprite = random_sprite(n=small_object_size, m=small_object_size, color_palette=[random_color], density=0.5)\n    x, y = random_free_location_for_sprite(grid, sprite)\n    grid = blit_sprite(x, y, grid, sprite, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/81/images/test_input.png", "output": "output/seeds/seed_examples/81/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/81/images/train_input_0.png", "output": "output/seeds/seed_examples/81/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/81/images/train_input_1.png", "output": "output/seeds/seed_examples/81/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/81/images/train_input_2.png", "output": "output/seeds/seed_examples/81/images/train_output_2.png"}]}, "index": 81, "seed": "6b9890af", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# draw lines, detect objects\n\n# description:\n# In the input you will see three colors scattered on the grid. One color only have four pixels on the boundary of the grid.\n# To make the output grid, you should connect the four pixels of the color on the boundary of the grid to make two lines.\n\ndef transform(input_grid):\n    # Find the used color\n    all_color = np.unique(input_grid)\n\n    # Find the color all on the boundary, which is the lines\u0027 color\n    def on_boundary(x, y):\n        return x == 0 or x == input_grid.shape[0] - 1 or y == 0 or y == input_grid.shape[1] - 1\n    \n    # Get the color all on the boundary, which is the lines\u0027 color\n    for color in all_color:\n        all_on_boundary = all(on_boundary(x, y) for x, y in np.argwhere(input_grid==color))\n        if all_on_boundary:\n            line_color = color\n    output_grid = np.zeros_like(input_grid)\n\n    # Find the boundary pixels of the line_color and then draw a horizontal/vertical line to its matching pair\n    for x, y in np.argwhere(input_grid == line_color):\n        # Check if it\u0027s left/right edge or top/bottom edge\n        if x == 0 or x == input_grid.shape[0] - 1:\n            # it\u0027s left/right, so draw horizontal\n            draw_line(grid=output_grid, x=x, y=y, color=line_color, direction=(1, 0))\n        elif y == 0 or y == input_grid.shape[1] - 1:\n            # it\u0027s top/bottom, so draw vertical\n            draw_line(grid=output_grid, x=x, y=y, color=line_color, direction=(0, 1))\n    \n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(12, 20), np.random.randint(12, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate random three colors on the grid.\n    three_colors = random.sample(Color.NOT_BLACK, k = 3)\n\n    scattered_colors = three_colors[:2]\n    special_color = three_colors[2]\n\n    # Two colors of pixels are scattered on the grid as noise.\n    for scattered_color in scattered_colors:\n        randomly_scatter_points(grid, color=scattered_color, density=0.2)\n\n    # One color of pixels are scattered on the boundary of the grid, and only four pixels\n    # They are guaranteed to form two lines.\n    for _ in range(2):\n        # Choose if the line is horizontal or vertical\n        if_horizonal = np.random.choice([True, False])\n        if if_horizonal:\n            # Choose the position of the line\n            pos = np.random.choice(range(1, m - 1))\n\n            # Draw horizontal line\n            grid[0, pos] = special_color\n            grid[n - 1, pos] = special_color\n        else:\n            # Choose the position of the line\n            pos = np.random.choice(range(1, n - 1))\n\n            # Draw vertical line\n            grid[pos, 0] = special_color\n            grid[pos, m - 1] = special_color\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/82/images/test_input.png", "output": "output/seeds/seed_examples/82/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/82/images/train_input_0.png", "output": "output/seeds/seed_examples/82/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/82/images/train_input_1.png", "output": "output/seeds/seed_examples/82/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/82/images/train_input_2.png", "output": "output/seeds/seed_examples/82/images/train_output_2.png"}]}, "index": 82, "seed": "6cdd2623", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rectangle detection, background shape detection\n\n# description:\n# In the input you will see a grid with scattered one color pixels\n# To make the output grid, you should detect the 3x3 black square in the random color pattern\n# and replace it with a 3x3 blue square\n\ndef transform(input_grid):\n    # Plan: \n    # 1. Detect the 3x3 regions that are all black\n    # 2. Draw a blue 3x3 in those regions\n\n    # 1. Detect the 3x3 regions that are all black\n    region_len = 3\n    output_grid = np.copy(input_grid)\n    matching_regions = [(x, y) for x in range(len(input_grid) - (region_len - 1)) for y in range(len(input_grid[0]) - (region_len - 1)) if np.all(input_grid[x:x + region_len, y:y + region_len] == Color.BLACK)]\n\n    # 2. Draw a blue 3x3 in those regions\n    for x, y in matching_regions:\n        # Check if the region is all black\n        if np.all(output_grid[x:x+region_len, y:y+region_len] == Color.BLACK):\n            output_grid[x:x+region_len, y:y+region_len] = Color.BLUE\n\n    return output_grid    \n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = 20, 20\n    grid = np.zeros((n, m), dtype=int)\n\n    # Get the random scatter color pixels on the grid.\n    avaliable_colors = [c for c in Color.NOT_BLACK if c != Color.BLUE]\n    background_color = np.random.choice(avaliable_colors)\n    \n    # Generate random color pixels on the grid.\n    randomly_scatter_points(grid, color=background_color, density=0.7)\n\n    # Randomly generate the number of black squares.\n    square_num = np.random.randint(1, 4)\n\n    # Generate the black squares on the grid.\n    square_len = 3\n    for _ in range(square_num):\n        square = np.full((square_len, square_len), Color.BLACK)\n        try:\n            # Get the random free location for the black square.\n            x, y = random_free_location_for_sprite(grid=grid, sprite=square, background=background_color)\n        except:\n            continue\n        # Blit the black square on the grid.\n        grid = blit_sprite(grid=grid, sprite=square, x=x, y=y, background=background_color)\n     \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/83/images/test_input.png", "output": "output/seeds/seed_examples/83/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/83/images/train_input_0.png", "output": "output/seeds/seed_examples/83/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/83/images/train_input_1.png", "output": "output/seeds/seed_examples/83/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/83/images/train_input_2.png", "output": "output/seeds/seed_examples/83/images/train_output_2.png"}]}, "index": 83, "seed": "6cf79266", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# sliding objects\n\n# description:\n# In the input grid, you will see a chevron-shaped object of one color in a black grid, with pixels of another color scattered around the grid.\n# To produce the output grid, take all pixels located underneath the chevron. For each of these pixels, extend a vertical line of the same color up and down, until reaching the bottom of the grid or the boundary of the chevron.\n\ndef transform(input_grid):\n    # 1. find the chevron: it is the largest object by size.\n    # 2. get the color of the chevron\n    # 3. get the color of the colored pixels in the grid.\n    # 4. for each colored pixel, check if the chevron is above it. if so, extend a line of the same color above and below it until we reach the bottom of the grid or the boundary of the chevron.\n\n    # get the chevron\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True)\n    chevron = max(objects, key=lambda o: np.count_nonzero(o))\n\n    # get the color of the chevron\n    chevron_color = chevron[chevron != Color.BLACK][0]\n\n    # get the color of the colored pixels (the other color in the grid)\n    colors = np.unique(input_grid)\n    colors = [c for c in colors if c not in [Color.BLACK, chevron_color]]\n    assert len(colors) == 1\n    pixel_color = colors[0]\n\n    # for each colored pixel, check if chevron is above it\n    # to do so, iterate through the grid and check for pixel_color.\n    # then try moving up until we hit the chevron color.\n    # if we do, then paint a vertical line onto the output grid.\n    output_grid = input_grid.copy()\n    for x in range(input_grid.shape[0]):\n        for y in range(input_grid.shape[1]):\n            if input_grid[x, y] != pixel_color:\n                continue\n            # try moving up until we hit the chevron color\n            dy = 0\n            while y + dy \u003e= 0 and input_grid[x, y + dy] != chevron_color:\n                dy = dy - 1\n\n            if input_grid[x, y + dy] == chevron_color:\n                # make a line from here to the bottom\n                output_grid[x, y + dy + 1:] = pixel_color\n\n    return output_grid\n\n\ndef generate_input():\n    # create a 20x20 black grid\n    input_grid = np.full((20, 20), Color.BLACK)\n\n    # choose a chevron color and pixel color\n    chevron_color, pixel_color = np.random.choice(Color.NOT_BLACK, 2, replace=False)\n\n    # create the chevron\n    chevron = np.full((7, 4), Color.BLACK)\n    # Create coordinate arrays\n    x, y = np.indices(chevron.shape)\n    # fill in the chevron\n    chevron[np.logical_and(y == 0, x == 3)] = chevron_color\n    chevron[np.logical_and(y == 1, np.logical_and(x \u003e= 2, x \u003c= 4))] = chevron_color\n    chevron[np.logical_and(y == 2, np.logical_and(x \u003e= 1, x \u003c= 5))] = chevron_color\n    chevron[np.logical_and(y == 3, np.logical_or(x == 0, x == 6))] = chevron_color\n    # put the chevron at a random location in the upper half of the grid\n    x, y = np.random.randint(0, 20 - 7), np.random.randint(0, 10 - 4)\n    blit_sprite(input_grid, chevron, x=x, y=y)\n\n    # generate 5-25 pixels at random (unfilled) spots.\n    n_pixels = np.random.randint(5, 26)\n    x_choices, y_choices = np.where(input_grid == Color.BLACK)\n    location_choices = list(zip(x_choices, y_choices))\n    pixel_locations = random.sample(location_choices, n_pixels)\n    for x, y in pixel_locations:\n        input_grid[x, y] = pixel_color\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/84/images/test_input.png", "output": "output/seeds/seed_examples/84/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/84/images/train_input_0.png", "output": "output/seeds/seed_examples/84/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/84/images/train_input_1.png", "output": "output/seeds/seed_examples/84/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/84/images/train_input_2.png", "output": "output/seeds/seed_examples/84/images/train_output_2.png"}]}, "index": 84, "seed": "6d58a25d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# shape completion\n\n# description:\n# In the input you will see an incomplete teal ractangle\n# To make the output grid, you should use the red color to complete the rectangle.\n\ndef transform(input_grid):\n    # Find the bounding box of the incomplete rectangle and use it to extra the sprite\n    x, y, x_len, y_len = bounding_box(grid=input_grid)\n    rectangle = input_grid[x:x + x_len, y:y + y_len]\n\n    # Find the missing parts of the rectangle (which are colored black) and complete it with red color\n    rectangle_sprite = np.where(rectangle == Color.BLACK, Color.RED, rectangle)\n\n    # Make the output by copying the sprite to a new canvas\n    output_grid = np.copy(input_grid)\n    output_grid = blit_sprite(grid=output_grid, sprite=rectangle_sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a grid with a size of n x m\n    n, m = np.random.randint(7, 15), np.random.randint(7, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly generate a rectangle with a size of x_len x y_len, not too big nor too small\n    x_len = np.random.randint(n // 2, n - 2)\n    y_len = np.random.randint(m // 2, m - 2)\n\n    # Randomly generate a rectangle with a size of x_len x y_len that is incomplete (density \u003c 1)\n    rectangle_sprite = random_sprite(n=x_len, m=y_len, color_palette=[Color.TEAL], density=0.3, connectivity=8)\n\n    # Randomly choose a position to draw the rectangle\n    x, y = random_free_location_for_sprite(grid=grid, sprite=rectangle_sprite, border_size=1)\n    grid = blit_sprite(grid=grid, sprite=rectangle_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/85/images/test_input.png", "output": "output/seeds/seed_examples/85/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/85/images/train_input_0.png", "output": "output/seeds/seed_examples/85/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/85/images/train_input_1.png", "output": "output/seeds/seed_examples/85/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/85/images/train_input_2.png", "output": "output/seeds/seed_examples/85/images/train_output_2.png"}]}, "index": 85, "seed": "6d75e8bb", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# direction, lines, pointing\n\n# description:\n# In the input, you will see several objects of the same color that are in an arrowhead shape and facing different directions.\n# The goal is to find the directions of the arrowheads and draw lines that would represent the path they had been moving in to go in that direction.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # find the objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    # for each object, find the direction the arrowhead is pointing in by finding the relative mean position of colored and black pixels in the bounding box of the object\n    for obj in objects:\n        # find the bounding box of the object\n        x, y, w, h = bounding_box(obj)\n\n        # crop the object to extract the sprite\n        sprite = crop(obj)\n\n        # find the color of the object\n        color = np.unique(obj[obj != Color.BLACK])[0]\n\n        # find the mean position of the colored pixels\n        mean_pos = np.mean(np.argwhere(sprite != Color.BLACK), axis=0)\n\n        # find the mean position of all the black pixels\n        mean_black_pos = np.mean(np.argwhere(sprite == Color.BLACK), axis=0)\n\n        # find the direction the arrowhead is pointing in, it is from the mean position of the colored pixels to the mean position of the black pixels\n        direction = np.sign(mean_black_pos - mean_pos).astype(int)\n\n        # draw a line in the direction the arrowhead is pointing in from the corresponding corner of the bounding box\n        # list the corners of the bounding box\n        corners = [(x - 1, y - 1), (x + w, y - 1), (x - 1, y + h), (x + w, y + h)]\n        # compute the center of the object\n        center = (x + w / 2, y + h / 2)\n        # if the direction of the corner from the center of the object matches the direction we want to draw a line in, then draw a line\n        for corner in corners:\n            # check if the corner is in the direction that the arrowhead is pointing\n            vector_to_corner = np.array(corner) - np.array(center)\n            if np.all(np.sign(vector_to_corner) == direction):\n                draw_line(output_grid, corner[0], corner[1], length=None, color=color, direction=direction)\n\n    return output_grid\n\ndef generate_input():\n    # make a 10x10 grid as background\n    grid = np.zeros((10, 10), dtype=int)\n\n    # choose the color of the arrowheads\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # make the arrowheads by making a 2x2 square then removing one of the corners randomly and placing it randomly on the grid\n    for i in range(4):\n        # make at arrowhead\n        arrowhead = np.full((2, 2), color)\n        corner = np.random.randint(4)\n        arrowhead[corner // 2, corner % 2] = Color.BLACK\n        \n        # place it in a random free location with 1 cell padding\n        x, y = random_free_location_for_sprite(grid, arrowhead, padding=1)\n        blit_sprite(grid, arrowhead, x=x, y=y)\n \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/86/images/test_input.png", "output": "output/seeds/seed_examples/86/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/86/images/train_input_0.png", "output": "output/seeds/seed_examples/86/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/86/images/train_input_1.png", "output": "output/seeds/seed_examples/86/images/train_output_1.png"}]}, "index": 86, "seed": "6e19193c", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, counting, color\n\n# description:\n# In the input you will see grey objects on a black background.\n# To make the output, count the number of pixels in each object and color the object green if it has two pixels, red if it has three pixels, and blue if it has four pixels.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # get the objects in the input grid\n    objects = find_connected_components(input_grid)\n\n    # count the number of pixels in each object and color them accordingly\n    for obj in objects:\n        num_pixels = np.sum(obj == Color.GREY)\n        if num_pixels == 2:\n            color = Color.GREEN\n        elif num_pixels == 3:\n            color = Color.RED\n        elif num_pixels == 4:\n            color = Color.BLUE\n        else:\n            color = Color.GREY\n        output_grid[obj == Color.GREY] = color\n\n    return output_grid\n\ndef generate_input():\n    # make a black 10x10 grid as the background\n    n = m = 10\n    grid = np.zeros((n, m), dtype=int)\n    \n    # make a random number of sprites\n    num_sprites = np.random.randint(3, 7)\n    for _ in range(num_sprites):\n        sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), symmetry=\"not_symmetric\", color_palette=[Color.GREY])\n        # make sure the sprite has between 2 and 4 pixels\n        while np.sum(sprite == Color.GREY) \u003c 2 or np.sum(sprite == Color.GREY) \u003e 4:\n            sprite = random_sprite(np.random.randint(1, 4), np.random.randint(1, 4), symmetry=\"not_symmetric\", color_palette=[Color.GREY])\n        try:\n            x, y = random_free_location_for_sprite(grid, sprite, padding=1, padding_connectivity=8)\n            blit_sprite(grid, sprite, x=x, y=y)\n        except:\n            pass\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/87/images/test_input.png", "output": "output/seeds/seed_examples/87/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/87/images/train_input_0.png", "output": "output/seeds/seed_examples/87/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/87/images/train_input_1.png", "output": "output/seeds/seed_examples/87/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/87/images/train_input_2.png", "output": "output/seeds/seed_examples/87/images/train_output_2.png"}]}, "index": 87, "seed": "6e82a1ae", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, color guide, masking, scaling\n\n# description:\n# In the input you will see a large monochromatic object, and a smaller square object with many colors.\n# To make the output, first downscale the large object so that it is the same size as the small multicolor square, and then use the large object as a binary mask to zero out pixels in the square. Return the resulting masked sprite.\n\ndef transform(input_grid):\n    # find all the objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=8, monochromatic=False)\n\n    # figure out which object is the pattern and which object is the multi-colored square\n    pattern = square = None\n    for obj in objects:\n        # if the object has only one color and black, it is the pattern. Otherwise, it is the multi-colored square.\n        if len(set(obj.flatten())) == 2:\n            pattern = obj\n        else:\n            square = obj\n    \n    # get the square location and cut out the bounding box\n    x, y, width, height = bounding_box(square)\n    square_sprite = square[x:x+width, y:y+height]\n\n    # cut out the bounding box of the pattern\n    x2, y2, width2, height2 = bounding_box(pattern)\n    # make sure the pattern is square\n    if width2 != height2:\n        width2 = height2 = max(width2, height2)\n    pattern_sprite = pattern[x2:x2+width2, y2:y2+height2]\n\n    # figure out how much bigger the pattern is than the square\n    scale = width2 // width\n\n    # scale down the pattern to fit the square\n    scaled_pattern = np.zeros_like(square_sprite) \n    for i in range(width):\n        for j in range(height):\n            scaled_pattern[i,j] = pattern_sprite[i * scale, j * scale]\n    \n    # if the pixel is in the pattern, keep the color from the square otherwise make it black in the output grid\n    output_grid = np.where(scaled_pattern, square_sprite, Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # decide how big the multi-colored square will be\n    size = np.random.randint(3, 5)\n\n    # make the multi-colored square with all colors except black\n    square = random_sprite(size, size, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n    \n    # make sure the square has more than one color, if not then try again\n    if len(set(square.flatten())) == 1:\n        return generate_input()\n\n    # make a random pattern that is the same size as the multi-colored square but only uses one color \n    color = np.random.choice(list(Color.NOT_BLACK))\n    pattern = random_sprite(size, size, density=.7, symmetry=\"not_symmetric\", color_palette=[color], connectivity=8)\n\n    # check that pattern is continuous, if not then try again\n    if not is_contiguous(pattern, connectivity=8):\n        return generate_input()\n\n    # decide how much to scale up the pattern\n    scale = np.random.randint(2, 6)\n\n    # scale up the pattern\n    pattern = np.repeat(np.repeat(pattern, scale, axis=0), scale, axis=1)\n\n    # make a grid large enough to fit both the pattern and the multi-colored square without touching\n    n = m = (size * scale) + (2 * size) + np.random.randint(2, 5)\n    grid = np.zeros((n, m), dtype=int)\n\n    # put the pattern on the grid randomly\n    x, y = np.random.randint(0, n - size * scale), np.random.randint(0, m - size * scale)\n    blit_sprite(grid, pattern, x=x, y=y)\n\n    # put the multi-colored square on the grid randomly but not touching the pattern\n    x2, y2 = random_free_location_for_sprite(grid, square)\n    # make sure the multi-colored square is not touching the pattern, if it is then keep looking for a place to put it\n    while contact(object1=grid, object2=square, x2=x2, y2=y2, connectivity=8):\n        x2, y2 = random_free_location_for_sprite(grid, square)\n    blit_sprite(grid, square, x=x2, y=y2)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/88/images/test_input.png", "output": "output/seeds/seed_examples/88/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/88/images/train_input_0.png", "output": "output/seeds/seed_examples/88/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/88/images/train_input_1.png", "output": "output/seeds/seed_examples/88/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/88/images/train_input_2.png", "output": "output/seeds/seed_examples/88/images/train_output_2.png"}]}, "index": 88, "seed": "6ecd11f4", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# borders\n\n# description:\n# In the input you will see an empty black grid.\n# To make the output, draw a line along the border of the input with a thickness of one pixel. The border should be teal.\n\ndef transform(input_grid):\n    # make the output grid\n    n, m = input_grid.shape\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # draw the border of the input grid\n    draw_line(grid=output_grid, x=0, y=0, length=None, color=Color.TEAL, direction=(1,0))\n    draw_line(grid=output_grid, x=n-1, y=0, length=None, color=Color.TEAL, direction=(0,1))\n    draw_line(grid=output_grid, x=0, y=0, length=None, color=Color.TEAL, direction=(0,1))\n    draw_line(grid=output_grid, x=0, y=m-1, length=None, color=Color.TEAL, direction=(1,0))\n\n    return output_grid\n    \n\ndef generate_input():\n    # make a rectangular black grid\n    n = np.random.randint(3, 8)\n    m = np.random.randint(3, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/89/images/test_input.png", "output": "output/seeds/seed_examples/89/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/89/images/train_input_0.png", "output": "output/seeds/seed_examples/89/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/89/images/train_input_1.png", "output": "output/seeds/seed_examples/89/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/89/images/train_input_2.png", "output": "output/seeds/seed_examples/89/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/89/images/train_input_3.png", "output": "output/seeds/seed_examples/89/images/train_output_3.png"}]}, "index": 89, "seed": "6f8cd79b", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# reflection\n\n# description:\n# In the input you will see a square pattern of random colors except black.\n# To make the output, reflect the pattern vertically, and put the reflected pattern beneath the input pattern.\n\ndef transform(input_grid):\n    # take the input pattern\n    pattern = input_grid\n\n    # reflect the pattern vertically\n    reflected_pattern = pattern[:, ::-1]\n\n    # make the output grid\n    output_grid = np.concatenate((pattern, reflected_pattern), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # make a random square pattern of random size and colors\n    n = m = np.random.randint(3, 6)\n    grid = random_sprite(n, m, density=1, symmetry=\"not_symmetric\", color_palette=Color.NOT_BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/90/images/test_input.png", "output": "output/seeds/seed_examples/90/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/90/images/train_input_0.png", "output": "output/seeds/seed_examples/90/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/90/images/train_input_1.png", "output": "output/seeds/seed_examples/90/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/90/images/train_input_2.png", "output": "output/seeds/seed_examples/90/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/90/images/train_input_3.png", "output": "output/seeds/seed_examples/90/images/train_output_3.png"}]}, "index": 90, "seed": "6fa7a44f", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, sprites\n\n# description:\n# In the input you will see several objects. One object represents a symmetic sprite. All the other objects represent non-symmetric sprites.\n# The goal is to find the symmetric sprite and return it.\n\ndef transform(input_grid):\n    # find the objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    # crop out the sprites from the objects\n    sprites = [crop(obj) for obj in objects]\n\n    # find the symmetric sprite\n    symmetric_sprite = None\n    for sprite in sprites:\n      # check if the sprite is radially symmetric\n      if np.array_equal(sprite, np.rot90(sprite, 1)):\n        symmetric_sprite = sprite\n        break\n      # check if the sprite is vertically symmetric\n      elif np.array_equal(sprite, np.fliplr(sprite)):\n        symmetric_sprite = sprite\n        break\n      # check if the sprite is horizontally symmetric\n      elif np.array_equal(sprite, np.flipud(sprite)):\n        symmetric_sprite = sprite\n        break\n      # check if the sprite is diagonally symmetric\n      elif np.array_equal(sprite, sprite.T) or np.array_equal(np.flipud(sprite), np.fliplr(sprite)):\n        symmetric_sprite = sprite\n        break\n\n    return symmetric_sprite\n\n  \n\ndef generate_input():\n    # make a black 10x10 grid as background\n    grid = np.zeros((10, 10), dtype=int)\n\n    # add a symmetric sprite:\n    # choose the color of the sprite\n    color = np.random.choice(Color.NOT_BLACK)\n\n    # choose the sidelength of the sprite\n    side_length = np.random.randint(2, 8)\n\n    # choose the width of the sprite to be either 2 or the side_length\n    width = np.random.choice([2, side_length])\n\n    # choose the height of the sprite to be whatever is left\n    height = side_length if width == 2 else 2\n\n    # choose the symmetry that the sprite will have\n    symmetry = np.random.choice([\u0027vertical\u0027, \u0027horizontal\u0027, \u0027diagonal\u0027, \u0027radial\u0027])\n\n    # override width and height if the symmetry is radial or diagonal\n    if symmetry in [\u0027radial\u0027, \u0027diagonal\u0027]:\n        width = height = np.random.randint(2, 5)\n\n    # make the sprite\n    symmetric_sprite = random_sprite(width, height, symmetry=symmetry, color_palette=[color], connectivity=8)\n\n    # place the sprite randomly on the grid\n    x, y = random_free_location_for_sprite(grid, symmetric_sprite, padding=1)\n    blit_sprite(grid, symmetric_sprite, x=x, y=y)\n\n    # add some non-symmetric sprites:\n    for _ in range(np.random.randint(3, 6)):\n        # choose the color of the sprite\n        color = np.random.choice(Color.NOT_BLACK)\n\n        # choose the sidelength of the sprite\n        side_length = np.random.randint(3, 8)\n\n        # choose the width of the sprite to be either 2 or the side_length\n        width = np.random.choice([2, side_length])\n\n        # choose the height of the sprite to be whatever is left\n        height = side_length if width == 2 else 2\n\n        # make the sprite\n        non_symmetric_sprite = random_sprite(width, height, symmetry=\"not_symmetric\", color_palette=[color], connectivity=8)\n\n        # place the sprite randomly on the grid if there is space\n        try:\n          x, y = random_free_location_for_sprite(grid, non_symmetric_sprite, padding=1)\n          blit_sprite(grid, non_symmetric_sprite, x=x, y=y)\n        except:\n          pass\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/91/images/test_input.png", "output": "output/seeds/seed_examples/91/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/91/images/train_input_0.png", "output": "output/seeds/seed_examples/91/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/91/images/train_input_1.png", "output": "output/seeds/seed_examples/91/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/91/images/train_input_2.png", "output": "output/seeds/seed_examples/91/images/train_output_2.png"}]}, "index": 91, "seed": "72ca375d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, flood fill, connectivity\n\n# description:\n# In the input, you will see a black grid with a red line that starts in the top left corner and bounces off the borders of the grid until it reaches the right side of the grid.\n# To make the output, find the black regions separated by the red lines, then, starting with the first region from the left, color every third region yellow.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # find the black regions in the input grid\n    black_regions = find_connected_components(input_grid, connectivity=4, background=Color.RED)\n\n    # sort the regions from left to right using the coordinates of their bounding boxes\n    black_regions = sorted(black_regions, key=lambda region: bounding_box(region, background=Color.RED)[0])\n\n    # color every third black region yellow using flood fill\n    for i, region in enumerate(black_regions):\n        if i % 3 == 0:\n            x, y = np.where(region == Color.BLACK)\n            flood_fill(output_grid, x[0], y[0], Color.YELLOW)\n\n    return output_grid\n\n\n\ndef generate_input():\n    # make a black grid that is 3 cells tall and between 10 and 20 cells wide\n    grid = np.zeros((np.random.randint(10,20), 3), dtype=int)\n\n    # make a red line that starts in the top left corner and bounces off the borders of the grid until it reaches the right side of the grid\n    x, y = 0, 0\n    dx, dy = 1, 1\n    # go until we reach the right side of the grid\n    while x \u003c grid.shape[0]:\n        # make the current cell red\n        grid[x, y] = Color.RED\n        # if we are at the top or bottom of the grid, bounce off the top or bottom border\n        if y + dy \u003e= grid.shape[1]:\n            dy = -1\n        elif y + dy \u003c 0:\n            dy = 1\n        x += dx\n        y += dy\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/92/images/test_input.png", "output": "output/seeds/seed_examples/92/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/92/images/train_input_0.png", "output": "output/seeds/seed_examples/92/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/92/images/train_input_1.png", "output": "output/seeds/seed_examples/92/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/92/images/train_input_2.png", "output": "output/seeds/seed_examples/92/images/train_output_2.png"}]}, "index": 92, "seed": "7447852a", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line detection, color extraction\n\n# description:\n# In the input you will see a grid consisting of stripes that are either horizontal or vertical.\n# To make the output, make a grid with one pixel for each stripe whose color is the same color as that stripe.\n# If the stripes are vertical, the output should be vertical, and if the stripes are horizontal, the output should be horizontal. The colors should be in the order they appear in the input.\n\ndef transform(input_grid):\n    # Parse input and then determine the orientation of the stripes\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=Color.BLACK)\n    x_positions = [ object_position(obj, background=Color.BLACK, anchor=\"center\")[0] for obj in objects]\n    y_positions = [ object_position(obj, background=Color.BLACK, anchor=\"center\")[1] for obj in objects]\n    if all(x == x_positions[0] for x in x_positions):\n        orientation = \"vertical\"\n    elif all(y == y_positions[0] for y in y_positions):\n        orientation = \"horizontal\"\n    else:\n        raise ValueError(\"The stripes are not aligned in a single axis\")\n    \n    # Sort the objects depending on the orientation\n    if orientation == \"horizontal\":\n        objects.sort(key=lambda obj: object_position(obj, background=Color.BLACK, anchor=\"center\")[0])\n    else:\n        objects.sort(key=lambda obj: object_position(obj, background=Color.BLACK, anchor=\"center\")[1])\n    \n    # Extract the colors of the stripes\n    colors = [ object_colors(obj, background=Color.BLACK)[0] for obj in objects ]\n\n    # Generate the output grid\n    if orientation == \"horizontal\":\n        output_grid = np.full((len(colors), 1), Color.BLACK)\n        output_grid[:, 0] = colors\n    else:\n        output_grid = np.full((1, len(colors)), Color.BLACK)\n        output_grid[0, :] = colors\n    \n    return output_grid\n    \n\n\ndef generate_input():\n    # Generate grid of size n x m\n    n, m = np.random.randint(3, 10), np.random.randint(2, 10)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose n colors\n    colors = np.random.choice(list(Color.NOT_BLACK), n)\n    \n    # Draw vertical lines of the chosen colors\n    for x, color in enumerate(colors):\n        draw_line(grid, x=x, y=0, length=m, color=color, direction=(0, 1))\n        # same as grid[x,:] = color\n    \n    # Randomly rotate the whole grid to make the lines horizontal or vertical\n    if random.random() \u003c 0.5:\n        grid = np.rot90(grid)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/93/images/test_input.png", "output": "output/seeds/seed_examples/93/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/93/images/train_input_0.png", "output": "output/seeds/seed_examples/93/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/93/images/train_input_1.png", "output": "output/seeds/seed_examples/93/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/93/images/train_input_2.png", "output": "output/seeds/seed_examples/93/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/93/images/train_input_3.png", "output": "output/seeds/seed_examples/93/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/93/images/train_input_4.png", "output": "output/seeds/seed_examples/93/images/train_output_4.png"}]}, "index": 93, "seed": "746b3537", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# same/different, color change, containment\n\n# description:\n# In the input you will see some monochromatic objects. Some of them will be contained by a grey box, and some of them will not.\n# To make the output, take each shape contained inside a grey box, and find any other shapes with the same shape (but a different color), and change their color to match the color of the shape inside the grey box.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract the objects and separate them according to if they are grey or not\n    # 2. Determine if each non-grey shape is contained by a grey shape\n    # 3. Check to see which objects (among grey contained shapes) have another object which has the same shape (not contained by grey)\n    # 4. Do the color change when you find these matching objects\n\n    # 1. Extract the objects, separating them by if they are grey or not\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=8, monochromatic=True)\n    grey_objects = [ obj for obj in objects if Color.GREY in object_colors(obj, background=Color.BLACK) ]\n    non_grey_objects = [ obj for obj in objects if Color.GREY not in object_colors(obj, background=Color.BLACK) ]\n\n    # 2. Determine if each non-grey shape is contained by a grey shape\n    # Divide the non-grey objects into two groups: those contained by grey, and those not contained by grey\n    # Make a helper function for checking of one object is contained by another\n    def object_contains_another_object(inside_object, outside_object):\n        # Using bounding boxes:\n        # inside_x, inside_y, inside_width, inside_height = bounding_box(inside_object)\n        # outside_x, outside_y, outside_width, outside_height = bounding_box(outside_object)\n        # return inside_x \u003e= outside_x and inside_y \u003e= outside_y and inside_x + inside_width \u003c= outside_x + outside_width and inside_y + inside_height \u003c= outside_y + outside_height\n        # Using topology+masks:\n        inside_object_mask = inside_object != Color.BLACK\n        outside_interior_mask = object_interior(outside_object, background=Color.BLACK)\n        return np.all(outside_interior_mask \u003e= inside_object_mask)\n    objects_contained_by_grey = [ non_grey for non_grey in non_grey_objects\n                                  if any( object_contains_another_object(non_grey, grey) for grey in grey_objects ) ]\n    objects_not_contained_by_gray = [ non_grey for non_grey in non_grey_objects\n                                     if not any( object_contains_another_object(non_grey, grey) for grey in grey_objects ) ]\n    \n    # 3. Check to see which objects (among grey contained shapes) have another object which has the same shape (not contained by grey)\n    output_grid = input_grid.copy()\n\n    # Helper function to check if two objects have the same shape\n    def objects_have_same_shape(obj1, obj2):\n        mask1 = crop(obj1, background=Color.BLACK) != Color.BLACK\n        mask2 = crop(obj2, background=Color.BLACK) != Color.BLACK\n        return np.array_equal(mask1, mask2)\n    \n    for grey_contained in objects_contained_by_grey:\n        for non_grey in objects_not_contained_by_gray:\n            if objects_have_same_shape(grey_contained, non_grey):\n                # 4. Do the color change\n                target_color = object_colors(grey_contained, background=Color.BLACK)[0]\n                non_grey_mask = non_grey != Color.BLACK\n                output_grid[non_grey_mask] = target_color\n\n    return output_grid\n\ndef generate_input():\n    # Make some sprites\n    # One of those sprites is going to be contained by a grey box, and occur more than once (but in different colors)\n    # The other sprites are not going to be contained by the grey box, and might occur multiple times anyway\n\n    width, height = random.choice(range(17, 30+1)), random.choice(range(17, 30+1))\n    grid = np.full((width, height), Color.BLACK)\n\n    possible_sprite_dimensions = [1,2,3,4]\n    contained_color = random.choice([ color for color in Color.NOT_BLACK if color != Color.GREY ])\n    contained_sprite = random_sprite(possible_sprite_dimensions, possible_sprite_dimensions,\n                                     color_palette=[contained_color])\n\n    # put down the contained sprite at a random spot, and then put a gray box around it\n    x, y = random_free_location_for_sprite(grid, contained_sprite, background=Color.BLACK, border_size=2, padding=2)\n    blit_sprite(grid, contained_sprite, x, y)\n    contained_w, contained_h = contained_sprite.shape\n\n    # make the gray box (outline of a rectangle)\n    grey_box = np.full((contained_w+4, contained_h+4), Color.GREY)\n    grey_box[1:-1, 1:-1] = Color.BLACK\n    blit_sprite(grid, grey_box, x-2, y-2)\n\n    # put down some other sprites which are the same shape as the contained sprite, but in different colors\n    n_duplicate_sprites = np.random.randint(1, 3)\n    for _ in range(n_duplicate_sprites):\n        duplicate_sprite = contained_sprite.copy()\n        duplicate_sprite[duplicate_sprite != Color.BLACK] = random.choice([ color for color in Color.NOT_BLACK if color != Color.GREY and color != contained_color ])\n        x, y = random_free_location_for_sprite(grid, duplicate_sprite, background=Color.BLACK, border_size=1, padding=1)\n        blit_sprite(grid, duplicate_sprite, x, y)\n    \n    # put down some other sprites which are not the same shape as the contained sprite, which might be duplicated occasionally\n    n_non_contained_sprites = np.random.randint(1, 3)\n    for _ in range(n_non_contained_sprites):\n        sprite_color = random.choice([ color for color in Color.NOT_BLACK if color != Color.GREY ])\n        sprite = random_sprite(possible_sprite_dimensions, possible_sprite_dimensions,\n                               color_palette=[sprite_color])\n        x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1, padding=1)\n        blit_sprite(grid, sprite, x, y)\n\n        # Maybe duplicate?\n        if np.random.rand() \u003c 0.5:\n            x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, border_size=1, padding=1)\n            blit_sprite(grid, sprite, x, y)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/94/images/test_input.png", "output": "output/seeds/seed_examples/94/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/94/images/train_input_0.png", "output": "output/seeds/seed_examples/94/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/94/images/train_input_1.png", "output": "output/seeds/seed_examples/94/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/94/images/train_input_2.png", "output": "output/seeds/seed_examples/94/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/94/images/train_input_3.png", "output": "output/seeds/seed_examples/94/images/train_output_3.png"}]}, "index": 94, "seed": "776ffc46", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# downscaling, rectangular partitions\n\n# description:\n# In the input you will see a grid consisting of a chessboard pattern (rectangular partitions) of different colors.\n# Each rectangular partition region is incompletely scattered with a color. Regions are separated by black lines, going all the way top-bottom/left-right. \n# To make the output, make a grid with one color pixel for each colored rectangular region of the input.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Partition the input into rectangular regions by finding all horizontal and vertical black lines\n    # 2. For each region, find the color of the region\n    # 3. Use one pixel to represent the original region and create the output grid\n\n    # 1. Input parsing\n    # Get the shape of the input grid\n    width, height = input_grid.shape\n    background = Color.BLACK\n    # Find all horizontal and vertical lines\n    vertical_lines = [ x for x in range(width) if np.all(input_grid[x, :] == background) ]\n    horizontal_lines = [ y for y in range(height) if np.all(input_grid[:, y] == background) ]\n    \n    # Start from (0, 0)\n    vertical_lines = [0] + vertical_lines\n    horizontal_lines = [0] + horizontal_lines\n\n    # Deduplicate successive lines\n    vertical_lines = [x for i, x in enumerate(vertical_lines) if i == 0 or x != vertical_lines[i - 1]]\n    horizontal_lines = [y for i, y in enumerate(horizontal_lines) if i == 0 or y != horizontal_lines[i - 1]]\n\n    # use one pixel to represent the original region and create the output grid\n    output_width, output_height = len(vertical_lines), len(horizontal_lines)\n    output_grid = np.full((output_width, output_height), background) \n\n    # Initialize the output grid\n    for i in range(len(vertical_lines)):\n        for j in range(len(horizontal_lines)):\n            # Get the region of the color\n            x1 = vertical_lines[i]\n            x2 = vertical_lines[i + 1] if i + 1 \u003c len(vertical_lines) else width\n            y1 = horizontal_lines[j]\n            y2 = horizontal_lines[j + 1] if j + 1 \u003c len(horizontal_lines) else height\n\n            # Get the original region\n            region = input_grid[x1:x2, y1:y2]\n            # Get the color of the region\n            color = object_colors(region, background=Color.BLACK)[0]\n            # Use one pixel to represent the original region\n            output_grid[i, j] = color\n\n    return output_grid\n\ndef generate_input():\n    # Randomly generate the grid size\n    width, height = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the grid separation\n    n_region_horizontal, n_region_vertical = np.random.randint(2, 5), np.random.randint(2, 5)\n    horizontal_region_boundaries = randomly_spaced_indices(max_len=width, n_indices=n_region_horizontal - 1, border_size=1, padding=2)\n    vertical_region_boundaries = randomly_spaced_indices(max_len=height, n_indices=n_region_vertical - 1, border_size=1, padding=2)\n\n    # Randomly select the colors to put in each region/partition\n    colors = np.random.choice(Color.NOT_BLACK, (n_region_horizontal, n_region_vertical), replace=True)\n\n    # Assign the colors to each partition\n    # Big (X,Y) indexes the partition coordinates, not the canvas coordinates, which are little (x,y)\n    for X in range(n_region_horizontal):\n        for Y in range(n_region_vertical):\n            # Get the region on the canvas\n            # Note that the final region goes all the way to the width/height\n            x1 = 0 if X == 0 else horizontal_region_boundaries[X-1]\n            x2 = horizontal_region_boundaries[X] if X \u003c len(horizontal_region_boundaries) else width\n            y1 = 0 if Y == 0 else vertical_region_boundaries[Y-1]\n            y2 = vertical_region_boundaries[Y] if Y \u003c len(vertical_region_boundaries) else height\n\n            # Each region is incomplete scattered color\n            sprite = np.full((x2 - x1, y2 - y1), Color.BLACK)\n            randomly_scatter_points(sprite, color=colors[X, Y], density=0.8)\n\n            # Place the pattern in the grid\n            blit_sprite(grid, sprite, x=x1, y=y1, background=Color.BLACK)\n\n    # Draw black lines to separate the colors\n    # First draw vertical lines\n    for x in horizontal_region_boundaries:\n        draw_line(grid=grid, x=x, y=0, direction=(0, 1), color=Color.BLACK)\n        # equivalently: grid[x, :] = Color.BLACK\n\n    # Then draw horizontal lines\n    for y in vertical_region_boundaries:\n        draw_line(grid=grid, x=0, y=y, direction=(1, 0), color=Color.BLACK)\n        # equivalently: grid[:, y] = Color.BLACK\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/95/images/test_input.png", "output": "output/seeds/seed_examples/95/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/95/images/train_input_0.png", "output": "output/seeds/seed_examples/95/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/95/images/train_input_1.png", "output": "output/seeds/seed_examples/95/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/95/images/train_input_2.png", "output": "output/seeds/seed_examples/95/images/train_output_2.png"}]}, "index": 95, "seed": "780d0b14", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# downscaling\n\n# description:\n# In the input you will see horizontal and vertical bars/dividers of a particular color that define rectangular regions, with some of the single-pixel vertices colored differently.\n# Some rectangular regions are have same color on the four vertices, and some are not.\n# To make the output, find the regions colored differently on all vertices and produce a single output pixel of that color in the corresponding part of the output.\n# Ignore regions which just have the color of the horizontal and vertical bars at their vertices.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input into  dividers, regions, and vertices\n    # 2. Extract the regions colored differently from the divider on all vertices\n    # 3. Produce the output grid by representing each region with a single pixel of the color of its vertices, as long as its color is not the divider\n\n    # 1. Parse the input\n    # Detect the objects\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # The divider color is the most frequent non-background color, and the background is black\n    divider_color = max(Color.NOT_BLACK, key=lambda color: np.sum(input_grid == color))\n\n    # Detect the single pixels that form the vertices of the regions\n    pixels = [ obj for obj in objects if object_colors(obj) != [divider_color] ]\n    x_positions = [object_position(obj)[0] for obj in pixels]\n    y_positions = [object_position(obj)[1] for obj in pixels]\n\n    # Ignore regions that are not part of those special pixels\n    x_min, x_max = min(x_positions), max(x_positions)\n    y_min, y_max = min(y_positions), max(y_positions)\n    input_grid = input_grid[x_min:x_max+1, y_min:y_max+1]\n\n    # Extract just the black regions delimited by the divider color\n    regions = find_connected_components(input_grid, background=divider_color, connectivity=4, monochromatic=True)\n    regions = [region for region in regions if object_colors(region, background=divider_color) == [Color.BLACK]]\n\n    # 2. Analyze vertices, which live on the diagonal corners of the regions, to find the color of the regions\n    # Determine their colors by the colors of their vertices, so we are going to have to look at the corners\n    def diagonal_corners(obj, background):\n        x, y, w, h = bounding_box(obj, background)\n        return [(x-1, y-1), (x + w, y-1), (x-1, y + h), (x + w, y + h)]\n    \n    region_colors = []\n    for region in regions:\n        vertex_colors = { input_grid[x, y] for x, y in diagonal_corners(region, background=divider_color) }\n        vertex_colors = set(vertex_colors)\n        if len(vertex_colors) == 1 and vertex_colors != {divider_color}:\n            region_colors.append(vertex_colors.pop())\n        else:\n            region_colors.append(Color.BLACK)\n\n    # 3. Produce the output grid, representing each big region as a single pixel\n    \n    # Find the number distinct X/Y positions of the regions, which tells us the size of the output\n    x_positions = sorted({object_position(region, background=divider_color)[0] for region in regions})\n    y_positions = sorted({object_position(region, background=divider_color)[1] for region in regions})\n\n    # Make the output\n    output_grid = np.full((len(x_positions), len(y_positions)), Color.BLACK)\n\n    for region, color in zip(regions, region_colors):\n        x, y = object_position(region, background=divider_color)\n        output_grid[x_positions.index(x), y_positions.index(y)] = color\n    \n    return output_grid\n            \ndef generate_input():\n    # We are going to generate square regions\n    # Randomly set square size and square number for each row\n    # Make sure the grid size is smaller than 30\n    square_size = np.random.randint(2, 4)\n    square_num = np.random.randint(6, 30 // (square_size + 1))\n\n    # Calculate the grid size\n    width = square_size * square_num + square_num - 1\n    height = width\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly set the color of the squares and lines\n    n_colors = 4\n    divider_color, *other_colors = np.random.choice(Color.NOT_BLACK, n_colors, replace=False)\n\n    # Draw horizontal/vertical lines to separate the square regions\n    # First draw the vertical lines\n    for x in range(square_size, width, square_size + 1):\n        draw_line(grid=grid, x=x, y=0, direction=(0, 1), color=divider_color)\n    # Then draw the horizontal lines\n    for y in range(square_size, height, square_size + 1):\n        draw_line(grid=grid, x=0, y=y, direction=(1, 0), color=divider_color)\n    \n    # Split the grid into black regions\n    regions = find_connected_components(grid=grid, background=divider_color, connectivity=4, monochromatic=True)\n    regions = [region for region in regions if object_colors(region, background=divider_color) == [Color.BLACK]]\n\n    # Repeatedly pick random regions and try coloring their vertices with a random color\n    # Remember that we can\u0027t recolor a vertex that is already colored differently from the divider\n    # Vertices are at diagonal corners, so define helper for this\n    def diagonal_corners(obj, background):\n        x, y, w, h = bounding_box(obj, background)\n        return [(x-1, y-1), (x + w, y-1), (x-1, y + h), (x + w, y + h)]\n    # check to make sure that we only consider regions whose corners are in the canvas\n    regions = [region for region in regions\n               if all(0 \u003c= x \u003c width and 0 \u003c= y \u003c height for x, y in diagonal_corners(region, background=divider_color))]\n    for _ in range(6):\n        region = random.choice(regions)\n        vertex_colors = { grid[x, y] for x, y in diagonal_corners(region, background=divider_color) }\n        # Pick the color, remembering that we can\u0027t recolor a vertex that is already colored differently from the divider\n        vertex_colors = vertex_colors - {divider_color}\n        if len(vertex_colors) == 0:\n            new_color = np.random.choice(other_colors)\n        elif len(vertex_colors) == 1:\n            new_color = vertex_colors.pop()\n        elif len(vertex_colors) \u003e 1:\n            continue\n\n        # Color the vertices\n        for x, y in diagonal_corners(region, background=divider_color):\n            grid[x, y] = new_color\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/96/images/test_input.png", "output": "output/seeds/seed_examples/96/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/96/images/train_input_0.png", "output": "output/seeds/seed_examples/96/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/96/images/train_input_1.png", "output": "output/seeds/seed_examples/96/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/96/images/train_input_2.png", "output": "output/seeds/seed_examples/96/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/96/images/train_input_3.png", "output": "output/seeds/seed_examples/96/images/train_output_3.png"}]}, "index": 96, "seed": "7837ac64", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color correspondence, object splitting\n\n# description:\n# In the input you will see a 9x9 grid with a 6x6 green sprite and a 2x2 sprite with 4 different colors separated by two teal lines.\n# To make the output grid, you should separate the 6x6 green sprite into 4 3x3 sub-sprites and color them \n# with the 4 different colors in the 2x2 sprite, with the same relative position.\n\ndef transform(input_grid):\n    # Detect four parts seperated by two intersected teal lines.\n    sub_grids = find_connected_components(grid=input_grid, connectivity=4, monochromatic=False, background=Color.TEAL)\n\n    # Find the green pattern and square with four colors as a coloring guidance.\n    for sub_grid in sub_grids:\n        cropped_sub_grid = crop(grid=sub_grid, background=Color.TEAL)\n\n        # If this part is the color guide, then store the color guide.\n        if np.all(cropped_sub_grid != Color.BLACK) and np.all(cropped_sub_grid != Color.GREEN):\n            color_guide = cropped_sub_grid\n\n        # If this part is the green pattern, then store the green pattern.s\n        elif np.any(cropped_sub_grid == Color.GREEN):\n            green_pattern = cropped_sub_grid\n    \n    # Caculate the size of four sub-sprites on green pattern to be colored.\n    width_green, height_green = green_pattern.shape\n    width_green_half, height_green_half = width_green // 2, height_green // 2\n    \n    # Color each sub-sprite on the green pattern follow the color guide: with the color in same relative position.\n    green_pattern[0: width_green_half, 0: height_green_half][green_pattern[0: width_green_half, 0: height_green_half] == Color.GREEN] = color_guide[0, 0]\n    green_pattern[width_green_half: width_green, 0: height_green_half][green_pattern[width_green_half: width_green, 0: height_green_half] == Color.GREEN] = color_guide[1, 0]\n    green_pattern[0: width_green_half, height_green_half: height_green][green_pattern[0: width_green_half, height_green_half: height_green] == Color.GREEN] = color_guide[0, 1]\n    green_pattern[width_green_half: width_green, height_green_half: height_green][green_pattern[width_green_half: width_green, height_green_half: height_green] == Color.GREEN] = color_guide[1, 1]\n\n    output_grid = green_pattern\n    return output_grid\n\ndef generate_input():\n    # Initialize the 9x9 grid with black color.\n    n, m = 9, 9\n    grid = np.zeros((n, m), dtype=int)\n\n    # Get available colors for the 2x2 sprite.\n    available_colors = [c for c in Color.NOT_BLACK if c != Color.GREEN and c != Color.TEAL]\n\n    # Generate the 6x6 green sprite with random pattern.\n    green_pattern = random_sprite(n=6, m=6, color_palette=[Color.GREEN], density=0.3)\n\n    # Get four different colors for the 2x2 sprite.\n    four_colors = random.sample(available_colors, 4)\n    color_guide = np.array([[four_colors[0], four_colors[1]], [four_colors[2], four_colors[3]]])\n\n    x_green, y_green = 3, 3\n    x_board, y_board = 0, 0\n\n    # Place the 6x6 green sprite and the 2x2 sprite on the input grid.\n    grid = blit_sprite(grid=grid, sprite=green_pattern, x=x_green, y=y_green, background=Color.BLACK)\n    grid = blit_sprite(grid=grid, sprite=color_guide, x=x_board, y=y_board, background=Color.BLACK)\n\n    # Place two teal lines that separate the 6x6 green sprite and the 2x2 sprite.\n    draw_line(grid=grid, color=Color.TEAL, x=x_board + 2, y=0, direction=(0, 1))\n    draw_line(grid=grid, color=Color.TEAL, x=0, y=y_board + 2, direction=(1, 0))\n\n    # Randomly rotate the input grid.\n    grid = np.rot90(grid, np.random.randint(0, 4))\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/97/images/test_input.png", "output": "output/seeds/seed_examples/97/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/97/images/train_input_0.png", "output": "output/seeds/seed_examples/97/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/97/images/train_input_1.png", "output": "output/seeds/seed_examples/97/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/97/images/train_input_2.png", "output": "output/seeds/seed_examples/97/images/train_output_2.png"}]}, "index": 97, "seed": "7c008303", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# denoising, topology\n\n# description:\n# In the input you will see a black background with large rectangles of the same color, and random \"noise\" pixels added at random locations sometimes on the rectangles and sometimes not.\n# To make the output, remove the noise pixels to reveal the rectangles.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract and classify the objects (rectangles, noise pixels)\n    # 2. If a noise pixel is significantly touching a rectangle (it has at least 2 neighbors that are part of the rectangle), then the noise reveals the rectangle color\n    # 3. Otherwise, the noise reveals the background, so delete the noise pixel\n\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=Color.BLACK)\n    rectangle_size_threshold = 4\n    noisy_objects = [ obj for obj in objects if np.sum(obj != Color.BLACK) \u003c rectangle_size_threshold ]\n    rectangle_objects = [ obj for obj in objects if np.sum(obj != Color.BLACK) \u003e= rectangle_size_threshold ]\n\n    output_grid = np.copy(input_grid)\n    for noise_object in noisy_objects:\n        noise_object_mask = noise_object != Color.BLACK\n        noise_neighbors_mask = object_neighbors(noise_object, connectivity=4, background=Color.BLACK)\n\n        for rectangle_object in rectangle_objects:\n            # Check if the noise object has at least 2 neighbors that are part of this rectangle\n            rectangle_object_mask = rectangle_object != Color.BLACK\n            if np.sum(noise_neighbors_mask \u0026 rectangle_object_mask) \u003e= 2:\n                rectangle_color = np.argmax(np.bincount(rectangle_object[rectangle_object_mask]))\n                output_grid[noise_object_mask] = rectangle_color\n                break\n        else:\n            # Delete this noise object\n            output_grid[noise_object_mask] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    w, h = np.random.randint(10, 25, size=2)\n    grid = np.full((w, h), Color.BLACK)\n\n    rectangle_color, noise_color = np.random.choice(Color.NOT_BLACK, size=2, replace=False)\n    n_rectangles = np.random.randint(2, 4)\n\n    for _ in range(n_rectangles):\n        rw, rh = np.random.randint(3, 2*w//3), np.random.randint(3, 2*h//3)\n        sprite = np.full((rw, rh), rectangle_color) # Can also do: random_sprite(rw, rh, color_palette=[rectangle_color], density=1)\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n    \n    n_noise_pixels = np.random.randint(8, 16)\n    for _ in range(n_noise_pixels):\n        x, y = np.random.randint(w), np.random.randint(h)\n        grid[x, y] = noise_color\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/98/images/test_input.png", "output": "output/seeds/seed_examples/98/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/98/images/train_input_0.png", "output": "output/seeds/seed_examples/98/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/98/images/train_input_1.png", "output": "output/seeds/seed_examples/98/images/train_output_1.png"}]}, "index": 98, "seed": "7e0986d6", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# denoising, topology\n\n# description:\n# In the input you will see a black background with large rectangles of the same color, and random \"noise\" pixels added at random locations, in the same color as the rectangles.\n# To make the output, remove the noise pixels, leaving only the big rectangles.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the neighbors of each pixel\n    # 2. If its neighbors are mostly colored (\u003e=2 neighbors), it\u0027s part of a rectangle\n    # 3. Otherwise, it\u0027s noise, so delete it\n\n    output_grid = np.copy(input_grid)\n\n    for x, y in np.argwhere(input_grid != Color.BLACK):\n        # Turn this single pixel into an object, and get its neighbors\n        obj = np.full(input_grid.shape, Color.BLACK)\n        obj[x, y] = input_grid[x, y]\n        neighbors_mask = object_neighbors(obj, connectivity=4, background=Color.BLACK)\n\n        # If the object has at least 2 colored neighbors, then it is part of a rectangle. Otherwise, it is noise, so delete it.\n        colors_of_neighbors = input_grid[neighbors_mask]\n        if np.sum(colors_of_neighbors != Color.BLACK) \u003e= 2:\n            # has at least 2 colored neighbors, so it\u0027s part of a rectangle\n            pass\n        else:\n            # doesn\u0027t have at least 2 colored neighbors, so delete it\n            output_grid[x, y] = Color.BLACK\n\n    return output_grid\n\n\ndef generate_input():\n    w, h = np.random.randint(10, 25, size=2)\n    grid = np.full((w, h), Color.BLACK)\n\n    color = np.random.choice(Color.NOT_BLACK)\n    n_rectangles = np.random.randint(2, 4)\n\n    for _ in range(n_rectangles):\n        rw, rh = np.random.randint(3, 2*w//3), np.random.randint(3, 2*h//3)\n        sprite = np.full((rw, rh), color) # Can also do: random_sprite(rw, rh, color_palette=[rectangle_color], density=1)\n        x, y = random_free_location_for_sprite(grid, sprite)\n        blit_sprite(grid, sprite, x, y)\n    \n    n_noise_pixels = np.random.randint(8, 16)\n    for _ in range(n_noise_pixels):\n        x, y = np.random.randint(w), np.random.randint(h)\n        grid[x, y] = color\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/99/images/test_input.png", "output": "output/seeds/seed_examples/99/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/99/images/train_input_0.png", "output": "output/seeds/seed_examples/99/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/99/images/train_input_1.png", "output": "output/seeds/seed_examples/99/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/99/images/train_input_2.png", "output": "output/seeds/seed_examples/99/images/train_output_2.png"}]}, "index": 99, "seed": "7f4411dc", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects, topology\n\n# description:\n# In the input grid, you will see various blue objects. Some are \"hollow\" and contain a fully-enclosed region, while others do not have a middle that is separate from outside the object, and fully enclosed.\n# To create the output grid, copy the input grid. Then, change the color of all \"hollow\" shapes to be green.\n\ndef transform(input_grid):\n    objects = find_connected_components(input_grid, connectivity=4)\n    output_grid = input_grid.copy()\n    for object in objects:\n        if is_hollow(object):\n            object[object != Color.BLACK] = Color.GREEN\n        blit_object(output_grid, object, background=Color.BLACK)\n\n    return output_grid\n\ndef is_hollow(object):\n    # to check if it contains a fully enclosed region, find everything that is enclosed by the object (in its interior), but not actually part of the object\n    interior_mask = object_interior(object)\n    object_mask = object != Color.BLACK\n    hollow_mask = interior_mask \u0026 ~object_mask\n    return np.any(hollow_mask)\n\n\ndef generate_input():\n    n = np.random.randint(10, 28)\n    input_grid = np.full((n, n), Color.BLACK)\n    # create a bunch of random objects. all objects are either (1) hollow, in which case they are the border of a rectangle of some size, or (2) not hollow, in which case they are a subset of a border of a rectangle of some size.\n    # make sure we place at least one hollow and nonhollow object. then add random objects until somewhat full.\n\n    def random_hollow_object():\n        n, m = np.random.randint(3, 7), np.random.randint(3, 7)\n        obj = np.full((n, m), Color.BLUE)\n        obj[1:n-1, 1:m-1] = Color.BLACK\n        return obj\n\n    def random_nonhollow_object():\n        obj = random_hollow_object()\n        # remove a random number of dots from it\n        size = np.count_nonzero(obj)\n        new_size = np.random.randint(1, size)\n        xs, ys = np.where(obj != Color.BLACK)\n        for i in range(size - new_size):\n            obj[xs[i], ys[i]] = Color.BLACK\n\n        return obj\n\n    try:\n        # add one hollow and one nonhollow object, then add random objects until somewhat full.\n        obj = random_hollow_object()\n        x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n        blit_sprite(input_grid, obj, x=x, y=y)\n\n        obj = random_nonhollow_object()\n        x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n        blit_sprite(input_grid, obj, x=x, y=y)\n    except ValueError:\n        return generate_input()\n\n    while True:\n        obj = random_hollow_object() if np.random.rand() \u003c 0.5 else random_nonhollow_object()\n        try:\n            x, y = random_free_location_for_sprite(input_grid, obj, padding=1)\n            blit_sprite(input_grid, obj, x=x, y=y)\n        except ValueError:\n            return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/100/images/test_input.png", "output": "output/seeds/seed_examples/100/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/100/images/train_input_0.png", "output": "output/seeds/seed_examples/100/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/100/images/train_input_1.png", "output": "output/seeds/seed_examples/100/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/100/images/train_input_2.png", "output": "output/seeds/seed_examples/100/images/train_output_2.png"}]}, "index": 100, "seed": "810b9b61", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# geometric pattern\n\n# description:\n# In the input you will see a grid with a single coloured pixel.\n# To make the output, move the colored pixel down one pixel and draw a yellow line from the pixel to the top of the grid.\n# Finally repeat the yellow line by repeating it horizontally left/right with a period of 2 pixels.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract the pixel from the input grid\n    # 2. Move the pixel one pixel down\n    # 3. Draw a yellow line from the pixel to the top of the grid, repeating it horizontally left/right with a period of 2 pixels\n\n    # 1. Extract the pixel\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_x, pixel_y = object_position(pixel)\n    pixel_color = object_colors(pixel)[0]\n\n    # 2. Move the pixel one pixel down\n    output_grid = input_grid.copy()\n    output_grid[pixel_x, pixel_y + 1] = pixel_color\n    output_grid[pixel_x, pixel_y] = Color.BLACK\n\n    # 3. Draw the vertical line from the pixel to top\n\n    # Draw the line from left to right\n    horizontal_period = 2\n    for x in range(pixel_x, output_grid.shape[0], horizontal_period):\n        draw_line(output_grid, x=x, y=pixel_y, direction=(0, -1), color=Color.YELLOW)\n\n    # Draw the line from left to right\n    for x in range(pixel_x, -1, -horizontal_period):\n        draw_line(output_grid, x=x, y=pixel_y, direction=(0, -1), color=Color.YELLOW)\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 30, size=2)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly choose one color\n    color = np.random.choice([color for color in Color.NOT_BLACK if color != Color.YELLOW])\n\n    # Randomly place the pixel on the grid\n    x, y = np.random.randint(0, width - 1), np.random.randint(0, height - 1)\n    grid[x, y] = color\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/101/images/test_input.png", "output": "output/seeds/seed_examples/101/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/101/images/train_input_0.png", "output": "output/seeds/seed_examples/101/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/101/images/train_input_1.png", "output": "output/seeds/seed_examples/101/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/101/images/train_input_2.png", "output": "output/seeds/seed_examples/101/images/train_output_2.png"}]}, "index": 101, "seed": "834ec97d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation\n\n# description:\n# In the input you will see a grid with a single pixel on the bottom of the grid.\n# To make the output, you should draw a geometric pattern starting outward from the pixel:\n# step 1: draw vertical bars starting from the pixel and going to the right with a horizontal period of 2.\n# step 2: put a grey pixel in between the vertical bars alternating between the top / bottom.\n\ndef transform(input_grid):\n    # Output grid is the same size as the input grid\n    output_grid = np.zeros_like(input_grid)\n\n    # Detect the pixel on the bottom of the grid\n    pixel = find_connected_components(input_grid, monochromatic=True)[0]\n    pixel_color = object_colors(pixel)[0]\n    pixel_x, pixel_y = object_position(pixel)\n\n    # Get the color of the pattern pixel by observation\n    pattern_pixel_color = Color.GRAY\n    \n    # STEP 1: Draw vertical bar from bottom to top starting from the pixel and going to the right, horizontal period of 2\n    horizontal_period = 2\n    for x in range(pixel_x, output_grid.shape[0], horizontal_period):\n        draw_line(output_grid, x=x, y=pixel_y, direction=(0, -1), color=pixel_color)\n    \n    # STEP 2: put a grey pixel in between the vertical bars alternating between the top / bottom.\n    cur_y = -1 if pixel_y == 0 else 0\n    for x in range(pixel_x + 1, output_grid.shape[0], horizontal_period):\n        output_grid[x, cur_y] = pattern_pixel_color\n        # alternate between top and bottom\n        cur_y = 0 if cur_y == -1 else -1\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose the color of the line\n    pattern_pixel_color = Color.GRAY\n    color = np.random.choice([color for color in Color.NOT_BLACK if color != pattern_pixel_color])\n\n    # Randomly place the pixel on the bottom of the grid\n    x = np.random.randint(0, n)\n    grid[x, -1] = color\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/102/images/test_input.png", "output": "output/seeds/seed_examples/102/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/102/images/train_input_0.png", "output": "output/seeds/seed_examples/102/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/102/images/train_input_1.png", "output": "output/seeds/seed_examples/102/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/102/images/train_input_2.png", "output": "output/seeds/seed_examples/102/images/train_output_2.png"}]}, "index": 102, "seed": "8403a5d5", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# puzzle pieces, rescaling\n\n# description:\n# In the input you will see a small multicolored object, and a big region bordered by 4 yellow pixels in the corners. The big region contains some colored things.\n# To make the output, rescale and translate the small multicolored object so that it is in the big region and matches as much as possible the colors of the things in the big region.\n# The output should be just the big region with its 4 yellow pixels (plus the rescaled and translated thing).\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the little object, yellow pixels, and big region\n    # 2. Rescale and translate the little object to cover as much of the big region as possible, matching colors whenever they overlap\n\n    # 1. Detect little object, yellow pixels, and big region\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK, monochromatic=False)\n    yellow_pixel_objects = [ obj for obj in objects if set(object_colors(obj, background=Color.BLACK)) == {Color.YELLOW} and crop(obj).shape == (1, 1) ]\n    assert len(yellow_pixel_objects) == 4, \"There should be exactly 4 yellow pixels\"\n\n    # Find the region indicated by the 4 yellow pixels\n    yellow_pixel_min_x, yellow_pixel_max_x, yellow_pixel_min_y, yellow_pixel_max_y = \\\n        min([ object_position(obj, anchor=\"center\")[0] for obj in yellow_pixel_objects ]), \\\n        max([ object_position(obj, anchor=\"center\")[0] for obj in yellow_pixel_objects ]), \\\n        min([ object_position(obj, anchor=\"center\")[1] for obj in yellow_pixel_objects ]), \\\n        max([ object_position(obj, anchor=\"center\")[1] for obj in yellow_pixel_objects ])\n    \n    # The little object is what is outside that region\n    little_objects = [ obj for obj in objects\n                      if object_position(obj, anchor=\"center\")[0] \u003c yellow_pixel_min_x or object_position(obj, anchor=\"center\")[0] \u003e yellow_pixel_max_x or object_position(obj, anchor=\"center\")[1] \u003c yellow_pixel_min_y or object_position(obj, anchor=\"center\")[1] \u003e yellow_pixel_max_y ]\n    assert len(little_objects) == 1, \"There should be exactly one little object\"\n    little_object = little_objects[0]\n\n    # The output grid is going to be the region delimited by the yellow pixels\n    output_grid = input_grid[yellow_pixel_min_x:yellow_pixel_max_x+1, yellow_pixel_min_y:yellow_pixel_max_y+1]\n\n    # The big region has some colored pixels that we are going to try and match with\n    # Extract the content of big region as tuples (x, y, color)\n    big_region_pixels = [ (x, y, output_grid[x, y])\n                         for x in range(output_grid.shape[0]) for y in range(output_grid.shape[1])\n                         if output_grid[x, y] != Color.BLACK and output_grid[x, y] != Color.YELLOW ]\n\n    # 2. Rescale and translate the little object to cover as much of the big region as possible, matching colors whenever they overlap\n    little_sprite = crop(little_object, background=Color.BLACK)\n    scaled_sprites = [ scale_sprite(little_sprite, factor) for factor in [1, 2, 3, 4, 5, 6] ]\n    # A placement solution is a tuple of (x, y, scaled_sprite) where x, y is the top-left corner of the scaled sprite\n    possible_solutions = [ (x, y, scaled_sprite) for scaled_sprite in scaled_sprites\n                          for x in range(output_grid.shape[0] - scaled_sprite.shape[0])\n                          for y in range(output_grid.shape[0] - scaled_sprite.shape[1]) ]\n    \n    # Filter placement solutions to only those where the colors of the big region match the colors of the scaled+translated sprite\n    def valid_solution(x, y, scaled_sprite):\n        # Make a canvas to try putting down the scaled sprite\n        test_canvas = np.full_like(output_grid, Color.BLACK)\n        blit_sprite(test_canvas, scaled_sprite, x, y)\n        # Check if every big region color is also in the test canvas\n        test_colors = [ (x, y, test_canvas[x, y]) for x in range(output_grid.shape[0]) for y in range(output_grid.shape[1]) if test_canvas[x, y] != Color.BLACK ]\n        return all( (x, y, color) in test_colors for x, y, color in big_region_pixels )        \n    \n    possible_solutions = [ solution for solution in possible_solutions if valid_solution(*solution) ]\n    if len(possible_solutions) == 0:\n        assert False, \"No solution found for the little object\"\n    \n    # Pick the first solution and blit the sprite into the output grid\n    x, y, scaled_sprite = list(possible_solutions)[0]\n    blit_sprite(output_grid, scaled_sprite, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Create a little object and then rescale it to make a big version.\n    # Cover up some parts of the big version with black pixels, and put yellow markers in the corners.\n    # Finally figure out how to put everything on a big canvas\n\n    little_sprite = random_sprite([2,3,4], [2,3,4], connectivity=4, color_palette=[color for color in Color.NOT_BLACK if color != Color.YELLOW], background=Color.BLACK)\n    scaling_factor = np.random.randint(2, 4+1)\n    big_sprite = scale_sprite(little_sprite, scaling_factor)\n\n    # Cover up some parts of the big sprite with black pixels\n    for _ in range(np.random.randint(1, 3)):\n        x0, y0 = np.random.randint(0, big_sprite.shape[0]), np.random.randint(0, big_sprite.shape[1])\n        x1, y1 = np.random.randint(x0, big_sprite.shape[0]), np.random.randint(y0, big_sprite.shape[1])\n        big_sprite[x0:x1+1, y0:y1+1] = Color.BLACK\n\n    # Create a big-ish canvas\n    width, height = np.random.randint(big_sprite.shape[0]+7, 30), np.random.randint(big_sprite.shape[1]+7, 30)\n    grid = np.full((width, height), Color.BLACK)\n    \n    # Put the big sprite in the canvas\n    x, y = random_free_location_for_sprite(grid, big_sprite, background=Color.BLACK)\n    blit_sprite(grid, big_sprite, x, y)\n\n    # Put yellow markers in the corners\n    grid[x-1, y-1] = Color.YELLOW\n    grid[x-1, y+big_sprite.shape[1]] = Color.YELLOW\n    grid[x+big_sprite.shape[0], y-1] = Color.YELLOW\n    grid[x+big_sprite.shape[0], y+big_sprite.shape[1]] = Color.YELLOW\n    \n    # Find a spot for the little sprite\n    x, y = random_free_location_for_sprite(grid, little_sprite, background=Color.BLACK)\n    blit_sprite(grid, little_sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/103/images/test_input.png", "output": "output/seeds/seed_examples/103/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/103/images/train_input_0.png", "output": "output/seeds/seed_examples/103/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/103/images/train_input_1.png", "output": "output/seeds/seed_examples/103/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/103/images/train_input_2.png", "output": "output/seeds/seed_examples/103/images/train_output_2.png"}]}, "index": 103, "seed": "8a004b2b", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# flip\n\n# description:\n# In the input you will see a monochromatic sprite.\n# To make the output, \n# 1. flip the grid horizontally with y-axis on the left side of the grid, making the canvas twice larger.\n# 2. flip it down with x-axis on the bottom side of the grid.\n# 3. concatenate the flipped grid in step 2 to the top and bottom of the grid in step 1.\n# In total the output grid is twice as wide and three times as tall as the input.\n\ndef transform(input_grid):\n    # Create the output grid twice as wide and three times as tall\n    n, m = input_grid.shape\n    output_grid = np.zeros((n * 2, m * 3), dtype=int)\n\n    # Step 1: Flip the grid horizontally with y-axis on the left side of the grid, concate it to the left.\n    # Place it in the middle of the output grid\n    flip_grid = np.flipud(input_grid)\n    blit_sprite(output_grid, sprite=flip_grid, x=0, y=m)\n    blit_sprite(output_grid, sprite=input_grid, x=n, y=m)\n\n    # Step 2: Flip it down with x-axis on the bottom side of the grid, concate it to the bottom and top.\n    original_object = output_grid[:, m :2 * m]\n    filp_down_object = np.fliplr(original_object)\n    blit_sprite(output_grid, sprite=filp_down_object, x=0, y=m * 2)\n    blit_sprite(output_grid, sprite=filp_down_object, x=0, y=0)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate grid of size n x m\n    n, m = np.random.randint(2, 6), np.random.randint(2, 6)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose 1 color\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # Randomly choose the density of the color\n    density = np.random.randint(2, n * m) / (n * m)\n\n    # Randomly scatter the color in the grid\n    randomly_scatter_points(grid, color=color, density=density)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/104/images/test_input.png", "output": "output/seeds/seed_examples/104/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/104/images/train_input_0.png", "output": "output/seeds/seed_examples/104/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/104/images/train_input_1.png", "output": "output/seeds/seed_examples/104/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/104/images/train_input_2.png", "output": "output/seeds/seed_examples/104/images/train_output_2.png"}]}, "index": 104, "seed": "8d5021e8", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# magnetism, lines\n\n# description:\n# In the input, you will see a horizontal grey line on a black background, with red and blue pixels scattered on either side of the line.\n# To make the output, draw vertical lines from each of the blue and red pixels, with lines from the red pixels going toward the grey line and lines from the blue pixels going away from the grey line. \n# These lines should stop when they hit the grey line or the edge of the grid.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # find the location of the horizontal grey line\n    grey_line = np.where(output_grid == Color.GREY)\n\n    # get the unique y-coordinates of the grey line\n    grey_line_y = np.unique(grey_line[1])\n\n    # find the red and blue pixels\n    red_pixels = np.where(output_grid == Color.RED)\n    blue_pixels = np.where(output_grid == Color.BLUE)\n\n    # draw lines from the red pixels toward the grey line\n    for i in range(len(red_pixels[0])):\n        x, y = red_pixels[0][i], red_pixels[1][i]\n        # make sure to handle the case where the red pixel is below the grey line and the case where it is above\n        if y \u003c grey_line_y:\n            draw_line(output_grid, x, y, length=None, color=Color.RED, direction=(0, 1), stop_at_color=[Color.GREY])\n        else:\n            draw_line(output_grid, x, y, length=None, color=Color.RED, direction=(0, -1), stop_at_color=[Color.GREY])\n\n    # draw lines from the blue pixels away from the grey line, using draw_line\n    for i in range(len(blue_pixels[0])):\n        x, y = blue_pixels[0][i], blue_pixels[1][i]\n        # make sure to handle the case where the blue pixel is below the grey line and the case where it is above\n        if y \u003c grey_line_y:\n            draw_line(output_grid, x, y, length=None, color=Color.BLUE, direction=(0, -1), stop_at_color=[Color.GREY])\n        else:\n            draw_line(output_grid, x, y, length=None, color=Color.BLUE, direction=(0, 1), stop_at_color=[Color.GREY])\n\n    return output_grid\n\ndef generate_input():\n    # make a 10x10 black grid for the background\n    n = m = 10\n    grid = np.zeros((n,m), dtype=int)\n\n    # make a horizontal grey line on a random row about halfway down the grid\n    row = np.random.randint(m//3, 2*(m//3))\n    grid[:, row] = Color.GREY\n\n    # scatter a random number of blue and red pixels on either side of the grey line so that no pixel is in the same column as any other pixel on its side of the grey line\n    # select columns for the pixels above the grey line\n    cols = np.random.choice(np.arange(m), size=np.random.randint(3, 7), replace=False)\n    for col in cols:\n      # randomly choose whether to make the pixel red or blue\n      if np.random.rand() \u003c 0.5:\n        grid[col, np.random.randint(row-1)] = Color.RED\n      else:\n        grid[col, np.random.randint(row-1)] = Color.BLUE\n    # select columns for the pixels below the grey line\n    cols = np.random.choice(np.arange(m), size=np.random.randint(3, 7), replace=False)\n    for col in cols:\n      # randomly choose whether to make the pixel red or blue\n      if np.random.rand() \u003c 0.5:\n        grid[col, np.random.randint(row+1, m)] = Color.RED\n      else:\n        grid[col, np.random.randint(row+1, m)] = Color.BLUE \n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/105/images/test_input.png", "output": "output/seeds/seed_examples/105/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/105/images/train_input_0.png", "output": "output/seeds/seed_examples/105/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/105/images/train_input_1.png", "output": "output/seeds/seed_examples/105/images/train_output_1.png"}]}, "index": 105, "seed": "8d510a79", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color stripe, fill the square in order\n\n# description:\n# In the input you will see several vertical or horizontal stripes of different colors and a gray square with length equal the number of the stripes.\n# To make the output, fill the gray square with the colors of the stripes in the order and direction they appear.\n\ndef transform(input_grid):\n    # Find the gray square in the input grid and get its position and size\n    gray_rectangle = detect_objects(grid=input_grid, colors=[Color.GRAY], monochromatic=True, connectivity=4)[0]\n    output_grid = crop(grid=gray_rectangle)\n\n    # Get the color lines in the input grid\n    objects = detect_objects(grid=input_grid, monochromatic=False, connectivity=8)\n    lines = []\n    for obj in objects:\n        # Get the position and size of the color line\n        x_pos, y_pos, x_len, y_len = bounding_box(grid=obj)\n        color = obj[x_pos, y_pos]\n        if color != Color.GRAY:\n            lines.append({\u0027x\u0027: x_pos, \u0027y\u0027: y_pos, \u0027color\u0027: color, \u0027x_len\u0027: x_len, \u0027y_len\u0027: y_len})\n    \n    # Check if the stripes are horizontal or vertical\n    is_horizontal = all(line[\u0027y_len\u0027] == 1 for line in lines)\n\n    # Sort the color lines by their position\n    if is_horizontal:\n        lines = sorted(lines, key=lambda x: x[\u0027y\u0027])\n    else:\n        lines = sorted(lines, key=lambda x: x[\u0027x\u0027])\n    \n    # Get the direction of the stripes\n    direction = (1, 0) if is_horizontal else (0, 1)\n\n    # Find the colors lines in the input grid in order\n    colors_in_square = [c[\u0027color\u0027] for i, c in enumerate(lines) if i == 0 or c[\u0027color\u0027] != lines[i - 1][\u0027color\u0027]]\n\n    # Fill the gray square with the colors of the stripes in the order and direction they appear\n    for i in range(len(output_grid)):\n        # Draw horizontal line\n        if is_horizontal:\n            draw_line(grid=output_grid, x=0, y=i, direction=direction, color=colors_in_square[i])\n        # Draw vertical line\n        else:\n            draw_line(grid=output_grid, x=i, y=0, direction=direction, color=colors_in_square[i])\n            \n    return output_grid\n\ndef generate_input():\n    # Initialize the grid, make sure the length and width are not too different\n    n, m = np.random.randint(9, 24), np.random.randint(9, 24)\n    while n \u003e 1.5 * m or m \u003e 1.5 * n:\n        n, m = np.random.randint(9, 24), np.random.randint(9, 24)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Set stripe\u0027s interval\n    STRIPE_INTERVAL = 3\n\n    # Randomly choose the starting position of the stripe\n    start_from = np.random.randint(0, STRIPE_INTERVAL)\n\n    # Calculate the number of horizontal stripes given the start position, direction and interval\n    num_lines = (m - start_from + STRIPE_INTERVAL - 1) // STRIPE_INTERVAL\n    \n    # Randomly choose the colors of the stripes, each stripe has a different color\n    avaliable_colors = [c for c in Color.NOT_BLACK if c != Color.GRAY]\n    colors = random.sample(avaliable_colors, num_lines)\n\n    # Draw horizontal stripes with different colors\n    for i in range(num_lines):\n        x, y = 0, i * STRIPE_INTERVAL + start_from\n        draw_line(grid=grid, x=x, y=y, direction=(1, 0), color=colors[i])\n\n    # Draw the gray square and its black border, the length of the square is the same as the number of the stripes\n    square_x, square_y = np.random.randint(0, n - (num_lines + 1)), np.random.randint(0, m - (num_lines + 1))\n    black_border = np.full((num_lines + 2, num_lines + 2), Color.BLACK)\n    gray_object = np.full((num_lines, num_lines), Color.GRAY)\n    grid = blit_sprite(grid, black_border, square_x, square_y, background=Color.GRAY)\n    grid = blit_sprite(grid, gray_object, square_x + 1, square_y + 1)\n\n    # Randomly rotate the grid\n    grid = np.rot90(grid, 1) if np.random.choice([True, False]) else grid\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/106/images/test_input.png", "output": "output/seeds/seed_examples/106/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/106/images/train_input_0.png", "output": "output/seeds/seed_examples/106/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/106/images/train_input_1.png", "output": "output/seeds/seed_examples/106/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/106/images/train_input_2.png", "output": "output/seeds/seed_examples/106/images/train_output_2.png"}]}, "index": 106, "seed": "8e1813be", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rotate, position\n\n# description:\n# In the input you will see a grid with 3 regions separated by grey horizontal lines. The leftmost region contains a multicolored sprite and the others are empty (black)\n# To make the output, rotate the leftmost region 90 degree clockwise and place it in the first empty region, then rotate it a further 90 degrees and put it in the second empty region, etc.\n\ndef transform(input_grid):\n    # Get all the regions separated by the divider in the input grid\n    divider_color = Color.GRAY\n    regions = find_connected_components(input_grid, connectivity=4, background=divider_color, monochromatic=False)\n\n    # Sort the region by x position so that we can get the leftmost, middle, and rightmost regions\n    regions.sort(key=lambda region: object_position(region, background=divider_color)[0])\n\n    # We are going to draw on top of the input\n    output_grid = input_grid.copy()\n\n    # Get the leftmost region which contains the multicolored sprite\n    leftmost_region = regions[0]\n    template_sprite = crop(grid=leftmost_region, background=divider_color)\n\n    empty_regions = regions[1:]\n\n    for empty_region in empty_regions:\n        # Rotate the template sprite 90 degree clockwise\n        template_sprite = np.rot90(template_sprite)\n\n        # Place the rotated template sprite in the empty region\n        x, y = object_position(empty_region, background=divider_color)\n        blit_sprite(output_grid, sprite=template_sprite, x=x, y=y)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a grid with some regions separated by vertical grey lines\n    # This is generalized so that there can be various numbers of regions\n    n_regions = random.choice([2, 3, 4, 5])\n    region_size = np.random.randint(3, 6)\n    n_dividers = n_regions - 1\n    width, height = n_regions * region_size + n_dividers, region_size\n    grid = np.full((width, height), Color.BLACK)\n\n    # Draw lines for the dividers\n    line_color = Color.GRAY\n    for x in range(region_size, width, region_size + 1):\n        draw_line(grid, x=x, y=0, direction=(0, 1), color=line_color)\n\n    # Draw one template\n    possible_colors = [color for color in Color.NOT_BLACK if color != line_color]\n    template_sprite = random_sprite(region_size, region_size, color_palette=possible_colors, density=1.0)\n\n    # Place the template pattern in the first black region\n    x, y = 0, 0\n    blit_sprite(grid, sprite=template_sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/107/images/test_input.png", "output": "output/seeds/seed_examples/107/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/107/images/train_input_0.png", "output": "output/seeds/seed_examples/107/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/107/images/train_input_1.png", "output": "output/seeds/seed_examples/107/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/107/images/train_input_2.png", "output": "output/seeds/seed_examples/107/images/train_output_2.png"}]}, "index": 107, "seed": "8e5a5113", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# downscaling, rectangular regions\n\n# description:\n# In the input you will see a grid consisting of monochromatic rectangular regions/partitions (chessboard pattern) of different colors.\n# Each rectangular region/partition/chessboard cell is filled with a single color, and has a different size.\n# To make the output, make a grid with one pixel for each cell of the chessboard.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the colored regions in the input grid\n    # 2. Get the coordinates of the chessboard pattern, which are the x/y positions of the regions\n    # 3. Draw the output grid with one pixel for each region (cell of the chessboard)\n\n    # 1. Input parsing\n    # Find the colored objects in the input grid\n    objects = find_connected_components(grid=input_grid, connectivity=4, monochromatic=True, background=Color.BLACK)\n\n    # 2. Figuring out the chessboard pattern\n    # Get the position of the objects\n    x_position_list = [object_position(obj)[0] for obj in objects]\n    y_position_list = [object_position(obj)[1] for obj in objects]\n\n    # Sort the position list, and get the unique position list since\n    # the pattern is separated as chessboard\n    x_position_list = sorted(np.unique(x_position_list))\n    y_position_list = sorted(np.unique(y_position_list))\n\n    # 3. Drawing the output\n    # Get the size of chessboard with one pixel represents the original region\n    w_color, h_color = len(x_position_list), len(y_position_list)\n    output_grid = np.full((w_color, h_color), Color.BLACK)\n\n    for x_index, x in enumerate(x_position_list):\n        for y_index, y in enumerate(y_position_list):\n            # Use one pixel to represent the original region\n            output_grid[x_index, y_index] = input_grid[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Randomly choose the a number of vertical and horizontal partitions, each of which will have a random color\n    n_regions_horizontal, n_regions_vertical = np.random.randint(2, 4), np.random.randint(2, 4)\n    colors = np.random.choice(Color.NOT_BLACK, (n_regions_horizontal, n_regions_vertical), replace=True)\n\n    # Randomly choose the size of the region of the canvas that we are going to color with a sprite\n    sprite_w, sprite_h = np.random.randint(15, 20), np.random.randint(15, 20)\n\n    # Randomly separate into a 2d grid of regions\n    horizontal_endpoints = randomly_spaced_indices(max_len=sprite_w, n_indices=n_regions_horizontal - 1, border_size=1, padding=2)\n    vertical_endpoints = randomly_spaced_indices(max_len=sprite_h, n_indices=n_regions_vertical - 1, border_size=1, padding=2)\n\n\n    # Assign the colors to different regions\n    sprite = np.zeros((sprite_w, sprite_h), dtype=int)\n    for X in range(n_regions_horizontal):\n        for Y in range(n_regions_vertical):\n            x1 = 0 if X == 0 else horizontal_endpoints[X-1]\n            x2 = horizontal_endpoints[X] if X \u003c len(horizontal_endpoints) else sprite_w\n            y1 = 0 if Y == 0 else vertical_endpoints[Y-1]\n            y2 = vertical_endpoints[Y] if Y \u003c len(vertical_endpoints) else sprite_h\n\n            sprite[x1:x2, y1:y2] = colors[X, Y]\n    \n    # Randomly place the sprite in the grid\n    # The grid size is larger than the sprite size\n    n, m = np.random.randint(sprite_w + 1, 30), np.random.randint(sprite_h + 1, 30)\n    grid = np.full((n, m), Color.BLACK)\n    x, y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK)\n    blit_sprite(grid, sprite, x=x, y=y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/108/images/test_input.png", "output": "output/seeds/seed_examples/108/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/108/images/train_input_0.png", "output": "output/seeds/seed_examples/108/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/108/images/train_input_1.png", "output": "output/seeds/seed_examples/108/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/108/images/train_input_2.png", "output": "output/seeds/seed_examples/108/images/train_output_2.png"}]}, "index": 108, "seed": "90c28cc7", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# objects separated by lines, color correspond to position\n\n# description:\n# In the input you will see several gray lines that separate the grid into several parts.\n# To make the output grid, you should color the upper left part with blue, the lower right part with green,\n# and the middle part with red.\n\ndef transform(input_grid):\n    # Find all the black rectangles separated by gray lines\n    black_rectangles = find_connected_components(grid=input_grid, connectivity=4, monochromatic=False, background=Color.GRAY)\n\n    # Get the bounding box of each black rectangle\n    rectangles_lists = []\n    for rectangle in black_rectangles:\n        x, y, w, h = bounding_box(grid=rectangle, background=Color.GRAY)\n        rectangles_lists.append({\u0027x\u0027: x, \u0027y\u0027: y, \u0027w\u0027: w, \u0027h\u0027: h})\n\n    # Sort the rectangles by x and y position\n    rectangles_lists = sorted(rectangles_lists, key=lambda rec: rec[\u0027x\u0027])\n    rectangles_lists = sorted(rectangles_lists, key=lambda rec: rec[\u0027y\u0027])\n    \n    left_upper_rectangle, middle_rectangle, right_bottom_rectangle = rectangles_lists[0], rectangles_lists[len(rectangles_lists) // 2], rectangles_lists[-1]\n\n    # Color the left upper part with blue\n    blue_grid = np.full((left_upper_rectangle[\u0027w\u0027], left_upper_rectangle[\u0027h\u0027]), Color.BLUE)\n\n    # Color the right lower part with green\n    green_grid = np.full((right_bottom_rectangle[\u0027w\u0027], right_bottom_rectangle[\u0027h\u0027]), Color.GREEN)\n\n    # Color the middle part with red\n    red_grid = np.full((middle_rectangle[\u0027w\u0027], middle_rectangle[\u0027h\u0027]), Color.RED)\n\n    # Place the blue, green, and red grid on the input grid\n    output_grid = input_grid.copy()\n    output_grid = blit_sprite(grid=input_grid, sprite=blue_grid, x=left_upper_rectangle[\u0027x\u0027], y=left_upper_rectangle[\u0027y\u0027])\n    output_grid = blit_sprite(grid=input_grid, sprite=green_grid, x=right_bottom_rectangle[\u0027x\u0027], y=right_bottom_rectangle[\u0027y\u0027])\n    output_grid = blit_sprite(grid=input_grid, sprite=red_grid, x=middle_rectangle[\u0027x\u0027], y=middle_rectangle[\u0027y\u0027])\n            \n    return output_grid\n\ndef generate_input():\n    # Generate a square grid as the black background\n    grid_len = np.random.randint(10, 20)\n    n, m = grid_len, grid_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Get the number of horizontal and vertical lines\n    line_nums = [2, 4]\n    line_num = np.random.choice(line_nums)\n\n    # Generate the gray lines\u0027 positions with interval between each line to form several rectangles\n    # If padding is True, the lines will be padded with 1 grid on both sides\n    vertical_lines = randomly_spaced_indices(max_len=n, n_indices=line_num, border_size=1, padding=4)\n    horizontal_lines = randomly_spaced_indices(max_len=m, n_indices=line_num, border_size=1, padding=2)\n\n    # Draw the gray vertical and horizontal lines on the grid\n    for vertical_line in vertical_lines:\n        draw_line(grid=grid, x=vertical_line, y=0, direction=(0, 1), color=Color.GRAY)\n    \n    for horizontal_line in horizontal_lines:\n        draw_line(grid=grid, x=0, y=horizontal_line, direction=(1, 0), color=Color.GRAY)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/109/images/test_input.png", "output": "output/seeds/seed_examples/109/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/109/images/train_input_0.png", "output": "output/seeds/seed_examples/109/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/109/images/train_input_1.png", "output": "output/seeds/seed_examples/109/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/109/images/train_input_2.png", "output": "output/seeds/seed_examples/109/images/train_output_2.png"}]}, "index": 109, "seed": "941d9a10", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# puzzle pieces, rotation\n\n# description:\n# In the input you will see a red object with holes in it, and several multicolored 3x3 \"puzzle pieces\"\n# To make the output, crop to just the red object and then put each puzzle piece in the red object so that the red pixels in the puzzle piece perfectly fit into the holes in the red object. You can rotate and translate the puzzle pieces to make them fit.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the object, separating the puzzle pieces from the red object with holes\n    # 2. Crop to just the red object\n    # 3. Put each puzzle piece so that its red pixels perfectly overlay holes in the red object (considering translations and rotations)\n\n    # 1. Separate puzzle pieces from the red object (remembering that puzzle pieces might have some red in them also: they are not monochromatic---but the red thing is fully red)\n    objects = find_connected_components(input_grid, connectivity=8, background=Color.BLACK, monochromatic=False)\n    red_objects = [ obj for obj in objects if set(object_colors(obj, background=Color.BLACK)) == {Color.RED} ]\n    puzzle_pieces = [ obj for obj in objects if set(object_colors(obj, background=Color.BLACK)) != {Color.RED} ]\n\n    assert len(red_objects) == 1, \"There should be exactly one fully red object\"\n    red_object = red_objects[0]\n\n    # 2. The output begins by cropping to just the red object\n    output_grid = crop(red_object, background=Color.BLACK)\n\n    # 3. Put each puzzle piece so that its red pixels perfectly overlay holes in the red object\n    # Put in the pieces which have the most red first (otherwise a small puzzle piece might go in a big hole)\n    puzzle_pieces.sort(key=lambda piece: np.sum(piece == Color.RED), reverse=True)\n\n    for puzzle_piece in puzzle_pieces:\n        # Extract just the sprite of this piece, and then figure out where it should go, including its position and rotation\n        piece_sprite = crop(puzzle_piece, background=Color.BLACK)\n        possible_sprites = [ piece_sprite, np.rot90(piece_sprite), np.rot90(piece_sprite, k=2), np.rot90(piece_sprite, k=3) ]\n\n        # A placement solution is a tuple (x, y, sprite) where x, y is the top-left corner of the rotated sprite\n        possible_solutions = [ (x, y, sprite)\n                              for sprite in possible_sprites\n                              for x in range(output_grid.shape[0] - piece_sprite.shape[0] + 1)\n                              for y in range(output_grid.shape[1] - piece_sprite.shape[1] + 1) ]\n        \n        # Filter placement solutions to only those where the red pixels of the piece fit into the holes of the red object\n        def valid_solution(x, y, sprite):\n            # Make a canvas to try putting down the sprite\n            test_canvas = np.full_like(output_grid, Color.BLACK)\n            blit_sprite(test_canvas, sprite, x, y)\n            # Check if every red pixel in the placed test object is also red in the red object\n            red_pixels = [ (x, y) for x, y in np.argwhere(test_canvas == Color.RED) ]\n            return all( output_grid[red_x, red_y] == Color.BLACK for red_x, red_y in red_pixels )\n                \n        possible_solutions = [ solution for solution in possible_solutions if valid_solution(*solution) ]\n        if len(possible_solutions) == 0:\n            assert False, \"No solution found for puzzle piece\"\n\n        # Pick the first solution and blit the sprite into the output grid\n        x, y, sprite = list(possible_solutions)[0]\n        blit_sprite(output_grid, sprite, x, y)\n    \n    return output_grid\n\ndef generate_input():\n    # Create a red canvas and some pieces that have red in them. Then place the pieces randomly (remembering to rotate) and punch black holes where they are red\n\n    canvas_width, canvas_height = np.random.randint(10, 20), np.random.randint(10, 20)\n    red_canvas = np.full((canvas_width, canvas_height), Color.RED)\n\n\n    n_pieces = np.random.randint(2, 5)\n    pieces = []\n    for _ in range(n_pieces):\n        # puzzle pieces are 3x3 and contain both red and non-red pixels\n        # treat the background as red, and give it a single color for the color palette, so that it ends up with just red and another color\n        piece_width, piece_height = 3, 3\n        non_red_color = random.choice([ color for color in Color.NOT_BLACK if color != Color.RED ])\n        piece = random_sprite(piece_width, piece_height, connectivity=8, color_palette=[non_red_color], background=Color.RED)\n        pieces.append(piece)\n\n        # the piece is randomly rotated and randomly placed\n        rotated_piece = np.rot90(piece, k=np.random.randint(0, 4))        \n        x, y = random_free_location_for_sprite(red_canvas, rotated_piece, background=Color.RED)\n\n        # punch holes in the red canvas where the piece is red\n        red_pixels = np.argwhere(rotated_piece == Color.RED)\n        for dx, dy in red_pixels:\n            red_canvas[x + dx, y + dy] = Color.BLACK\n        \n    # create the actual input grid, which contains the red canvas and the pieces randomly arranged\n    width, height = np.random.randint(canvas_width+3, 30+1), np.random.randint(canvas_height+3, 30+1)\n    grid = np.full((width, height), Color.BLACK)\n\n    x, y = random_free_location_for_sprite(grid, red_canvas, background=Color.BLACK)\n    blit_sprite(grid, red_canvas, x, y)\n\n    for piece in pieces:\n        x, y = random_free_location_for_sprite(grid, piece, background=Color.BLACK)\n        blit_sprite(grid, piece, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/110/images/test_input.png", "output": "output/seeds/seed_examples/110/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/110/images/train_input_0.png", "output": "output/seeds/seed_examples/110/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/110/images/train_input_1.png", "output": "output/seeds/seed_examples/110/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/110/images/train_input_2.png", "output": "output/seeds/seed_examples/110/images/train_output_2.png"}]}, "index": 110, "seed": "97a05b5b", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern matching, color correspondence\n\n# description:\n# In the input you will see three different 4x4 patterns of gray pixels place horizonlly and seperate by black interval. \n# To make the output grid, you should find out each pattern corresponds to a color: red, teal, yellow, or green, \n# and color the corresponding row in the output grid with the corresponding color in the order from left to right.\n\ndef transform(input_grid):\n    # Distinguish four different pattern with different black pixels placing on the gray background.\n    b, g = Color.BLACK, Color.GRAY\n    red_pattern = np.array([[g, g, g, g], [g, g, g, g], [g, g, g, g], [g, g, g, g]]).transpose()\n    teal_patten = np.array([[g, g, g, g], [g, b, b, g], [g, b, b, g], [g, g, g, g]]).transpose()\n    yellow_pattern = np.array([[g, g, g, g], [g, g, g, g], [g, b, b, g], [g, b, b, g]]).transpose()\n    green_pattern = np.array([[g, g, g, g], [b, g, g, b], [b, g, g, b], [g, g, g, g]]).transpose()\n\n    # Detect the patterns of gray pixels with size 4x4 place horizonlly and seperate by black interval.\n    detect_patterns = detect_objects(grid=input_grid, colors=[Color.GRAY], connectivity=8, monochromatic=True)\n\n    # Get the bounding box of each pattern and crop the pattern.\n    pattern_lists = []\n    for pattern in detect_patterns:\n        x, y, w, h = bounding_box(grid=pattern, background=Color.BLACK)\n        pattern_shape = crop(grid=pattern, background=Color.BLACK)\n        pattern_lists.append({\u0027x\u0027: x, \u0027y\u0027: y, \u0027pattern\u0027: pattern_shape})\n    pattern_lists = sorted(pattern_lists, key=lambda rec: rec[\u0027x\u0027])\n\n    # Find the corresponding color of each pattern from left to right.\n    color_list = []\n    for pattern in pattern_lists:\n        cur_pattern = pattern[\u0027pattern\u0027]\n        if np.array_equal(cur_pattern, red_pattern):\n            color_list.append(Color.RED)\n        elif np.array_equal(cur_pattern, teal_patten):\n            color_list.append(Color.TEAL)\n        elif np.array_equal(cur_pattern, yellow_pattern):\n            color_list.append(Color.YELLOW)\n        elif np.array_equal(cur_pattern, green_pattern):\n            color_list.append(Color.GREEN)\n        else:\n            raise ValueError(\"Invalid pattern\")\n    square_number = len(color_list)\n\n    # Color the corresponding row in the output grid with the corresponding color in order.\n    output_grid = np.zeros((square_number,square_number), dtype=int)\n    for cnt, color in enumerate(color_list):\n        draw_line(grid=output_grid, color=color, x=0, y=cnt, direction=(1, 0))\n    return output_grid\n\ndef generate_input():\n    # There are three patterns of gray pixels with size 4x4 place horizonlly and seperate by black interval.\n    square_length = 4\n    square_number = 3\n\n    # Create four different pattern by placing black pixels on the gray background.\n    b, g = Color.BLACK, Color.GRAY\n    red_pattern = np.array([[g, g, g, g], [g, g, g, g], [g, g, g, g], [g, g, g, g]]).transpose()\n    teal_patten = np.array([[g, g, g, g], [g, b, b, g], [g, b, b, g], [g, g, g, g]]).transpose()\n    yellow_pattern = np.array([[g, g, g, g], [g, g, g, g], [g, b, b, g], [g, b, b, g]]).transpose()\n    green_pattern = np.array([[g, g, g, g], [b, g, g, b], [b, g, g, b], [g, g, g, g]]).transpose()\n    \n    # Calulate the size of the input grid.\n    n = square_number * square_length + square_number - 1\n    m = square_length\n\n    grid = np.zeros((n, m), dtype=int)\n\n    # Assign the color of each pattern.\n    available_colors = [Color.RED, Color.TEAL, Color.YELLOW, Color.GREEN]\n\n    # Randomly choose the three patterns represented by the given colors on the input grid.\n    color_list = np.random.choice(available_colors, size=square_number, replace=False)\n    \n    # Place the corresponding pattern on the input grid.\n    for square_num, color in enumerate(color_list):\n        x = square_num * (square_length + 1)\n        y = 0\n        # Each pattern corresponds to a diffferent color: red, teal, yellow, or green.\n        if color == Color.RED:\n            grid = blit_sprite(grid=grid, sprite=red_pattern, x=x, y=y)\n        elif color == Color.TEAL:\n            grid = blit_sprite(grid=grid, sprite=teal_patten, x=x, y=y)\n        elif color == Color.YELLOW:\n            grid = blit_sprite(grid=grid, sprite=yellow_pattern, x=x, y=y)\n        elif color == Color.GREEN:\n            grid = blit_sprite(grid=grid, sprite=green_pattern, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/111/images/test_input.png", "output": "output/seeds/seed_examples/111/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/111/images/train_input_0.png", "output": "output/seeds/seed_examples/111/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/111/images/train_input_1.png", "output": "output/seeds/seed_examples/111/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/111/images/train_input_2.png", "output": "output/seeds/seed_examples/111/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/111/images/train_input_3.png", "output": "output/seeds/seed_examples/111/images/train_output_3.png"}]}, "index": 111, "seed": "995c5fa3", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting\n\n# description:\n# The input grid consists of a small grid filled completely with different colors.\n# To create the output grid, take the colors present in the input, and sort them by number of pixels of that color in the input, greatest to least. Then create an output grid of shape (num_colors, max_num_pixels), where num_colors is the number of colors in the input, and max_num_pixels is the max number of pixels of any color in the input. Then fill each row with the color corresponding to that row\u0027s index in the sorted list of colors, filling K pixels from the top downwards, where K is the number of pixels of that color in the input. Leave the remaining pixels in the row black.\n\ndef transform(input_grid):\n    # find all unique colors in the input grid\n    colors = np.unique(input_grid)\n\n    # track the number of pixels of each color in the input grid\n    colors_with_counts = [(c, np.sum(input_grid == c)) for c in colors]\n    sorted_colors_with_counts = sorted(colors_with_counts, key=lambda x: x[1], reverse=True)\n\n    # create an output grid of shape (num_colors, max_num_pixels)\n    num_colors = len(colors)\n    max_num_pixels = max([count for _, count in sorted_colors_with_counts])\n    output_grid = np.full((num_colors, max_num_pixels), Color.BLACK)\n\n    # for each color in the list, color K pixels to that color from top to bottom, leaving the remaining pixels black, where K is the number of pixels of that color in the input.\n    for i, (color, count) in enumerate(sorted_colors_with_counts):\n        output_grid[i, :count] = color\n\n    return output_grid\n\n\ndef generate_input():\n    # create a small grid (3-5 x 3-5)\n    input_grid = np.full((np.random.randint(3, 6), np.random.randint(3, 6)), Color.BLACK)\n\n    # while there are black pixels remaining, choose a random color, choose a random number of pixels to color with that color, and color those pixels\n    while True:\n        # if there are no black pixels remaining, we\u0027re done\n        if np.sum(input_grid == Color.BLACK) == 0:\n            break\n\n        # choose a random color and number of pixels to color with that color\n        color = np.random.choice(Color.NOT_BLACK)\n        num_pixels = np.random.randint(1, min(np.sum(input_grid == Color.BLACK) + 1, 6))\n\n        # choose num_pixels random black pixels to color with the chosen color\n        choices = np.argwhere(input_grid == Color.BLACK)\n        pixels = np.random.choice(len(choices), num_pixels, replace=False)\n\n        # color the chosen pixels\n        for pixel in pixels:\n            x, y = choices[pixel]\n            input_grid[x, y] = color\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/112/images/test_input.png", "output": "output/seeds/seed_examples/112/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/112/images/train_input_0.png", "output": "output/seeds/seed_examples/112/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/112/images/train_input_1.png", "output": "output/seeds/seed_examples/112/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/112/images/train_input_2.png", "output": "output/seeds/seed_examples/112/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/112/images/train_input_3.png", "output": "output/seeds/seed_examples/112/images/train_output_3.png"}]}, "index": 112, "seed": "9af7a82c", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# downscaling, mirror, horizontal/vertical bars\n\n# description:\n# In the input you will see horizontal and vertical bars separating different regions/cells/partitions with each cell containing different colors, like a chessboard.\n# Each separated region has a single color.\n# To make the output, make a grid with one colored pixel for each region of the chessboard.\n# Finally mirror along the x-axis.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Determine the color of the separator between the regions\n    # 2. Extract all the regions separated by the separator color\n    # 3. Find the region positions and their possible X/Y positions\n    # 4. Create the output grid so that one pixel represents the original region, preserving X/Y ordering\n    # 5. Mirror the output grid by x-axis\n\n    # 1. Find the color of horizontal and vertical bars that separate the different regions/cells/partitions\n    # One way of doing this is to find the connected component which stretches all the way horizontally and vertically over the input\n    separator_candidates = [ possible_separator\n                            for possible_separator in find_connected_components(grid=input_grid, connectivity=4, monochromatic=True, background=Color.BLACK)\n                            if crop(possible_separator).shape == input_grid.shape ]\n    assert len(separator_candidates) == 1, \"There should be exactly 1 separator partitioning the input\"\n    separator = separator_candidates[0]\n    separator_color = object_colors(separator, background=Color.BLACK)[0]\n\n    # 2. Extract all the regions separated by the separator color\n    regions = find_connected_components(grid=input_grid, connectivity=4, monochromatic=True, background=separator_color)\n\n    # 3. Find the region positions\n    x_positions = { object_position(obj, background=separator_color)[0] for obj in regions }\n    y_positions = { object_position(obj, background=separator_color)[1] for obj in regions }\n\n    # 4. Create the output grid, each region becomes a single pixel\n\n    # Get the size of the output\n    width = len(x_positions)\n    height = len(y_positions)    \n\n    # Create the output grid\n    # Use one pixel to represent the original region\n    output_grid = np.full((width, height), Color.BLACK)\n    for output_x, input_x in enumerate(sorted(x_positions)):\n        for output_y, input_y in enumerate(sorted(y_positions)):\n            for region in regions:\n                if object_position(region, background=separator_color) == (input_x, input_y):\n                    output_grid[output_x, output_y] = object_colors(region, background=separator_color)[0]\n                    break\n\n    # 5. Mirror the output grid by x-axis\n    output_grid = np.flip(output_grid, axis=0)\n\n    return output_grid\n\ndef generate_input():\n    # Randomly choose the number of regions that are going to form the output canvas\n    w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n    # Keep track of the color of each region\n    region_colors = np.full((w, h), Color.BLACK)\n\n    # Randomly choose the colors. the separator gets a special color and colored regions get a color randomly selected from other_colors\n    num_other_colors = np.random.randint(1, 4)\n    separator_color, *other_colors = np.random.choice(Color.NOT_BLACK, num_other_colors + 1, replace=False)\n\n    # Randomly color the regions\n    for x, y in np.ndindex(w, h):\n        # Randomly determine if the cell should be colored\n        if np.random.choice([True, False]):\n            # Randomly choose the color\n            region_colors[x, y] = np.random.choice(other_colors)\n    \n    # Randomly choose the scale factor and scale the regions so that they are bigger than just a single pixel\n    scale_factor = np.random.randint(3, 6)\n    grid = scale_sprite(region_colors, scale_factor)\n    \n    # Draw horizontal/vertical lines to separate the colors\n    interval = scale_factor\n    # First draw vertical lines\n    for x in range(interval, w * scale_factor, interval):\n        draw_line(grid, x=x, y=0, direction=(0, 1), color=separator_color)\n    # Then draw horizontal lines\n    for y in range(interval, h * scale_factor, interval):\n        draw_line(grid, x=0, y=y, direction=(1, 0), color=separator_color)\n    \n    # drop the extra pixels\n    grid = grid[1:,1:]\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/113/images/test_input.png", "output": "output/seeds/seed_examples/113/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/113/images/train_input_0.png", "output": "output/seeds/seed_examples/113/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/113/images/train_input_1.png", "output": "output/seeds/seed_examples/113/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/113/images/train_input_2.png", "output": "output/seeds/seed_examples/113/images/train_output_2.png"}]}, "index": 113, "seed": "9f236235", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bouncing\n\n# description:\n# In the input you will see a single blue pixel on a black background\n# To make the output, shoot the blue pixel diagonally up and to the right, having it reflect and bounce off the walls until it exits at the top of the grid\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the pixel\n    # 2. Shoot each line of the reflection one-by-one, bouncing (changing horizontal direction) when it hits a (horizontal) wall/edge of canvas\n\n    # 1. Find the location of the pixel\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one blue pixel\"\n    blue_pixel = list(objects)[0]\n    blue_pixel_x, blue_pixel_y = object_position(blue_pixel, background=Color.BLACK, anchor=\u0027center\u0027)\n\n    # 2. do the bounce which requires keeping track of the direction of the ray we are shooting, as well as the tip of the ray\n    # initially we are shooting diagonally up and to the right (dx=1, dy=-1)\n    # initially the tip of the ray is the blue pixel, x=blue_pixel_x, y=blue_pixel_y\n    direction = (1, -1)\n\n    # loop until we fall out of the canvas\n    while 0 \u003c= blue_pixel_x \u003c input_grid.shape[0] and 0 \u003c= blue_pixel_y \u003c input_grid.shape[1]:\n        stop_x, stop_y = draw_line(input_grid, blue_pixel_x, blue_pixel_y, direction=direction, color=Color.BLUE)\n        # Terminate if we failed to make progress\n        if stop_x == blue_pixel_x and stop_y == blue_pixel_y:\n            break\n        blue_pixel_x, blue_pixel_y = stop_x, stop_y\n        direction = (-direction[0], direction[1])\n    \n    return input_grid\n\n\ndef generate_input():\n    width, height = np.random.randint(2, 15), np.random.randint(10, 30)\n    grid = np.full((width, height), Color.BLACK)\n    grid[0,-1] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/114/images/test_input.png", "output": "output/seeds/seed_examples/114/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/114/images/train_input_0.png", "output": "output/seeds/seed_examples/114/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/114/images/train_input_1.png", "output": "output/seeds/seed_examples/114/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/114/images/train_input_2.png", "output": "output/seeds/seed_examples/114/images/train_output_2.png"}]}, "index": 114, "seed": "a3df8b1e", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# diagonal lines\n\n# description:\n# In the input you will see a grid with a diagonal line and gray objects touching it. The grey objects are all right triangles.\n# To make the output grid, draw additional diagonal lines in the same color emanating from the tip of the grey objects. Delete the grey objects.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the diagonal (it\u0027s the only one) and greys\n    # 2. For each grey, find the tip\n    # 3. ... and draw a diagonal line in the same color and same direction\n    # 4. Delete the greys\n    \n    # 1. Input parsing: Find the grey objects, and then extract by color everything that is not grey\n    background = Color.BLACK\n    grey_objects = [ obj for obj in find_connected_components(input_grid, connectivity=4, monochromatic=True, background=background)\n                     if Color.GREY in object_colors(obj, background=background) ]\n    # extracting the diagonal by color: we know it\u0027s just everything that\u0027s not grey\n    diagonal_object = input_grid.copy()\n    diagonal_object[diagonal_object == Color.GREY] = background\n\n    # Parse out the color and directionbof the diagonal\n    diagonal_color = object_colors(diagonal_object, background=background)[0]\n    if crop(diagonal_object, background=background)[0,0] == diagonal_color:\n        diagonal_direction = (1,1) # down-right\n    else:\n        diagonal_direction = (-1,1) # up-right\n\n    # We draw on top of the input, so copy it\n    output_grid = input_grid.copy()\n\n    # 2. Find the tips of the grey objects\n    for grey_object in grey_objects:\n        # The tip is the bordering pixel farthest away from the diagonal\n        bordering_pixels_mask = object_neighbors(grey_object, connectivity=8, background=background)\n        def distance_to_object(x, y, obj):\n            return min( np.linalg.norm([x - x2, y - y2]) for x2, y2 in np.argwhere(obj != background) )\n        tip = max( np.argwhere(bordering_pixels_mask), key=lambda xy: distance_to_object(xy[0], xy[1], diagonal_object) )\n        tip_x, tip_y = tip\n\n        # 3. Draw the diagonal line\n        draw_line(output_grid, tip_x, tip_y, direction=diagonal_direction, color=diagonal_color)\n        draw_line(output_grid, tip_x, tip_y, direction=(-diagonal_direction[0], -diagonal_direction[1]), color=diagonal_color)\n\n    # 4. Delete grey\n    output_grid[output_grid == Color.GREY] = background\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    grid_len = np.random.randint(10, 20)\n    grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    diagonal_color = random.choice([ color for color in Color.NOT_BLACK if color != Color.GREY ])\n    diagonal_direction = (1,1) # rotate at the end in order to get variety of orientations5\n    diagonal_x, diagonal_y = random.choice(np.argwhere(grid == Color.BLACK))\n    draw_line(grid, diagonal_x, diagonal_y, direction=diagonal_direction, color=diagonal_color)\n    draw_line(grid, diagonal_x, diagonal_y, direction=(-diagonal_direction[0], -diagonal_direction[1]), color=diagonal_color)\n\n    # Randomly generate grey objects and place them on the grid so they are touching the diagonal\n    num_grey_objects = random.choice([1, 2, 3])\n    for _ in range(num_grey_objects):\n        # the grey sprite is a right-triangle of random size\n        grey_size = np.random.randint(2, 5)\n        grey_sprite = np.full((grey_size, grey_size), Color.BLACK)\n        for x in range(grey_size):\n            for y in range(grey_size):\n                if x\u003c=y: grey_sprite[x, y] = Color.GREY\n        \n        # random orientation\n        if np.random.rand() \u003c 0.5: grey_sprite = grey_sprite.T\n\n        # find a placement so it touches\n        while True:\n            x, y = random_free_location_for_sprite(grid, sprite=grey_sprite)\n            diagonal_mask = (grid == diagonal_color)\n            if contact(object1=diagonal_mask, object2=grey_sprite, x2=x, y2=y, background=Color.BLACK):\n                break\n        blit_sprite(grid, grey_sprite, x, y)\n    \n    # Randomly rotate the grid\n    grid = np.rot90(grid, k=np.random.randint(4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/115/images/test_input.png", "output": "output/seeds/seed_examples/115/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/115/images/train_input_0.png", "output": "output/seeds/seed_examples/115/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/115/images/train_input_1.png", "output": "output/seeds/seed_examples/115/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/115/images/train_input_2.png", "output": "output/seeds/seed_examples/115/images/train_output_2.png"}]}, "index": 115, "seed": "a78176bb", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translation, color change\n\n# description:\n# In the input you will see a grid with a teal object.\n# To make the output grid, you should translate the teal object down by 1 pixel and change its color to red.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the object (it\u0027s the only one)\n    # 2. Change its color to red\n    # 3. Translate it downward by 1 pixel\n\n    \n    # Get the single teal object\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=Color.BLACK)\n    assert len(objects) == 1\n    teal_object = objects[0]\n\n    # Make a blank output grid\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n\n    # Change its color to red\n    teal_object[teal_object != Color.BLACK] = Color.RED\n\n    # Translate it downward by 1 pixel\n    teal_object = translate(teal_object, x=0, y=1, background=Color.BLACK)\n\n    # Blit the teal object onto the output grid\n    output_grid = blit_object(grid=output_grid, obj=teal_object, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    grid_len = np.random.randint(4, 8)\n    grid = np.zeros((grid_len, grid_len), dtype=int)\n\n    # Randomly generate the teal object and place it on the grid.\n    sprite_width, sprite_height = np.random.randint(1, grid_len - 1), np.random.randint(1, grid_len -1)\n    sprite = random_sprite(n=sprite_width, m=sprite_height, color_palette=[Color.TEAL], density=0.5)\n    x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, border_size=1)\n    grid = blit_sprite(x=x, y=y, grid=grid, sprite=sprite, background=Color.BLACK)\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/116/images/test_input.png", "output": "output/seeds/seed_examples/116/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/116/images/train_input_0.png", "output": "output/seeds/seed_examples/116/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/116/images/train_input_1.png", "output": "output/seeds/seed_examples/116/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/116/images/train_input_2.png", "output": "output/seeds/seed_examples/116/images/train_output_2.png"}]}, "index": 116, "seed": "a79310a0", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# alignment, sliding objects\n\n# description:\n# In the input, you should see a black grid with nine 3x3 grey squares randomly placed in it (some of the squares touch a little bit). Each square contains a colored object of a different color, 3-4 cells in area, except for one which is blank. The colored objects are at the border of the 3x3 shape.\n# To make the output, create a 9x9 grey grid. Now place each of the 3x3 squares from the input grid into the output grid. The location of an object is done so that the colored object in the grey square is moved \"away\" fromm the center square of the output grid in the direction the colored object is in the 3x3 square.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract the 3x3 grey squares from the input grid (tricky because sometimes they touch, so we can\u0027t use connected components; detect_objects works better)\n    # 2. Create the output grid\n    # 3. Place the 3x3 squares into the output grid by sliding it in the direction of the colored (non-grey) portion\n\n    # step 1: extract the 3x3 squares, which are grey+another color\n    square_length = 3\n    square_objects = detect_objects(input_grid, background=Color.BLACK, allowed_dimensions=[(square_length, square_length)],\n                                    predicate=lambda sprite: np.all(sprite != Color.BLACK) and np.any(sprite == Color.GREY))\n    square_sprites = [crop(obj, background=Color.BLACK) for obj in square_objects]\n\n    assert len(square_sprites) == 9, \"There should be exactly 9 3x3 grey squares in the input grid\"\n\n    # step 2: create the output grid, which is all grey\n    output_grid = np.full((9, 9), Color.GREY, dtype=int)\n\n    # step 3: place the 3x3 squares into the output grid\n    # for each square, find the \"direction\" of the colored object in it, and place it in that direction of the output grid.\n\n    # we can ignore the blank square, since the middle is already grey\n    square_sprites = [square for square in square_sprites if not (square == Color.GREY).all()]\n\n    def get_direction_between(point1, point2):\n        \u0027\u0027\u0027\n        returns one of (-1, -1), (-1, 0), (-1, 1),\n                       (0, -1), (0, 0), (0, 1),\n                       (1, -1), (1, 0), (1, 1)\n\n        based on the direction from point1 to point2\n        \u0027\u0027\u0027\n        x1, y1 = point1\n        x2, y2 = point2\n\n        dx, dy = x2 - x1, y2 - y1\n\n        def sign(x):\n            if x \u003c 0:\n                return -1\n            elif x \u003e 0:\n                return 1\n            else:\n                return 0\n\n        return (sign(dx), sign(dy))\n\n    for square in square_sprites:\n        colored_object_center_of_mass = np.argwhere(square != Color.GREY).mean(axis=0)\n        grey_center_of_mass = np.argwhere(square == Color.GREY).mean(axis=0)\n\n        dx, dy = get_direction_between(grey_center_of_mass, colored_object_center_of_mass)\n\n        # start with the square in the middle of the canvas, which has length 9 (we will slide it afterward)\n        x, y = (9 - square_length)//2, (9 - square_length)//2\n        \n        # slide until we can\u0027t anymore\n        while 0 \u003c x \u003c 9 - square_length and 0 \u003c y \u003c 9 - square_length:\n            x += dx\n            y += dy\n\n        blit_sprite(output_grid, square, x=x, y=y)\n\n    return output_grid\n\n\ndef generate_input():\n\n    # 1. create nine 3x3 grey squares with colored objects in them.\n    # One is blank. Each of the 8 shapes can be defined by taking a border point, and coloring it and its 4-connected neighbors in a random color.\n    squares = []\n    for x in range(3):\n        for y in range(3):\n            square = np.full((3, 3), Color.GREY, dtype=int)\n\n            # Middle square is all grey (blank square)\n            if (x, y) == (1, 1):\n                squares.append(square)\n                continue\n\n            # color this point and its neighbors in a random color\n            color = np.random.choice([c for c in Color.ALL_COLORS if c != Color.GREY and c != Color.BLACK])\n            square[x, y] = color\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 \u003c= nx \u003c 3 and 0 \u003c= ny \u003c 3:\n                    square[nx, ny] = color\n\n            squares.append(square)\n\n    # 2. place the squares randomly in the grid.\n    # to do so, we can put each square in a random open location greedily.\n    # placement might fail if there is no open location for a square.\n    # so try repeatedly until we succeed\n    while True:\n        # create a black (14-17)x(14-17) grid\n        n = np.random.randint(14, 18)\n        m = np.random.randint(14, 18)\n        input_grid = np.full((n, m), Color.BLACK, dtype=int)\n        success = True\n        for square in squares:\n            try:\n                x, y = random_free_location_for_sprite(input_grid, square, padding=1, padding_connectivity=4)\n                blit_sprite(input_grid, square, x=x, y=y)\n            except: # no free location\n                success = False\n                break\n\n        if success:\n            return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/117/images/test_input.png", "output": "output/seeds/seed_examples/117/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/117/images/train_input_0.png", "output": "output/seeds/seed_examples/117/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/117/images/train_input_1.png", "output": "output/seeds/seed_examples/117/images/train_output_1.png"}]}, "index": 117, "seed": "a8c38be5", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# constant pattern, diagonal corners\n\n# description:\n# In the input you will see one red pixel\n# To make the output grid, you should \n# 1. draw a pattern with four different colors centered at the red pixel at its diagonal corners:\n#    green in the upper left, pink in the upper right, teal in the lower left, and yellow in the lower right.\n# 2. remove the red pixel (equivalently start with a blank canvas and draw the pattern at the red pixel location)\n\ndef transform(input_grid):\n    # Find the red single pixel object\n    red_pixel_objects = detect_objects(grid=input_grid, colors=[Color.RED], allowed_dimensions=[(1, 1)], monochromatic=True, connectivity=4)\n    assert len(red_pixel_objects) == 1\n    red_pixel_object = red_pixel_objects[0]\n\n    # Find out the position of the red pixel\n    red_x, red_y = object_position(red_pixel_object, background=Color.BLACK, anchor=\"upper left\")\n\n    # Construct the specific pattern that is going to be drawn where the red pixel was\n    pattern = np.array([[Color.GREEN, Color.BLACK, Color.PINK], \n                        [Color.BLACK, Color.BLACK, Color.BLACK],\n                        [Color.TEAL, Color.BLACK, Color.ORANGE]]).transpose()\n    \n    # Because sprites are anchored by the upper left corner, we are going to need to calculate where the pattern\u0027s upper left corner should be\n    pattern_width, pattern_height = pattern.shape\n    pattern_x, pattern_y = red_x - pattern_width//2, red_y - pattern_height//2\n\n    # The output grid is the same size of input grid\n    # start with a blank canvas and then lit the pattern\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    output_grid = blit_sprite(grid=output_grid, x=pattern_x, y=pattern_y, sprite=pattern, background=Color.BLACK)\n\n    return output_grid\n    \ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = 5, 3\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly select the position of the red pixel and draw it.\n    x, y = np.random.randint(0, n - 1), np.random.randint(0, m - 1)\n    grid[x, y] = Color.RED\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/118/images/test_input.png", "output": "output/seeds/seed_examples/118/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/118/images/train_input_0.png", "output": "output/seeds/seed_examples/118/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/118/images/train_input_1.png", "output": "output/seeds/seed_examples/118/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/118/images/train_input_2.png", "output": "output/seeds/seed_examples/118/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/118/images/train_input_3.png", "output": "output/seeds/seed_examples/118/images/train_output_3.png"}]}, "index": 118, "seed": "a9f96cdd", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# color guide, filling, objects\n\n# description:\n# In the input, you will see a colored object in the middle and a single pixel in the bottom left corner of a different color.\n# To make the output, remove the pixel from bottom left corner and color the object in the middle with the color from the pixel you removed.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # get the color of the pixel in the bottom left corner\n    color = output_grid[0, -1]\n\n    # remove the pixel from the bottom left corner\n    output_grid[0, -1] = Color.BLACK\n\n    # color the object in the middle with the color of the pixel from the bottom left corner\n    output_grid = np.where(output_grid, color, output_grid)\n    # could also have used flood_fill:\n    # x, y = np.where(output_grid != Color.BLACK)\n    # flood_fill(output_grid, x[0], y[0], color)\n\n    return output_grid\n\ndef generate_input():\n    # make 7x7 black grid with black background\n    n = m = 7\n    grid = np.zeros((n,m), dtype=int)\n\n    # select a color for the sprite\n    sprite_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # select a color for the corner pixel\n    corner_color = np.random.choice(list(Color.NOT_BLACK))\n\n    # check that colors are different\n    # if they are the same then try again\n    if sprite_color == corner_color:\n        return generate_input()\n    \n    # make random sprite and put it in middle of grid\n    sprite = random_sprite(n-2, m-2, \"not_symmetric\", [sprite_color])\n    blit_sprite(grid, sprite, x=1, y=1)\n\n    # put a single pixel in the bottom left corner\n    grid[0, -1] = corner_color\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/119/images/test_input.png", "output": "output/seeds/seed_examples/119/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/119/images/train_input_0.png", "output": "output/seeds/seed_examples/119/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/119/images/train_input_1.png", "output": "output/seeds/seed_examples/119/images/train_output_1.png"}]}, "index": 119, "seed": "aabf363d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cups, filling\n\n# description:\n# In the input you will see a cups, meaning an almost-enclosed shape with a small opening on one of its sides, and empty space (black pixels) inside.\n# To make the output grid, you should fill the interior of each cup with yellow, then shoot yellow out of the opening of the cup both straight out and diagonally from the edges of the opening.\n# \n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the cup\n    # 2. Find the mask of the inside of the cup\n    # 3. Find the mask of the opening of the cup (on one of its sides)\n    # 4. Fill the cup with yellow\n    # 5. Shoot pixels outward from the opening (straight out)\n    # 6. Shoot pixels outward from the opening (diagonally out, from the edges)\n    \n    # 1. Detect cup\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one cup\"\n    obj = list(objects)[0]\n\n    output_grid = input_grid.copy()\n\n    # 2. Extract what\u0027s inside the cup (as its own object), which is everything in the bounding box that is not the object itself\n    cup_x, cup_y, cup_width, cup_height = bounding_box(obj)\n    inside_cup_mask = np.zeros_like(input_grid, dtype=bool)\n    inside_cup_mask[cup_x:cup_x+cup_width, cup_y:cup_y+cup_height] = True\n    inside_cup_mask = inside_cup_mask \u0026 (obj == Color.BLACK)\n\n    # 3. Extract the hole in the cup, which is what\u0027s inside and on the boundary of the bounding box\n    # what\u0027s inside...\n    hole_mask = inside_cup_mask.copy()\n    # ...and then we need to remove anything not on the boundary\n    hole_mask[cup_x+1 : cup_x+cup_width-1, cup_y+1 : cup_y+cup_height-1] = False\n\n    # 4. Fill the cup with yellow\n    output_grid[inside_cup_mask] = Color.YELLOW\n\n    # 5. Shoot pixels outward from the opening (straight out)\n    # Find the direction of the opening, which is the unit vector that points from the center of the cup to the hole\n    hole_x, hole_y = object_position(hole_mask, background=Color.BLACK, anchor=\u0027center\u0027)\n    cup_x, cup_y = object_position(obj, background=Color.BLACK, anchor=\u0027center\u0027)\n    direction = (int(np.sign(hole_x - cup_x)), int(np.sign(hole_y - cup_y)))\n    # Loop over every boundary pixel and shoot outward\n    for x, y in np.argwhere(hole_mask):\n        draw_line(output_grid, x, y, direction=direction, color=Color.YELLOW)\n\n    # 6. Shoot pixels outward from the opening (diagonally out, from the edges)\n    # Find the two extremal points on the boundary of the hole, which are the points farthest away from each other\n    points_on_boundary = np.argwhere(hole_mask)\n    pt1, pt2 = max({ ( (x1,y1), (x2,y2) ) for x1,y1 in points_on_boundary for x2,y2 in points_on_boundary },\n                   key=lambda pair: np.linalg.norm(np.array(pair[0]) - np.array(pair[1])))\n    \n    # For each of those points, shoot diagonal lines in all directions, but stop as soon as you hit something that\u0027s not black\n    for pt in [pt1, pt2]:\n        for direction in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n            draw_line(output_grid, pt[0]+direction[0], pt[1]+direction[1], direction=direction, color=Color.YELLOW, stop_at_color=Color.NOT_BLACK)\n    \n    return output_grid\n\ndef generate_input():\n    # Generate the grid with random size\n    width = np.random.randint(8, 30)\n    height = np.random.randint(8, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Pick a random width/height for this cup\n    cup_width = np.random.randint(4, 8)\n    cup_height = np.random.randint(3, 8)\n\n    # Make a sprite, which is just going to be a blue outline of a rectangle with a hole at the top\n    sprite = np.full((cup_width, cup_height), Color.BLACK)\n    color = np.random.choice([ color for color in Color.NOT_BLACK if color != Color.YELLOW ])\n    sprite[0, :] = color\n    sprite[-1, :] = color\n    sprite[:, 0] = color\n    sprite[:, -1] = color\n\n    # Make the hole centered at the top (variable size)\n    hole_left_x = np.random.randint(1, cup_width//2+1)\n    hole_right_x = cup_width - hole_left_x - 1\n    hole_y = 0\n    sprite[hole_left_x:hole_right_x+1, hole_y] = Color.BLACK\n\n    # Find a random free location for it\n    free_x, free_y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, sprite, free_x, free_y, background=Color.BLACK)\n\n    # Do a random rotation, so the cup can face any direction\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/120/images/test_input.png", "output": "output/seeds/seed_examples/120/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/120/images/train_input_0.png", "output": "output/seeds/seed_examples/120/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/120/images/train_input_1.png", "output": "output/seeds/seed_examples/120/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/120/images/train_input_2.png", "output": "output/seeds/seed_examples/120/images/train_output_2.png"}]}, "index": 120, "seed": "aba27056", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, color change\n\n# description:\n# In the input you will see a grid with a red pattern\n# To make the output grid, you should find out any single isolated red objects with size of 1x1 and change them to blue.\n\ndef transform(input_grid):\n    # Detect all the red objects in the grid, ignoring objects of other colors\n    red_objects = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n\n    # Convert 1x1 objects (isolated pixels) into blue\n    output_grid = input_grid.copy()\n    for object in red_objects:\n        x, y, length, width = bounding_box(object, background=Color.BLACK)\n        # Find out the single isolated red object with size of 1x1 and change it to blue.\n        if length == 1 and width == 1:\n            output_grid[x, y] = Color.BLUE\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = np.random.randint(3, 6), np.random.randint(3, 6)\n    grid = np.zeros((n, m), dtype=int)\n\n    colored = 0\n    # Randomly scatter density of red pixels on the grid.\n    density = 0.4\n    while colored \u003c density * n * m:\n        x = np.random.randint(0, n)\n        y = np.random.randint(0, m)\n        if grid[x, y] == Color.BLACK:\n            grid[x, y] = Color.RED\n            colored += 1\n\n    # Ensure there is at least one 1x1 single isolated red object in the grid.\n    red_objects = detect_objects(grid=grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n    if not any(np.sum(object != Color.BLACK) == 1 for object in red_objects):\n        return generate_input()\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/121/images/test_input.png", "output": "output/seeds/seed_examples/121/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/121/images/train_input_0.png", "output": "output/seeds/seed_examples/121/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/121/images/train_input_1.png", "output": "output/seeds/seed_examples/121/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/121/images/train_input_2.png", "output": "output/seeds/seed_examples/121/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/121/images/train_input_3.png", "output": "output/seeds/seed_examples/121/images/train_output_3.png"}]}, "index": 121, "seed": "aedd82e4", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling, surrounding\n\n# description:\n# In the input you will see several yellow pixels arranged in groups of 4 so that each group outlines a rectangular shape.\n# To make the output, fill the corresponding inner rectangular regions with red.\n\ndef transform(input_grid):\n    # Detect the rectangular regions by finding groups of four surrounding yellow pixels\n    surrounding_color = Color.YELLOW\n    rectangle_color = Color.RED\n    \n    output_grid = np.copy(input_grid) \n\n    # loop over all the yellows...\n    for x, y in np.argwhere(input_grid == surrounding_color):\n        # ...and find the other matching yellows forming a rectangle: (x, y), (x, y\u0027), (x\u0027, y), (x\u0027, y\u0027)\n        for other_x, other_y in np.argwhere(input_grid == surrounding_color):\n            if input_grid[x, other_y] == surrounding_color and input_grid[other_x, y] == surrounding_color:\n                # fill the rectangle with red\n                output_grid[x+1:other_x, y+1:other_y] = rectangle_color\n\n    return output_grid\n\ndef generate_input():\n    # Create the background grid\n    n, m = np.random.randint(10, 15), np.random.randint(10, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    rectangle_num = np.random.randint(1, 4)\n\n    # Draw rectangles on the grid\n    rectangle_color = Color.RED\n    surrounding_color = Color.YELLOW\n\n    for _ in range(rectangle_num):\n        rectangle_len = np.random.randint(1, 5)\n        rectangle_width = np.random.randint(1, 5)\n        \n        # Draw the rectangle with rectangle color\n        rectangle_sprite = np.full((rectangle_len, rectangle_width), rectangle_color)\n        try:\n            x, y = random_free_location_for_sprite(grid, rectangle_sprite, padding=2, padding_connectivity=8, border_size=1)\n        except:\n            continue\n\n        blit_sprite(grid, rectangle_sprite, x=x, y=y)\n\n        # Place four surrounding colors around the rectangle right outside its corners\n        min_x, min_y, max_x, max_y = x, y, x+rectangle_len, y+rectangle_width\n        grid[min_x-1, min_y-1] = surrounding_color\n        grid[min_x-1, max_y] = surrounding_color\n        grid[max_x, y-1] = surrounding_color\n        grid[max_x, max_y] = surrounding_color\n\n    # Remove the inner rectangle color, only keep the surrounding color\n    grid[grid == rectangle_color] = Color.BLACK\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/122/images/test_input.png", "output": "output/seeds/seed_examples/122/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/122/images/train_input_0.png", "output": "output/seeds/seed_examples/122/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/122/images/train_input_1.png", "output": "output/seeds/seed_examples/122/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/122/images/train_input_2.png", "output": "output/seeds/seed_examples/122/images/train_output_2.png"}]}, "index": 122, "seed": "af902bf9", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# growing\n\n# description:\n# In the input you will see a grid with some green rectangles. Each rectangle has one red pixel on one of its borders.\n# To make the output, you should extend the green region of each rectangle to the border of the grid in the direction of the red pixel, with the extent of the line increasing with the extent of the rectangle.\n# Also you should draw a red line from the red pixel to the border of the grid.\n\n\ndef transform(input_grid):\n    # Initialize the output grid\n    output_grid = np.copy(input_grid)\n    \n    rectangle_color = Color.GREEN\n    indicator_color = Color.RED\n    background = Color.BLACK\n\n    # get all the green rectangles on the grid. because of the red pixel on the border of the rectangle, they are not monochromatic.\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False, background=background)\n    for obj in objects:\n        # find the red indicator\n        for red_x, red_y in np.argwhere(obj == indicator_color):\n            break\n\n        # Get the dimensions of the object, and its position\n        x, y, width, height = bounding_box(obj, background=background)  \n\n        # depending on which side of the rectangle that the indicator is on, we draw in different directions\n        # left edge: draw to the left\n        if red_x == x:\n            # Extend the green rectangle to the left until it reaches the border\n            output_grid[0:red_x, red_y-(width-1) : red_y+(width-1)+1] = rectangle_color\n            # Draw the red line from the red pixel to the border\n            draw_line(output_grid, x=red_x, y=red_y, direction=(-1, 0), color=indicator_color)\n        elif red_x == x + width - 1:\n            # Extend the green rectangle to the right until it reaches the border\n            output_grid[red_x:, red_y-(width-1) : red_y+(width-1)+1] = rectangle_color\n            # Draw the red line from the red pixel to the border\n            draw_line(output_grid, x=red_x, y=red_y, direction=(1, 0), color=indicator_color)\n        elif red_y == y:\n            # Extend the green rectangle to the top until it reaches the border\n            output_grid[red_x-(height-1) : red_x+(height-1)+1, 0:red_y] = rectangle_color\n            # Draw the red line from the red pixel to the border\n            draw_line(output_grid, x=red_x, y=red_y, direction=(0, -1), color=indicator_color)\n        elif red_y == y + height - 1:\n            # Extend the green rectangle to the bottom until it reaches the border\n            output_grid[red_x-(height-1) : red_x+(height-1)+1, red_y:] = rectangle_color\n            # Draw the red line from the red pixel to the border\n            draw_line(output_grid, x=red_x, y=red_y, direction=(0, 1), color=indicator_color)\n        else:\n            assert False, \"The red pixel is not on the border of the rectangle\"\n\n    return output_grid\n\ndef generate_input():\n    # Create the background grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), Color.BLACK)\n\n    rectangle_num = 2\n    rectangle_color = Color.GREEN\n    indicator_color = Color.RED\n\n    # Draw rectangles on the grid\n    for i in range(rectangle_num):\n        width, height = np.random.randint(3, 20), np.random.randint(3, 20)\n\n        # The width should be twice smaller than the height\n        while (width * 2 + 2) \u003e= height:\n            width, height = np.random.randint(3, 20), np.random.randint(3, 20)\n\n        green_rectangle = np.full((width, height), rectangle_color)\n\n        # Place one indicator pixel on one random border of the rectangle\n        # Spare enough space for the extend line with the same size of width - 1\n        x_coord = np.random.choice([0, width - 1])\n        y_coord = np.random.choice(range(width + 1, height - (width + 1)))\n        green_rectangle[x_coord, y_coord] = indicator_color\n        # Randomly rotate the object so that we get a variety of orientations\n        if np.random.choice([True, False]):\n            green_rectangle = np.rot90(green_rectangle)\n            x_coord, y_coord = y_coord, x_coord\n\n        # Place the rectangle on the grid\n        try:\n            x, y = random_free_location_for_sprite(grid=grid, sprite=green_rectangle, padding=2, padding_connectivity=8)        \n        # Check if there is no space for the rectangle\n        except:\n            return generate_input()\n        blit_sprite(grid, green_rectangle, x=x, y=y)\n\n    # Check if the generated grid is valid\n    transformed_grid = main(grid)\n    objects = find_connected_components(grid=transformed_grid, connectivity=4, monochromatic=False)\n\n    # After transformation, the two objects should not touch each other\n    if len(objects) != rectangle_num:\n        # Regenerate the grid\n        return generate_input()\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/123/images/test_input.png", "output": "output/seeds/seed_examples/123/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/123/images/train_input_0.png", "output": "output/seeds/seed_examples/123/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/123/images/train_input_1.png", "output": "output/seeds/seed_examples/123/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/123/images/train_input_2.png", "output": "output/seeds/seed_examples/123/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/123/images/train_input_3.png", "output": "output/seeds/seed_examples/123/images/train_output_3.png"}]}, "index": 123, "seed": "b527c5c6", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# growing, connecting\n\n# description:\n# In the input you will see two pixels of different colors aligned horizontally or vertically.\n# To make the output, you need to connect the two pixels with two lines and a hollow rectangle of size 4x5 in the middle.\n# Half of the rectangle is colored with the color of the one side\u0027s pixel, and the other half with the color of the other side\u0027s pixel.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input\n    # 2. Canonicalize the input: because it could be horizontal or vertical, rotate to make horizontal (we will rotate back at the end)\n    # 3. Prepare a 4x5 rectangle sprite whose left half is left_color and right half is right_color\n    # 4. Place the rectangle in the middle of the two pixels\n    # 5. Draw lines to connect the original two pixels with the rectangle\n    # 6. Rotate the grid back if it was not originally horizontal\n\n    # 1. Input parsing\n    # Extract the two pixels from the input grid\n    pixels = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # 2. Canonicalize the input: Ensure that the two pixels are horizontally aligned\n    # Check if the two pixels are horizontally aligned\n    was_originally_horizontal = object_position(pixels[0])[1] == object_position(pixels[1])[1]\n    \n    # If the two pixels are not horizontally aligned, rotate the grid for easier processing\n    if not was_originally_horizontal:\n        input_grid = np.rot90(input_grid)\n        pixels = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n    \n    # we draw on top of the input\n    output_grid = input_grid.copy()\n\n    # Prepare for what follows: extract properties of the input here\n    # Sort the two horizontally-aligned pixels by their position, from left to right\n    pixels = sorted(pixels, key=lambda x: object_position(x)[0])\n    # Get the position of the two pixels\n    left_pos = object_position(pixels[0])\n    right_pos = object_position(pixels[1])\n    left_color = object_colors(pixels[0])[0]\n    right_color = object_colors(pixels[1])[0]\n    \n    # 3. Prepare hollow 4x5 rectangle sprite whose left half is left_color and right half is right_color\n    rectangle_width, rectangle_height = 4, 5\n    rectangle_sprite = np.full((rectangle_width, rectangle_height), Color.BLACK)\n    rectangle_sprite[0, :] = left_color\n    rectangle_sprite[-1, :] = right_color\n    rectangle_sprite[:rectangle_width//2, 0] = left_color\n    rectangle_sprite[rectangle_width//2:, 0] = right_color\n    rectangle_sprite[:rectangle_width//2, -1] = left_color\n    rectangle_sprite[rectangle_width//2:, -1] = right_color\n\n    # 4. Place the rectangle in the middle of the two pixels\n    middle_x = (left_pos[0] + right_pos[0] + 1) // 2\n    middle_y = left_pos[1]\n    blit_sprite(output_grid, sprite=rectangle_sprite, x=middle_x - rectangle_width // 2, y=middle_y - rectangle_height // 2)\n\n    # 5. Draw lines that connect the original two pixels with the rectangle\n    draw_line(grid=output_grid, x=left_pos[0]+1, y=left_pos[1], direction=(1, 0), color=left_color, stop_at_color=Color.NOT_BLACK)\n    draw_line(grid=output_grid, x=right_pos[0]-1, y=right_pos[1], direction=(-1, 0), color=right_color, stop_at_color=Color.NOT_BLACK)\n\n    # 6. If the grid is not horizontal, rotate it back\n    if not was_originally_horizontal:\n        output_grid = np.rot90(output_grid, k=-1)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a random background grid\n    # Make sure the grid\u0027s width is greater than its height\n    width, height = random.randint(15, 20), random.randint(10, 15)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Get the color of two pixels\n    colors = np.random.choice(Color.NOT_BLACK, 2, replace=False)\n    color1, color2 = colors\n\n    # Place the two pixels on the grid horizontally (randomly rotate at the end to get a variety of orientations)\n    x1 = np.random.randint(0, width)\n    x2 = np.random.randint(0, width)\n    y = np.random.randint(0, height)\n\n    # Ensure there is enough horizontal distance to place the 4x5 rectangle\n    distance = abs(x2 - x1)\n    rectangle_width, rectangle_height = 4, 5\n    if distance \u003c rectangle_width+1: return generate_input()\n\n    # Ensure the remaining distance is odd, so that we can split the pixel colors in half between them\n    if (distance - rectangle_width) % 2 != 1: return generate_input()\n\n    # Ensure there is enough vertical space to place the rectangle\n    if y \u003c rectangle_height // 2 or y + rectangle_height // 2 \u003e= height: return generate_input()    \n\n    # Place the two pixels on the grid\n    grid[x1, y] = color1\n    grid[x2, y] = color2\n\n    # Randomly rotate the whole grid\n    if np.random.rand() \u003c 0.5:\n        grid = np.rot90(grid)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/124/images/test_input.png", "output": "output/seeds/seed_examples/124/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/124/images/train_input_0.png", "output": "output/seeds/seed_examples/124/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/124/images/train_input_1.png", "output": "output/seeds/seed_examples/124/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/124/images/train_input_2.png", "output": "output/seeds/seed_examples/124/images/train_output_2.png"}]}, "index": 124, "seed": "b7249182", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, mirror\n\n# description:\n# In the input you will see big objects with a primary color and some single pixels of different colors attached to it.\n# To make the output, mirror the primary colored part of each object over the differently colored pixels attached to it, changing the primary color to match the other color.\n\ndef transform(input_grid):\n    # Plan\n    # 1. Parse the input into primary regions and their associated single pixel indicators\n    # 2. For each primary region and each attached indicator pixel, change color and mirror.\n\n    # 1. Input parsing\n    background = Color.BLACK\n    objects = find_connected_components(grid=input_grid, connectivity=8, monochromatic=True, background=background)\n    indicator_pixels = [ obj for obj in objects if np.sum(obj != background) == 1 ]\n    primary_objects = [ obj for obj in objects if np.sum(obj != background) \u003e 1 ]\n\n    # 2. Output generation\n\n    # Copy the input because we draw on top of it\n    output_grid = input_grid.copy()\n\n    # loop over primary objects and every pixel that they are in contact with\n    for primary_object in primary_objects:\n        for indicator_pixel in indicator_pixels:\n            if not contact(object1=primary_object, object2=indicator_pixel, background=background, connectivity=8): continue\n\n            # Recolor\n            indicator_color = object_colors(indicator_pixel, background=background)[0]\n            recolored_object = np.copy(primary_object)\n            recolored_object[primary_object != background] = indicator_color\n\n            # Build the mirroring object\n            indicator_x, indicator_y = object_position(indicator_pixel, background=background, anchor=\"upper left\")\n            primary_x1, primary_y1 = object_position(primary_object, background=background, anchor=\"upper left\")\n            primary_x2, primary_y2 = object_position(primary_object, background=background, anchor=\"lower right\")\n            # If it\u0027s in the corners, we mirror diagonally (over both x and y)\n            # If it\u0027s on the left/right side, we mirror horizontally\n            # If it\u0027s on the top/bottom side, we mirror vertically\n            mirror_x, mirror_y = None, None\n            if indicator_x == primary_x1-1: mirror_x = primary_x1-0.5\n            if indicator_x == primary_x2+1: mirror_x = primary_x2+0.5\n            if indicator_y == primary_y1-1: mirror_y = primary_y1-0.5\n            if indicator_y == primary_y2+1: mirror_y = primary_y2+0.5\n            symmetry = MirrorSymmetry(mirror_x=mirror_x, mirror_y=mirror_y)\n\n            # Mirror the primary object over the indicator pixel\n            for x, y in np.argwhere(primary_object != background):\n                x2, y2 = symmetry.apply(x, y)\n                if 0 \u003c= x2 \u003c output_grid.shape[0] and 0 \u003c= y2 \u003c output_grid.shape[1]:\n                    output_grid[x2, y2] = recolored_object[x, y]\n\n    return output_grid\n\ndef generate_input():\n    # Create monochromatic objects and then attach differently colored indicator pixels at one of their corners\n    width, height = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.zeros((width, height), dtype=int)\n\n    num_objects = np.random.randint(1, 4)\n    for _ in range(num_objects):\n        # we\u0027ll attach indicators to the upper left and then randomly rotate the sprite before putting it on the canvas\n        # at most three indicators, so we\u0027ll choose a primary color and then choose the indicator colors from the rest5\n        max_indicators = 3\n        num_indicators = np.random.randint(1, max_indicators+1)\n        primary_color, *indicator_colors = np.random.choice(Color.NOT_BLACK, size=num_indicators+1, replace=False)\n\n        # create sprite with indicators attached to it in the upper left. it must be contiguous, so we loop until we find one that is\n        while True:\n            sprite = random_sprite([3,4,5,6], [3,4,5,6], color_palette=[primary_color], symmetry=\"not_symmetric\")\n            # Clear place for indicators in the upper left\n            sprite[:1, :] = Color.BLACK\n            sprite[:, :1] = Color.BLACK\n            # three indicator locations in the upper left corner\n            indicator_locations = [(0, 0), (0, 1), (1, 0)]\n            random.shuffle(indicator_locations)\n            for color, (x, y) in zip(indicator_colors, indicator_locations):\n                sprite[x, y] = color\n            # make sure that the upper left corner is connected to the rest of the sprite\n            if sprite[1, 1] == primary_color: break\n        \n        # randomly rotate to get variety of orientations\n        sprite = np.rot90(sprite, k=np.random.randint(4))\n        \n        # randomly place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid, sprite, padding=max(sprite.shape), padding_connectivity=8)\n        blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/125/images/test_input.png", "output": "output/seeds/seed_examples/125/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/125/images/train_input_0.png", "output": "output/seeds/seed_examples/125/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/125/images/train_input_1.png", "output": "output/seeds/seed_examples/125/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/125/images/train_input_2.png", "output": "output/seeds/seed_examples/125/images/train_output_2.png"}]}, "index": 125, "seed": "b775ac94", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# maze, path finding\n\n# description:\n# In the input you will see a maze with a path that has two indicator pixels of different colors.\n# To make the output, fill all reachable parts of the maze starting with the indicator pixels and alternating colors.\n\ndef transform(input_grid):\n    # Output grid draws on top of the input grid\n    output_grid = input_grid.copy()\n\n    # Parse the input\n    maze_color = Color.TEAL\n    indicator_colors = [ color for color in object_colors(input_grid, background=Color.BLACK) if color != maze_color]\n    assert len(indicator_colors) == 2, \"expected exactly two indicator colors\"\n    \n    # Fill the path with alternating colors in turn\n    def fill_maze(cur_color, next_color, x, y, grid):\n        width, height = grid.shape\n        # Search outward in four directions\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for direction in directions:\n            new_x, new_y = x + direction[0], y + direction[1]\n            if 0 \u003c= new_x \u003c width and 0 \u003c= new_y \u003c height and grid[new_x, new_y] == Color.BLACK:\n                grid[new_x, new_y] = next_color\n                # Change the next color to the current color: swap current and next\n                fill_maze(next_color, cur_color, new_x, new_y, grid)\n    \n    # Fill the path with two colors\n    # Start to fill the path with the pixel that already has the path_color\n    for x, y in np.argwhere((input_grid != Color.BLACK) \u0026 (input_grid != maze_color)):\n        cur_color = input_grid[x, y]\n        next_color = indicator_colors[0] if cur_color == indicator_colors[1] else indicator_colors[1]\n        fill_maze(cur_color, next_color, x, y, output_grid)\n\n    return output_grid\n\ndef generate_input():\n    # Create the background grid\n    width, height = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # function to check if the surrounding pixels are all black\n    def check_available(x, y, grid, directions):\n        for direction in directions:\n            new_x, new_y = x + direction[0], y + direction[1]\n            if 0 \u003c= new_x and new_x \u003c grid.shape[0] and 0 \u003c= new_y and new_y \u003c grid.shape[1] and grid[new_x, new_y] != Color.BLACK:\n                return False\n        return True\n    \n    # function for random walk to generate the maze\n    def random_walk(color, grid, x, y):\n        # Four walking directions\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        # Randomly choose one available direction\n        random.shuffle(directions)\n        for direction in directions:\n            cur_x, cur_y = x + direction[0], y + direction[1]\n            # Check if the next position is out of the grid\n            if cur_x \u003c 0 or cur_x \u003e= width or cur_y \u003c 0 or cur_y \u003e= height:\n                continue\n\n            # Check if the next position touch other maze path\n            rest_directions = [d for d in directions if d != (-direction[0], -direction[1])]\n            if check_available(cur_x, cur_y, grid, rest_directions):\n                # If not, mark the next position as the maze path\n                # And continue the random walking\n                grid[cur_x, cur_y] = color\n                random_walk(color, grid, cur_x, cur_y)\n                break\n\n    # The color for the maze path        \n    maze_color = Color.TEAL\n\n    # Iterate over the grid to generate the maze\n    for x, y in np.argwhere(grid == Color.BLACK):\n        # If the current position is not empty, skip\n        if grid[x, y] != Color.BLACK:\n            continue\n\n        # Check if the surrounding pixels are all black, which means we can start the random walking\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n        if check_available(x, y, grid, directions):\n            # Start the random walking\n            grid[x, y] = maze_color\n\n            # Avoid the exception `maximum recursion depth exceeded`\n            try:\n                random_walk(maze_color, grid, x, y)\n            except:\n                continue\n    \n    # The path has two colors which appear in turn\n    path_color = np.random.choice([color for color in Color.NOT_BLACK if color != maze_color], 2, replace=False)\n\n    # Mark the longest path to be colored to the path_color in turn\n    objects = find_connected_components(grid, background=maze_color, connectivity=4, monochromatic=True)\n    path = max(objects, key=lambda x: np.sum(x == Color.BLACK))\n\n    # Find one empty position to start the path\n    x, y = random.choice(np.argwhere(path == Color.BLACK))\n\n    # Color the position with one of the path_color\n    grid[x, y] = path_color[0]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for direction in directions:\n        if 0 \u003c= x + direction[0] \u003c width and 0 \u003c= y + direction[1] \u003c height and grid[x + direction[0], y + direction[1]] == Color.BLACK:\n            # Color the surrounding pixels with the other path_color\n            # Which indicates the color should be changed in the next step\n            grid[x + direction[0], y + direction[1]] = path_color[1]\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/126/images/test_input.png", "output": "output/seeds/seed_examples/126/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/126/images/train_input_0.png", "output": "output/seeds/seed_examples/126/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/126/images/train_input_1.png", "output": "output/seeds/seed_examples/126/images/train_output_1.png"}]}, "index": 126, "seed": "b782dc8a", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, incrementing\n\n# description:\n# In the input, you will see a row with partially filled with pixels from the one color from left to right.\n# To make the output: \n# 1. Take the input row\n# 2. Copy it below the original row with one more colored pixel added to the sequence if there is space\n# 3. Repeat until there are half as many rows as there are columns\ndef transform(input_grid):\n    # get the color of the row\n    color = input_grid[0]\n\n    # copy the row from the input grid\n    row = np.copy(input_grid)\n\n    # make the output grid\n    output_grid = np.copy(input_grid)\n\n    # repeat the row on the output grid until there are half as many rows as there are columns\n    for _ in range(input_grid.shape[0]//2 - 1):\n        # find the rightmost color pixel in the row and add one more pixel of the same color to the right if there is space\n        rightmost_color_pixel = np.where(row == color)[0][-1]\n        if rightmost_color_pixel \u003c input_grid.shape[0] - 1:\n            row[rightmost_color_pixel + 1] = color\n\n        # add the row to the output grid\n        output_grid = np.concatenate((output_grid, row), axis=1)\n\n    return output_grid\n\ndef generate_input():\n    # decide the length of the row, and make it even\n    length = np.random.randint(3, 8) * 2\n\n    # decide the color to partially fill the row with\n    color = random.choice(list(Color.NOT_BLACK))\n\n    # make a row with the color partially filled from left to right\n    row = np.zeros((length,1), dtype=int)\n    num_colored_pixels = np.random.randint(1, length//2 + 2)\n    row[:num_colored_pixels,:] = color\n\n    # make this row the entire grid\n    grid = row\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/127/images/test_input.png", "output": "output/seeds/seed_examples/127/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/127/images/train_input_0.png", "output": "output/seeds/seed_examples/127/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/127/images/train_input_1.png", "output": "output/seeds/seed_examples/127/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/127/images/train_input_2.png", "output": "output/seeds/seed_examples/127/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/127/images/train_input_3.png", "output": "output/seeds/seed_examples/127/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/127/images/train_input_4.png", "output": "output/seeds/seed_examples/127/images/train_output_4.png"}]}, "index": 127, "seed": "bbc9ae5d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# patterns, positioning, copying\n\n# description:\n# In the input you will see a pattern of pixels in the top left corner of the grid, the top right corner of the grid, the bottom left corner of the grid, and the bottom right corner of the grid. All the pixels are the same color, and the patterns are in square regions.\n# To make the output, copy the pattern in each corner of the input to the corresponding corner of the output. The output grid is one pixel larger in each dimension than the maximum pattern side length.\n\ndef transform(input_grid):\n    # get the patterns from the input\n    objects = find_connected_components(input_grid, connectivity=8)\n\n    # find the bounding box of each pattern\n    bounding_boxes = [bounding_box(obj) for obj in objects]\n\n    # figure out how big the output grid should be (the pattern is a square and the output should be one pixel larger in each dimension)\n    n = m = max([max(pattern[2], pattern[3]) for pattern in bounding_boxes]) + 1\n\n    # make the output grid\n    output_grid = np.full((n, m), Color.BLACK)\n\n    # copy the patterns to the output grid\n    for obj, (x, y, _, _) in zip(objects, bounding_boxes):\n        # adjust the position of the pattern in the output grid if necessary\n        if x \u003e= n - 1:\n            x = x - input_grid.shape[0] + n\n        if y \u003e= m - 1:\n            y = y - input_grid.shape[1] + m\n        # crop the pattern to remove any extra rows or columns of black pixels\n        sprite = crop(obj)\n        # copy the pattern to the output grid\n        blit_sprite(output_grid, sprite, x=x, y=y, background=Color.BLACK)\n    \n    return output_grid\n    \n\ndef generate_input():\n    # make a random sized grid with black background\n    n = np.random.randint(5, 8)\n    m = np.random.randint(5, 8)\n    grid = np.zeros((n, m), dtype=int)\n\n    # select a color for the patterns\n    color = np.random.choice(list(Color.NOT_BLACK))\n\n    # select a size for the patterns so that there will be space between the patterns after they are in their corners\n    size = np.random.randint(2, (min(n, m) + 1) // 2)\n\n\n    # make a random pattern in the top left corner of the specified size\n    grid[:size, :size] = [[np.random.choice([color, Color.BLACK]) for _ in range(size)] for _ in range(size)]\n\n    # make a random pattern in the top right corner of the specified size\n    grid[:size, -size:] = [[np.random.choice([color, Color.BLACK]) for _ in range(size)] for _ in range(size)]\n\n    # make a random pattern in the bottom left corner of the specified size\n    grid[-size:, :size] = [[np.random.choice([color, Color.BLACK]) for _ in range(size)] for _ in range(size)]\n\n    # make a random pattern in the bottom right corner of the specified size\n    grid[-size:, -size:] = [[np.random.choice([color, Color.BLACK]) for _ in range(size)] for _ in range(size)]\n\n    # Check that at least one of the patterns is not all black\n    # If they are all black, try again\n    if np.all(grid == Color.BLACK):\n        return generate_input()\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/128/images/test_input.png", "output": "output/seeds/seed_examples/128/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/128/images/train_input_0.png", "output": "output/seeds/seed_examples/128/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/128/images/train_input_1.png", "output": "output/seeds/seed_examples/128/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/128/images/train_input_2.png", "output": "output/seeds/seed_examples/128/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/128/images/train_input_3.png", "output": "output/seeds/seed_examples/128/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/128/images/train_input_4.png", "output": "output/seeds/seed_examples/128/images/train_output_4.png"}]}, "index": 128, "seed": "bc1d5164", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# patterns, lines\n\n# description:\n# In the input, you will see a top row with a sequence of colored pixels, and right below it is a grey line.\n# To make the output, copy the first two rows of the input. \n# Then, starting below the grey line, draw rows one color at a time in the order of the colors in the top row from left to right, with the color of each row matching the color of the corresponding pixel in the top row. \n# Repeat this pattern until you reach the bottom of the grid.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # get the colors from the top row\n    colors = input_grid[:, 0]\n\n    # get the number of colors\n    num_colors = len(set(colors))\n\n    # get the y-coordinate of the grey line\n    grey_line = np.where(input_grid[0] == Color.GREY)[0][-1]\n\n    # draw the rows below the grey line\n    for i in range(input_grid.shape[1] - grey_line - 1):\n        draw_line(output_grid, 0, grey_line + i + 1, length=None, color=colors[i % num_colors], direction=(1, 0))\n\n    return output_grid\n\n\n\n\n\ndef generate_input():\n    # decide how many colors to use\n    num_colors = np.random.randint(2, 6)\n\n    # select colors for the sequence\n    colors = np.random.choice(list(Color.NOT_BLACK), num_colors, replace=False)\n\n    # make a grid that will fit the colors along the top row, a grey line below it, and 2 times the number of colors rows below that\n    n = num_colors\n    m = 2 * num_colors + 2\n    grid = np.zeros((n, m), dtype=int)\n\n    # put the colors in the top row\n    grid[:, 0] = colors\n\n    # put a grey line below the top row\n    grid[:, 1] = Color.GREY\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/129/images/test_input.png", "output": "output/seeds/seed_examples/129/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/129/images/train_input_0.png", "output": "output/seeds/seed_examples/129/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/129/images/train_input_1.png", "output": "output/seeds/seed_examples/129/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/129/images/train_input_2.png", "output": "output/seeds/seed_examples/129/images/train_output_2.png"}]}, "index": 129, "seed": "bd4472b8", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# translational symmetry, symmetry detection, non-black background\n\n# description:\n# In the input you will see a a translationally symmetric pattern that does not extend to cover the entire canvas. The background is not black.\n# To make the output, continue the symmetric pattern until it covers the entire canvas, but shift everything right by one pixel.\n \ndef transform(input_grid):\n    # Plan:\n    # 1. Find the background color\n    # 2. Find the repeated translation, which is a symmetry\n    # 3. Extend the pattern by computing the orbit of each pixel in the pattern\n\n    # Find the background color which is the most common color along the border of the canvas\n    pixels_on_border = np.concatenate([input_grid[0, :], input_grid[-1, :], input_grid[:, 0], input_grid[:, -1]])\n    background = max(set(pixels_on_border), key=list(pixels_on_border).count)\n    \n    # Find the repeated translation, which is a symmetry\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[], background=background)\n    assert len(symmetries) \u003e 0, \"No translational symmetry found\"\n\n    # because we are going to shift everything right by one pixel, we make an output grid which is one pixel wider\n    # at the end, we will just remove the leftmost pixels\n    width, height = input_grid.shape\n    output_grid = np.full((width+1, height), Color.BLACK)\n    \n    # Copy all of the input pixels to the output, INCLUDING their symmetric copies (i.e. their orbit)\n    for x, y in np.argwhere(input_grid != background):\n        # Compute the orbit into the output grid\n        for x2, y2 in orbit(output_grid, x, y, symmetries):\n            output_grid[x2, y2] = input_grid[x, y]\n    \n    # Shift everything right by one pixel by removing the leftmost pixels\n    output_grid = output_grid[1:, :]\n\n    return output_grid\n\n\ndef generate_input():\n\n    background_color = random.choice(Color.NOT_BLACK)\n    # Make a random large canvas\n    grid = np.full((np.random.randint(15, 30), np.random.randint(15, 30)), background_color)\n\n    # Make the basic sprite\n    w, h = random.randint(2, 4), random.randint(2, 4)\n    sprite = np.random.choice([color for color in Color.ALL_COLORS if color != background_color], (w, h))\n\n    # Tile it a few times, starting from the upper left hand corner\n    max_x = random.randint(w+1, grid.shape[0])\n    max_y = random.randint(h+1, grid.shape[1])\n    for x in range(0, max_x, w):\n        for y in range(0, max_y, h):\n            blit_sprite(grid, sprite, x, y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/130/images/test_input.png", "output": "output/seeds/seed_examples/130/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/130/images/train_input_0.png", "output": "output/seeds/seed_examples/130/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/130/images/train_input_1.png", "output": "output/seeds/seed_examples/130/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/130/images/train_input_2.png", "output": "output/seeds/seed_examples/130/images/train_output_2.png"}]}, "index": 130, "seed": "caa06a1f", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# scaling, shape matching, non-black background\n\n# description:\n# In the input you should see three objects, two of which are the same shape but different sizes and colors. The third object is a different shape.\n# To make the output, you need to find the two objects that are the same shape but different sizes and colors.\n# Return the smaller object in the same shape.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the background color\n    # 2. Extract objects by color\n    # 3. Define a helper function to check if two objects are the same shape but different color/scale, remembering that the bigger one might be partially out of the canvas\n    # 4. Iterate all candidate objects and check if they are the same shape but different color/scale\n    # 5. Return what we find\n\n    # Determine the background color, which is the most common color in the grid\n    colors = np.unique(input_grid)\n    background = colors[np.argmax([np.sum(input_grid == c) for c in colors])]\n    object_colors = [c for c in colors if c != background]\n\n    # Extract the objects, each of which is a different color.\n    # This means we can split the canvas by color, instead of using connected components.\n    objects = []\n    for color in object_colors:\n        object = np.copy(input_grid)\n        object[input_grid != color] = background\n        objects.append(object)\n    \n    # Define a helper function for checking if two objects are different color/scale but same shape\n    # This has to handle the case where the bigger object is partially outside the grid\n    def same_shape_different_color_different_scale(obj1, obj2):\n        # obj1 is the smaller object\n        if np.sum(obj1 != background) \u003e np.sum(obj2 != background): return False\n\n        mask1 = crop(obj1, background=background) != background\n        mask2 = crop(obj2, background=background) != background\n\n        # Loop through all possible scale factors\n        for scale_factor in range(2, 4):\n            scaled_mask1 = scale_sprite(mask1, scale_factor)\n            # loop over all possible places that we might put mask2, which starts anywhere in the scaled_mask1\n            # note that we are only doing this because there can be objects that fall outside of the canvas\n            # otherwise we would just compare the two masks directly\n            for dx, dy in np.ndindex(scaled_mask1.shape):\n                if np.array_equal(scaled_mask1[dx : dx + mask2.shape[0], dy : dy + mask2.shape[1]], mask2):\n                    return True\n        return False\n    \n    output_grid_candidates = []\n    # Iterate all candidate objects\n    for obj in objects:\n        other_objects = [o for o in objects if o is not obj]\n        if any( same_shape_different_color_different_scale(obj, other_obj) for other_obj in other_objects ):\n            output_grid_candidates.append(obj)\n\n    # Check if the generated input grid is valid\n    assert len(output_grid_candidates) == 1, f\"Should only have one output grid candidate, have {len(output_grid_candidates)}\"\n\n    output_grid = crop(output_grid_candidates[0], background=background)\n\n    return output_grid\n\ndef generate_input():\n    # get color for background and three objects\n    background, small_color, big_color, other_color = np.random.choice(Color.NOT_BLACK, 4, replace=False)\n\n    # Create background grid\n    n, m = np.random.randint(20, 30), np.random.randint(20, 30)\n    grid = np.full((n, m), background)\n\n    # Create two different sprites\n    n1, m1 = np.random.randint(3, 6), np.random.randint(3, 6)\n    n2, m2 = np.random.randint(3, 6), np.random.randint(3, 6)\n\n    sprite_small = random_sprite(n=n1, m=m1, color_palette=[small_color], background=background, connectivity=8)\n    sprite_other = random_sprite(n=n2, m=m2, color_palette=[other_color], background=background, connectivity=8)\n\n    # Scale the small sprite to the big sprite\n    scale_factor = np.random.randint(2, 4)\n    sprite_big = scale_sprite(sprite_small, scale_factor)\n    # change its color\n    sprite_big[sprite_big == small_color] = big_color\n\n    # Place the big sprite on the grid\n    # The sprite can be partially outside the grid\n    # Ensure the sprite is not too outside the grid\n    padding = 4\n    x, y = np.random.randint(padding, n - padding), np.random.randint(padding, m - padding)\n    blit_sprite(grid=grid, sprite=sprite_big, x=x, y=y, background=background)\n\n    try:\n        # Place the small sprite on the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite_small, background=background)\n        blit_sprite(grid=grid, sprite=sprite_small, x=x, y=y, background=background)\n\n        # Place the other sprite on the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite_other, background=background)\n        blit_sprite(grid=grid, sprite=sprite_other, x=x, y=y, background=background)\n\n        # Check if the generated grid is valid\n        main(grid)\n    except:\n        return generate_input()\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/131/images/test_input.png", "output": "output/seeds/seed_examples/131/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/131/images/train_input_0.png", "output": "output/seeds/seed_examples/131/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/131/images/train_input_1.png", "output": "output/seeds/seed_examples/131/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/131/images/train_input_2.png", "output": "output/seeds/seed_examples/131/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/131/images/train_input_3.png", "output": "output/seeds/seed_examples/131/images/train_output_3.png"}]}, "index": 131, "seed": "ce602527", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# occlusion\n\n# description:\n# In the input you will see three regions separated by red vertical bars. Each region is rectangular and the regions are arranged horizontally, so there is a left region, middle region, and a right region. \n# The regions display a yellow pattern, a maroon pattern, and a blue pattern from left to right.\n# To make the output, you have to copy the blue pattern first, then overlay the maroon pattern over that, finally overlay the yellow pattern over that as well.\n\ndef transform(input_grid):\n    # find the location of the vertical red bars that separate the three sections\n    red_bars = np.where(input_grid == Color.RED)\n\n    # get the unique x-coordinates of the red bars\n    red_bars_x = np.unique(red_bars[0])\n\n    # get the blue pattern from the third section and copy it to make the base of the output grid\n    blue_pattern = input_grid[red_bars_x[1]+1:, :]\n    output_grid = blue_pattern\n    # could also have used blit_sprite:\n    # output_grid = blit_sprite(output_grid, blue_pattern, x=0, y=0)\n\n    # get the maroon pattern from the second section and overlay it on output grid\n    maroon_pattern = input_grid[red_bars_x[0]+1:red_bars_x[1], :]\n    output_grid = np.where(maroon_pattern, maroon_pattern, output_grid)\n    # could also have used blit:\n    # output_grid = blit_sprite(output_grid, maroon_pattern, x=0, y=0)\n\n    # get the yellow pattern from the first section and overlay it on output grid\n    yellow_pattern = input_grid[0:red_bars_x[0], :]\n    output_grid = np.where(yellow_pattern, yellow_pattern, output_grid)\n    # could also have used blit:\n    # output_grid = blit_sprite(output_grid, yellow_pattern, x=0, y=0)\n\n    return output_grid\n\ndef generate_input():\n    # make a red divider to be used to separate the three sections\n    red_divider = np.full((1,4), Color.RED, dtype=int)\n\n    # make a yellow section and scatter yellow pixels in it\n    yellow_section = np.zeros((4,4), dtype=int)\n    for _ in range(12):\n        x, y = np.random.randint(yellow_section.shape[1]), np.random.randint(yellow_section.shape[0])\n        yellow_section[x, y] = Color.YELLOW\n\n    # make a maroon section and scatter maroon pixels in it\n    maroon_section = np.zeros((4,4), dtype=int)\n    for _ in range(12):\n        x, y = np.random.randint(yellow_section.shape[1]), np.random.randint(yellow_section.shape[0])\n        maroon_section[x, y] = Color.MAROON\n\n    # make a blue section and scatter blue pixels in it\n    blue_section = np.zeros((4,4), dtype=int)\n    for _ in range(12):\n        x, y = np.random.randint(yellow_section.shape[1]), np.random.randint(yellow_section.shape[0])\n        blue_section[x, y] = Color.BLUE\n    \n    # concatenate the three sections with the red dividers\n    grid = np.concatenate([yellow_section, red_divider, maroon_section, red_divider, blue_section], axis=0)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/132/images/test_input.png", "output": "output/seeds/seed_examples/132/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/132/images/train_input_0.png", "output": "output/seeds/seed_examples/132/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/132/images/train_input_1.png", "output": "output/seeds/seed_examples/132/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/132/images/train_input_2.png", "output": "output/seeds/seed_examples/132/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/132/images/train_input_3.png", "output": "output/seeds/seed_examples/132/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/132/images/train_input_4.png", "output": "output/seeds/seed_examples/132/images/train_output_4.png"}]}, "index": 132, "seed": "cf98881b", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# staircase pattern\n\n# description:\n# In the input you will see a single teal pixel.\n# To make the output, draw a staircase from the teal pixel to the upper right and lower left with a step size of 2.\n\ndef transform(input_grid):\n    # Find the location of the teal pixel\n    teal_x, teal_y = np.argwhere(input_grid == Color.TEAL)[0]\n\n    # staircase is gray\n    staircase_color = Color.GRAY\n\n    # we are going to draw on top of the input\n    output_grid = input_grid.copy()\n    width, height = input_grid.shape\n\n    # Draw stairs from the teal pixel\n    STAIR_LEN = 2\n    # First draw stair to the upper right\n    x, y = teal_x, teal_y\n    while 0 \u003c= x \u003c width and 0 \u003c= y \u003c height:\n        # go up\n        draw_line(output_grid, x, y, length=STAIR_LEN, color=staircase_color, direction=(0, -1))\n        y -= STAIR_LEN\n        # go right\n        draw_line(output_grid, x, y, length=STAIR_LEN, color=staircase_color, direction=(1, 0))\n        x += STAIR_LEN\n    \n    # Then draw stair to the lower left\n    x, y = teal_x, teal_y\n    while 0 \u003c= x \u003c width and 0 \u003c= y \u003c height:\n        # go down\n        draw_line(output_grid, x, y, length=STAIR_LEN, color=staircase_color, direction=(0, 1))\n        y += STAIR_LEN\n        # go left\n        draw_line(output_grid, x, y, length=STAIR_LEN, color=staircase_color, direction=(-1, 0))\n        x -= STAIR_LEN\n    \n    # make sure that the teal pixel stays there\n    output_grid[teal_x, teal_y] = Color.TEAL\n\n    return output_grid\n\ndef generate_input():\n    # Generate grid\n    width, height = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((width, height), dtype=int)\n\n    # Randomly place one teal pixel on the grid\n    # Ensure the pixel is not on the border\n    x, y = np.random.randint(width // 3, width * 2 // 3), np.random.randint(height // 3, height * 2 // 3)\n    grid[x, y] = Color.TEAL\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/133/images/test_input.png", "output": "output/seeds/seed_examples/133/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/133/images/train_input_0.png", "output": "output/seeds/seed_examples/133/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/133/images/train_input_1.png", "output": "output/seeds/seed_examples/133/images/train_output_1.png"}]}, "index": 133, "seed": "d06dbe63", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting\n\n# description:\n# The input consists of several grey objects in a 10x10 grid.\n# To create the output, change the color of all objects of area 6 to red, and all other objects to blue.\n\ndef transform(input_grid):\n    # extract objects\n    objects = find_connected_components(input_grid, connectivity=4)\n\n    # convert each object to the desired color\n    for obj in objects:\n        if np.sum(obj != Color.BLACK) == 6:\n            obj[obj != Color.BLACK] = Color.RED\n        else:\n            obj[obj != Color.BLACK] = Color.BLUE\n\n    # place new objects back into a grid\n    output_grid = np.zeros_like(input_grid)\n    for obj in objects:\n        output_grid = blit_object(output_grid, obj, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    # create a 10x10 grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # generate objects and place into the grid until it is filled\n    # we want some area six objects, and some non-area six objects.\n    # to do so, first place a couple area six objects, then fill up the remaining space with random objects\n\n    # place two area six objects\n    for _ in range(2):\n        while True:\n            obj = random_sprite(list(range(1, 5)), list(range(1, 5)), color_palette=[Color.GREY])\n            if np.sum(obj != Color.BLACK) == 6:\n                break\n        x, y = random_free_location_for_sprite(grid, obj, padding=1)\n        grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n\n    # now fill up the remaining space with random objects.\n    while True:\n        obj = random_sprite(list(range(1, 5)), list(range(1, 5)), color_palette=[Color.GREY])\n\n        # try to place the object. if we can\u0027t, we\u0027re done\n        try:\n            x, y = random_free_location_for_sprite(grid, obj, padding=1)\n            grid = blit_sprite(grid, obj, x, y, background=Color.BLACK)\n        except ValueError:\n            break\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/134/images/test_input.png", "output": "output/seeds/seed_examples/134/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/134/images/train_input_0.png", "output": "output/seeds/seed_examples/134/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/134/images/train_input_1.png", "output": "output/seeds/seed_examples/134/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/134/images/train_input_2.png", "output": "output/seeds/seed_examples/134/images/train_output_2.png"}]}, "index": 134, "seed": "d2abd087", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# lines, color\n\n# description:\n# In the input you will see a red pixel and a teal pixel.\n# To make the output, draw a horizontal yellow line from the red pixel to the column of the teal pixel, then draw a vertical yellow line from there to the teal pixel.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # find the red and teal pixels\n    red_x, red_y = np.where(input_grid == Color.RED)\n    teal_x, teal_y = np.where(input_grid == Color.TEAL)\n\n    # draw the horizontal yellow line from the red pixel to the column the teal pixel is\n    # figure out the direction of the line\n    if red_x[0] \u003c teal_x[0]:\n        direction = (1, 0)\n    else:\n        direction = (-1, 0)\n    # draw the line but don\u0027t draw over the red pixel\n    draw_line(output_grid, red_x[0]+direction[0], red_y[0], length=np.abs(teal_x[0] - red_x[0]), color=Color.YELLOW, direction=direction)\n\n    # draw the vertical yellow line from the end of the horizontal yellow line to the teal pixel\n    # figure out the direction of the line\n    if red_y[0] \u003c teal_y[0]:\n        direction = (0, 1)\n    else:\n        direction = (0, -1)\n    # draw the line\n    draw_line(output_grid, teal_x[0], red_y[0], length=None, color=Color.YELLOW, direction=direction, stop_at_color=[Color.TEAL])\n\n    return output_grid\n\n\ndef generate_input():\n    # make a black grid as the background\n    n = np.random.randint(6, 15)\n    m = np.random.randint(6, 15)\n    grid = np.zeros((n, m), dtype=int)\n\n    # select a random position for the red pixel\n    red_x = np.random.randint(0, n)\n    red_y = np.random.randint(0, m)\n    grid[red_x, red_y] = Color.RED\n\n    # select a random position for the teal pixel\n    teal_x = np.random.randint(0, n)\n    teal_y = np.random.randint(0, m)\n    grid[teal_x, teal_y] = Color.TEAL\n\n    # check if the red and teal pixels are in the same row or column\n    # if they are, then try again\n    if red_x == teal_x or red_y == teal_y:\n        return generate_input()\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/135/images/test_input.png", "output": "output/seeds/seed_examples/135/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/135/images/train_input_0.png", "output": "output/seeds/seed_examples/135/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/135/images/train_input_1.png", "output": "output/seeds/seed_examples/135/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/135/images/train_input_2.png", "output": "output/seeds/seed_examples/135/images/train_output_2.png"}]}, "index": 135, "seed": "d4a91cb9", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# cups, filling\n\n# description:\n# In the input you will see grey cups, meaning an almost-enclosed shape with a small opening on one of its sides, and empty space (black pixels) inside.\n# To make the output grid, you should fill the interior of each cup with teal, then shoot teal out of the opening of the cup straight out in a line.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the cup\n    # 2. Find the mask of the inside of the cup\n    # 3. Find the mask of the opening of the cup (on one of its sides)\n    # 4. Fill the cup with teal\n    # 5. Shoot pixels outward from the opening (straight out)\n    \n    # 1. Detect cup\n    objects = find_connected_components(input_grid, connectivity=4, background=Color.BLACK)\n    assert len(objects) == 1, \"There should be exactly one cup\"\n    obj = list(objects)[0]\n\n    output_grid = input_grid.copy()\n\n    # 2. Extract what\u0027s inside the cup (as its own object), which is everything in the bounding box that is not the object itself\n    cup_x, cup_y, cup_width, cup_height = bounding_box(obj)\n    inside_cup_mask = np.zeros_like(input_grid, dtype=bool)\n    inside_cup_mask[cup_x:cup_x+cup_width, cup_y:cup_y+cup_height] = True\n    inside_cup_mask = inside_cup_mask \u0026 (obj == Color.BLACK)\n\n    # 3. Extract the hole in the cup, which is what\u0027s inside and on the boundary of the bounding box\n    # what\u0027s inside...\n    hole_mask = inside_cup_mask.copy()\n    # ...and then we need to remove anything not on the boundary\n    hole_mask[cup_x+1 : cup_x+cup_width-1, cup_y+1 : cup_y+cup_height-1] = False\n\n    # 4. Fill the cup with teal\n    output_grid[inside_cup_mask] = Color.TEAL\n\n    # 5. Shoot pixels outward from the opening (straight out)\n    # Find the direction of the opening, which is the unit vector that points away from the interior\n    for cardinal_direction in [ (0, 1), (0, -1), (1, 0), (-1, 0) ]:\n        dx, dy = cardinal_direction\n        hole_x, hole_y = object_position(hole_mask, background=Color.BLACK, anchor=\u0027center\u0027)\n        if inside_cup_mask[hole_x - dx, hole_y - dy]:\n            direction = cardinal_direction\n            break\n    # Loop over every boundary pixel and shoot outward\n    for x, y in np.argwhere(hole_mask):\n        draw_line(output_grid, x, y, direction=direction, color=Color.TEAL)\n    return output_grid\n\ndef generate_input():\n    # Generate the grid with random size\n    width = np.random.randint(8, 30)\n    height = np.random.randint(8, 30)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Pick a random width/height for this cup\n    cup_width = np.random.randint(4, 8)\n    cup_height = np.random.randint(3, 8)\n\n    # Make a sprite, which is just going to be a grey outline of a rectangle with a hole on one of its sides\n    sprite = np.full((cup_width, cup_height), Color.BLACK)\n    color = random.choice([ color for color in Color.NOT_BLACK if color != Color.TEAL ])\n    sprite[0, :] = color\n    sprite[-1, :] = color\n    sprite[:, 0] = color\n    sprite[:, -1] = color\n\n    # Make the hole randomly somewhere on the edges (but not in the corners)\n    edges_but_not_corners = [ (0, y) for y in range(1, cup_height-1) ] + [ (cup_width-1, y) for y in range(1, cup_height-1) ] + [ (x, 0) for x in range(1, cup_width-1) ] + [ (x, cup_height-1) for x in range(1, cup_width-1) ]\n    hole_x, hole_y = random.choice(edges_but_not_corners)\n    sprite[hole_x, hole_y] = Color.BLACK\n\n    # Find a random free location for it\n    free_x, free_y = random_free_location_for_sprite(grid, sprite, background=Color.BLACK, padding=1, border_size=1)\n    blit_sprite(grid, sprite, free_x, free_y, background=Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/136/images/test_input.png", "output": "output/seeds/seed_examples/136/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/136/images/train_input_0.png", "output": "output/seeds/seed_examples/136/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/136/images/train_input_1.png", "output": "output/seeds/seed_examples/136/images/train_output_1.png"}]}, "index": 136, "seed": "d4f3cd78", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# colors\n\n# description:\n# To create the output grid, swap the teal and grey colors in the grid.\n\ndef transform(input_grid):\n    output_grid = input_grid.copy()\n    output_grid[input_grid == Color.GREY] = Color.TEAL\n    output_grid[input_grid == Color.TEAL] = Color.GREY\n    return output_grid\n\n\ndef generate_input():\n    # make a random grid\n    n = np.random.randint(3, 10)\n    input_grid = np.random.choice(Color.NOT_BLACK, size=(n, n))\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/137/images/test_input.png", "output": "output/seeds/seed_examples/137/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/137/images/train_input_0.png", "output": "output/seeds/seed_examples/137/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/137/images/train_input_1.png", "output": "output/seeds/seed_examples/137/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/137/images/train_input_2.png", "output": "output/seeds/seed_examples/137/images/train_output_2.png"}]}, "index": 137, "seed": "d511f180", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# connected components\n\n# description:\n# In the input you will see two rectangles separated by a gap.\n# To make the output, you need to connect the two rectangles with a teal line.\n\ndef transform(input_grid):\n    # Copy the input grid as output\n    output_grid = input_grid.copy()\n\n    # Detect the objects\n    objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    for x, y in np.argwhere(input_grid == Color.BLACK):\n        # Check if the current position is between the two objects\n        # Also ensure it is not between the borders of the objects (padding=1)\n        if check_between_objects(obj1=objects[0], obj2=objects[1], x=x, y=y, padding=1):\n            output_grid[x, y] = Color.TEAL\n    \n    return output_grid\n\n\ndef generate_input():\n    # Generate the background grid\n    n, m = np.random.randint(10, 20, size=2)\n    grid = np.full((n, m), Color.BLACK)\n\n    # Choose two colors for the pattern\n    color_connect = Color.TEAL\n    colors = np.random.choice([color for color in Color.NOT_BLACK if color != color_connect], 2, replace=False)\n    color1, color2 = colors\n\n    # Generate two rectangles\n    n1, m1 = np.random.randint(3, 10, size=2)\n    n2, m2 = np.random.randint(3, 10, size=2)\n\n    rectangle1 = np.full((n1, m1), color1)\n    rectangle2 = np.full((n2, m2), color2)\n\n    # Place the rectangles on the grid\n    x1, y1 = random_free_location_for_sprite(grid=grid, sprite=rectangle1, background=Color.BLACK, padding=2, padding_connectivity=8)\n    blit_sprite(grid, rectangle1, x1, y1, Color.BLACK)\n    try:\n        # Check if there is enough space for the second rectangle\n        x2, y2 = random_free_location_for_sprite(grid=grid, sprite=rectangle2, background=Color.BLACK, padding=2, padding_connectivity=8)\n        blit_sprite(grid, rectangle2, x2, y2, Color.BLACK)\n        # Ensure the two rectangles can be connected\n        main(grid)\n    except Exception as e:\n        # If not, regenerate the input\n        return generate_input()\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/138/images/test_input.png", "output": "output/seeds/seed_examples/138/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/138/images/train_input_0.png", "output": "output/seeds/seed_examples/138/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/138/images/train_input_1.png", "output": "output/seeds/seed_examples/138/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/138/images/train_input_2.png", "output": "output/seeds/seed_examples/138/images/train_output_2.png"}]}, "index": 138, "seed": "d6ad076f", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# line drawing, obstacle avoidance\n\n# description:\n# In the input you will see several red pixels on the bottom row of the grid, and some gray pixels scattered on the grid.\n# To make the output grid, you should draw a red line upward from each red pixel, but avoiding the gray pixels.\n# To avoid touching the gray pixels, go right to avoid them until you can go up again.\n\ndef transform(input_grid):\n    # The output grid is the same size as the input grid, and we are going to draw on top of the input, so we copy it\n    output_grid = input_grid.copy()\n    width, height = input_grid.shape\n\n    # Get the positions of the red pixels on the bottom row\n    for x, y in np.argwhere(input_grid == Color.RED):\n        # Draw the red line upward, but move to the right to avoid touching gray pixels\n        while 0 \u003c y \u003c height and 0 \u003c x \u003c width:\n            if output_grid[x, y - 1] == Color.GRAY:\n                # If the red line touch the gray pixel, it should go right then up to avoid the gray pixel.\n                output_grid[x + 1, y] = Color.RED\n                x += 1\n            else:\n                # Otherwise we go up\n                output_grid[x, y - 1] = Color.RED\n                y -= 1\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    n, m = 10, 10\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate the red pixels on the bottom row.\n    # Get 3 random positions for the red pixels.\n    available_postion = range(1, 9)\n    red_location = random.sample(available_postion, 3)\n\n    # Draw the red pixels on the bottom row.\n    for pos_x in red_location:\n        grid[pos_x, -1] = Color.RED\n    \n    # Get the region except the bottom row, left most column and right most column.\n    # Randomly scatter the gray pixels on the grid.\n    randomly_scatter_points(grid[1:-1, 1:-1], color=Color.GRAY, density=0.1)\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/139/images/test_input.png", "output": "output/seeds/seed_examples/139/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/139/images/train_input_0.png", "output": "output/seeds/seed_examples/139/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/139/images/train_input_1.png", "output": "output/seeds/seed_examples/139/images/train_output_1.png"}]}, "index": 139, "seed": "d9f24cd1", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, pyramid, color alternation\n\n# description:\n# In the input you will see a single orange line that connects to the top of the grid.\n# To make the output, you should draw a pyramid pattern outward from the orange line.\n# The pattern is expanded from the orange line to the left and right of the grid.\n# Each line of the pattern is one cell shorter than the previous one, and the color alternates between orange and teal.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input\n    # 2. Draw the left side of the pyramid\n    # 3. Draw the right side of the pyramid\n\n    # 1. Parse the input\n    # Extract the orange line from the input grid\n    original_line = find_connected_components(input_grid, monochromatic=True)[0]\n    original_x, original_y, width, height = bounding_box(original_line)\n\n    # two color pattern\n    color1 = Color.ORANGE\n    color2 = Color.TEAL\n    # Draw on top of the input\n    output_grid = np.copy(input_grid)\n\n    # Draw the pattern from the orange line and expand to left and right\n    # Each line is one cell shorter than the previous one\n    # The line is colored alternately between color1 and color2\n\n    # 2. draw pattern from left to right\n    cur_color = color2\n    cur_height = height - 1\n    for x in range(original_x + 1, output_grid.shape[0]):\n        # If the height of the line is 0, stop drawing\n        if cur_height \u003c= 0:\n            break\n        draw_line(output_grid, x=x, y=original_y, direction=(0, 1), length=cur_height, color=cur_color)\n        # pyramid pattern, each line is one pixel shorter than the previous one\n        cur_height -= 1\n        # colors alternate\n        cur_color = color1 if cur_color == color2 else color2\n    \n    # 3. Then draw pattern from right to left\n    cur_color = color2\n    cur_height = height - 1\n    for x in reversed(range(original_x)):\n        # If the height of the line is 0, stop drawing\n        if cur_height \u003c= 0:\n            break\n        draw_line(output_grid, x=x, y=original_y, direction=(0, 1), length=cur_height, color=cur_color)\n        # pyramid pattern, each line is one pixel shorter than the previous one\n        cur_height -= 1\n        # colors alternate\n        cur_color = color1 if cur_color == color2 else color2\n    \n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(5, 10, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly generate one orange line connecting to the top\n    # The line should be at least 4 cells long\n    length = np.random.randint(3, height - 1)\n\n    # Randomly choose one position to start the line\n    x = np.random.randint(0, width)\n    line_color = Color.ORANGE\n    draw_line(grid=grid, x=x, y=0, direction=(0, 1), length=length, color=line_color)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/140/images/test_input.png", "output": "output/seeds/seed_examples/140/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/140/images/train_input_0.png", "output": "output/seeds/seed_examples/140/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/140/images/train_input_1.png", "output": "output/seeds/seed_examples/140/images/train_output_1.png"}]}, "index": 140, "seed": "db3e9e38", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# Expanding, Framing, Growing\n\n# description:\n# In the input you will see some squares of different sizes and colors.\n# To make the output, you need to:\n# 1. Expand the squares down to the bottom of the grid using the color BLUE.\n# 2. Draw a green frame around the squares. The green square should be twice as long as the original square.\n# 3. Put the original square back to the center of the green square.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract the square objects from the input grid\n    # 2. Expand the squares down to the bottom using the color BLUE\n    # 3. Draw the frame\n    # 4. Put the original squares back\n\n    # 1. Input parsing and setup\n    # Extract the squares in the input grid\n    square_objects = find_connected_components(input_grid, background=Color.BLACK, connectivity=4, monochromatic=True)\n\n    # Note the frame color and the expansion down color\n    frame_color = Color.GREEN\n    expand_color = Color.BLUE\n\n    # The output grid is the same size as the input grid\n    output_grid = np.full_like(input_grid, Color.BLACK)\n\n    # 2. Expand the square down to the bottom use color expand_color\n    for square_obj in square_objects:\n        x, y, w, h = bounding_box(square_obj)\n        # Equivalently:\n        # output_grid[x:x+w, y+h:] = expand_color\n        for i in range(x, x + w):\n            draw_line(grid=output_grid, x=i, y=y + h, color=expand_color, direction=(0, 1))\n    \n    # 3. Draw a green square frame around the original squares, the green square should be twice as big as original were\n    for square_obj in square_objects:\n        # The square can be partly outside the canvas\n        # This math is to get the (x,y) of the top-left corner of the square, even if it\u0027s outside the canvas\n        x, y, w, h = bounding_box(square_obj)\n        square_len = max(w, h)\n        x -= (square_len - w)\n        y -= (square_len - h)\n        # Make and draw the frame\n        frame_len = square_len * 2\n        green_frame = np.full((frame_len, frame_len), frame_color)\n        blit_sprite(output_grid, green_frame, x - square_len // 2, y - square_len // 2)\n    \n    # 4. Put the original square back to the center of the green square\n    for square_obj in square_objects:\n        x, y, w, h = bounding_box(square_obj)\n        square_obj = crop(square_obj)\n        blit_sprite(output_grid, square_obj, x, y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width = np.random.randint(15, 30)\n    height = width\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly select the number of squares\n    square_num = np.random.randint(2, 5)\n    square_color = Color.MAROON\n\n    for _ in range(square_num):\n        # Randomly select the size of the squares\n        square_size = np.random.randint(1, 4)\n        # Ensure the size of square is even\n        square_size = square_size * 2\n\n        square = np.full((square_size, square_size), square_color)\n        try:\n            # Place the square on the grid\n            x, y = random_free_location_for_sprite(grid=grid, sprite=square, background=Color.BLACK, padding=2, padding_connectivity=8, border_size=1)\n        except:\n            # If there is no space, regenerate the input\n            return generate_input()\n        blit_sprite(grid, square, x, y, Color.BLACK)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/141/images/test_input.png", "output": "output/seeds/seed_examples/141/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/141/images/train_input_0.png", "output": "output/seeds/seed_examples/141/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/141/images/train_input_1.png", "output": "output/seeds/seed_examples/141/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/141/images/train_input_2.png", "output": "output/seeds/seed_examples/141/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/141/images/train_input_3.png", "output": "output/seeds/seed_examples/141/images/train_output_3.png"}]}, "index": 141, "seed": "db93a21d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# bouncing\n\n# description:\n# In the input you will see a single blue pixel on a black background\n# To make the output, shoot the blue pixel diagonally up and to the right, having it reflect and bounce off the walls until it exits at the top of the grid. Finally, change the background color to teal.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Detect the pixel\n    # 2. Shoot each line of the reflection one-by-one, bouncing (changing horizontal direction) when it hits a (horizontal) wall/edge of canvas\n    # 3. Change the background color to teal\n\n    # 1. Find the location of the pixel\n    blue_pixel_x, blue_pixel_y = np.argwhere(input_grid == Color.BLUE)[0]\n\n    # 2. do the bounce which requires keeping track of the direction of the ray we are shooting, as well as the tip of the ray\n    # initially we are shooting diagonally up and to the right (dx=1, dy=-1)\n    # initially the tip of the ray is the blue pixel, x=blue_pixel_x, y=blue_pixel_y\n    direction = (1, -1)\n\n    # loop until we fall out of the canvas\n    while 0 \u003c= blue_pixel_x \u003c input_grid.shape[0] and 0 \u003c= blue_pixel_y \u003c input_grid.shape[1]:\n        stop_x, stop_y = draw_line(input_grid, blue_pixel_x, blue_pixel_y, direction=direction, color=Color.BLUE)\n        # Terminate if we failed to make progress\n        if stop_x == blue_pixel_x and stop_y == blue_pixel_y:\n            break\n        blue_pixel_x, blue_pixel_y = stop_x, stop_y\n        direction = (-direction[0], direction[1])\n    \n    old_background = Color.BLACK\n    new_background = Color.TEAL\n    input_grid[input_grid == old_background] = new_background\n    \n    return input_grid\n\n\ndef generate_input():\n    width, height = np.random.randint(2, 15), np.random.randint(10, 30)\n    grid = np.full((width, height), Color.BLACK)\n    grid[0,-1] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/142/images/test_input.png", "output": "output/seeds/seed_examples/142/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/142/images/train_input_0.png", "output": "output/seeds/seed_examples/142/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/142/images/train_input_1.png", "output": "output/seeds/seed_examples/142/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/142/images/train_input_2.png", "output": "output/seeds/seed_examples/142/images/train_output_2.png"}]}, "index": 142, "seed": "e179c5f4", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, expansion, color sequence\n\n# description:\n# In the input you will see a grid with a cross pattern. Each pixel in the cross has a different color.\n# To make the output, you should expand the cross right/left/top/bottom following the original color sequence of the cross.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input and create output canvas to draw on top of\n    # 2. Extract the vertical and horizontal parts of the cross, and make note of the coordinate of the middle\n    # 3. Expand the horizontal part to the right and left, aligned with the middle y coordinate\n    # 4. Expand the vertical part to the top and bottom, aligned with the middle x coordinate    \n\n    # 1. Input parsing\n    # Extract the cross, which has many colors and so is not monochromatic.\n    objects = find_connected_components(input_grid, monochromatic=False)\n    assert len(objects) == 1, \"exactly one cross expected\"\n    obj = objects[0]\n    cross_x, cross_y = object_position(obj)\n\n    # Create output grid, which we are going to draw on top of, so we start with the input grid\n    output_grid = input_grid.copy()\n    width, height = input_grid.shape\n\n    # 2. Cross analysis: Extract subsprites, get the middle\n    # Extract the horizontal/vertical parts of the cross sprite by figuring out where its middle is (where the horizontal and vertical lines meet)\n    sprite = crop(obj)\n    cross_width, cross_height = sprite.shape\n    # Middle is where they meet\n    cross_middle_x = next( x for x in range(cross_width) if np.all(sprite[x, :] != Color.BLACK) )\n    cross_middle_y = next( y for y in range(cross_height) if np.all(sprite[:, y] != Color.BLACK) )\n    # Extract the horizontal and vertical parts of the cross\n    vertical_sprite = sprite[cross_middle_x:cross_middle_x+1, :]\n    horizontal_sprite = sprite[:, cross_middle_y:cross_middle_y+1]\n\n    # 3. Expand the horizontal line to the right and left\n    x_start, y_start, len_line = cross_x, cross_y + cross_middle_y, cross_width\n    for i in range(x_start, width, len_line):\n        blit_sprite(output_grid, horizontal_sprite, x=i, y=y_start)\n    for i in range(x_start, -(len_line), -len_line):\n        blit_sprite(output_grid, horizontal_sprite, x=i, y=y_start)\n    \n    # 4. Expand the vertical line to the top and bottom\n    x_start, y_start, len_line = cross_x + cross_middle_x, cross_y, cross_height\n    for i in range(y_start, height, len_line):\n        blit_sprite(output_grid, vertical_sprite, x=x_start, y=i)\n    for i in range(y_start, -(len_line), -len_line):\n        blit_sprite(output_grid, vertical_sprite, x=x_start, y=i)\n        \n    return output_grid\n\ndef generate_input():\n    # Generate the background grid\n    width, height = np.random.randint(20, 30, size=2)\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose the number of colors\n    num_colors = np.random.randint(2, 5)\n    colors = np.random.choice(Color.NOT_BLACK, size=num_colors, replace=False)\n\n    # Generate a line with these colors in sequence\n    line = np.full((num_colors, 1), Color.BLACK)\n    for i in range(num_colors):\n        line[i, 0] = colors[i]\n\n    # form a cross pattern randomly\n    cross_points = random.randint(0, num_colors - 1)\n    sprite = np.full((num_colors, num_colors), Color.BLACK)\n    line_t = np.transpose(line)\n    blit_sprite(sprite, line, x=0, y=cross_points)\n    blit_sprite(sprite, line_t, x=cross_points, y=0)\n\n    # Randomly rotate the pattern\n    sprite = np.rot90(sprite, k=np.random.randint(4))\n\n    # Randomly place the pattern on the grid\n    x, y = random_free_location_for_sprite(grid, sprite)\n    blit_sprite(grid, sprite, x=x, y=y)\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/143/images/test_input.png", "output": "output/seeds/seed_examples/143/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/143/images/train_input_0.png", "output": "output/seeds/seed_examples/143/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/143/images/train_input_1.png", "output": "output/seeds/seed_examples/143/images/train_output_1.png"}]}, "index": 143, "seed": "e21d9049", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting\n\n# description:\n# In the input, you will see a 10x10 black grid. The grid has one row and one column colored solidly in a single color, forming a cross of that color across the grid. The grid also has H grey pixels in the rightmost column at the top of the grid.\n# To create the output, convert the H grey pixels to be black. Then shift the \"cross\" H pixels to the left and H pixels down.\n\ndef transform(input_grid):\n    # 1. Calculate the shift amount: the number of grey pixels in the rightmost column\n    H = np.sum(input_grid[-1, :] == Color.GREY)\n\n    # 2. find the row and column of the cross, and its color.\n    color = next(c for c in np.unique(input_grid) if c not in [Color.BLACK, Color.GREY])\n\n    # find which column is fully colored with the color\n    x = np.where(np.all(input_grid == color, axis=1))[0][0]\n    # find which row is fully colored with the color\n    y = np.where(np.all(input_grid == color, axis=0))[0][0]\n\n    # shift the column and row down/left by H\n    x -= H\n    y += H\n\n    # create the output grid by recreating the cross at the new location\n    output_grid = np.full(input_grid.shape, Color.BLACK)\n    output_grid[x, :] = color\n    output_grid[:, y] = color\n\n    return output_grid\n\ndef generate_input():\n    # create a 10x10 black grid\n    grid = np.full((10, 10), Color.BLACK)\n\n    # choose a random column/row and color for the cross, and create it\n    # the column/row should be at least 1 pixel away from the bottom left.\n    x = np.random.randint(1, 10)\n    y = np.random.randint(9)\n    color = np.random.choice(Color.NOT_BLACK)\n    grid[x, :] = color\n    grid[:, y] = color\n\n    # choose a random number of grey pixels to place in the rightmost column\n    # it should be less than the column and row numbers\n    H = np.random.randint(1, min(x, y))\n\n    # color the rightmost column\u0027s top H pixels grey\n    grid[-1, :H] = Color.GREY\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/144/images/test_input.png", "output": "output/seeds/seed_examples/144/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/144/images/train_input_0.png", "output": "output/seeds/seed_examples/144/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/144/images/train_input_1.png", "output": "output/seeds/seed_examples/144/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/144/images/train_input_2.png", "output": "output/seeds/seed_examples/144/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/144/images/train_input_3.png", "output": "output/seeds/seed_examples/144/images/train_output_3.png"}]}, "index": 144, "seed": "e48d4e1a", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# topology, counting\n\n# description:\n# In the input you will see a grid with several green objects with different number of bends.\n# To make the output, color the objects with one bend with blue, two bends with pink, three bends with red.\n\ndef transform(input_grid):\n    # Create a copy of the input grid to avoid modifying the original\n    output_grid = np.copy(input_grid)\n\n    # Find all the green objects in the grid\n    object_color = Color.GREEN\n    background = Color.BLACK\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background)\n    for obj in objects:\n        # Get the bounding box of the sprite and crop the sprite\n        x, y, w, h = bounding_box(obj, background=background)\n        sprite = crop(obj, background=Color.BLACK)\n        mask = sprite != background\n\n        # Determine how many bends the mask has\n        # Do this by building an L-shaped mask, and seeing how many times it appears in the sprite\n        bend_mask = np.array([[1, 1], [1, 0]])\n        rotated_bend_masks = [bend_mask, np.rot90(bend_mask), np.rot90(bend_mask, 2), np.rot90(bend_mask, 3)]\n\n        from scipy.ndimage import correlate\n        \n        n_bends = sum( np.sum( correlate(mask*1, filter*1, mode=\u0027constant\u0027, cval=0) == np.sum(filter*1) ) for filter in rotated_bend_masks )\n\n        # find the new color based on bends\n        new_color = {1: Color.BLUE, 2: Color.PINK, 3: Color.RED}[n_bends]\n        # color the sprite with the new color\n        sprite[sprite == object_color] = new_color\n        blit_sprite(output_grid, sprite=sprite, x=x, y=y)\n\n    return output_grid\n\ndef generate_input():\n    # Generate grid of size n x m\n    n, m = np.random.randint(15, 25), np.random.randint(15, 25)\n    grid = np.zeros((n, m), dtype=int)\n\n    # The objects color is green\n    object_color = Color.GREEN\n\n    # keep track of what bends we\u0027ve already created, so that we end up with at least one of each bend\n    bends_we_have = set()\n\n    for _ in range(random.randint(3, 6)):\n        # Randomly generate sprite with one to three bends\n        w, h = np.random.randint(3, 6), np.random.randint(3, 6)\n\n        # Generate sprite with the object color\n        sprite = random_sprite(w, h, color_palette=[object_color], symmetry=\"not_symmetric\", density=0.3)\n\n        # calculate how many bends it has and make sure that the number of bends are 1-3\n        mask = sprite != Color.BLACK\n        bend_mask = np.array([[1, 1], [1, 0]])\n        rotated_bend_masks = [bend_mask, np.rot90(bend_mask), np.rot90(bend_mask, 2), np.rot90(bend_mask, 3)]\n        from scipy.ndimage import correlate\n        n_bends = sum( np.sum( correlate(mask*1, filter*1, mode=\u0027constant\u0027, cval=0) == np.sum(filter*1) ) for filter in rotated_bend_masks )\n        if n_bends not in [1, 2, 3]: continue\n\n        # keep track of what bends we\u0027ve already created\n        bends_we_have.add(n_bends)\n\n        # Randomly place the sprite on the grid\n        x, y = random_free_location_for_sprite(grid=grid, sprite=sprite, padding=1, padding_connectivity=8)\n\n        blit_sprite(grid, sprite, x=x, y=y)\n\n    # The input grid should have at least one object one type of bend as example.\n    if len(bends_we_have) \u003c 3:\n        return generate_input()\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/145/images/test_input.png", "output": "output/seeds/seed_examples/145/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/145/images/train_input_0.png", "output": "output/seeds/seed_examples/145/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/145/images/train_input_1.png", "output": "output/seeds/seed_examples/145/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/145/images/train_input_2.png", "output": "output/seeds/seed_examples/145/images/train_output_2.png"}]}, "index": 145, "seed": "e509e548", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# filling\n\n# description:\n# The input consists of a black grid containing a few hollow grey rectangles. Each rectangle has 1-3 grey horizontal or vertical lines emanating off of it (at most one per side), either travelling to the border or stopping at another rectangle.\n# To create the output, fill in the hollow grey rectangles with yellow.\n\ndef transform(input_grid):\n    # extract objects using grey as background\n    objects = find_connected_components(input_grid, background=Color.GREY, connectivity=4, monochromatic=True)\n\n    # create an output grid to store the result\n    output_grid = np.full(input_grid.shape, Color.GREY)\n\n    # for each object, fill it in if it is a rectangle\n    for obj in objects:\n        # to check if the object is a rectangle,\n        # we can check if the cropped object is entirely black\n        sprite = crop(obj, background=Color.GREY)\n        is_rectangle = np.all(sprite == Color.BLACK)\n\n        if is_rectangle:\n            # we also need to make sure the rectangle isn\u0027t caused from an emanating line.\n            # to do so, check for grey pixels around the border of the grey\n            # border adjacent to a corner (aka the x/y value is one less than the max)\n            border = object_neighbors(obj, background=Color.GREY, connectivity=8)\n            # to get the border of the border, make a copy,\n            # add yellow where the border is,\n            # then find the border of this new object\n            obj2 = obj.copy()\n            obj2[border] = Color.YELLOW\n            border2 = object_neighbors(obj2, background=Color.GREY, connectivity=8)\n            x, y, w, h = bounding_box(obj2, background=Color.GREY)\n\n            pixels_to_check = [\n                (x2, y2) for x2 in range(obj.shape[0]) for y2 in range(obj.shape[1])\n                if (border2[x2, y2]\n                    # check if pixel is adjacent to a corner\n                    and (x2 in [x, x + w-1] or y2 in [y, y + h-1]))\n            ]\n\n            if not any(input_grid[x, y] == Color.GREY for x, y in pixels_to_check):\n                # good rectangle!\n                # fill in the original object with yellow\n                obj[obj == Color.BLACK] = Color.YELLOW\n\n        blit_object(output_grid, obj, background=Color.GREY)\n\n    return output_grid\n\n\ndef generate_input():\n    # create a 10-20x10-20 black grid\n    # to make it possible to place rectangles that go offscreen,\n    n = np.random.randint(10, 21)\n    m = np.random.randint(10, 21)\n    n, m = 8, 8\n    # add a pixel of padding, which we will remove later\n    n += 1\n    m += 1\n    grid = np.full((n, m), Color.BLACK)\n\n    # add 2-4 grey rectangles with hollow insides\n    # each rectangle can be 3-7x3-7\n    # if we can\u0027t find a space, just stop adding new rectangles\n    # num_rectangles = np.random.randint(2, 5)\n    num_rectangles = 1\n\n    # store the rectangles so we can add lines to them later\n    rectangles = []\n    for _ in range(num_rectangles):\n        r_n = np.random.randint(3, 8)\n        r_m = np.random.randint(3, 8)\n        rectangle = np.full((r_n, r_m), Color.GREY)\n        try:\n            x, y = random_free_location_for_sprite(grid, rectangle, padding=1)\n        except ValueError:\n            break\n\n        # make the rectangle hollow, but mark it yellow, so we don\u0027t place another rectangle inside of it.\n        # later we will convert yellow back to black\n        rectangle[1:-1, 1:-1] = Color.YELLOW\n        blit(grid, rectangle, x, y)\n        rectangles.append((rectangle, (x, y)))\n\n    # now draw 1-3 lines emanating from the rectangles\n    # a line from another rectangle might emanate into the rectangle, so check for existing lines before adding one\n    for rectangle, (x, y) in rectangles:\n        # num_lines = np.random.randint(1, 4)\n        num_lines = 0\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        indices = np.random.choice(len(directions), num_lines, replace=False)\n        directions = [directions[i] for i in indices]\n\n        for direction in directions:\n            # if there\u0027s already a line here, don\u0027t draw another one\n            # to check, look for grey pixel within 1 pixel of the rectangle\n            w, h = rectangle.shape\n\n            bordering_pixels = find_bordering_pixels_in_direction(x, y, w, h, direction)\n            bordering_pixels = np.array([(x, y) for x, y in bordering_pixels if 0 \u003c= x \u003c n and 0 \u003c= y \u003c m])\n            if len(bordering_pixels) == 0:\n                continue\n\n            if any(grid[x, y] == Color.GREY for x, y in bordering_pixels):\n                continue\n\n            # now draw a line emanating outwards at a random bordering pixel\n            # ignore the extreme most bordering pixels (assumes they are returned in order)\n            bordering_pixels = bordering_pixels[1:-1]\n\n            ix = np.random.choice(range(len(bordering_pixels)))\n            start_pixel = bordering_pixels[ix]\n            draw_line(grid, start_pixel[0], start_pixel[1], direction=direction, color=Color.GREY, stop_at_color=[Color.GREY])\n\n    # convert yellow back to black\n    grid[grid == Color.YELLOW] = Color.BLACK\n\n    # remove the pixel of padding\n    grid = grid[1:-1, 1:-1]\n\n    return grid\n\n\n\ndef find_bordering_pixels_in_direction(x, y, w, h, direction):\n    dx, dy = direction\n    if dx == 1:  # right\n        bordering_pixels = [(x + w, y + i) for i in range(h)]\n    elif dx == -1:  # left\n        bordering_pixels = [(x - 1, y + i) for i in range(h)]\n    elif dy == 1:  # down\n        bordering_pixels = [(x + i, y + h) for i in range(w)]\n    elif dy == -1:  # up\n        bordering_pixels = [(x + i, y - 1) for i in range(w)]\n\n    return np.array(bordering_pixels)", "images": {"test": {"input": "output/seeds/seed_examples/146/images/test_input.png", "output": "output/seeds/seed_examples/146/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/146/images/train_input_0.png", "output": "output/seeds/seed_examples/146/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/146/images/train_input_1.png", "output": "output/seeds/seed_examples/146/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/146/images/train_input_2.png", "output": "output/seeds/seed_examples/146/images/train_output_2.png"}]}, "index": 146, "seed": "e73095fd", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# repeated translation, indicator pixels, non-black background\n\n# description:\n# In the input you will see a non-black background with a black object and an indicator pixel touching it of a different color.\n# To make the output, repeatedly translate the black object in the direction of the indicator pixel and make the color of these repeated translations match the indicator.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input into the black object and the indicator pixel(s)\n    # 2. Determine the direction of translation\n    # 3. Put down recolored versions of the black object\n\n    # 1. Parse the input\n    # background is most common color\n    background = max(Color.ALL_COLORS, key=lambda color: np.sum(input_grid == color))\n    # REMEMBER: pass background to everything that needs it, because it isn\u0027t by default BLACK\n    objects = find_connected_components(input_grid, connectivity=8, background=background, monochromatic=True)\n    # indicators are single pixels\n    indicator_objects = [ obj for obj in objects if crop(obj, background=background).shape == (1,1) ]\n    # other objects are bigger than (1,1)\n    template_objects = [ obj for obj in objects if crop(obj, background=background).shape != (1,1) ]\n\n    # We draw on top of the output, so copy it\n    output_grid = input_grid.copy()\n\n    # Iterate over every template and indicator which are in contact\n    for template_obj in template_objects:\n        template_sprite = crop(template_obj, background=background)\n        for indicator_obj in indicator_objects:\n            if not contact(object1=template_obj, object2=indicator_obj, background=background, connectivity=8): continue\n\n            # 2. Determine the direction of translation\n            indicator_x, indicator_y = object_position(indicator_obj, background=background, anchor=\"center\")\n            template_x, template_y = object_position(template_obj, background=background, anchor=\"center\")\n\n            dx, dy = np.sign(indicator_x - template_x), np.sign(indicator_y - template_y)\n            # Figure out the stride the translation, which is as far as we can go while still covering the indicator pixel\n            possible_strides = [ stride for stride in range(1, max(output_grid.shape))\n                                if collision(object1=indicator_obj, object2=template_obj, x2=stride*dx, y2=stride*dy, background=background) ]\n            stride = max(possible_strides)\n\n            # 3. Put down recolored versions of the black object as much as we can until we fall out of the canvas\n            # Prepare a new version of the sprite\n            new_color = object_colors(indicator_obj, background=background)[0]\n            recolored_template_sprite = template_sprite.copy()\n            recolored_template_sprite[recolored_template_sprite != background] = new_color\n\n            # Put down the recolored sprite at every stride\n            for i in range(1, 10):\n                old_x, old_y = object_position(template_obj, background=background, anchor=\"upper left\")\n                new_x, new_y = old_x + i*dx*stride, old_y + i*dy*stride\n                blit_sprite(output_grid, recolored_template_sprite, new_x, new_y, background=background)\n    \n    return output_grid\n\ndef generate_input():\n    # Make a grid with a grey horizontal rectangle stretching all the way through the middle, and some scattered points around it\n    # Then randomly rotate to get a variety of orientations\n\n    background_color, indicator_color = np.random.choice(Color.ALL_COLORS, size=2, replace=False)\n    template_color = Color.BLACK\n\n    width, height = np.random.randint(10, 25), np.random.randint(10, 25)\n    grid = np.full((width, height), background_color)\n\n    template_sprite = random_sprite(range(3,6), range(3,6), color_palette=[template_color], background=background_color)\n\n    # place the template sprite randomly in the grid\n    x, y = random_free_location_for_sprite(grid, template_sprite, background=background_color)\n    blit_sprite(grid, template_sprite, x, y, background=background_color)\n\n    # figure out a direction/stride that works\n    indicator_sprite = np.full((1,1), indicator_color)\n    dx, dy = 1, 1 # randomly rotate at the end to get a variety of orientations\n    possible_strides = [ stride for stride in range(1, max(grid.shape))\n                        if contact(object1=grid, object2=indicator_sprite, x2=x+stride*dx, y2=y+stride*dy, background=background_color) ]\n    stride = max(possible_strides)\n\n    # Put down the indicator pixel\n    blit_sprite(grid, indicator_sprite, x+stride*dx, y+stride*dy, background=background_color)\n    \n    # random rotation to get a variety of orientations\n    grid = np.rot90(grid, np.random.randint(0, 4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/147/images/test_input.png", "output": "output/seeds/seed_examples/147/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/147/images/train_input_0.png", "output": "output/seeds/seed_examples/147/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/147/images/train_input_1.png", "output": "output/seeds/seed_examples/147/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/147/images/train_input_2.png", "output": "output/seeds/seed_examples/147/images/train_output_2.png"}]}, "index": 147, "seed": "e8dc4411", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# object detection, pattern drawing\n\n# description:\n# In the input you will see two blue pixels\n# To make the output grid, you should place a 3x3 green cross pattern between the two blue pixels exactly halfway between them.\n\ndef transform(input_grid):\n    # Detect the two blue pixels on the grid.\n    blue_pixels = detect_objects(grid=input_grid, colors=[Color.BLUE], monochromatic=True, connectivity=4)\n    first_pixel, second_pixel = blue_pixels[0], blue_pixels[1]\n\n    # Find the midpoint\n    first_x, first_y = object_position(first_pixel, background=Color.BLACK, anchor=\"center\")\n    second_x, second_y = object_position(second_pixel, background=Color.BLACK, anchor=\"center\")\n    mid_x, mid_y = int((first_x + second_x) / 2), int((first_y + second_y) / 2)\n\n    # Generate the 3x3 green cross pattern between the two blue pixels.\n    green_cross_sprite = np.array( [[Color.BLACK, Color.GREEN, Color.BLACK],\n                                [Color.GREEN, Color.GREEN, Color.GREEN],\n                                [Color.BLACK, Color.GREEN, Color.BLACK]])\n    output_grid = input_grid.copy()\n    green_cross_width, green_cross_height = 3, 3\n\n    # Put the cross centered at the midpoint\n    upper_left_x = mid_x - green_cross_width // 2\n    upper_left_y = mid_y - green_cross_height // 2\n    blit_sprite(output_grid, green_cross_sprite, x=upper_left_x, y=upper_left_y, background=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x m.\n    grid_len = np.random.randint(10, 15)\n    n, m = grid_len, grid_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Randomly choose if the two blue pixels are horizontal or vertical.\n    if_horizontal  = np.random.choice([True, False])\n\n    # Randomly place two blue pixels on the grid and ensure a 3x3 green cross pattern can be placed in the middle of them.\n    line_interval = random.choice(range(1, 4))\n    line_width = 3 + line_interval * 2\n\n    while(line_width + 2 \u003e grid_len):\n        line_interval = random.choice(range(1, 4))\n        line_width = 3 + line_interval * 2\n\n    # Ensure there is enough space for the 3 x 3 green cross pattern and two blue pixels.\n    if if_horizontal:\n        x = np.random.randint(0, n - line_width - 1)\n        y = np.random.randint(1, m - 1)\n        grid[x, y] = Color.BLUE\n        grid[x + line_width + 1, y] = Color.BLUE\n    else:\n        x = np.random.randint(1, n - 1)\n        y = np.random.randint(0, m - line_width - 1)\n        grid[x, y] = Color.BLUE\n        grid[x, y + line_width + 1] = Color.BLUE\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/148/images/test_input.png", "output": "output/seeds/seed_examples/148/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/148/images/train_input_0.png", "output": "output/seeds/seed_examples/148/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/148/images/train_input_1.png", "output": "output/seeds/seed_examples/148/images/train_output_1.png"}]}, "index": 148, "seed": "e9614598", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# non-black background, diagonal lines\n\n# description:\n# In the input you will see a grid there\u0027s all the same color except for a single black pixel in the middle. Equivalently, a black pixel on a non-black background.\n# To make the output, draw black diagonal lines outward from the single black pixel in all 4 diagonal directions.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the black pixel\n    # 2. Draw diagonal lines outward from the black pixel\n\n    # Find the possible locations that are black, then check that there is exactly one\n    black_pixel_locations = np.argwhere(input_grid == Color.BLACK)\n    assert len(black_pixel_locations) == 1\n    black_pixel_location = black_pixel_locations[0]\n    black_x, black_y = black_pixel_location\n\n    # We are going to draw on top of the input grid\n    output_grid = input_grid.copy()\n\n    # Draw the diagonal lines\n    for dx, dy in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n        direction = (dx, dy)\n        draw_line(output_grid, black_x, black_y, direction=direction, color=Color.BLACK)\n\n    return output_grid\n\ndef generate_input():\n    # Make a grid with a random background color (not black)\n    background_color = np.random.choice(Color.NOT_BLACK)\n    width, height = np.random.randint(3, 30, size=2)\n    input_grid = np.full((width, height), background_color)\n\n    # Place a black pixel in the middle\n    input_grid[width // 2, height // 2] = Color.BLACK\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/149/images/test_input.png", "output": "output/seeds/seed_examples/149/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/149/images/train_input_0.png", "output": "output/seeds/seed_examples/149/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/149/images/train_input_1.png", "output": "output/seeds/seed_examples/149/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/149/images/train_input_2.png", "output": "output/seeds/seed_examples/149/images/train_output_2.png"}]}, "index": 149, "seed": "ea786f4a", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pattern generation, flipping\n\n# description:\n# In the input you will see a grid with wave patterns.\n# To make the output, you should flip the input grid horizontally and place it in the output grid.\n# And then place the flipped input grid in the output grid again.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Create output grid\n    # 2. Flip the input grid horizontally and put it in the output repeatedly\n\n    # 1. Create output grid\n    input_width, input_height = input_grid.shape\n    # The output grid is placing and flipping the original pattern 4 times\n    output_width, output_height = input_width, (input_height - 1) * 4 + 1\n    output_grid = np.full((output_width, output_height), Color.BLACK)\n\n    # 2. Make the output by flipping the input and ultimately putting 4 copies (some flipped) into the output\n    # Flip the input grid horizontally\n    flipped_input = np.fliplr(input_grid)\n\n    # Place the input and flipped input in the output grid\n    blit_sprite(output_grid, input_grid, x=0, y=0)\n    blit_sprite(output_grid, flipped_input, x=0, y=input_height - 1)\n    blit_sprite(output_grid, input_grid, x=0, y=2 * (input_height - 1))\n    blit_sprite(output_grid, flipped_input, x=0, y=3 * (input_height - 1))\n\n    return output_grid\n\ndef generate_input():\n    # randomly select pattern number and pattern hight\n    pattern_num = np.random.randint(3, 5)\n    pattern_height = np.random.randint(3, 5)\n\n    # Each pattern is 5 pixels wide\n    width, height = pattern_num * 4 + 1, pattern_height\n    grid = np.full((width, height), Color.BLACK)\n\n    # Draw the pattern, which looks like a wave\n    color = np.random.choice(Color.NOT_BLACK)\n    for x in range(0, width, 4):\n        grid[x, -1] = color\n    for x in range(2, width, 4):\n        grid[x, 0] = color\n    for x in range(1, width, 2):\n        draw_line(grid, x=x, y=1, end_x=x, end_y=height-2, color=color, direction=(0, 1))\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/150/images/test_input.png", "output": "output/seeds/seed_examples/150/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/150/images/train_input_0.png", "output": "output/seeds/seed_examples/150/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/150/images/train_input_1.png", "output": "output/seeds/seed_examples/150/images/train_output_1.png"}]}, "index": 150, "seed": "eb281b96", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# downscaling, nesting\n\n# description:\n# In the input you will see a grid consisting of nested shapes of different colors.\n# To make the output, make a grid with one pixel for each layer of the shapes, \n# with the color from outermost layer to the innermost layer in the same order they appear in the input.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Parse the input into objects and order them from outermost to innermost by area\n    # 2. Draw nested rectangles with the colors of the input objects, each layer has only one pixel length\n\n    # 1. input parsing\n    # Find the objects in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=True, background=Color.BLACK)\n\n    # Sort the objects from outermost to innermost, using area to determine the order\n    objects.sort(key=lambda obj: crop(obj).shape[0] * crop(obj).shape[1], reverse=True)\n\n    # 2. drawing the output\n    # Leave only one layer of each color shape\n    grid_len = len(objects) * 2 - 1\n    output_grid = np.full((grid_len, grid_len), Color.BLACK)\n\n    # Calculate each layer\u0027s length, which starts at the outermost layer\n    current_len = grid_len\n\n    # Draw nested shapes with the colors of the input objects. Each layer has only one pixel length of the current color\n    for i, object in enumerate(objects):\n        # Get the color of the current layer\n        color = object_colors(object)[0]\n        # Fill the region with the current color\n        cur_shape = np.full((current_len, current_len), color)\n        # Place the current shape in the output grid\n        # Make sure each layer has only one pixel length of the current color\n        blit_sprite(output_grid, sprite=cur_shape, x=i, y=i)\n        current_len -= 2\n\n    return output_grid\n\ndef generate_input():\n    # Get the number of colors\n    n_colors = random.randint(2, 6)\n    colors = np.random.choice(Color.NOT_BLACK, n_colors, replace=False)\n\n    # Get the innermost shape dimensions\n    cur_width, cur_height = np.random.randint(3, 6), np.random.randint(3, 6)\n    \n    # Draw a nested shape with the colors\n    previous_shape = None\n    for color in colors:\n        # Fill the current shape with the current color\n        cur_shape = np.full((cur_width, cur_height), color)\n        if previous_shape is not None:\n            # Place the previous shape in a random location in the current shape\n            x, y = random_free_location_for_sprite(grid=cur_shape, sprite=previous_shape, background=color, border_size=1)\n            blit_sprite(grid=cur_shape, sprite=previous_shape, x=x, y=y, background=color)\n\n        # Update the previous shape\n        previous_shape = cur_shape\n        \n        # Update the dimensions of the next shape, should be larger than the previous shape\n        next_layer_width, next_layer_height = np.random.randint(cur_width + 2, cur_width + 6), np.random.randint(cur_height + 2, cur_height + 6)\n        cur_width, cur_height = next_layer_width, next_layer_height\n    \n    # The final shape is the last shape with all inner shapes inside each other\n    grid = cur_shape\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/151/images/test_input.png", "output": "output/seeds/seed_examples/151/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/151/images/train_input_0.png", "output": "output/seeds/seed_examples/151/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/151/images/train_input_1.png", "output": "output/seeds/seed_examples/151/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/151/images/train_input_2.png", "output": "output/seeds/seed_examples/151/images/train_output_2.png"}]}, "index": 151, "seed": "eb5a1d5d", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# magnetism, direction, lines\n\n# description:\n# In the input, you will see a black grid with teal pixels scattered along one edge and red pixels scattered along an edge perpendicular to the teal one.\n# To make the output, make the teal pixels flow from the edge they are on to the opposite edge. Whenever there is a red pixel in the same column or row as the flow of teal pixels, push the teal pixel\u0027s flow one pixel away from the red pixel.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = np.copy(input_grid)\n\n    # figure out which edges the red and teal pixels are on and decide the direction of flow and push based on that\n    top = output_grid[:,0]\n    bottom = output_grid[:, -1]\n    left = output_grid[0, :]\n    if Color.RED in top:\n        # push the teal pixels down\n        push = (0, 1)\n\n        # teal can only be on the left or right edge if red is on the top edge\n        if Color.TEAL in left:\n            flow = (1, 0) # flow right\n        else:\n            flow = (-1, 0) # flow left    \n    elif Color.RED in bottom:\n        # push the teal pixels up\n        push = (0, -1)\n\n        # teal can only be on the left or right edge if red is on the bottom edge\n        if Color.TEAL in left:\n            flow = (1, 0) # flow right\n        else:\n            flow = (-1, 0) # flow left\n    elif Color.RED in left:\n        # push the teal pixels to the right\n        push = (1, 0)\n\n        # teal can only be on the top or bottom edge if red is on the left edge\n        if Color.TEAL in top:\n            flow = (0, 1) # flow down\n        else:\n            flow = (0, -1) # flow up\n    else: # red is on the right edge\n        # push the teal pixels to the left\n        push = (-1, 0)\n        \n        # teal can only be on the top or bottom edge if red is on the right edge\n        if Color.TEAL in top:\n            flow = (0, 1) # flow down\n        else:\n            flow = (0, -1) # flow up\n\n    # find the coordinates of the teal and red pixels\n    teal = np.where(input_grid == Color.TEAL)\n    red = np.where(input_grid == Color.RED)\n\n    # draw the flow of teal pixels\n    for i in range(len(teal[0])):\n        # start at a teal pixel\n        x, y = teal[0][i], teal[1][i]\n\n        # draw across the grid one pixel at a time adjusting for red pixel effects\n        while x \u003e= 0 and x \u003c output_grid.shape[0] and y \u003e= 0 and y \u003c output_grid.shape[1]:\n            # push the teal pixel away from the red pixel if it is in the same row or column\n            if x in red[0] or y in red[1]:\n                x += push[0]\n                y += push[1]\n\n                # stop this flow if it goes off the grid\n                if x \u003c 0 or x \u003e= output_grid.shape[0] or y \u003c 0 or y \u003e= output_grid.shape[1]:\n                    break\n                \n            # draw a teal pixel in the flow\n            output_grid[x, y] = Color.TEAL\n\n            # move the flow one pixel in the direction of flow\n            x += flow[0]\n            y += flow[1]\n\n    return output_grid\n\n\ndef generate_input():\n    # make a black grid as the background\n    n = np.random.randint(10, 20)\n    m = np.random.randint(10, 20)\n    grid = np.zeros((n, m), dtype=int)\n\n    # select which edges will be teal and which will be red\n    top_or_bottom_color = np.random.choice([Color.TEAL, Color.RED])\n    left_or_right_color = Color.TEAL if top_or_bottom_color == Color.RED else Color.RED\n\n    # make a random vector of length m for the top or bottom edge of the grid\n    top_or_bottom = np.zeros(m, dtype=int)\n\n    # scatter the selected color anywhere along the vector except the ends\n    top_or_bottom[np.random.choice(range(1, m-1), np.random.randint(2, 5), replace=False)] = top_or_bottom_color\n    \n    # make a random vector of length n for the left or right edge of the grid\n    left_or_right = np.zeros(n, dtype=int)\n\n    # scatter the selected color anywhere along the vector except the ends\n    left_or_right[np.random.choice(range(1, n-1), np.random.randint(2, 5), replace=False)] = left_or_right_color\n\n    # randomly put the top_or_bottom vector on the top or bottom of the grid\n    if np.random.rand() \u003c 0.5:\n        grid[0] = top_or_bottom\n    else:\n        grid[-1] = top_or_bottom\n    \n    # randomly put the left_or_right vector on the left or right of the grid\n    if np.random.rand() \u003c 0.5:\n        grid[:,0] = left_or_right\n    else:\n        grid[:,-1] = left_or_right\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/152/images/test_input.png", "output": "output/seeds/seed_examples/152/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/152/images/train_input_0.png", "output": "output/seeds/seed_examples/152/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/152/images/train_input_1.png", "output": "output/seeds/seed_examples/152/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/152/images/train_input_2.png", "output": "output/seeds/seed_examples/152/images/train_output_2.png"}]}, "index": 152, "seed": "f15e1fac", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry, mirror\n\n# description:\n# In the input you will see two patterns close by two frames.\n# To make the output, you need to split the inner pattern into two parts by the symmetry of the framework. \n# Then, mirror the two parts according to each frame\u0027s line and place them in the output grid.\n\ndef transform(input_grid):\n    # Extract the framework\n    frame_color = Color.RED\n\n    # Create an empty grid\n    n, m = input_grid.shape\n    output_grid = np.zeros((n, m), dtype=int)\n\n    # Get two frame that form the framework\n    frames = find_connected_components(grid=input_grid, connectivity=4)\n    frames = [frame for frame in frames if np.any(frame == frame_color)]\n    framework = []\n    for frame in frames:\n        # Get the frame and its position\n        x, y, w, h = bounding_box(grid=frame)\n        cropped_frame = crop(grid=frame)\n        framework.append({\"x\": x, \"y\": y, \"w\": w, \"h\": h, \"frame\": cropped_frame})\n        # Place the frame in the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=cropped_frame, x=x, y=y)\n\n    # Sort the framework by position\n    framework = sorted(framework, key=lambda x: x[\"x\"])\n    framework = sorted(framework, key=lambda x: x[\"y\"])\n\n    # Get the inner pattern\n    x_whole, y_whole, w_whole, h_whole = bounding_box(grid=input_grid)\n    inner_pattern = input_grid[x_whole + 1 : x_whole + w_whole - 1, y_whole + 1 : y_whole + h_whole - 1]\n\n    # Check if the framework is horizontal or vertical\n    if_horizontal = framework[0][\"w\"] \u003e framework[0][\"h\"]\n\n    if if_horizontal:\n        # Split the inner pattern into two parts by the symmetry of the framework\n        pattern_len = inner_pattern.shape[1] // 2\n        pattern_part1 = inner_pattern[:, : pattern_len]\n        pattern_part2 = inner_pattern[:, pattern_len:]\n\n        # Mirror the two inner patterns according to each frame\u0027s line\n        pattern_part1 = np.fliplr(pattern_part1)\n        pattern_part2 = np.fliplr(pattern_part2)\n\n        # Place the two inner patterns in the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=pattern_part1, x=framework[0][\u0027x\u0027] + 1, y=framework[0][\u0027y\u0027] - pattern_len)\n        output_grid = blit_sprite(grid=output_grid, sprite=pattern_part2, x=framework[1][\u0027x\u0027] + 1, y=framework[1][\u0027y\u0027] + 2)\n    else:\n        # Split the inner pattern into two parts by the symmetry of the framework\n        pattern_len = inner_pattern.shape[0] // 2\n        pattern_part1 = inner_pattern[: pattern_len, :]\n        pattern_part2 = inner_pattern[pattern_len:, :]\n\n        # Mirror the two inner patterns according to each frame\u0027s line\n        pattern_part1 = np.flipud(pattern_part1)\n        pattern_part2 = np.flipud(pattern_part2)\n\n        # Place the two inner patterns in the output grid\n        output_grid = blit_sprite(grid=output_grid, sprite=pattern_part1, x=framework[0][\u0027x\u0027] - pattern_len, y=framework[0][\u0027y\u0027] + 1)\n        output_grid = blit_sprite(grid=output_grid, sprite=pattern_part2, x=framework[1][\u0027x\u0027] + 2, y=framework[1][\u0027y\u0027] + 1)\n\n    return output_grid\n\ndef generate_input():\n    # Create a 2D background\n    n, m = np.random.randint(15, 30), np.random.randint(15, 30)\n    grid = np.zeros((n, m), dtype=int)\n\n    # Get a framework for pattern\n    frame_length = np.random.randint(5, 10)\n    frame_width = 2\n    frame_color = Color.RED\n\n    # Draw a half of the framework\n    frame = np.zeros((frame_length, frame_width), dtype=int)\n    frame = draw_line(grid=frame, x=0, y=0, direction=(1, 0), color=frame_color)\n    frame[0][1] = frame_color\n    frame[-1][1] = frame_color\n\n    # Select the interval for two half frameworks that form one entire framework\n    frame_interval = 4\n    \n    # Calculate the sizes of two patterns in framwork\n    pattern_color = Color.GRAY\n    pattern_interval = 1\n    pattern_length = frame_length - 2\n    pattern_width_1 = frame_interval // 2\n    pattern_width_2 = frame_interval - pattern_width_1 - pattern_interval\n\n    # Generate two patterns in framwork\n    pattern_1 = random_sprite(n=pattern_length, m=pattern_width_1, color_palette=[pattern_color])\n    pattern_2 = random_sprite(n=pattern_length, m=pattern_width_2, color_palette=[pattern_color])\n\n    # place the pattern in the frame\n    whole_frame = np.zeros((frame_length, frame_width * 2 + frame_interval), dtype=int)\n    # Place the upper half of the frame\n    whole_frame = blit_sprite(grid=whole_frame, sprite=frame, x=0, y=0)\n    # Place the upper pattern\n    whole_frame = blit_sprite(grid=whole_frame, sprite=pattern_1, x=1, y=frame_width)\n    # Place the lower pattern\n    whole_frame = blit_sprite(grid=whole_frame, sprite=pattern_2, x=1, y=frame_width + pattern_width_1 + pattern_interval)\n    # Place the lower half of the frame\n    whole_frame = blit_sprite(grid=whole_frame, sprite=np.fliplr(frame), x=0, y=frame_width + pattern_width_1 + pattern_interval + pattern_width_2)\n\n    # place the frame in the background\n    x, y = random_free_location_for_sprite(grid=grid, sprite=whole_frame)\n    grid = blit_sprite(grid=grid, sprite=whole_frame, x=x, y=y)\n\n    # Randomly rotate the grid\n    grid = np.rot90(grid, k=np.random.randint(4))\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/153/images/test_input.png", "output": "output/seeds/seed_examples/153/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/153/images/train_input_0.png", "output": "output/seeds/seed_examples/153/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/153/images/train_input_1.png", "output": "output/seeds/seed_examples/153/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/153/images/train_input_2.png", "output": "output/seeds/seed_examples/153/images/train_output_2.png"}]}, "index": 153, "seed": "f8a8fe49", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# rectangular cells, counting\n\n# description:\n# In the input you will see monochromatic rectangles arranged into an array.\n# To make the output, find the most common color of the 2x1 rectangles, second most common color, etc.\n# Then, make the output a vertical stripe colored with the second common color, then the third most common color, etc., starting at the top, and skipping the most common color.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Extract the objects, arranged into the array\n    # 2. Count the colors\n    # 3. Sort the colors by count\n    # 4. Create the output grid, remembering to skip the most common color\n\n    background = Color.BLACK\n    \n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=4, background=background)\n    possible_x_values = [ object_position(obj, background=background, anchor=\"upper left\")[0] for obj in objects ]\n    possible_y_values = [ object_position(obj, background=background, anchor=\"upper left\")[1] for obj in objects ]\n    object_array = [ [ next(obj for obj in objects if (x, y) == object_position(obj, background=background, anchor=\"upper left\") )\n                      for y in sorted(set(possible_y_values)) ]\n                    for x in sorted(set(possible_x_values)) ]\n\n    # Extract and count the colors\n    object_colors = [ obj[obj!=background][0] for obj in objects ]\n    color_counts = { color: sum(1 for object_color in object_colors if object_color == color) for color in set(object_colors) }\n\n    sorted_colors = list(sorted(color_counts, key=lambda color: color_counts[color], reverse=True))\n    # skip the most common color\n    sorted_colors = sorted_colors[1:]\n\n    # the output is a vertical stripe containing one pixel per color\n    output_grid = np.full((1, len(sorted_colors)), background)\n    for y, color in enumerate(sorted_colors):\n        output_grid[0, y] = color\n\n    return output_grid\n\n\n\n\ndef generate_input():\n    # Plan:\n    # 1. randomly pick size and possible colors for the rectangles\n    # 2. randomly pick how far apart the rectangle should be when they are arranged in an array\n    # 3. create the array of rectangles, randomly choosing colors\n    # 5. double check that no two colors have the exact same count\n\n    rectangle_dimensions = np.random.randint(1, 4, size=(2))\n    number_of_distinct_colors = np.random.randint(3, 6)\n    rectangle_colors = np.random.choice(Color.NOT_BLACK, size=(number_of_distinct_colors), replace=False)\n\n    rectangle_spacing = np.random.randint(1, 4, size=(2))\n    grid_dimensions = np.random.randint(10, 30, size=(2))\n\n    grid = np.full(grid_dimensions, Color.BLACK)\n\n    possible_x_values = np.arange(rectangle_spacing[0], grid_dimensions[0] - rectangle_dimensions[0], rectangle_spacing[0] + rectangle_dimensions[0])\n    possible_y_values = np.arange(rectangle_spacing[1], grid_dimensions[1] - rectangle_dimensions[1], rectangle_spacing[1] + rectangle_dimensions[1])\n    for x in possible_x_values:\n        for y in possible_y_values:\n            color = np.random.choice(rectangle_colors)\n            sprite = random_sprite(rectangle_dimensions[0], rectangle_dimensions[1], density=1, color_palette=[color])\n            blit_sprite(grid, sprite, x, y)\n\n    # doublecheck that no pair of colors have the same count\n    for color1 in rectangle_colors:\n        for color2 in rectangle_colors:\n            if color1 == color2:\n                continue\n            count1 = sum(1 for color in grid.flatten() if color == color1)\n            count2 = sum(1 for color in grid.flatten() if color == color2)\n            assert count1 != count2\n    \n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/154/images/test_input.png", "output": "output/seeds/seed_examples/154/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/154/images/train_input_0.png", "output": "output/seeds/seed_examples/154/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/154/images/train_input_1.png", "output": "output/seeds/seed_examples/154/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/154/images/train_input_2.png", "output": "output/seeds/seed_examples/154/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/154/images/train_input_3.png", "output": "output/seeds/seed_examples/154/images/train_output_3.png"}]}, "index": 154, "seed": "f8b3ba0a", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# symmetry detection, occlusion\n\n# description:\n# In the input you will see a translationally symmetric pattern that has been partially occluded by a black rectangle\n# The output should be what the black rectangle should be in order to make it perfectly symmetric.\n# In other words, the output should be the missing part of the pattern, and it should be the same dimensions as the black rectangle.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the black rectangle\n    # 2. Find the symmetry\n    # 3. Fill in the missing part\n    # 4. Extract the part that you filled in, which is the final output\n\n    # Find the black rectangle and save where it is\n    # Do this first because we will need to know where it was after we fill it in\n    occlusion_color = Color.BLACK\n    black_rectangle_mask = (input_grid == occlusion_color)\n\n    # Find the symmetry. Notice that black is not the background, but instead is the occlusion color. In fact there is no well-defined background color.\n    symmetries = detect_translational_symmetry(input_grid, ignore_colors=[occlusion_color], background=None)\n\n    # Fill in the missing part\n    for occluded_x, occluded_y in np.argwhere(black_rectangle_mask):\n        for symmetric_x, symmetric_y in orbit(input_grid, occluded_x, occluded_y, symmetries):\n            if input_grid[symmetric_x, symmetric_y] != occlusion_color:\n                input_grid[occluded_x, occluded_y] = input_grid[symmetric_x, symmetric_y]\n                break\n    \n    # Extract the region that we filled in, ultimately as a 2D sprite\n    # first, get just the part of the final image which corresponds to what used to be included\n    filled_in_region = np.full_like(input_grid, occlusion_color)\n    filled_in_region[black_rectangle_mask] = input_grid[black_rectangle_mask]\n    # then, crop it to obtain the sprite\n    filled_in_region = crop(filled_in_region, background=occlusion_color)\n\n    return filled_in_region\n    \n\n\ndef generate_input():\n    # Plan:\n    # 1. Make a random sprite\n    # 2. Tile it to make a symmetric pattern\n    # 3. Occlude it with a black rectangle\n\n    # Make a random sprite\n    w, h = np.random.randint(2, 5, size=(2))\n    sprite = random_sprite(w, h, color_palette=Color.NOT_BLACK, density=1)\n\n    # Tile it to make a symmetric pattern\n    horizontal_repetitions, vertical_repetitions = np.random.randint(2, 5, size=(2))\n    pattern = np.tile(sprite, (horizontal_repetitions, vertical_repetitions))\n\n    # Occlude it with a randomly placed black rectangle\n    w_occluder, h_occluder = np.random.randint(2, 5, size=(2))\n    x_occluder, y_occluder = np.random.randint(0, pattern.shape[0] - w_occluder + 1), np.random.randint(0, pattern.shape[1] - h_occluder + 1)\n    black_rectangle_sprite = np.full((w_occluder, h_occluder), Color.BLACK)\n    blit_sprite(pattern, black_rectangle_sprite, x_occluder, y_occluder, background=None)\n\n    return pattern", "images": {"test": {"input": "output/seeds/seed_examples/155/images/test_input.png", "output": "output/seeds/seed_examples/155/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/155/images/train_input_0.png", "output": "output/seeds/seed_examples/155/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/155/images/train_input_1.png", "output": "output/seeds/seed_examples/155/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/155/images/train_input_2.png", "output": "output/seeds/seed_examples/155/images/train_output_2.png"}]}, "index": 155, "seed": "f9012d9b", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting\n\n# description:\n# In the input, you will see a 10x10 black grid containing a few 2x2 squares. Each square contains 1-4 colors.\n# To create the output, draw a green 2xL rectangle just below each 2x2 square, where L is the number of colors in the square.\n\ndef transform(input_grid):\n    # copy the input grid to the output grid\n    output_grid = input_grid.copy()\n    # find all connected components in the input grid\n    objects = find_connected_components(input_grid, connectivity=4, monochromatic=False)\n\n    # for each object, draw a green rectangle below it of shape 2xL, where L is the number of colors in the square\n    for obj in objects:\n        obj_x, obj_y, obj_width, obj_height = bounding_box(obj, background=Color.BLACK)\n        num_colors = len(np.unique(obj[obj != Color.BLACK]))\n        green_rectangle = np.full((obj_width, num_colors), Color.GREEN)\n        blit_sprite(output_grid, green_rectangle, obj_x, obj_y + obj_height, background=Color.BLACK)\n\n    return output_grid\n\n\ndef generate_input():\n    input_grid = np.full((10, 10), Color.BLACK)\n    num_squares = np.random.randint(1, 5)\n    for _ in range(num_squares):\n        square = random_sprite(2, 2, density=1.0, color_palette=Color.NOT_BLACK)\n        x, y = random_free_location_for_sprite(input_grid, square, padding=1)\n        input_grid = blit_sprite(input_grid, square, x, y, background=Color.BLACK)\n\n    return input_grid", "images": {"test": {"input": "output/seeds/seed_examples/156/images/test_input.png", "output": "output/seeds/seed_examples/156/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/156/images/train_input_0.png", "output": "output/seeds/seed_examples/156/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/156/images/train_input_1.png", "output": "output/seeds/seed_examples/156/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/156/images/train_input_2.png", "output": "output/seeds/seed_examples/156/images/train_output_2.png"}]}, "index": 156, "seed": "fcc82909", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# pixel patterns, counting, expanding, diagonal lines\n\n# description:\n# In the input you will see a line with several colored pixels.\n# To make the output, create a square grid and place the input line at the bottom-left. Each colored pixel shoots a diagonal line outward toward the upper right.\n# The length of the output grid is the product of the number of colored input pixels and the length of the input line.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Figure out how big the output should be and make a blank output grid\n    # 2. Place the input line at the bottom left of the output grid\n    # 3. Repeatedly translate it diagonally toward the upper right corner, equivalently shooting diagonal lines from each colored pixel\n\n    # 1. The output grid size is the number of non-black pixels in the input grid times the original grid width\n    input_width, input_height = input_grid.shape\n    num_different_colors = sum(color in input_grid.flatten() for color in Color.NOT_BLACK )\n    output_size = input_width * num_different_colors\n    output_grid = np.full((output_size, output_size), Color.BLACK)\n\n    # 2-3. Place the input at the bottom left and then move it upward and rightward\n    bottommost_y = output_size - 1\n    for iteration in range(output_size):\n        blit_sprite(output_grid, input_grid, x=iteration, y=bottommost_y - iteration*input_height)\n\n    return output_grid\n\ndef generate_input():\n    # Generate a line\n    width = np.random.randint(3, 7)\n    height = 1\n    grid = np.full((width, height), Color.BLACK)\n\n    # Randomly choose colors for each grid\n    colors = np.random.choice(Color.NOT_BLACK, size=width, replace=False)\n    for x in range(width):\n        # Randomly assign a color to each pixel\n        if np.random.rand() \u003c 0.6:\n            grid[x, 0] = colors[x]\n\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/157/images/test_input.png", "output": "output/seeds/seed_examples/157/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/157/images/train_input_0.png", "output": "output/seeds/seed_examples/157/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/157/images/train_input_1.png", "output": "output/seeds/seed_examples/157/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/157/images/train_input_2.png", "output": "output/seeds/seed_examples/157/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/157/images/train_input_3.png", "output": "output/seeds/seed_examples/157/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/157/images/train_input_4.png", "output": "output/seeds/seed_examples/157/images/train_output_4.png"}]}, "index": 157, "seed": "feca6190", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# counting, object detection, alternating pattern\n\n# description:\n# In the input you will see several 2 x 2 red squares on the grid.\n# To make the output grid, you should count the number of red squares\n# Then place the same number of 1 x 1 blue squares on the output grid following this pattern in the output:\n# First fill the top row, then the next row, but skip every other column. Begin the first/third/fifth/etc row in the first column, but begin the second/forth/etc row in the second column.\n\ndef transform(input_grid):\n    # Detect all the 2 x 2 red squares on the grid.\n    red_square = detect_objects(grid=input_grid, colors=[Color.RED], monochromatic=True, connectivity=4)\n\n    # Count the number of 2 x 2 red squares.\n    num_red_square = len(red_square)\n\n    # Output grid is always 3 x 3.\n    output_grid = np.zeros((3, 3), dtype=int)\n\n    # Fill the output grid with red square number follow specific pattern sequence:\n    # 1. Fill the top row, then the next row, but skip every other column.\n    # 2. Begin the first/third/fifth/etc row in the first column, but begin the second/forth/etc row in the second column.\n    pos_list = []\n    for i in range(9):\n        if i % 2 == 0:\n            pos_list.append((i % 3, i // 3))\n\n    # Place the same number of 1 x 1 blue squares on the output grid follow the specific pattern sequence.\n    for i in range(num_red_square):\n        x, y = pos_list[i]\n        output_grid[x, y] = Color.BLUE\n        \n    return  output_grid\n\ndef generate_input():\n    # Generate the background grid with size of n x n.\n    square_len = np.random.randint(3, 10)\n    n, m = square_len, square_len\n    grid = np.zeros((n, m), dtype=int)\n\n    # Generate the 2 x 2 red squares on the grid.\n    square = random_sprite(n=2, m=2, color_palette=[Color.RED], density=1.0)\n\n    # Randomly choose the number of 2 x 2 red squares.\n    square_num = np.random.randint(1, 6)\n\n    # Place the 2 x 2 red squares on the grid.\n    for _ in range(square_num):\n        # Make sure there is enough space for the 2 x 2 red square.\n        try:\n            # Place the 2 x 2 red square on the grid.\n            # Make sure the red square is not too close to each other.\n            x, y = random_free_location_for_sprite(grid=grid, sprite=square, padding=1, padding_connectivity=4)\n            grid = blit_sprite(grid=grid, sprite=square, x=x, y=y)\n        except:\n            break\n    return grid", "images": {"test": {"input": "output/seeds/seed_examples/158/images/test_input.png", "output": "output/seeds/seed_examples/158/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/158/images/train_input_0.png", "output": "output/seeds/seed_examples/158/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/158/images/train_input_1.png", "output": "output/seeds/seed_examples/158/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/158/images/train_input_2.png", "output": "output/seeds/seed_examples/158/images/train_output_2.png"}, {"input": "output/seeds/seed_examples/158/images/train_input_3.png", "output": "output/seeds/seed_examples/158/images/train_output_3.png"}, {"input": "output/seeds/seed_examples/158/images/train_input_4.png", "output": "output/seeds/seed_examples/158/images/train_output_4.png"}, {"input": "output/seeds/seed_examples/158/images/train_input_5.png", "output": "output/seeds/seed_examples/158/images/train_output_5.png"}, {"input": "output/seeds/seed_examples/158/images/train_input_6.png", "output": "output/seeds/seed_examples/158/images/train_output_6.png"}, {"input": "output/seeds/seed_examples/158/images/train_input_7.png", "output": "output/seeds/seed_examples/158/images/train_output_7.png"}]}, "index": 158, "seed": "ff28f65a", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}, {"code": "from common import *\n\nimport numpy as np\nfrom typing import *\n\n# concepts:\n# triangle, infinite ray, color guide\n\n# description:\n# In the input you will see a pyramid with a flat base (possibly rotated), with a single special pixel inside of it that is a different color. The special pixel is centered in the base of the pyramid, opposite the tip of the pyramid.\n# To make the output, draw a line starting from the tip of the pyramid and extending outward infinitely (away from the pyramid). The color of the line is the color of the special pixel.\n\ndef transform(input_grid):\n    # Plan:\n    # 1. Find the special pixel and the pyramid\n    # 2. Find the tip of the pyramid, and which way it is pointing\n    # 3. Draw a line outward from the tip of the pyramid in the correct direction (away from the pyramid)\n\n    # 1. Find the special pixel and the triangle, and extract the color of the special pixel\n    objects = find_connected_components(input_grid, monochromatic=True, connectivity=8)\n    for obj in objects:\n        if np.count_nonzero(obj) == 1:\n            special_pixel = obj\n        else:\n            pyramid = obj\n    special_pixel_color = next(iter(set(special_pixel.flatten()) - {Color.BLACK}))\n\n    # 2. Find the tip of the pyramid, and which way it is pointing\n    # To do this, remember that the special pixel is opposite the tip of the pyramid (and centered on the base)\n    # Compute the vector from the special pixel to the centre of the pyramid, and go in that direction to find the tip\n    # Computing vector: Difference of center positions\n    special_x, special_y, special_w, special_h = bounding_box(special_pixel)\n    pyramid_x, pyramid_y, pyramid_w, pyramid_h = bounding_box(pyramid)\n    special_center_x, special_center_y = special_x + special_w / 2, special_y + special_h / 2\n    pyramid_center_x, pyramid_center_y = pyramid_x + pyramid_w / 2, pyramid_y + pyramid_h / 2\n    dx, dy = np.sign([pyramid_center_x - special_center_x, pyramid_center_y - special_center_y])\n    # make sure everything grid is ints\n    dx, dy = int(dx), int(dy)\n    # Move along the vector until we reach the end of the tip, at which point we are on the background (Color.BLACK)\n    tip_x, tip_y = special_x, special_y\n    while input_grid[tip_x, tip_y] != Color.BLACK:\n        tip_x += dx\n        tip_y += dy\n    \n    # 3. Draw a line outward from the tip of the pyramid in the correct direction (away from the pyramid)\n    # The line is the same color as the special pixel\n    output_grid = np.copy(input_grid)\n    draw_line(output_grid, tip_x, tip_y, length=None, direction=(dx, dy), color=special_pixel_color)\n\n    return output_grid\n\ndef generate_input():\n    # Make the pyramid by concatenating (horizontally) together two lower-diagonal matrices\n    pyramid_color = random.choice(Color.NOT_BLACK)\n    pyramid_height = np.random.randint(2, 6)\n    pyramid_width = 2 * pyramid_height - 1\n    pyramid = np.concatenate([np.tri(pyramid_height)[:, ::-1], # left half\n                              np.tri(pyramid_height).T[1:]], # right half\n                              axis=0) # horizontal (along X axis)\n    pyramid[pyramid != 0] = pyramid_color\n\n    # Make the special pixel\n    special_pixel_color = random.choice([ color for color in Color.NOT_BLACK if color != pyramid_color ])\n    special_y = pyramid_height - 1\n    special_x = pyramid_width // 2\n    pyramid[special_x, special_y] = special_pixel_color\n\n    # Randomly rotate the pyramid\n    rotated_pyramid = np.rot90(pyramid, np.random.randint(4))\n\n    # Make the output grid, ensuring it is large enough to contain the rotated pyramid\n    width, height = np.random.randint(rotated_pyramid.shape[0]+2, 20), np.random.randint(rotated_pyramid.shape[1]+2, 20)\n    output_grid = np.full((width, height), Color.BLACK)\n\n    # Place the pyramid in the output grid\n    x, y = random_free_location_for_sprite(output_grid, rotated_pyramid, border_size=1)\n    blit_sprite(output_grid, rotated_pyramid, x, y, background=Color.BLACK)\n\n    return output_grid", "images": {"test": {"input": "output/seeds/seed_examples/159/images/test_input.png", "output": "output/seeds/seed_examples/159/images/test_output.png"}, "train": [{"input": "output/seeds/seed_examples/159/images/train_input_0.png", "output": "output/seeds/seed_examples/159/images/train_output_0.png"}, {"input": "output/seeds/seed_examples/159/images/train_input_1.png", "output": "output/seeds/seed_examples/159/images/train_output_1.png"}, {"input": "output/seeds/seed_examples/159/images/train_input_2.png", "output": "output/seeds/seed_examples/159/images/train_output_2.png"}]}, "index": 159, "seed": "25d487eb", "source": "seed_examples", "source_description": "160 seeds problem from the ARC training dataset with human written generator and solution.", "source_display_name": "ARC Tasks", "total_examples": 160}];
        const sourceInfo = {
            seed_examples: {
                name: 'ARC Tasks',
                description: '160 seeds problem from the ARC training dataset with human written generator and solution.'
            }
        };

        let state = {
            currentSource: 'seed_examples',
            page: 0,
            loading: false,
            itemsPerPage: 12,
            shuffled: false,
            shuffledExamples: [],
            originalExamples: [],
            shuffleCount: 0,
            filteredExamples: null 
        };

        function addFilterIndicator(seedCount) {
            const nav = document.querySelector('.nav-group');
            const existingIndicator = document.getElementById('filterIndicator');
            if (!existingIndicator) {
                const indicator = document.createElement('div');
                indicator.id = 'filterIndicator';
                indicator.className = 'gradient-btn px-4 py-2 rounded-lg';
                indicator.innerHTML = `
                    <i class="fas fa-filter mr-2"></i>
                    <span>${seedCount} Seeds Selected</span>
                    <button class="ml-2 text-slate-400 hover:text-white" onclick="clearSeedFilter()">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                nav.appendChild(indicator);
            }
        }

        function handleSeedFilter() {
            const urlParams = new URLSearchParams(window.location.search);
            const seeds = urlParams.getAll('seeds');
            
            if (seeds.length > 0) {
                // Disable shuffle button
                const shuffleButton = document.getElementById('shuffleButton');
                const mobileShuffleButton = document.getElementById('mobileShuffleButton');
                
                if (shuffleButton) {
                    shuffleButton.disabled = true;
                    shuffleButton.style.opacity = '0.5';
                    shuffleButton.style.cursor = 'not-allowed';
                }
                
                if (mobileShuffleButton) {
                    mobileShuffleButton.disabled = true;
                    mobileShuffleButton.style.opacity = '0.5';
                    mobileShuffleButton.style.cursor = 'not-allowed';
                }
                
                // Rest of your existing handleSeedFilter code
                state.page = 0;
                ui.grid.innerHTML = '';
                
                const description = document.getElementById('descriptionText');
                if (description) {
                    description.textContent = `Filtering ${seeds.length} seeds`;
                }
                
                const filteredExamples = examples.filter(ex => seeds.includes(ex.seed));
                state.filteredExamples = filteredExamples;
                
                addFilterIndicator(seeds.length);
                
                const totalCount = document.getElementById('totalCount');
                if (totalCount) {
                    totalCount.textContent = filteredExamples.length;
                }
                
                loadMoreExamples();
            }
        }

        // Add reset filter functionality
        function addResetFilterButton() {
            let resetButton = document.getElementById('resetFilterButton');
            if (!resetButton) {
                const nav = document.querySelector('.nav-group');
                resetButton = document.createElement('button');
                resetButton.id = 'resetFilterButton';
                resetButton.className = 'gradient-btn px-4 py-2 rounded-lg';
                resetButton.innerHTML = `
                    <i class="fas fa-times mr-2"></i>
                    <span>Reset Filter</span>
                `;
                resetButton.onclick = clearSeedFilter;
                nav.appendChild(resetButton);
            }
        }

        function clearSeedFilter() {
            // Re-enable shuffle button
            const shuffleButton = document.getElementById('shuffleButton');
            const mobileShuffleButton = document.getElementById('mobileShuffleButton');
            
            if (shuffleButton) {
                shuffleButton.disabled = false;
                shuffleButton.style.opacity = '1';
                shuffleButton.style.cursor = 'pointer';
            }
            
            if (mobileShuffleButton) {
                mobileShuffleButton.disabled = false;
                mobileShuffleButton.style.opacity = '1';
                mobileShuffleButton.style.cursor = 'pointer';
            }
            
            // Rest of your existing clearSeedFilter code
            state.filteredExamples = null;
            state.page = 0;
            ui.grid.innerHTML = '';
            
            const indicator = document.getElementById('filterIndicator');
            if (indicator) {
                indicator.remove();
            }
            
            window.history.pushState({}, '', window.location.pathname);
            
            const description = document.getElementById('descriptionText');
            if (description) {
                description.textContent = sourceInfo[state.currentSource].description;
            }
            
            updateSourceInfo();
            loadMoreExamples();
        }

        // UI Components
        const ui = {
            grid: document.getElementById('examplesGrid'),
            loading: document.getElementById('loadingIndicator'),
            sourceSelect: document.getElementById('sourceSelector'),
            totalCount: document.getElementById('totalCount'),
            currentSource: document.getElementById('currentSource'),
            description: document.getElementById('descriptionText'),
            shuffleButton: document.getElementById('shuffleButton'),
            resetButton: document.getElementById('resetButton')
        };

        // Helper Functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            // Double shuffle for better randomization
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function getFilteredExamples() {
            let filtered = examples.filter(ex => ex.source === state.currentSource);
            
            // If we have filtered examples (from URL seeds), use those instead
            if (state.filteredExamples) {
                filtered = state.filteredExamples;
            }
            
            if (state.shuffled) {
                return state.shuffledExamples;
            }
            
            return filtered;
        }

        function handleShuffle() {
            state.shuffled = true;
            state.page = 0;
            state.shuffleCount++;
            ui.grid.innerHTML = '';
            
            if (state.shuffleCount === 1) {
                const filtered = examples.filter(ex => ex.source === state.currentSource);
                state.originalExamples = [...filtered];
            }
            
            state.shuffledExamples = shuffleArray(
                state.shuffleCount === 1 ? state.originalExamples : state.shuffledExamples
            );
            
            // Show reset button (both desktop and mobile)
            ui.resetButton.classList.remove('hidden');
            document.getElementById('mobileResetButton')?.classList.remove('hidden');
            
            // Add spin animation
            [ui.shuffleButton, document.getElementById('mobileShuffleButton')].forEach(button => {
                if (button) {
                    const icon = button.querySelector('i');
                    icon.classList.add('spin-animation');
                    setTimeout(() => icon.classList.remove('spin-animation'), 1000);
                }
            });
            
            loadMoreExamples();
        }

        function handleReset() {
            state.shuffled = false;
            state.page = 0;
            state.shuffleCount = 0;
            state.shuffledExamples = [];
            ui.grid.innerHTML = '';
            
            // Hide reset button (both desktop and mobile)
            ui.resetButton.classList.add('hidden');
            document.getElementById('mobileResetButton')?.classList.add('hidden');
            
            // Add spin animation
            [ui.resetButton, document.getElementById('mobileResetButton')].forEach(button => {
                if (button) {
                    const icon = button.querySelector('i');
                    icon.classList.add('spin-animation');
                    setTimeout(() => icon.classList.remove('spin-animation'), 1000);
                }
            });
            
            loadMoreExamples();
        }

        function updateSourceInfo() {
            const filtered = getFilteredExamples();
            const info = sourceInfo[state.currentSource];
            
            ui.totalCount.textContent = filtered.length;
            ui.currentSource.textContent = info.name;
            ui.description.textContent = info.description;
        }

        function showToast(message, isError = false) {
            const toast = document.createElement('div');
            toast.className = 'copy-toast';
            toast.textContent = message;
            if (isError) {
                toast.style.background = 'rgba(239, 68, 68, 0.9)';
            }
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 1500);
        }

        function copyToClipboard(text, button) {
            // Check if we can use the modern clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        showCopySuccess(button);
                    })
                    .catch(() => {
                        fallbackCopyToClipboard(text, button);
                    });
            } else {
                fallbackCopyToClipboard(text, button);
            }
        }

        function fallbackCopyToClipboard(text, button) {
            // Create temporary textarea
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            
            try {
                textArea.select();
                document.execCommand('copy');
                showCopySuccess(button);
            } catch (err) {
                showToast('Failed to copy', true);
            } finally {
                textArea.remove();
            }
        }

        function showCopySuccess(button) {
            showToast('Copied to clipboard');
            button.classList.add('copied');
            const icon = button.querySelector('i');
            icon.classList.remove('fa-copy');
            icon.classList.add('fa-check');
            
            setTimeout(() => {
                button.classList.remove('copied');
                icon.classList.remove('fa-check');
                icon.classList.add('fa-copy');
            }, 1500);
        }

        function createExampleCard(example) {
            const codeHtml = example.code ? example.code.replace(/</g, '&lt;').replace(/>/g, '&gt;') : '';
            const rawCode = example.code ? example.code.replace(/`/g, '\\`').replace(/\${/g, '\\${') : '';
            
            return `
                <div class="card-container" id="card-${example.index}">
                    <div class="card-flipper">
                        <div class="card-front">
                            <div class="example-card">
                                <div class="card-header">
                                    <span class="text-lg font-medium text-slate-400">
                                        ${example.seed}
                                    </span>
                                    <button class="button-base" onclick="toggleCode(${example.index})">
                                        <i class="fas fa-code"></i>
                                        <span>View Code</span>
                                    </button>
                                </div>
                                
                                <div class="image-grid">
                                    ${example.images.train.map((train, i) => `
                                        <div class="image-container">
                                            <div class="image-pair">
                                                <div class="image-wrapper">
                                                    <img data-src="${train.input}" 
                                                        alt="Train Input ${i+1}" 
                                                        class="w-full rounded-lg">
                                                    <p class="image-caption">Train Input ${i+1}</p>
                                                </div>
                                                <div class="image-wrapper">
                                                    <img data-src="${train.output}" 
                                                        alt="Train Output ${i+1}" 
                                                        class="w-full rounded-lg">
                                                    <p class="image-caption">Train Output ${i+1}</p>
                                                </div>
                                            </div>
                                        </div>
                                    `).join('')}
                                    
                                    <div class="image-container">
                                        <div class="image-pair">
                                            <div class="image-wrapper">
                                                <img data-src="${example.images.test.input}" 
                                                    alt="Test Input"
                                                    class="w-full rounded-lg">
                                                <p class="image-caption">Test Input</p>
                                            </div>
                                            <div class="image-wrapper">
                                                <img data-src="${example.images.test.output}" 
                                                    alt="Test Output"
                                                    class="w-full rounded-lg">
                                                <p class="image-caption">Test Output</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-back">
                            <div class="card-header">
                                <!-- Change the onclick to use a data attribute instead -->
                                <button class="button-base copy-button" data-code="${rawCode}">
                                    <i class="fas fa-copy"></i>
                                    <span>Copy</span>
                                </button>
                                <button class="button-base" onclick="toggleCode(${example.index})">
                                    <i class="fas fa-image"></i>
                                    <span>View Example</span>
                                </button>
                            </div>
                            <div class="code-content">
                                <pre><code class="language-python">${codeHtml}</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }

        function initializeCopyButtons() {
            // Remove any existing listeners first
            document.querySelectorAll('.copy-button').forEach(button => {
                button.removeEventListener('click', handleCopyClick);
            });
            
            // Add fresh listeners
            document.querySelectorAll('.copy-button').forEach(button => {
                button.addEventListener('click', handleCopyClick);
            });
        }

        function handleCopyClick(event) {
            const button = event.currentTarget;
            const code = button.getAttribute('data-code');
            if (code) {
                copyToClipboard(code, button);
            }
        }

        function toggleCode(index) {
            const cardContainer = document.querySelector(`#card-${index}`);
            if (!cardContainer) return;
            
            const flipper = cardContainer.querySelector('.card-flipper');
            if (flipper) {
                flipper.classList.toggle('flipped');
            }
        }

        // Data Loading
        async function loadMoreExamples() {
            if (state.loading) return;
            
            state.loading = true;
            ui.loading.classList.remove('hidden');
            
            try {
                const filtered = getFilteredExamples();
                const start = state.page * state.itemsPerPage;
                const end = start + state.itemsPerPage;
                const pageExamples = filtered.slice(start, end);
                
                if (pageExamples.length > 0) {
                    const fragment = document.createDocumentFragment();
                    pageExamples.forEach(example => {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = createExampleCard(example);
                        fragment.appendChild(tempDiv.firstElementChild);
                    });
                    ui.grid.appendChild(fragment);
                    state.page++;
                    
                    // Initialize copy buttons after adding new content
                    initializeCopyButtons();
                    
                    // Initialize lazy loading for new images
                    requestAnimationFrame(() => {
                        lazyLoadImages();
                    });
                }
            } catch (error) {
                console.error('Error loading examples:', error);
            } finally {
                state.loading = false;
                ui.loading.classList.add('hidden');
            }
        }

        const debouncedResize = debounce(() => {
            initializeCopyButtons();
        }, 250);

        window.addEventListener('resize', debouncedResize);


        function handleScroll() {            
            const threshold = 1000;
            const bottomDistance = document.documentElement.scrollHeight - (window.scrollY + window.innerHeight);
            
            if (bottomDistance < threshold) {
                loadMoreExamples();
            }
            
            // Trigger lazy loading check on scroll
            lazyLoadImages();
        }

        // Initialize
        function initializeViewport() {
            const viewportStyle = document.createElement('meta');
            viewportStyle.name = 'viewport';
            viewportStyle.content = 'width=device-width, initial-scale=1.0';
            document.head.appendChild(viewportStyle);
        }

        function initializeIntersectionObserver() {
            const options = {
                root: null,
                rootMargin: '100px',
                threshold: 0.1
            };

            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add('visible');
                    }
                });
            }, options);

            document.querySelectorAll('.example-card').forEach(card => {
                observer.observe(card);
            });
        }

        function toggleInfo() {
            const infoPanel = document.querySelector('.info-panel-wrapper');
            const mobileInfoPanel = document.getElementById('mobileInfoPanel');
            const infoToggle = document.getElementById('infoToggle');
            
            if (window.innerWidth <= 768) {
                // Mobile: toggle mobile info panel
                mobileInfoPanel.classList.toggle('open');
                document.body.classList.toggle('info-open');
            } else {
                // Desktop: toggle desktop info panel
                infoPanel.classList.toggle('open');
            }
        }

        function initializeInfoPanels() {
            const mobileInfoContent = document.getElementById('mobileInfoContent');
            const desktopInfoContent = document.getElementById('infoDisplay').innerHTML;
            mobileInfoContent.innerHTML = desktopInfoContent;
            
            // Add click handlers
            document.getElementById('infoToggle').addEventListener('click', toggleInfo);
            document.getElementById('mobileInfoToggle').addEventListener('click', toggleInfo);
        }

        function initializePage() {
            // Set up scrollbar
            const scrollbar = document.querySelector('.custom-scrollbar');
            const thumb = document.querySelector('.scrollbar-thumb');
            const track = document.querySelector('.scrollbar-track');
            let isDragging = false;
            let startY;
            let scrollStartY;

            function updateThumbSize() {
                const viewportHeight = window.innerHeight;
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const scrollbarHeight = track.offsetHeight;
                
                // Calculate thumb height based on viewport/document ratio
                const thumbHeight = Math.max(
                    (viewportHeight / documentHeight) * scrollbarHeight,
                    40 // Minimum thumb height
                );
                
                thumb.style.height = `${thumbHeight}px`;
            }

            function flipCard(index) {
                const cardContainer = document.getElementById(`card-${index}`);
                const flipper = cardContainer.querySelector('.card-flipper');
                flipper.classList.toggle('flipped');
            }

            // Handle clicking outside the card
            document.addEventListener('click', function(event) {
                const cardContainers = document.querySelectorAll('.card-container');
                cardContainers.forEach(container => {
                    const flipper = container.querySelector('.card-flipper');
                    const isFlipped = flipper.classList.contains('flipped');
                    
                    if (isFlipped && !container.contains(event.target)) {
                        flipper.classList.remove('flipped');
                    }
                });
            });

            // Stop propagation on card clicks to prevent the outside click handler from firing
            document.querySelectorAll('.card-container').forEach(container => {
                container.addEventListener('click', function(event) {
                    event.stopPropagation();
                });
            });

            function updateThumbPosition() {
                if (isDragging) return;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const scrollbarHeight = track.offsetHeight;
                const maxScroll = documentHeight - viewportHeight;
                const scrolled = window.scrollY;
                
                if (maxScroll <= 0) {
                    thumb.style.display = 'none';
                    return;
                }
                
                thumb.style.display = 'block';
                const scrollRatio = scrolled / maxScroll;
                const thumbTravel = scrollbarHeight - thumb.offsetHeight;
                const thumbPosition = thumbTravel * scrollRatio;
                
                thumb.style.transform = `translateY(${thumbPosition}px)`;
            }

            // Handle thumb drag
            thumb.addEventListener('mousedown', (e) => {
                isDragging = true;
                thumb.classList.add('dragging');
                startY = e.clientY - thumb.getBoundingClientRect().top;
                scrollStartY = window.scrollY;
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const trackRect = track.getBoundingClientRect();
                const y = e.clientY - trackRect.top - startY;
                const scrollbarHeight = track.offsetHeight;
                const thumbHeight = thumb.offsetHeight;
                const maxY = scrollbarHeight - thumbHeight;
                
                const boundedY = Math.max(0, Math.min(y, maxY));
                const scrollRatio = boundedY / maxY;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const maxScroll = documentHeight - viewportHeight;
                
                window.scrollTo(0, maxScroll * scrollRatio);
                thumb.style.transform = `translateY(${boundedY}px)`;
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                thumb.classList.remove('dragging');
            });

            // Track click to jump to position
            track.addEventListener('click', (e) => {
                if (e.target === thumb) return;
                
                const trackRect = track.getBoundingClientRect();
                const clickY = e.clientY - trackRect.top;
                const scrollbarHeight = track.offsetHeight;
                const thumbHeight = thumb.offsetHeight;
                const maxY = scrollbarHeight - thumbHeight;
                
                const boundedY = Math.max(0, Math.min(clickY - thumbHeight / 2, maxY));
                const scrollRatio = boundedY / maxY;
                
                const documentHeight = Math.max(
                    document.documentElement.scrollHeight,
                    document.body.scrollHeight
                );
                const viewportHeight = window.innerHeight;
                const maxScroll = documentHeight - viewportHeight;
                
                window.scrollTo({
                    top: maxScroll * scrollRatio,
                    behavior: 'smooth'
                });
            });

            // Update on scroll
            window.addEventListener('scroll', updateThumbPosition, { passive: true });

            // Update on resize
            window.addEventListener('resize', () => {
                updateThumbSize();
                updateThumbPosition();
            });

            // Set up intersection observer
            initializeIntersectionObserver();

            // Set up initial state and UI
            updateSourceInfo();
            loadMoreExamples();

            // Add event listeners
            window.addEventListener('scroll', handleScroll, { passive: true });
            ui.shuffleButton.addEventListener('click', handleShuffle);
            ui.resetButton.addEventListener('click', handleReset);

            // Initialize scrollbar
            updateThumbSize();
            updateThumbPosition();

            // Add keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === 's' && !e.ctrlKey && !e.metaKey) {
                    handleShuffle();
                } else if (e.key === 'r' && !e.ctrlKey && !e.metaKey) {
                    if (!state.shuffled) return;
                    handleReset();
                }
                switch(e.key) {
                    case 'ArrowLeft':
                        const prevOption = ui.sourceSelect.selectedIndex - 1;
                        if (prevOption >= 0) {
                            ui.sourceSelect.selectedIndex = prevOption;
                        }
                        break;
                    case 'ArrowRight':
                        const nextOption = ui.sourceSelect.selectedIndex + 1;
                        if (nextOption < ui.sourceSelect.options.length) {
                            ui.sourceSelect.selectedIndex = nextOption;
                        }
                        break;
                }
            });

            document.querySelectorAll('pre code').forEach((block) => {
                Prism.highlightElement(block);
            });
        }

        // Add performance optimizations
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // Optimize scroll handler
        const debouncedScroll = debounce(handleScroll, 16);
        window.addEventListener('scroll', debouncedScroll, { passive: true });
        let globalImageObserver;

        // Image loading optimization
        function lazyLoadImages() {
            // Create observer if it doesn't exist
            if (!globalImageObserver) {
                globalImageObserver = new IntersectionObserver((entries, observer) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const img = entry.target;
                            if (img.dataset.src) {
                                img.src = img.dataset.src;
                                img.removeAttribute('data-src');
                                observer.unobserve(img);
                            }
                        }
                    });
                }, {
                    root: null,
                    rootMargin: '50px 0px',
                    threshold: 0.1
                });
            }

            // Get all unloaded images
            const imageElements = document.querySelectorAll('img[data-src]');
            imageElements.forEach(img => {
                globalImageObserver.observe(img);
            });
        }

        // Add mobile touch handling
        let touchStartY = 0;
        document.addEventListener('touchstart', (e) => {
            touchStartY = e.touches[0].pageY;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            const touchY = e.touches[0].pageY;
            const difference = touchStartY - touchY;
            
            if (difference > 0) { // Scrolling up
                const nearBottom = window.innerHeight + window.pageYOffset >= 
                    document.documentElement.scrollHeight - 1000;
                if (nearBottom) {
                    loadMoreExamples();
                }
            }
        }, { passive: true });

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('Page error:', e.error);
            ui.loading.classList.add('hidden');
            state.loading = false;
        });

        function initializeCodeHighlighting() {
            // Re-run Prism highlighting when new code is added
            document.querySelectorAll('pre code').forEach((block) => {
                Prism.highlightElement(block);
            });
        }

        // Initialize everything when the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializePage();
            handleSeedFilter();

            initializeInfoPanels();

            // Update click outside handling
            document.addEventListener('click', (e) => {
                const infoPanel = document.querySelector('.info-panel-wrapper');
                const mobileInfoPanel = document.getElementById('mobileInfoPanel');
                const infoToggle = document.getElementById('infoToggle');
                const mobileInfoToggle = document.getElementById('mobileInfoToggle');
                
                if (!infoPanel.contains(e.target) && !infoToggle?.contains(e.target)) {
                    infoPanel.classList.remove('open');
                }
                
                if (!mobileInfoPanel.contains(e.target) && !mobileInfoToggle?.contains(e.target)) {
                    mobileInfoPanel.classList.remove('open');
                    document.body.classList.remove('info-open');
                }
            });
        });
    </script>
</body>
</html>